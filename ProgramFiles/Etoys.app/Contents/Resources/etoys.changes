'From etoys4.1 of 13 October 2010 [latest update: #2390] on 13 October 2010 at 11:03:03 pm'!!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/27/2008 13:12'!analogousCodeTo: aMethodProperties	| bs |	(bs := self basicSize) ~= aMethodProperties basicSize ifTrue:		[^false].	1 to: bs do:		[:i|		((self basicAt: i) analogousCodeTo: (aMethodProperties basicAt: i)) ifFalse:			[^false]].	^true! !!AdditionalMethodState methodsFor: 'testing' stamp: 'bgf 12/6/2008 12:15'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [(aBlock value: propertyOrPragma key)					or: [(aBlock value: propertyOrPragma value)					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/29/2008 16:40'!hasLiteralThorough: literal	"Answer true if any literal in these properties is literal,	 even if embedded in array structure."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [propertyOrPragma key == literal					or: [propertyOrPragma value == literal					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteral: literal]]]]			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 10:53'!includesKey: aKey	"Test if the property aKey or pragma with selector aKey is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) key == aKey ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 10:53'!includes: aPropertyOrPragma "<Association|Pragma>"	"Test if the property or pragma is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) = aPropertyOrPragma ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/29/2008 13:47'!isEmpty	^self basicSize = 0! !!AdditionalMethodState methodsFor: 'testing' stamp: 'md 2/19/2006 11:24'!isMethodProperties	^true! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 16:49'!notEmpty	^self basicSize > 0! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 10:19'!at: aKey	"Answer the property value or pragma associated with aKey."		^self at: aKey ifAbsent: [self error: 'not found']! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:54'!at: aKey ifAbsentPut: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^method propertyValueAt: aKey put: aBlock value! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:55'!at: aKey ifAbsent: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^aBlock value! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:56'!at: aKey put: aValue	"Replace the property value or pragma associated with aKey."		1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value: aValue]				ifFalse: [self basicAt: i put: aValue]]].	^method propertyValueAt: aKey put: aValue! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 18:36'!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma value]			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 14:11'!pragmas	"Answer the raw messages comprising my pragmas."	| pragmaStream |	pragmaStream := WriteStream on: (Array new: self basicSize).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Message>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifFalse:			[pragmaStream nextPut: propertyOrPragma]].	^pragmaStream contents! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 10:25'!properties	| propertyStream |	propertyStream := WriteStream on: (Array new: self basicSize * 2).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma value]].	^IdentityDictionary newFromPairs: propertyStream contents! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 19:32'!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma key]				ifFalse: [propertyOrPragma keyword])			== aKey ifTrue:			[^method removeProperty: aKey]].	^aBlock value! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector	^selector! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector: aSymbol	selector := aSymbol! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 18:28'!setMethod: aMethod	method := aMethod.	1 to: self basicSize do:		[:i| | propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifFalse:			[propertyOrPragma setMethod: aMethod]]! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 11/29/2008 18:35'!copyWithout: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which no longer includes aPropertyOrPragma"	| bs copy offset |	copy := self class new: (bs := self basicSize) - ((self includes: aPropertyOrPragma)													ifTrue: [1]													ifFalse: [0]).	offset := 0.	1 to: bs do:		[:i|		(self basicAt: i) = aPropertyOrPragma			ifTrue: [offset := 1]			ifFalse: [copy basicAt: i - offset put: (self basicAt: i)]].	^copy		selector: selector;		setMethod: method;		yourself! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 11/29/2008 18:35'!copyWith: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which includes aPropertyOrPragma"	| bs copy |	(Association == aPropertyOrPragma class	 or: [Pragma == aPropertyOrPragma class]) ifFalse:		[self error: self class name, ' instances should hold only Associations or Pragmas.'].	copy := self class new: (bs := self basicSize) + 1.	1 to: bs do:		[:i|		copy basicAt: i put: (self basicAt: i)].	copy basicAt: bs + 1 put: aPropertyOrPragma.	^copy		selector: selector;		setMethod: method;		yourself! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 10:28'!includesProperty: aKey	"Test if the property aKey is present."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 10:18'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[aBlock value: propertyOrPragma key value: propertyOrPragma value]]! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 11:46'!propertyValueAt: aKey	"Answer the property value associated with aKey."		^ self propertyValueAt: aKey ifAbsent: [ self error: 'Property not found' ].! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 11:45'!propertyValueAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^propertyOrPragma value]].	^aBlock value! !!AdditionalMethodState methodsFor: 'properties' stamp: 'lr 2/6/2006 20:48'!removeKey: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeKey: aKey ifAbsent: [ self error: 'Property not found' ].! !!AdditionalMethodState methodsFor: 'decompiling' stamp: 'eem 6/11/2009 17:06'!method: aMethodNodeOrNil	"For decompilation"	method := aMethodNodeOrNil! !!AdditionalMethodState commentStamp: '<historical>' prior: 0!I am class holding state for compiled methods. All my instance variables should be actually part of the CompiledMethod itself, but the current implementation of the VM doesn't allow this.  Currently I hold the selector and any pragmas or properties the compiled method has.  Pragmas and properties are stored in indexable fields; pragmas as instances of Pragma, properties as instances of Association.I am a reimplementation of much of MethodProperties, but eliminating the explicit properties and pragmas dictionaries.  Hence I answer true to isMethodProperties.!!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 11/29/2008 18:48'!forMethod: aMethod selector: aSelector	^(self basicNew: 0)		selector: aSelector;		setMethod: aMethod;		yourself! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 11/28/2008 12:26'!selector: aSelector with: aPropertyOrPragma	^(self basicNew: 1)		selector: aSelector;		basicAt: 1 put: aPropertyOrPragma;		yourself! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'wiz 1/1/2007 20:21'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue		ifTrue: [^self].	self changed .	self image: (images at:	(imageIndex _ imageIndex \\ images size + 1)).	self changed . 	d _ (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!AnimatedImageMorph class methodsFor: 'fileIn/Out' stamp: 'wiz 10/13/2008 21:42'!serviceOpenGIFInWindow	"Answer a service for opening a gif graphic in a window"	^ (SimpleServiceEntry		provider: self		label: 'open the graphic as a morph'		selector: #openGIFInWindow:		description: 'open a GIF graphic file as a morph'		buttonLabel: 'open gif')		argumentGetter: [:fileList | fileList readOnlyStream]! !!AnimatedImageMorph class methodsFor: 'fileIn/Out' stamp: 'wiz 10/13/2008 21:42'!services	^ Array		with: self serviceOpenGIFInWindow		"with: Form serviceImageImports"		"with: Form serviceImageAsBackground"! !!Array methodsFor: 'testing' stamp: 'md 7/30/2005 21:19'!isArray	^true! !!AutoStart class methodsFor: 'initialization' stamp: 'bf 8/20/2010 13:16'!startUp: resuming	"The image is either being newly started (resuming is true), or it's just been snapshotted.	If this has just been a snapshot, skip all the startup stuff."	| startupParameters launchers |	self active ifTrue: [^self].	self active: true.	resuming ifFalse: [^self].	HTTPClient determineIfRunningInBrowser.	startupParameters _ AbstractLauncher extractParameters.	(startupParameters includesKey: 'apiSupported' asUppercase )		ifTrue: [			HTTPClient browserSupportsAPI: ((startupParameters at: 'apiSupported' asUppercase) asUppercase = 'TRUE').			HTTPClient isRunningInBrowser				ifFalse: [HTTPClient isRunningInBrowser: true]]."	self checkForUpdates ifTrue: [^self].""	self checkForPluginUpdate."	launchers _ self installedLaunchers collect: [:launcher |		launcher new].	launchers do: [:launcher |		launcher parameters: startupParameters].	launchers do: [:launcher |		Smalltalk at: #WorldState ifPresent: [ :ws | ws addDeferredUIMessage: [launcher startUp] fixTemps]]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'kfr 1/10/2010 11:10'!playSoundNamed: soundName	"There is sound support, so we play the given sound."	Preferences soundsEnabled ifTrue: [		^SampledSound playSoundNamed: soundName asString]! !!Behavior methodsFor: 'compiling' stamp: 'bf 4/19/2010 01:09'!compile: code classified: category notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode  := self compilerClass new				compile: code				in: self				"classified: category"		"not in Etoys image yet"				notifying: requestor				ifFail: failBlock.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes.! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 12/29/2009 17:26'!includesLocalSelector: aSymbol	^self includesSelector: aSymbol! !!Behavior methodsFor: 'traits' stamp: 'ar 12/31/2009 18:22'!traitComposition	"Backstop. When traits are unloaded we never have a trait composition"	^#()! !!Behavior methodsFor: 'traits' stamp: 'ar 1/1/2010 17:51'!traitCompositionString	"Backstop. Monticello needs a traitCompositionString even with traits unloaded"	^'{}'! !!BlockNode methodsFor: 'testing' stamp: 'eem 9/25/2008 12:10'!isBlockNode	^true! !!BlockNode methodsFor: 'code generation' stamp: 'eem 4/18/2010 19:10'!noteOptimizedIn: anOptimizedMessageNode	"Forward-compatibility with eem's closure compiler."! !!BookMorph methodsFor: 'classification' stamp: 'sw 3/24/2009 13:15'!defersHaloToInteriorMorph: aMorph	"Answer whether  when a halo-click goes down over some subobject within me, I should defer to it rather than seize the halo myself."	^ aMorph hasOwner: currentPage! !!BookMorph methodsFor: 'menu' stamp: 'RIF 7/21/2010 22:14'!addBookMenuItemsTo: aMenu hand: aHandMorph	"For the 'control menu' -- add book-menu items to it."	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' translated action: #previousPage.	subMenu add: 'next page' translated action: #nextPage.	subMenu add: 'goto page' translated action: #goToPage.	subMenu add: 'insert a page' translated action: #insertPage.	subMenu add: 'delete this page' translated action: #deletePage.	self canRevertThisPage ifTrue: [		subMenu add: 'revert this page' translated action: #revertPage].	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide page controls' translated action: #hidePageControls.			subMenu add: 'fewer page controls' translated action: #fewerPageControls]		ifFalse:			[subMenu add: 'show page controls' translated action: #showPageControls].	self isInFullScreenMode ifTrue: [		subMenu add: 'exit full screen' translated action: #exitFullScreen.	] ifFalse: [		subMenu add: 'show full screen' translated action: #goFullScreen.	].	subMenu addLine.	subMenu add: 'sound effect for all pages' translated action: #menuPageSoundForAll:.	subMenu add: 'sound effect this page only' translated action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all pages' translated action: #menuPageVisualForAll:.	subMenu add: 'visual effect this page only' translated action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' translated action: #sortPages:.	subMenu add: 'uncache page sorter' translated action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' translated action: #textSearch.	(aHandMorph pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page' translated	action: #pasteBookPage].	subMenu add: 'send all pages to server' translated action: #savePagesOnURL.	subMenu add: 'send this page to server' translated action: #saveOneOnURL.	subMenu add: 'reload all from server' translated action: #reload.	subMenu add: 'copy page url to clipboard' translated action: #copyUrl.	subMenu add: 'keep in one file' translated action: #keepTogether.	subMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	subMenu add: 'mark this page to be revertible' translated action: #markForRevert.	subMenu add: 'mark entire book to be revertible' translated action: #markBookForRevert.	subMenu add: 'unmark this page to be revertible' translated action: #unmarkForRevert.	subMenu add: 'unmark entire book to be revertible' translated action: #unmarkBookForRevert."	subMenu add: 'revert this page' translated action: #revertPage.	subMenu add: 'revert all pages' translated action: #revertAllPages."	aMenu add: 'book...' translated subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'kfr 6/16/2010 15:23'!addSaveAndRevertItemsTo: aMenu	"Add items relating to use of revertible page-prototypes "	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'mark this page to be revertible' translated action: #markForRevert..	subMenu add: 'mark entire book to be revertible' translated action: #markBookForRevert.	aMenu add: 'save for later revert...' translated subMenu: subMenu! !!BookMorph methodsFor: 'fileIn/out' stamp: 'bf 9/5/2010 01:15'!prepareToBeSaved	super prepareToBeSaved.	self removeProperty: #pagesForRevert.	pages do: [:p | p removeProperty: #revertKey].! !!BookMorph methodsFor: 'new reverting' stamp: 'bf 9/5/2010 01:12'!markForRevert: page	"Save the current page for future revert."	| key revertPage revertDict |	page setProperty: #revertMarked toValue: true.	revertDict _ self pagesForRevert.	key _ page valueOfProperty: #revertKey ifAbsent: [0].	revertPage := revertDict at: key ifAbsent: [nil].	(key = 0 or: [revertPage isNil])		ifTrue:			[key := pages inject: 0 into:				[:max :p | max max: (p  valueOfProperty: #revertKey ifAbsent: [0]) + 1].			page setProperty: #revertKey toValue: key.			revertDict at: key put: page copy]		ifFalse:			[			self deletePageAlongWithPlayers: revertPage.			revertDict at: key put: page copy]! !!BooleanPreferenceView methodsFor: 'user interface' stamp: 'bf 9/17/2010 00:10'!offerPersistenceMenu	| aMenu |	Preferences ensurePersistedPreferencesAccessible		ifFalse: [^self].	aMenu := MenuMorph new defaultTarget: self preference.	aMenu addTitle: self preference name.	aMenu addUpdating: #isEnabledOnStartupString target: self preference  selector: #persistValue: argumentList: {true}.	aMenu addUpdating: #isDisabledOnStartupString target: self preference  selector: #persistValue: argumentList: {false}.	aMenu addUpdating: #isNotSetOnStartupString target: self preference  selector: #persistValue: argumentList: {nil}.	aMenu popUpInWorld! !!BooleanPreferenceView methodsFor: 'user interface' stamp: 'bf 8/8/2010 18:41'!offerPreferenceNameMenu: aPanel with: ignored1 in: ignored2	"the user clicked on a preference name -- put up a menu"	| aMenu |	ActiveHand showTemporaryCursor: nil.	aMenu := MenuMorph new defaultTarget: self preference.	aMenu addTitle: self preference name.	(Preferences okayToChangeProjectLocalnessOf: self preference name) ifTrue:		[aMenu addUpdating: #isProjectLocalString target: self preference action: #toggleProjectLocalness.		aMenu balloonTextForLastItem: 'Some preferences are best applied uniformly to all projects, and others are best set by each individual project.  If this item is checked, then this preference will be printed in bold and will have a separate value for each project' translated].	aMenu add: 'browse senders' translated target: self systemNavigation selector: #browseAllCallsOn: argument: self preference name.	aMenu balloonTextForLastItem: 'This will open a method-list browser on all methods that the send the preference "' translated, self preference name, '".'. 	aMenu add: 'show category...' translated target: aPanel selector: #findCategoryFromPreference: argument: self preference name.	aMenu balloonTextForLastItem: 'Allows you to find out which category, or categories, this preference belongs to.' translated.	Smalltalk isMorphic ifTrue:		[aMenu add: 'hand me a button for this preference' translated target: self selector: #tearOffButton.		aMenu balloonTextForLastItem: 'Will give you a button that governs this preference, which you may deposit wherever you wish' translated].	aMenu add: 'copy this name to clipboard' translated target: self preference selector: #copyName.	aMenu balloonTextForLastItem: 'Copy the name of the preference to the text clipboard, so that you can paste into code somewhere' translated.	aMenu add: 'set automatically on startup...' translated target: self selector: #offerPersistenceMenu.	aMenu balloonTextForLastItem: 'Store a value for this preference on file. On startup, it will be automatically restored.' translated.	aMenu popUpInWorld! !!BooleanPreferenceView methodsFor: 'user interface' stamp: 'bf 5/8/2010 12:44'!representativeButtonWithColor: aColor inPanel: aPreferencesPanel	"Return a button that controls the setting of prefSymbol.  It will keep up to date even if the preference value is changed in a different place"	| outerButton aButton str miniWrapper |		outerButton := AlignmentMorph newRow height: 24.	outerButton color:  (aColor ifNil: [Color r: 0.645 g: 1.0 b: 1.0]).	outerButton hResizing: (aPreferencesPanel ifNil: [#shrinkWrap] ifNotNil: [#spaceFill]).	outerButton vResizing: #shrinkWrap.	outerButton addMorph: (aButton := UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self preference;		actionSelector: #togglePreferenceValue;		getSelector: #preferenceValue.	outerButton addTransparentSpacerOfSize: (2 @ 0).	str := StringMorph contents: self preference name font: Preferences standardButtonFont.	self preference localToProject ifTrue:		[str emphasis: 1].	miniWrapper := AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap.	miniWrapper layoutInset: 0.	miniWrapper beTransparent addMorphBack: str lock.	aPreferencesPanel		ifNotNil:  "We're in a Preferences panel"			[miniWrapper on: #mouseDown send: #offerPreferenceNameMenu:with:in: to: self withValue: aPreferencesPanel.			miniWrapper on: #mouseEnter send: #menuButtonMouseEnter: to: miniWrapper.			miniWrapper on: #mouseLeave send: #menuButtonMouseLeave: to: miniWrapper.			miniWrapper setBalloonText: 'Click here for a menu of options regarding this preference.  Click on the checkbox to the left to toggle the setting of this preference' translated]		ifNil:  "We're a naked button, not in a panel"			[miniWrapper setBalloonText: self preference helpString translated; setProperty: #balloonTarget toValue: aButton].	outerButton addMorphBack: miniWrapper.	outerButton setNameTo: self preference name.	aButton setBalloonText: self preference helpString.	^ outerButton! !!ButtonProperties methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:20'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt targetPoint.	target := rootMorphs size > 1 		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!ByteArray methodsFor: 'testing' stamp: 'stephane.ducasse 2/1/2009 23:10'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^ true! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:39'!printOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:40'!storeOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each storeOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!Carre methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/22/2008 22:28'!carre: s1 and: s2 and: s3 and: s4 n: integer 	integer > 0		ifTrue: [self				carre: (self segment: s1 and: s2)				and: (self segment: s2 and: s3)				and: (self segment: s3 and: s4)				and: (self segment: s4 and: s1)				n: integer - 1]! !!Carre methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/22/2008 22:24'!segment: s1 and: s2 	| p1 p2 |	p1 := canvas pointOnCurve: s1 at: 1 / 8.	p2 := canvas pointOnCurve: s2 at: 1 / 8.	^ canvas segment: p1 hide to: p2 hide! !!Carre methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/10/2008 12:18'!initialize	| p1 |	canvas := DrGeoCanvas new.	self		carre: (canvas				segment: (p1 := canvas point: -2 @ 2)				to: (canvas point: 2 @ 2))		and: (canvas				segment: (canvas point: 2 @ 2)				to: (canvas point: 2 @ -2))		and: (canvas				segment: (canvas point: 2 @ -2)				to: (canvas point: -2 @ -2))		and: (canvas				segment: (canvas point: -2 @ -2)				to: (canvas point: -2 @ 2))		n: 30.	"MessageTally		spyOn: [canvas domain moveEvent: p1 mathItem inDirection: 1 @ -1]"! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 5/16/2009 05:48'!assureCategoryFullyVisible	"Keep deleting categoryviewers other than the receiver  until the receiver is fully visible."	| ready toDelete |	ready := false.	[(self  bounds bottom > ActiveWorld bottom) and: [ready not]] whileTrue:			[owner submorphs size > 2 ifTrue:				[toDelete :=owner submorphs allButFirst reversed detect: [:cv | cv ~~ self] ifNone: [^ self].				toDelete delete.				ActiveWorld doOneCycleNow]			ifFalse:				[ready := true]]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 5/16/2009 05:36'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList special |	Cursor wait showWhile: [			aList _ (scriptedPlayer categoriesForViewer: self) asOrderedCollection.		special :=  {ScriptingSystem nameForScriptsCategory.  ScriptingSystem nameForInstanceVariablesCategory}.		aList removeAllFoundIn: special.		aList := special, aList.		aLinePosition _ aList indexOf: #miscellaneous ifAbsent: [nil].		aList _ aList collect:				[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].		lineList _ aLinePosition ifNil: [#(2)] ifNotNil: [Array with: 2 with: aLinePosition].		aMenu _ CustomMenu labels: aList lines: lineList selections: aList.		reply _ aMenu startUpWithCaption: 'category' translated.		reply ifNil: [^ self].		self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol.		self assureCategoryFullyVisible	]! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/4/2009 01:29'!booleanPhraseFromPhrase: phrase	"Answer, if possible, a boolean-valued phrase derived from the phrase provided"	|  retrieverOp retrieverTile |	(phrase isKindOf: ParameterTile orOf: FunctionTile) ifTrue: [^ phrase booleanComparatorPhrase].	phrase isBoolean ifTrue: [^ phrase].	((scriptedPlayer respondsTo: #costume) 		and:[scriptedPlayer costume isInWorld not]) ifTrue: [^ Array new].	((phrase isMemberOf: PhraseTileMorph) and: [phrase submorphs size > 1] and: [#(bearingTo: distanceToPlayer:) includes: phrase submorphs second operatorOrExpression])		ifTrue:			[^ self booleanPhraseFromNumericGetterWithArgument: phrase].	((retrieverTile _ phrase submorphs last) isKindOf: TileMorph) ifFalse: [^ phrase].	retrieverOp _ retrieverTile operatorOrExpression.	(Vocabulary vocabularyForType: phrase resultType)		affordsCoercionToBoolean ifTrue: [			retrieverOp =  #getPatchValueIn: ifTrue: [				^ self booleanPhraseForGetPatchValueOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getRedComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #red  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getGreenComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #green  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getBlueComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #blue retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getUphillIn: ifTrue: [				^ self booleanPhraseForGetUpHillOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getDistanceTo: ifTrue: [				^ self booleanPhraseForGetDistanceToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getAngleTo: ifTrue: [				^ self booleanPhraseForGetAngleToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #bounceOn: ifTrue: [				^ self booleanPhraseForBounceOnOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			]."			(retrieverOp = #bounceOn:color: or: [retrieverOp = #bounceOnColor:]) ifTrue: [				^ self booleanPhraseForBounceOnColorOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			]."			"retrieverOp = #getTurtleAt: ifTrue: [				^ self booleanPhraseForGetTurtleAtOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			]."			retrieverOp = #getTurtleOf: ifTrue: [				^ self booleanPhraseForGetTurtleOfOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			^ self booleanPhraseForRetrieverOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.		].	^ phrase! !!CategoryViewer methodsFor: 'as yet unclassified' stamp: 'sw 10/4/2009 01:23'!booleanPhraseFromNumericGetterWithArgument: phrase 	"Answer a morph derived from the incoming phrase, a bearingTo: or distanceToPlayer: phrase, which will be suitable for dropping into a TEST area. "		| outerPhrase  rel finalTile |	rel := Vocabulary numberVocabulary comparatorForSampleBoolean.	outerPhrase _ PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: #Number argType: #Number.	outerPhrase firstSubmorph addMorph: phrase.	outerPhrase firstSubmorph changeTableLayout.	finalTile _ ScriptingSystem tileForArgType: #Number.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel). 	^ outerPhrase! !!ChangeList methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47'!changeTo: changeSubset	| newList newChangeList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	1 to: changeList size do:		[:i | (changeSubset includes: (changeList at: i)) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list	! !!ChangeList class methodsFor: '*monticello' stamp: 'ar 8/6/2009 18:46'!recentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size == 0 ifTrue: [^self recent: end on: origChangesFile].	pos := UIManager default chooseFrom: banners values: positions				title: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	^self recent: end - pos on: origChangesFile! !!ChangeList class methodsFor: '*monticello' stamp: 'nice 1/19/2010 01:52'!recent: charCount on: origChangesFile 	"Opens a changeList on the end of the specified changes log file"	| changeList end changesFile |	changesFile := origChangesFile readOnlyCopy.	end := changesFile size.	changeList := Cursor read		showWhile: [self new						scanFile: changesFile						from: (0 max: end - charCount)						to: end].	changesFile close.	^changeList! !!ChangeRecord methodsFor: '*monticello' stamp: 'avi 9/14/2004 14:27'!asMethodDefinition	^ MCMethodDefinition 		className: class		classIsMeta: meta		selector: self methodSelector		category: category		timeStamp: stamp		source: self string! !!ChangeSet methodsFor: 'accessing' stamp: 'bf 4/30/2009 16:35'!name: anObject	name := anObject.	Smalltalk currentProjectDo: [:prj |		self == prj changeSet			ifTrue: [prj nameChangedWhileCurrent]]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ChangeSorter changeSetNamed: aName! !!CircleMorph methodsFor: 'geometry' stamp: 'Richo 6/20/2010 17:36'!height: aNumber	" Set my width and height to the same amount; my position (top-left corner) will remain the same"	self extent: aNumber asInteger@ aNumber asInteger.! !!CircleMorph methodsFor: 'geometry' stamp: 'Richo 6/20/2010 17:36'!width: aNumber	" Set my width and height to the same amount; my position (top-left corner) will remain the same"	self extent: aNumber asInteger@ aNumber asInteger.! !!Class methodsFor: 'class variables' stamp: 'bf 1/12/2006 10:44'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol := aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do:[:classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					InMidstOfFileinNotification signal ifTrue: [						Transcript cr; show: self name, ' (' , aString , ' is Undeclared) '.						^Undeclared declare: aSymbol from: classPool].					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue:[^Undeclared declare: aSymbol from: classPool]						ifFalse:[^self]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool := nil].! !!Class methodsFor: '*monticello' stamp: 'al 3/26/2006 21:31'!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		traitComposition: self traitCompositionString		classTraitComposition: self class traitCompositionString		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!Class methodsFor: '*monticello' stamp: 'avi 3/10/2004 13:32'!classDefinitions	^ Array with: self asClassDefinition! !!Class methodsFor: '*monticello' stamp: 'ab 4/14/2003 22:30'!poolDictionaryNames	^ self sharedPools collect: [:ea | self environment keyAtIdentityValue: ea]! !!ClassDescription methodsFor: 'compiling' stamp: 'yo 3/18/2009 22:26'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource for: anInstance	| methodAndNode |	methodAndNode _ self basicCompile: text asString notifying: requestor 							trailer: self defaultMethodTrailer ifFail: [^nil] for: anInstance.	methodAndNode method: (methodAndNode method copyWithTempNames: (methodAndNode node tempNames)).	logSource ifTrue: [		self logMethodSource: text forMethodWithNode: methodAndNode 			inCategory: category withStamp: changeStamp notifying: requestor.	].	self addAndClassifySelector: methodAndNode selector withMethod: methodAndNode 		method inProtocol: category notifying: requestor.	self theNonMetaClass noteCompilationOf: methodAndNode selector meta: self isMeta.	^ methodAndNode selector! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'NS 4/12/2004 15:03'!classSide	^self theMetaClass! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'NS 4/12/2004 15:04'!instanceSide	^ self theNonMetaClass! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'al 5/9/2004 20:50'!isClassSide	^self == self classSide! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'al 5/9/2004 20:50'!isInstanceSide	^self isClassSide not! !!Clipboard methodsFor: 'accessing' stamp: 'bf 9/29/2009 14:06'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| text string decodedString ind |	text := ExtendedClipboardInterface current readTextClipboardData.	text isEmptyOrNil ifFalse: [		^text asString = contents asString			ifTrue: [contents]			ifFalse: [text]].	string := self primitiveClipboardText.	(string size > 0 and: [(ind := string indexOf: (Character value: 0)) > 0]) ifTrue: [		string := string copyFrom: 1 to: ind - 1].	(string isEmpty			or: [string = contents asString])		ifTrue: [^ contents].	decodedString := self interpreter fromSystemClipboard: string.	^ decodedString = contents asString		ifTrue: [contents]		ifFalse: [decodedString asText].! !!CommandTilesMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:13'!initialize	super initialize.	self wrapCentering: #center; cellPositioning: #leftCenter.	self hResizing: #shrinkWrap.	borderWidth _ 0.	self layoutInset: 0.	self extent: 5@5.  "will grow to fit"! !!CommandTilesMorph methodsFor: 'initialization' stamp: 'sw 1/29/98 18:32'!setMorph: aMorph	playerScripted _ aMorph playerScripted! !!CommandTilesMorph methodsFor: 'miscellaneous'!tileRows	^ Array with: self submorphs! !!CommandTilesMorph commentStamp: '<historical>' prior: 0!An entire Smalltalk statement in tiles.  A line of code.!!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/20/2009 11:43'!clearFlag	"Clear the user-level flag bit"	self objectAt: 1 put: (self header bitAnd: (1 << 29) bitInvert)! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/20/2009 11:42'!flag	"Answer the user-level flag bit"	^((self header bitShift: -29) bitAnd: 1) = 1! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 11:38'!methodClass	"answer the class that I am installed in"	^(self literalAt: self numLiterals) value.! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 11:38'!methodClassAssociation	"answer the association to the class that I am installed in, or nil if none."	^self literalAt: self numLiterals! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 2/28/2006 18:04'!methodClass: aClass	"set the class binding in the last literal to aClass"	self literalAt: self numLiterals put: aClass binding! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/30/2008 08:55'!properties	"Answer the method properties of the receiver."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector]		ifFalse: [AdditionalMethodState forMethod: self selector: propertiesOrSelector]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 17:23'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."	self literalAt: self numLiterals - 1		put: (aMethodProperties isEmpty				ifTrue: [aMethodProperties selector]				ifFalse: [aMethodProperties							setMethod: self;							yourself])! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/28/2008 12:54'!selector	"Answer a method's selector.  This is either the penultimate literal,	 or, if the method has any properties or pragmas, the selector of	 the MethodProperties stored in the penultimate literal."	| penultimateLiteral | 	^(penultimateLiteral := self penultimateLiteral) isMethodProperties		ifTrue: [penultimateLiteral selector]		ifFalse: [penultimateLiteral]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/28/2008 12:58'!selector: aSelector	"Set a method's selector.  This is either the penultimate literal,	 or, if the method has any properties or pragmas, the selector of	 the MethodProperties stored in the penultimate literal."	| penultimateLiteral nl | 	(penultimateLiteral := self penultimateLiteral) isMethodProperties		ifTrue: [penultimateLiteral selector: aSelector]		ifFalse: [(nl := self numLiterals) < 2 ifTrue:					[self error: 'insufficient literals to hold selector'].				self literalAt: nl - 1 put: aSelector]! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 11/29/2008 11:28'!hasNewPropertyFormat	"As of the closure compiler all methods have (or better have) the new	 format where the penultimate literal is either the method's selector	 or its properties and the ultimate literal is the class association."	^true! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 1/19/2009 10:28'!primitiveErrorVariableName	"Answer the primitive error code temp name, or nil if none."	self primitive > 0 ifTrue:		[self pragmas do:			[:pragma| | kwds ecIndex |			((kwds := pragma keyword keywords) first = 'primitive:'			and: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:				[^pragma argumentAt: ecIndex]]].	^nil! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 1/23/2010 16:37'!who	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."	self hasNewPropertyFormat ifTrue:[^{self methodClass. self selector}].	self systemNavigation allBehaviorsDo: 		[:class | 		(class methodDict keyAtIdentityValue: self ifAbsent: [nil]) ifNotNilDo:			[:sel| ^Array with: class with: sel]].	^Array with: #unknown with: #unknown! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 5/6/2008 11:28'!allLiterals	^self literals! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 11:37'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	  do:[:index |		literal == (self objectAt: index) ifTrue: [^true]].	^false! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 17:01'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this method, even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralSuchThat: litBlock]) ifTrue:		[^true].	2 to: self numLiterals + 1 do:		[:index | | lit |		lit := self objectAt: index.		((litBlock value: lit)		or: [lit isArray and: [lit hasLiteralSuchThat: litBlock]]) ifTrue:			[^true]].	^false! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 8/7/2009 11:43'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralThorough: literal]) ifTrue:[^true].	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:[:index | | lit |		((lit := self objectAt: index) == literal		 or: [(lit isVariableBinding and: [lit key == literal])		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:			[^ true]].	^ false ! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 11:38'!indexOfLiteral: literal	"Answer the literal index of the argument, literal, or zero if none."	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:		[:index |		literal == (self objectAt: index) ifTrue: [^index - 1]].	^0! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 4/30/2009 18:03'!literalStrings	| litStrs |	litStrs := OrderedCollection new: self numLiterals.	self literalsDo:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 10/28/2008 10:47'!literalsDo: aBlock	"Evaluate aBlock for each of the literals referenced by the receiver."	1 to: self numLiterals do:		[:index |		aBlock value: (self objectAt: index + 1)]! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ar 2/28/2006 18:19'!decompile	"Return the decompiled parse tree that represents self"	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	^class decompilerClass new decompile: selector in: class method: self.! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 1/23/2010 16:43'!methodNode	"Return the parse tree that represents self"	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	^ self methodNodeDecompileClass: class selector: selector! !!CompiledMethod methodsFor: 'private' stamp: 'eem 11/29/2008 11:10'!penultimateLiteral	"Answer the penultimate literal of the receiver, which holds either	 the receiver's selector or its properties (which will hold the selector)."	| pIndex |	^(pIndex := self numLiterals - 1) > 0 		ifTrue: [self literalAt: pIndex]		ifFalse: [nil]! !!CompiledMethod methodsFor: 'private' stamp: 'eem 11/29/2008 11:52'!penultimateLiteral: anObject	"Answer the penultimate literal of the receiver, which holds either	 the receiver's selector or its properties (which will hold the selector)."	| pIndex |	(pIndex := self numLiterals - 1) > 0 		ifTrue: [self literalAt: pIndex put: anObject]		ifFalse: [self error: 'insufficient literals']! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 16:58'!pragmaAt: aKey	"Answer the pragma with selector aKey, or nil if none."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector at: aKey ifAbsent: [nil]]		ifFalse: [nil]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 16:36'!pragmas	| selectorOrProperties |	^(selectorOrProperties := self penultimateLiteral) isMethodProperties		ifTrue: [selectorOrProperties pragmas]		ifFalse: [#()]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 17:33'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue:		[propertiesOrSelector propertyKeysAndValuesDo: aBlock]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 11:45'!propertyValueAt: propName	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector propertyValueAt: propName ifAbsent: [nil]]		ifFalse: [nil]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 11:50'!propertyValueAt: propName ifAbsent: aBlock	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector propertyValueAt: propName ifAbsent: aBlock]		ifFalse: [aBlock value]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/30/2008 08:55'!propertyValueAt: propName put: propValue	"Set or add the property with key propName and value propValue.	 If the receiver does not yet have a method properties create one and replace	 the selector with it.  Otherwise, either relace propValue in the method properties	 or replace method properties with one containing the new property."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:		[self penultimateLiteral: ((AdditionalMethodState									selector: propertiesOrSelector									with: (Association											key: propName asSymbol											value: propValue))									setMethod: self;									yourself).		^propValue].	(propertiesOrSelector includesProperty: propName) ifTrue:		[^propertiesOrSelector at: propName put: propValue].	self penultimateLiteral: (propertiesOrSelector								copyWith: (Association												key: propName asSymbol												value: propValue)).	^propValue! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 11:02'!removeProperty: propName	"Remove the property propName if it exists.	 Do _not_ raise an error if the property is missing."	| value |	value := self propertyValueAt: propName ifAbsent: [^nil].	self penultimateLiteral: (self penultimateLiteral copyWithout:									(Association										key: propName										value: value)).	^value! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 11:02'!removeProperty: propName ifAbsent: aBlock	"Remove the property propName if it exists.	 Answer the evaluation of aBlock if the property is missing."	| value |	value := self propertyValueAt: propName ifAbsent: [^aBlock value].	self penultimateLiteral: (self penultimateLiteral copyWithout:									(Association										key: propName										value: value)).	^value! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'md 7/14/2006 21:21'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits := primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].	method := self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits.	1 to: trailer size do:  "Copy the source code trailer to the end"		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'md 7/14/2006 21:21'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method flagBit |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	"For now the high bit of the primitive no. is in a high bit of the header"	primBits := (primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19).	flagBit := flag ifTrue: [ 1 ] ifFalse: [ 0 ].	method := self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits +				(flagBit bitShift: 29).	"Copy the source code trailer to the end"	1 to: trailer size do:		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'ar 2/28/2006 18:43'!toReturnConstant: index trailerBytes: trailer	"Answer an instance of me that is a quick return of the constant	indexed in (true false nil -1 0 1 2)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256 + index! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'ar 2/28/2006 18:43'!toReturnField: field trailerBytes: trailer	"Answer an instance of me that is a quick return of the instance variable 	indexed by the argument, field."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 264 + field! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'ar 2/28/2006 18:43'!toReturnSelfTrailerBytes: trailer	"Answer an instance of me that is a quick return of the instance (^self)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256! !!CompressedSourceStream methodsFor: 'access' stamp: 'bf 1/17/2010 14:50'!decodeString: string andRuns: runsRaw	self flag: #workAround. 	"all accessors should decode utf8"	^super decodeString: string utf8ToSqueak andRuns: runsRaw! !!CompressedSourceStream methodsFor: 'access' stamp: 'bf 1/17/2010 14:54'!nextChunk	| s |	self flag: #workAround. 	"all accessors should decode utf8"	s := super nextChunk.	"Has been decoded already if lang tag was present (#decodeString:andRuns:)"	s isWideString ifFalse: [s := s utf8ToSqueak].	^s! !!ContextPart methodsFor: 'private' stamp: 'bf 5/22/2009 13:49'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: nil].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ControlManager methodsFor: 'scheduling' stamp: 'dtl 4/4/2005 06:42'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	^ self interruptName: labelString preemptedProcess: nil! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 9/6/2009 11:09'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| newActiveController preemptedProcess |	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	preemptedProcess suspend.	"There is something wrong here. We suspend *two* processes, the interrupted	process and the activeControllerProcess (unless they are the same). How can	that possibly be right? However, it is what the code did before I added the comment	(it was merely hidden underneith another pile of code). Someone with more 	understanding about MVC fix this please."	preemptedProcess == activeControllerProcess 		ifFalse:[activeControllerProcess suspend].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController :=		(Debugger			openInterrupt: labelString			onProcess: preemptedProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!CrLfFileStream methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47'!lineEndingConvention: aSymbol		lineEndConvention := aSymbol! !!CurrentProjectRefactoring class methodsFor: 'revectoring to current' stamp: 'dtl 4/3/2005 14:14'!currentInterruptName: aString preemptedProcess: theInterruptedProcess	^ Project interruptName: aString preemptedProcess: theInterruptedProcess! !!Cursor class methodsFor: 'constants' stamp: 'bf 8/17/2009 12:55'!normal	"Answer the instance of me that is the shape of an arrow slanted left."	^Preferences biggerCursors		ifTrue: [CursorWithAlpha biggerNormal]		ifFalse: [NormalCursor]! !!CursorWithAlpha class methodsFor: 'constants' stamp: 'bf 8/17/2009 12:55'!biggerNormal	"self biggerNormal show"	"(Base64MimeConverter mimeEncode: ((FileStream readOnlyFileNamed: 'EtoysCursor.png') binary)) upToEnd"	^self constants at: #biggerNormal ifAbsentPut: [		| form cursor |		form := (PNGReadWriter on: (Base64MimeConverter mimeDecodeToBytes:			'iVBORw0KGgoAAAANSUhEUgAAABsAAAArCAYAAACJrvP4AAAACXBIWXMAAAsTAAALEwEAmpwY			AAAEF0lEQVRYCb2XS0hcVxjHj2/G8ZWMQQbSGO2iRhERwRALBmJNoOOqwUXtYtxOTQJxI8SN			CyXJqggVEghusrAuBB8IddUWF64CvnCj+AJrsYKio6JJOPn/j+dc5s6MztyZMR/857v3PL7f			/c4595w7QmiTUvrN9ZV7wGhfB3jOunpgOoYtPQQm19fXn6DsulY2PJUSi4ARvLm5+SuiE5hS			mAsBXSYzv99vLuXExMRL1H2jlRKoDYbAMhS4uLj4PJUwN4K5TTqEhQPHxsZeayCzTCrDqLC0			tLQryTAqjNmFA1OR4YWwaMBk5/BSWDRgMhnGhEUDJpphXDACqdDXIpEMHcHCF43TDB3Bks0w			IVj4kMabYcKwcGA8c+gIlp2drRaKGc5wYKwMHcFycnIiYOHACzLkhi9SAgsHRsnQOSzaMBJk			FPoejo6OvkJ5iZY67R1lZoJe5kOBKysrzxzBCgoKrCcnpKysTO7v75sjMKafmZl5gX6uNPww			M4EeQXrsEAJDJc7Ozngr8vPzRVVVldjZ2RGrq6uqrLi4WPT394u2tjZxeHj4P8C7qiLkJzMz			8zNvc3NzT+jR/yl9xDBmZWWpTAoLC2V9fb3c29uTXV1dtuwaGxtVRgcHBzuI0QY91vLBUw+0			voOnXPyyijBEUWWVlZViampKFBUVCcyDKC8vt9pitYnp6WlmfqO7u/uOVRHjIiKzjIwM2dDQ			oDIKnZCWlhZbdoFAQFUvLCz8Bcb3WrfgqWItFR/XKrEIWG1trQWam5v7Z3Bw8C2jjoyMyNLS			UgvIYeYQ05A5h5HA+GE1NTVWgPn5+b/RubWiosJ/enoaZNDq6moLhjrZ19fHYjk7O/sO9/eg			G1oZ8JTNbJmZJ9Wgn9GyleJQMWhPT48NhnllsTw+Pv4X7WLCuI1YX8TsuLy8/CfKmrXuwt9t			b2//iXX4LJder9cCut1uOT4+zio5PDz8G9pWaqm4uLaZDaZBXLY2GO4bdnd3PzAowDZYc3Mz			i+X29vY82l0K4ypR/2JOTk7e49qsIuMLUEbdXFpaes6gk5OT0uPxWECeBGtra6ySvb29v6Bt			ve7DfjZTsKOjo99RyvkzEOMtGOpuBoPBbQblQsK9Ejfnzs5OFsuNjY0JlF8IQ11clodWeVgo			bxh0YGDABmOmNGxzh2j3EPJqRV2VqLvUFKyjo+NHBuWqxb4nS0pKVFZmGFG+gihJw8wTerHx			/kEgXng6y7a2thYxnAHAHkHfavEcoxyZBcOh+AOHixS+7HwnfT4f/6nynSQoaZh5MjWcTU1N			94aGhtrr6up8qLgPcVFQd7SuwVPmIdN5njk1wmi31a8QHu3VuYVrLhDaf+dOHGgvE4Gp3RsB			cnUQMx+f9P1H7c9PXyHUIcoy01HXX637AibwgHAnFRPGAAAAAElFTkSuQmCC' 				readStream) readStream) nextImage.	cursor := CursorWithAlpha extent: form extent depth: 32.	form displayOn: cursor.	cursor offset: -2@-1.	cursor preMultiplyAlpha.	cursor]! !!CursorWithAlpha class methodsFor: 'constants' stamp: 'bf 8/17/2009 12:56'!resetConstants	Constants := nil.! !!CustomMenu methodsFor: '*Morphic-invocation' stamp: 'wiz 7/20/2004 12:20'!startUpWithCaption: caption at: aPoint 	"Build and invoke this menu with no initial selection. Answer the  	selection associated with the menu item chosen by the user or nil if  	none is chosen; use the provided caption"	^ self startUp: nil withCaption: caption at: aPoint! !!CustomMenu methodsFor: '*Morphic-invocation' stamp: 'wiz 7/20/2004 12:18'!startUp: initialSelection withCaption: caption at: aPoint 	"Build and invoke this menu with the given initial selection and caption. 	Answer the selection associated with the menu item chosen by the user 	or nil if none is chosen."	self build.	initialSelection notNil		ifTrue: [self preSelect: initialSelection].	^ super startUpWithCaption: caption at: aPoint! !!DAVClient methodsFor: 'public protocol' stamp: 'yo 9/9/2009 01:22'!allLastResponseCodeFrom: aString	"'HTTP/1.1 405 Method Not Allowed' copyFrom: 10 to: 12"	| c xml |	self multistatus ifTrue: [		c := OrderedCollection new.		xml := (XMLDOMParser parseDocumentFrom: aString readStream useNamespaces: true) .			c := OrderedCollection new.			xml withAllElementsDo: [:e |				(e name asLowercase endsWith: 'd:status') ifTrue: [c add: e contents first asString]].			^ c collect: [:s | s copyFrom: 10 to: 12]]	ifFalse: [		^ Array with: (self lastResponse copyFrom: 10 to: 12)].! !!DAVClient methodsFor: 'public protocol' stamp: 'yo 9/16/2009 17:00'!openUrl: aUrl 	"self new openUrl: 'http://localhost/some/path.html' asUrl"	| newPort addr |	newPort := aUrl port				ifNil: [self defaultPortNumber].	(aUrl authority = self hostName			and: [newPort = self port])		ifFalse: [self close].	self url: aUrl.	addr := [NetNameResolver addressForName: aUrl authority timeout: 20] on: Error do: [:ex | nil].	addr ifNil: [NetworkError signal].	self		openOnHost: addr		port: newPort! !!DAVClient methodsFor: 'public protocol' stamp: 'yo 8/3/2009 19:37'!quit	self close.! !!DAVClient methodsFor: 'accessing' stamp: 'yo 9/9/2009 01:23'!multistatus	^ multistatus! !!DAVClient methodsFor: 'private protocol' stamp: 'yo 8/6/2009 15:50'!isRetryNeeded	self lastResponse isEmpty		ifTrue: [self error: 'no content'.			^ true].	((lastHeader includesKey: 'connection')			and: [(lastHeader at: 'connection')					= 'close'])		ifTrue: [self close.			self ensureConnection].	self lastResponseCode first = $2		ifTrue: [^ false].	self lastResponseCode = '401'		ifTrue: [self askNamePasswordIfNecessary.			self password isEmptyOrNil ifTrue: [^false].			^ (HTTPLoginFailedException protocolInstance: self)				signal: self lastResponse].	(self lastResponseCode first = $3			and: [lastHeader includesKey: 'location'])		ifTrue: [self openUrl: (lastHeader at: 'location') asUrl.			^ true].	self lastResponseCode first = $5		ifTrue: [self inform: ('An Internal Server Error Occured ({1})' translated format: {self lastResponseCode printString}).			^ true].	(ProtocolClientError protocolInstance: self)		signal: self lastResponse.	^ false! !!DAVClient methodsFor: 'private protocol' stamp: 'yo 9/9/2009 00:36'!method: method header: aDictionary body: aStringOrByteArray 	"(self openUrl: 'http://localhost:8080/svn/' asUrl) method: 'GET' header: Dictionary new body: ''"	| body |	self askNamePasswordIfNecessary.	[self		sendRequest: method		header: aDictionary		body: aStringOrByteArray.	body := self receiveResponse.	self isRetryNeeded] whileTrue.	^ body! !!DAVClient methodsFor: 'private' stamp: 'yo 8/6/2009 18:15'!askName	self user: (FillInTheBlankMorph					request: 'User account name?'					initialAnswer: (self user ifNil: [''])					onCancelReturn: nil).	Utilities authorName: self user.! !!DAVClient methodsFor: 'private' stamp: 'yo 8/6/2009 18:16'!askNamePassword	self askName.	self askPassword.! !!DAVClient methodsFor: 'private' stamp: 'yo 8/6/2009 19:44'!askNamePasswordIfNecessary	lastHeader ifNil: [^ true].	(self user isNil or: [self password isNil]) ifFalse: [^ true].	self askNamePassword.! !!DAVClient methodsFor: 'private' stamp: 'yo 8/6/2009 18:16'!askPassword	self password: (FillInTheBlank  requestPassword: 'Password?').	^ true! !!DAVClient methodsFor: 'private' stamp: 'yo 9/9/2009 01:23'!lastResponse: aString	lastResponse _ aString.	multistatus := (lastResponse asLowercase endsWith: 'multistatus') or: [lastResponse asLowercase endsWith:'multi-status'].! !!DAVClient methodsFor: 'as yet unclassified' stamp: 'yo 9/9/2009 01:23'!initialize	super initialize.	multistatus := false.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 21:29'!askName	| ret |	ret := FillInTheBlankMorph					request: (useDefaultAccount ifTrue: [						'User account name? (Cancel to stay with default name)'] ifFalse: ['User account name?'])					initialAnswer: (user ifNil: [''])					onCancelReturn: nil.	(useDefaultAccount and: [ret isNil or: [ret = user]]) ifTrue: [^ false].	self user: ret.	passwordHolder := nil.	Utilities authorName: user.	^ true.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 20:18'!askNamePassword	self askName ifTrue: [self askPassword]! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 19:49'!askNamePasswordIfNecessary	(self user isNil or: [self password isNil]) ifFalse: [^ true].	self askNamePassword.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 19:49'!askPassword	self password: (FillInTheBlank  requestPassword: 'Password?').! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 19:49'!asServerFileNamed: aName	| rFile |	rFile _ self as: DAVServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	^rFile! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 19:10'!createPersonalDirectory: aString	aString ifNil: [^ self].	directory := origDirectory, '/', self pathToUserAccount.	altURL := server,  directory.	self createDirectory: aString.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 20:58'!initialize	super initialize.	self setupSelector: #setupSharedDirectory:.	useDefaultAccount := false.	loggedIn := false.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/8/2009 19:52'!origDirectory: aString	origDirectory := aString! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/8/2009 18:15'!password	user ifNil: [passwordHolder := nil. (HTTPLoginFailedException protocolInstance: DAVClient new) signal. ^ self].	passwordHolder ifNil: [passwordHolder _ Password new].	passwordHolder isString ifTrue: [^ passwordHolder].	^ passwordHolder passwordFor: self	"may ask the user"! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 19:10'!pathToUserAccount	^  'everyone/accounts/'! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 21:05'!setUserAndPassIn: aUrl	aUrl username: self user.	aUrl password: self password.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 19:10'!setupPersonalDirectory: aString	aString ifNil: [^ self].	directory := origDirectory, '/', self pathToUserAccount, aString.	altURL := server,  directory.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 15:08'!setupSelector: aSymbol	setupSelector := aSymbol! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 15:32'!setupSharedDirectory: aString! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 19:51'!useDefaultAccount: aBoolean	useDefaultAccount := aBoolean.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 9/8/2009 10:57'!user	| orig |	orig := user.	(useDefaultAccount not and: [user isNil]) ifTrue: [self askName ifFalse: [self user: orig]].	^ user.! !!DAVMultiUserServerDirectory methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2009 20:48'!user: aString	super user: aString.	self perform: setupSelector with: aString.! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 20:12'!createDirectory: localName 	| url |	url := ('http://', self server , '/' , self directory , '/' , localName) asUrl.	self setUserAndPassIn: url.	DAVClient openUrl: url while: [ :c | c mkcol]! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 20:12'!deleteDirectory: fullName 	| url |	url := (self server , '/' , self directory , '/' , fullName , '/') asUrl.	self setUserAndPassIn: url.	DAVClient openUrl: url while: [ :c | c delete]! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 20:12'!deleteFileNamed: fullName 	| url |	url := (self server , '/' , self directory , '/' , fullName) asUrl.	self setUserAndPassIn: url.	DAVClient openUrl: url while: [ :c | c delete]! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 21:30'!entries	"EntryCache -- a collection of {time. url. directory index}"	| url now newCache found newEntry aUrl |	url := (aUrl := self asUrl) toText.	now := Time totalSeconds.	"Last time should be 'now' +- 3 seconds. +3 is needed if this image move	to another time zone."	newCache := self class entryCache				select: [:each | now - 3 < each first						and: [each first < (now + 3)]].	found := newCache				detect: [:each | each second = url]				ifNone: [].	found		ifNotNil: [^ found third].	newEntry := self privateEntriesFor: aUrl.	newCache add: {now. url. newEntry}.	self class entryCache: newCache.	^ newEntry! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 20:12'!oldFileNamed: aName 	| contents aUrl |	aUrl :=  (self altUrl , '/' , aName) asUrl.	self setUserAndPassIn: aUrl.	contents := DAVClient				openUrl: aUrl				while: [:c | c get].	^ (SwikiPseudoFileStream with: contents) reset; directory: self; localName: aName; yourself! !!DAVServerDirectory methodsFor: 'file directory' stamp: 'yo 8/6/2009 20:12'!putFile: fileStream named: fileNameOnServer 	| fullURL dir |	dir := self directory first = $/ ifTrue: [self directory allButFirst] ifFalse: [self directory].	fullURL _ (self server , '/' , dir , '/' , fileNameOnServer encodeForHTTP) asUrl.	self setUserAndPassIn: fullURL.	fileStream binary.	DAVClient openUrl: fullURL while: [ :c | c put: fileStream contents]! !!DAVServerDirectory methodsFor: 'svn protocol private' stamp: 'yo 8/6/2009 20:12'!pathForRevision: aNumber forFileNamed: fullName 	| location aUrl |	location := (self asUrl newFromRelativeText: fullName) toText.	aUrl _ location asUrl.	self setUserAndPassIn: aUrl.	DAVClient		openUrl: aUrl		while: [:connection | ^ self				pathForClient: connection				revision: aNumber				forFileNamed: fullName]! !!DAVServerDirectory methodsFor: 'svn protocol private' stamp: 'yo 8/6/2009 20:13'!revisionsForFileNamed: fullName 	| location newest aUrl |	location _ (self asUrl newFromRelativeText: fullName) toText.	newest _ self newestVersionForFileNamed: location.	newest		ifNil: [^ ''].	aUrl := location asUrl.	self setUserAndPassIn: aUrl.	^ DAVClient		openUrl: aUrl		while: [:c | c				logReportFrom: newest				to: 1				depth: 0]! !!DAVServerDirectory methodsFor: 'private' stamp: 'yo 8/6/2009 20:11'!setUserAndPassIn: aUrl	aUrl username: self user.	aUrl password: self password.! !!DAVServerDirectory methodsFor: 'accessing' stamp: 'yo 8/6/2009 20:14'!asUrl	| newUrl |	newUrl _ ('http://' , self server , '/' , self directory, '/') asUrl.	self setUserAndPassIn: newUrl.	^ newUrl.! !!DAVServerDirectory methodsFor: 'property access' stamp: 'yo 9/16/2009 11:37'!parsePropertyResponse: response 	"Answer a DirectoryEntry made from response xml"	| childName directoryString propStats aDictionary mtime value dirFlag fileSize contentString unescaped |	directoryString := self directory.	directoryString first = $/		ifFalse: [directoryString := '/' , directoryString].	directoryString last = $/		ifFalse: [directoryString := directoryString , '/'].	contentString := (response elementUnqualifiedAt: 'href') contentString.	unescaped := directoryString unescapePercents.	contentString size < unescaped size		ifTrue: [childName := '']		ifFalse: [childName := contentString allButFirst: unescaped size].	(childName isEmpty not			and: [childName last = $/])		ifTrue: [childName := childName allButLast].	childName.	propStats := response elements				select: [:e | e localName = 'propstat'].	aDictionary := Dictionary new.	propStats		do: [:propStat | (propStat elementUnqualifiedAt: 'prop') ifNotNilDo: [:x | x  elements				do: [:propElement | 					value := propElement elements isEmpty								ifTrue: [propElement contentString]								ifFalse: [propElement elements first localName].					aDictionary at: propElement localName put: value]]].	mtime := fileSize := 0.	dirFlag := false.	mtime := aDictionary				at: #getlastmodified				ifPresent: [:v | [(TimeStamp						fromString: (v allButFirst: 5)) asSeconds] on: Error do: [:ex | 0]].	dirFlag := aDictionary				at: #resourcetype				ifPresent: [:v | v = #collection].	fileSize := aDictionary				at: #getcontentlength				ifPresent: [:v | v asNumber].	^ DirectoryEntry		name: childName unescapePercents		creationTime: 0		modificationTime: mtime		isDirectory: dirFlag		fileSize: fileSize! !!DAVServerDirectory methodsFor: 'property access' stamp: 'yo 9/9/2009 01:23'!privateEntries	| location aUrl |	location := 'http://' , self server , '/' , self directory , '/'.	aUrl := location asUrl.	self setUserAndPassIn: aUrl.	^ self privateEntriesFor: aUrl.! !!DAVServerDirectory methodsFor: 'property access' stamp: 'yo 9/9/2009 01:39'!privateEntriesFor: aUrl	| ret |	client := DAVClient openUrl: aUrl.	ret := [client propFind: #('getlastmodified' 'getcontentlength' 'resourcetype' )				depth: 1				label: nil]		on: Error do: [:ex | client close. (ex isKindOf: LoginFailedException) ifTrue: [ex outer]. ''].	client multistatus ifTrue: [		(client allLastResponseCodeFrom: ret) do: [:code |			code first = $2 ifFalse: [(LoginFailedException protocolInstance: client) signal]]].	^ ret ifNotEmpty: [self parseDirectoryEntries: ret readStream] ifEmpty: [#()]! !!Date methodsFor: 'utils' stamp: 'tbn 7/11/2006 10:30'!addMonths: monthCount 	|year month maxDaysInMonth day |	year := self year + (monthCount + self monthIndex - 1 // 12).	month := self monthIndex + monthCount - 1 \\ 12 + 1.	maxDaysInMonth := Month daysInMonth: month forYear: year.	day := self dayOfMonth > maxDaysInMonth				ifTrue: [maxDaysInMonth]				ifFalse: [self dayOfMonth].	^ Date		newDay: day		month: month		year: year! !!DBusEtoysService commentStamp: 'bf 6/17/2008 15:25' prior: 0!I make available all players in the current World on the DBus.DBus sessionBus	registerName: 'org.squeak.etoys';	export: DBusEtoysService new at: '/org/squeak/etoys'.!!DBusObject methodsFor: 'accessing' stamp: 'bf 8/17/2010 13:16'!dbusMethodSpecsAndSelectorsDo: aBlock	"Evaluate aBlock with all method specs and corresponding selectors that are to be exposed on the DBus.	By default, this gathers only methods marked as #dbusMethod:."	| cls |	cls := self class.	[cls selectorsAndMethodsDo: [:sel :meth | 		(meth numLiterals >= 2 and: [(meth literalAt: 1) == #dbusMethod: and: [(meth literalAt: 2) isString]])			ifTrue: [aBlock value: (meth literalAt: 2) value: sel]].	cls == DBusObject] whileFalse: [cls := cls superclass].! !!Debugger class methodsFor: 'opening' stamp: 'sw 11/23/2008 23:12'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.Preferences logDebuggerStackToFile ifTrue:	[(aString includesSubString: 'Space') & 		(aString includesSubString: 'low') ifTrue: [			Smalltalk logError: aString inContext: debugger interruptedContext to:'LowSpaceDebug.log']].	Smalltalk isMorphic ifTrue: [ActiveWorld ifNotNil: [ActiveWorld stopRunningAll]].	^ debugger		openNotifierContents: nil		label: aString! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 7/1/2009 10:35'!jump: dist if: condition	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock	  thenJump elseJump condHasValue isIfNil saveStack blockBody |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc := lastPc.	elseStart := pc + dist.	end := limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign := condition.	savePc := pc.	self interpretJump ifNotNil:		[:elseDist|		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:			 [sign := sign not.  elseStart := pc + elseDist]].	pc := savePc.	ifExpr := stack removeLast.	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:		[stack removeLast].	saveStack := stack.	stack := OrderedCollection new.	thenBlock := self blockTo: elseStart.	condHasValue := hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			  thenJump will jump to the beginning of the while expr.  In the case of while's			  with a block in the condition, the while expr should include more than just			  the last expression: find all the statements needed by re-decompiling."			stack := saveStack.			pc := thenJump.			blockBody := self statementsTo: elsePc.			"discard unwanted statements from block"			blockBody size - 1 timesRepeat: [statements removeLast].			statements addLast:				(constructor					codeMessage: (constructor codeBlock: blockBody returns: false)					selector: (constructor								codeSelector: (sign												ifTrue: [#whileFalse:]												ifFalse: [#whileTrue:])								code: #macro)					arguments: { thenBlock }).			pc := elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock := self blockTo: thenJump.			elseJump := exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc ifTrue:				[pc := lastPc].			cond := isIfNil						ifTrue:							[constructor								codeMessage: ifExpr ifNilReceiver								selector: (constructor											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])											code: #macro)								arguments: (Array with: thenBlock)]						ifFalse:							[constructor								codeMessage: ifExpr								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)								arguments:	(sign												ifTrue: [{elseBlock. thenBlock}]												ifFalse: [{thenBlock. elseBlock}])].			stack := saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'public access' stamp: 'kfr 6/8/2010 22:44'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: (aSelector ifNil: [method defaultSelector])		block: block		tempVars: tempVars		primitive: method primitive		class: aClass! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'eem 1/23/2010 14:17'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class 	| selectorNode methodNode methodTemps |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	methodTemps := tempVars select: [:t | t scope >= 0].	methodNode := MethodNode new		selector: selectorNode		arguments: (methodTemps copyFrom: 1 to: nArgs)		precedence: selector precedence		temporaries: (methodTemps copyFrom: nArgs + 1 to: methodTemps size)		block: block		encoder: (Encoder new initScopeAndLiteralTables				temps: tempVars				literals: literalValues				class: class)		primitive: primitive		properties: method properties copy.	methodNode properties method: method.	^methodNode! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:01'!at: key ifAbsentPut: aBlock 	"Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self at: key put: aBlock value]! !!Dictionary class methodsFor: 'instance creation' stamp: 'bgf 10/25/2006 17:08'!newFromPairs: anArray 	"Answer an instance of me associating (anArray at:i) to (anArray at: i+i)	 for each odd i.  anArray must have an even number of entries."	| newDictionary |	newDictionary := self new: (anArray size/2).	1 to: (anArray size-1) by: 2 do: [ :i|		newDictionary at: (anArray at: i) put: (anArray at: i+1).	].	^ newDictionary	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !!DiskProxy methodsFor: 'printing' stamp: 'bf 8/7/2010 23:00'!printOn: aStream	"Try to report the name of the project"	globalObjectName == #Project ifFalse: [^ super printOn: aStream].	constructorArgs size > 0 ifFalse: [^ super printOn: aStream].	constructorArgs first isString ifFalse: [^ super printOn: aStream].	aStream nextPutAll: ('{1} (not loaded yet)' translated format: {constructorArgs first})! !!DisplayScanner methodsFor: 'scanning' stamp: 'ar 7/30/2009 22:13'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	destY := lineY + line baseline - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex 	"XXXX: The following is an interesting bug. All stopConditions exept #endOfRun		have lastIndex past the last character displayed. #endOfRun sets it *on* the character.		If we display up until lastIndex then we will also display invisible characters like		CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex		consistently) but I don't want to deal with the fallout right now so we keep the		fix minimally invasive."				to: (stopCondition == #endOfRun ifTrue:[lastIndex] ifFalse:[lastIndex-1]) 				at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		lastIndex > runStopIndex ifTrue: [done := true].	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!DisplayScreen methodsFor: 'private' stamp: 'bf 5/8/2010 11:48'!actualDisplay	"The display known to the VM"	^self! !!DisplayScreen class methodsFor: 'host window access'!hostWindowIndex	^ 1! !!DisplayScreen class methodsFor: 'host window access' stamp: 'bf 8/22/2009 01:27'!hostWindowSize: aPoint 	self primitiveWindowSize: self hostWindowIndex width: aPoint x heigth: aPoint y! !!DisplayScreen class methodsFor: 'host window access'!hostWindowTitle: aString 	self primitiveWindowTitle: self hostWindowIndex string: aString squeakToUtf8! !!DisplayScreen class methodsFor: 'host window access' stamp: 'bf 8/22/2009 01:26'!primitiveWindowSize: id width: width heigth: height 	<primitive: 'primitiveHostWindowSizeSet' module: 'HostWindowPlugin'>	"ignore failure"! !!DisplayScreen class methodsFor: 'host window access' stamp: 'bf 4/29/2009 21:50'!primitiveWindowTitle: id string: titleString 	<primitive: 'primitiveHostWindowTitle' module:'HostWindowPlugin'>	"ignore failure"! !!DrGAngle2VectorsItem methodsFor: 'private' stamp: 'jlrr 9/29/2007 14:40'!adaptiveDescriptiveName	^ 'This oriented angle %1' translated! !!DrGAngle2VectorsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/5/2006 12:39'!basicType	^#angle! !!DrGAngle2VectorsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:38'!nodeType	^ #'vectors'! !!DrGAngle2VectorsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!update|u v|	self doesParentExist ifTrue:		[u := parents first direction.		v := parents second direction.		(u = (0@0) or: [v = (0@0)]) 			ifTrue: [exist := false]			ifFalse:				[radianValue := value := ((u crossProduct: v) asFloat arcTan2: (u dotProduct: v)).				degreeValue := radianValue radiansToDegrees]].	! !!DrGAngle2VectorsItem commentStamp: '<historical>' prior: 0!Define an oriented angle, in the range ]-180 ; 180]!!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 22:33'!forceVisible: aBoolean	(super forceVisible: aBoolean) ifFalse: [^false].	aBoolean 		ifTrue: 			[drawable addMorph: shapeMorph]		ifFalse: 			[drawable removeMorph: shapeMorph].	^true! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 23:57'!position|angle|	angle := length negated / 2 + origin negated.	^ (drawable worldToMorph: center) 		+ ((30 * (angle cos)) @ (30 * (angle sin)))! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/5/2006 12:37'!redraw	self redrawShape.	"do it last cause we have some needed computation in redrawShape"	super redraw ! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 5/12/2010 21:08'!redrawArc	shapeMorph className ~= 'DrGArcMorph'		ifTrue:			[drawable removeMorph: shapeMorph.			shapeMorph := DrGArcMorph new borderColor: Color black; 				borderWidth: 1. 			drawable addMorph: shapeMorph].	shapeMorph 			center: (drawable worldToMorph: center)			radius: 15			origin: origin negated			length: length negated! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 5/12/2010 21:07'!redrawRec	| vertices sum |	shapeMorph className = 'DrGPolylineMorph' 		ifFalse: 			[drawable removeMorph: shapeMorph.			shapeMorph := (DrGPolylineMorph new)						borderColor: Color black;						borderWidth: 1.			drawable addMorph: shapeMorph].	vertices := OrderedCollection new.	vector1 := vector1 + screenCenter.	sum := vector1 + vector2.	vector2 := vector2 + screenCenter.	vertices		add: vector1;		add: sum;		add: vector2.	shapeMorph setVertices: vertices! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/5/2006 12:10'!redrawShape	self updateArcData.	(mathItem radianAngle closeTo: Float halfPi)		ifTrue:			[self updateRecData.			self redrawRec]		ifFalse:			[self redrawArc].! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 6/22/2006 08:47'!updateArcData|end parents |	parents := mathItem parents.	center := parents second point.	vector1 := parents first point - center.	vector2 := parents third point - center.	(vector1 = (0@0) or: [vector2 = (0@0)]) 		ifTrue: [^self].	origin := (vector1 y asFloat) arcTan2: vector1 x.	end := (vector2 y asFloat) arcTan2: vector2 x.	origin < 0 ifTrue: [origin := origin + DrGDirectionItem twoPi].	end < 0 ifTrue: [end := end + DrGDirectionItem twoPi].	length := (end - origin) cos arcCos.	(end - origin > Float pi 		or: [end - origin < 0 and: [end - origin > Float pi negated]])				ifTrue: [length := length negated].! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/5/2006 01:31'!updateRecData|size|	(vector1 = (0@0) or: [vector2 = (0@0)]) 		ifTrue: [^self].	size := drawable pixelToWorld: 10.	vector1 := drawable vectorToMorph: (size * vector1 / vector1 r).	vector2 := drawable vectorToMorph: (size * vector2 / vector2 r).	screenCenter := drawable worldToMorph: center.! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 22:35'!updateToInvisible	super updateToInvisible.	drawable removeMorph: shapeMorph.! !!DrGAngle3PointsCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 22:28'!updateToVisible	super updateToVisible.	style isNotHidden		ifTrue: [drawable addMorph: shapeMorph]! !!DrGAngle3PointsCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/4/2006 17:22'!initialize	super initialize.	drawable addMorph: shapeMorph! !!DrGAngle3PointsCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/5/2006 12:34'!instantiateMorph	super instantiateMorph.	shapeMorph := DrGArcMorph new borderColor: Color black; borderWidth: 1.! !!DrGAngle3PointsCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/3/2008 10:59'!release	drawable removeMorph: shapeMorph.	super release.! !!DrGAngle3PointsCostume commentStamp: '<historical>' prior: 0!origin, length, center, vector1 and vector are data to drwa the arc or square for the geometric angle!!DrGAngle3PointsItem methodsFor: 'private' stamp: 'jlrr 9/29/2007 14:36'!adaptiveDescriptiveName	^ 'This geometric angle %1' translated! !!DrGAngle3PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/5/2006 12:13'!basicType	^#angle3Points! !!DrGAngle3PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 22:45'!move: aPoint"Don't move when user drag around"! !!DrGAngle3PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!update|u v center|	self doesParentExist ifTrue:		[center := parents second point.		u := parents first point - center.		v := parents third point - center.		(u = (0@0) or: [v = (0@0)]) 			ifTrue: [exist := false]			ifFalse:				[radianValue := value := ((u crossProduct: v) asFloat arcTan2: (u dotProduct: v)) abs.				degreeValue := radianValue radiansToDegrees]].! !!DrGAngle3PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:39'!nodeType	^#'3pts'! !!DrGAngle3PointsItem commentStamp: '<historical>' prior: 0!Define a geometric angle in the range  [0 ; 180]!!DrGAngleBuilder methodsFor: 'private' stamp: 'HilaireFernandes 2/4/2006 10:59'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection first isPointItem		ifTrue:			[pointA ifNil: 				[pointA := aMathItemCollection first.				^self].			pointB ifNil:				[pointB := aMathItemCollection first.				^self].			pointC := aMathItemCollection first]		ifFalse:			[vectorA ifNil:				[vectorA := aMathItemCollection first.				^self].			vectorB := aMathItemCollection first]! !!DrGAngleBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 8/6/2008 13:52'!arguments	^pointA 		ifNotNil: [{pointA . pointB . pointC. point}]		ifNil: [{vectorA . vectorB. point}]! !!DrGAngleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 4/30/2010 22:27'!isWanted: aMathItemCollection	^aMathItemCollection notEmpty		and: 			[(aMathItemCollection first isPointItem				and: [aMathItemCollection first ~= pointA]				and: [aMathItemCollection first ~= pointB					and: [aMathItemCollection first ~= pointC]]	)			or: 	[aMathItemCollection first isVectorItem 				and: [aMathItemCollection first ~= vectorA]				and: [aMathItemCollection first ~= vectorB]]]! !!DrGAngleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 2/4/2006 11:02'!readyToBuild	^ (pointA notNil and: [pointB notNil] and: [pointC notNil])		or: [vectorA notNil and: [vectorB notNil]]			! !!DrGAngleBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 8/6/2008 13:52'!mathItemClass	^pointA 		ifNotNil: [DrGAngle3PointsItem]		ifNil: [DrGAngle2VectorsItem]! !!DrGAngleBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 2/4/2006 11:02'!reset	super reset.	pointA := pointB := pointC := vectorA := vectorB := nil! !!DrGAngleCostume methodsFor: 'testing' stamp: 'HilaireFernandes 2/5/2006 12:33'!basicType	^#angle! !!DrGAngleCostume methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/16/2006 17:10'!roundedValueString	^ mathItem degreeAngle rounded asString, ''.! !!DrGAngleCostume methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/28/2008 21:47'!textMorph:	string	"we don't have label'"! !!DrGAngleCostume commentStamp: '<historical>' prior: 0!origin, length, center, vector1 and vector are data to drwa the arc or square for the geometric angle!!DrGAngleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/4/2006 11:56'!basicType	^#angle! !!DrGAngleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/4/2006 10:25'!degreeAngle"return the angle in degree"	^degreeValue ! !!DrGAngleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/4/2006 10:25'!radianAngle"return the angle in radian"	^radianValue ! !!DrGAngleItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/4/2006 09:58'!isAngleItem	^true! !!DrGAngleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:38'!nodeName	^#angle! !!DrGArc3PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 10:53'!endPoint	^parents third point! !!DrGArc3PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:35'!parentQty	^3! !!DrGArc3PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 10:53'!startPoint	^parents first point! !!DrGArc3PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 08:44'!nodeType	^#'3pts'! !!DrGArc3PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 7/18/2008 13:49'!update	| direction1 direction2 a b c ab |	self doesParentExist 		ifTrue: 			[a := parents first point.			b := parents second point.			c := parents third point.			a = b 				ifTrue: 					[exist := false.					^self].			c = b 				ifTrue: 					[exist := false.					^self ].			direction1 := (DrGDirectionItem new)						origin: (a + b) / 2;						direction: (a - b) normal.			direction2 := (DrGDirectionItem new)						origin: (b + c) / 2;						direction: (b - c) normal.			center := direction1 intersectionWithDirection: direction2.			center ifNil: [^self updateAsSegmentOrRay].			a := a - center.			b := b - center.			c := c - center.			radius := a r.			origin := a y asFloat arcTan2: a x.			ab := (b y asFloat arcTan2: b x) - origin.			length := (c y asFloat arcTan2: c x) - origin.			length = 0 				ifTrue: 					[exist := false.					^self].			(length < 0 and: [ab < length or: [ab > 0]]) 				ifTrue: 					[length := length + DrGDirectionItem twoPi.					^self].			(length > 0 and: [ab > length or: [ab < 0]]) 				ifTrue: [length := length - DrGDirectionItem twoPi]].! !!DrGArc3PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!updateAsSegmentOrRay"the three point are aligned, the arc is a segment"	exist := false.! !!DrGArcBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/16/2006 20:45'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint.	pointA ifNil: 		[pointA := aMathItemCollection first.		^ self].	pointB ifNil: 		[pointB := aMathItemCollection first.		^self].	pointC ifNil: [pointC := aMathItemCollection first].	! !!DrGArcBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 20:46'!arguments	^{pointA . pointB . pointC}! !!DrGArcBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/16/2006 20:50'!isWanted: aMathItemCollection 	^aMathItemCollection notEmpty		and: [aMathItemCollection first isPointItem] 		and: [aMathItemCollection first ~= pointA] 		and: [aMathItemCollection first ~= pointB]		and: [aMathItemCollection first ~= pointC]! !!DrGArcBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/16/2006 20:52'!readyToBuild	^pointA notNil and: [pointB notNil] and: [pointC notNil]! !!DrGArcBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:55'!mathItemClass	^DrGArc3PointsItem! !!DrGArcBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/16/2006 20:52'!reset	super reset.	pointA := pointB := pointC := nil! !!DrGArcCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/17/2006 08:58'!basicType	^#arc! !!DrGArcCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:02'!instantiateMorph	morph := DrGArcMorph new! !!DrGArcCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 11:23'!redraw	exist ifFalse: [^self].	super redraw.	mathItem center 		ifNotNil:			[morph class = DrGArcMorph 				ifTrue: [self redrawAsArc] 				ifFalse: 					["mutate the morph to an DrGArcMorph and draw it"]]		ifNil:			[morph class = DrGSegmentMorph				ifTrue: [self redrawAsSegmentOrRay]				ifFalse: ["mutate the morph to DrGSegment and draw it"]].! !!DrGArcCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 11:06'!redrawAsArc	morph 		center: (drawable worldToMorph: mathItem center)		radius: (drawable worldToPixel: mathItem radius)		origin: mathItem origin negated		length: mathItem length negated! !!DrGArcCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 11:22'!redrawAsSegmentOrRay! !!DrGArcCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:03'!styleClass	^DrGFinitCurveCostumeStyle! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 15:39'!abscissaOf: aPoint	^(self angleOf: aPoint) / length! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:00'!basicType	^#arc! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:01'!center	^center! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:01'!center: aPoint	center := aPoint ! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 10:51'!endPoint	self subclassResponsibility! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:02'!length	^length! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:02'!length: aFloat	length := aFloat ! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:02'!origin	^origin! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:02'!origin: aFloat	origin := aFloat ! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:01'!radius	^radius! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2006 21:01'!radius: aFloat	radius := aFloat! !!DrGArcItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 10:51'!startPoint	self subclassResponsibility! !!DrGArcItem methodsFor: 'private' stamp: 'jlrr 9/29/2007 15:01'!adaptiveDescriptiveName	^ 'This Arc Circle %1' translated! !!DrGArcItem methodsFor: 'private' stamp: 'HilaireFernandes 6/22/2006 08:50'!angleOf: aPoint 	"Compute the angle position of aPoint in the circle"	| angleM pointM |	pointM := aPoint - center.	angleM := (pointM y asFloat arcTan2: pointM x) - origin.	"Transcript show: 'angle(1): ', angleM asString, 'origin: ', origin asString."	length > 0 		ifTrue: 			[angleM < 0 ifTrue: [angleM := angleM + DrGDirectionItem twoPi].			angleM > length ifTrue: [angleM := length]]		ifFalse: 			[angleM > 0 ifTrue: [angleM := angleM - DrGDirectionItem twoPi].			angleM < length ifTrue: [angleM := length]].	"	Transcript show: 'angle: ', angleM asString , ' length: ', length asString;cr."	^angleM! !!DrGArcItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/17/2006 14:37'!closestPointTo: aPoint	| angle |	angle := self angleOf: aPoint.	^center + (radius * ((origin + angle) cos @ (origin + angle) sin))! !!DrGArcItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/24/2006 22:55'!intersectionWithCircle: aCircleOrArcItem flag: aFlag 	| circleItem |	circleItem := (DrGCircleItem new)				center: self center;				radius: self radius.	^circleItem intersectionWithCircle: aCircleOrArcItem flag: aFlag! !!DrGArcItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/24/2006 22:55'!intersectionWithDirection: aDirectionItem flag: aFlag 	| circleItem |	circleItem := (DrGCircleItem new)				center: self center;				radius: self radius.	^circleItem intersectionWithDirection: aDirectionItem flag: aFlag! !!DrGArcItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/17/2006 18:58'!intersectionWith: aCurveItem flag: aFlag	| aPoint |	aCurveItem isLineItem 		ifTrue: 			[aPoint := self intersectionWithDirection: aCurveItem flag: aFlag.			aPoint ifNil: [^nil].			(self contains: aPoint)				ifTrue: [^aPoint]				ifFalse: [^nil]].	(aCurveItem isRayItem or: [aCurveItem isSegmentItem])		ifTrue:			[aPoint := self intersectionWithDirection: aCurveItem flag: aFlag.			aPoint ifNil: [^nil].			((self contains: aPoint) and: [aCurveItem contains: aPoint])				ifTrue: [^aPoint]				ifFalse: [^nil]].	aCurveItem isCircleItem		ifTrue:			[aPoint := self intersectionWithCircle: aCurveItem flag: aFlag.			aPoint ifNil: [^nil].			(self contains: aPoint)				ifTrue: [^aPoint]				ifFalse: [^nil]].	aCurveItem isArcItem		ifTrue:			[aPoint := self intersectionWithCircle: aCurveItem flag: aFlag.			aPoint ifNil: [^nil].			((self contains: aPoint) and: [aCurveItem contains: aPoint])				ifTrue: [^aPoint]				ifFalse: [^nil]].! !!DrGArcItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/17/2006 14:39'!pointAt: anAbscissa	|angle|	angle := origin + (anAbscissa * length).	^center + (radius * (angle cos @ angle sin))	! !!DrGArcItem methodsFor: 'testing' stamp: 'HilaireFernandes 9/5/2009 22:53'!contains: aPoint 	| angleM pointM |	((center dist: aPoint) closeTo: radius) ifFalse: [^false].	pointM := aPoint - center.	angleM := (pointM y asFloat arcTan2: pointM x) - origin.	^ length > 0 		ifTrue: 			[angleM < 0 ifTrue: [angleM := angleM + DrGDirectionItem twoPi].			length >= angleM]		ifFalse: 			[angleM > 0 ifTrue: [angleM := angleM - DrGDirectionItem twoPi].			length <= angleM]! !!DrGArcItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:34'!isArcItem	^true! !!DrGArcItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:34'!isCurveItem	^true! !!DrGArcItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:34'!isGeometricItem	^true! !!DrGArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 08:50'!nodeName	'arcCircle'! !!DrGArcMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 12:29'!center: aPoint radius: aFloat origin: anOrigin length: aLength|step costep sinstep csteX csteY mobile|	step := 5 / aFloat * aLength sign.	(aLength / step) abs > 100 ifTrue: [step := aLength / 100].	costep := step cos.	sinstep := step sin.	csteX := aPoint x * (1 - costep) + (aPoint y * sinstep).	csteY := aPoint y * (1 - costep) - (aPoint x * sinstep).	mobile := aPoint + (aFloat * (anOrigin cos @ anOrigin sin)).	vertices := OrderedCollection new add: mobile; yourself.	0 to: (aLength / step) truncated -1  do: [:i|		mobile := (mobile x * costep - (mobile y * sinstep) + csteX)			@(mobile x * sinstep + (mobile y * costep) + csteY).		vertices add: mobile].	mobile := aPoint + (aFloat * ((anOrigin + aLength) cos @ (anOrigin + aLength) sin)).	vertices add: mobile.	self computeBounds! !!DrGBuildTool methodsFor: 'adding' stamp: 'HilaireFernandes 8/9/2008 16:13'!add: aCostume	self stopBlinking.	selectedCostumes add: aCostume.	self startBlinking.	"the flyCostume need this to catch the selected mathItem"	self triggerEvent: #selectedCostume with: aCostume.! !!DrGBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/5/2006 17:13'!builder	^builder! !!DrGBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/5/2006 17:12'!builder: aBuilder	builder := aBuilder ! !!DrGBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/22/2008 16:27'!initialize	super initialize.	self switchState:  DrGBuildToolState.	selectedCostumes := OrderedCollection new! !!DrGBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/5/2006 17:50'!registerDependant: anObject	builder when: #readyToBuild send: #readyToBuild to: anObject! !!DrGBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:27'!release	super release.	builder release.	self releaseActionMap. ! !!DrGBuildTool methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:09'!isWanted: aMathItemCollection	^builder isWanted: aMathItemCollection  ! !!DrGBuildTool methodsFor: 'updating' stamp: 'HilaireFernandes 6/15/2010 22:29'!reset	super reset.	self stopBlinking.	self builder reset.	selectedCostumes := OrderedCollection new! !!DrGBuildTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/24/2008 23:49'!startBlinking	selectedCostumes do: [ :aCostume | aCostume startBlinking ]! !!DrGBuildTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/24/2008 23:49'!stopBlinking	selectedCostumes do: [ :aCostume | aCostume stopBlinking ]! !!DrGBuildTool class methodsFor: 'instance creation' stamp: 'HilaireFernandes 1/5/2006 17:12'!with: aBuilderClassName	^self new builder: aBuilderClassName new.! !!DrGBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 3/21/2006 10:15'!handleChoice: aCostumeCollection|aMathItemCollection|	aMathItemCollection := OrderedCollection new.	aCostumeCollection do: [:aCostume|		aMathItemCollection add: aCostume mathItem.		self context add: aCostume].	^self context builder 		add: aMathItemCollection 		at: (self area gridWorldPoint: self context last)! !!DrGBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/22/2008 16:26'!handlePress: aPoint 	"return true if we process something (including additional user choice)"	| costumes |	self area hideTip.	self context last: aPoint.	costumes := self context costumesAt: aPoint.	costumes size = 1 		ifTrue: 			[self handleChoice: costumes.			^true].	(costumes size = 0 and: [self context builder isWanted: { }]) 		ifTrue: 			[self handleChoice: costumes.			^true].	"More than one math item under mouse, user must choose one item"	costumes size >= 2 		ifTrue: 			["Display a pop-up menu to select one item"			self context chooseCostume: costumes.			^true].	^false! !!DrGCircle2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:03'!nodeType	^#'2pts'! !!DrGCircle2PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:35'!parentQty	^2! !!DrGCircle2PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!update	self doesParentExist		ifTrue: [center := parents first point.					radius := center dist: parents second point].! !!DrGCircleBuilder methodsFor: 'private' stamp: 'HilaireFernandes 3/21/2010 21:42'!addItem: aMathItemCollection at: aPoint 	point := aPoint.	aMathItemCollection first isValueItem		ifTrue: [radius 	ifNil: [radius := aMathItemCollection first]]					ifFalse: 			[pointA 				ifNil: [pointA := aMathItemCollection first]				ifNotNil: [pointB := aMathItemCollection first]]! !!DrGCircleBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2010 21:43'!arguments	^pointB		ifNil: [radius ifNotNil: [ {pointA. radius}]]		ifNotNil: [{pointA. pointB}]! !!DrGCircleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 21:38'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty		and: [(aMathItemCollection first isPointItem					and: [aMathItemCollection first ~= pointA]					and: [aMathItemCollection first ~= pointB])				or: [aMathItemCollection first isValueItem						and: [pointA isNil not]						and: [aMathItemCollection first ~= radius]]]! !!DrGCircleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 21:39'!readyToBuild	^ (radius notNil and: [pointA notNil])		or: [pointA notNil and: [pointB notNil]]! !!DrGCircleBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/21/2010 21:44'!mathItemClass	^ radius		ifNil: [DrGCircle2PointsItem]		ifNotNil: [DrGCircleRadius]! !!DrGCircleBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 9/6/2007 21:08'!reset	super reset.	radius := nil.! !!DrGCircleCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#circle! !!DrGCircleCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:02'!instantiateMorph	morph := DrGCircleMorph new! !!DrGCircleCostume methodsFor: 'updating' stamp: 'HilaireFernandes 6/21/2007 17:54'!redraw	super redraw.	mathItem radius > 100		ifTrue: [self redrawAsLine]		ifFalse: [self redrawAsCircle]! !!DrGCircleCostume methodsFor: 'updating' stamp: 'HilaireFernandes 6/21/2007 17:37'!redrawAsCircle	lineMorph ifNotNil: [		drawable removeMorph: lineMorph.		drawable addMorph: morph.		lineMorph := nil].	morph		center: (drawable worldToMorph: mathItem center)		radius: (drawable worldToPixel: mathItem radius)! !!DrGCircleCostume methodsFor: 'updating' stamp: 'HilaireFernandes 6/21/2007 18:08'!redrawAsLine	| p1 p2 |	lineMorph		ifNil: [lineMorph := DrGLineMorph new costume: self.			lineMorph color: morph color;				 borderWidth: morph borderWidth.			drawable removeMorph: morph.			drawable addMorph: lineMorph].	p1 := mathItem				closestPointTo: (drawable morphToWorld: ActiveHand position).	p2 := mathItem pointAt: (mathItem abscissaOf: p1)					+ 0.001.	lineMorph		from: (drawable worldToMorph: p1)		direction: (drawable vectorToMorph: p2 - p1)! !!DrGCircleCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:02'!styleClass	^DrGCurveCostumeStyle! !!DrGCircleCostume commentStamp: 'HilaireFernandes 6/21/2007 17:30' prior: 0!when Circle goes infinit replace it by a lineMorph!!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2006 22:55'!abscissaOf: aPoint 	| angle vector |	vector := aPoint - self center.	angle := vector y arcTan: vector x.	angle < 0 ifTrue: [angle := angle + (2 * Float pi)].	^angle * 0.5 * DrGDirectionItem invPi! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 10:41'!basicType	^#circle! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 10:23'!center	^center! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/3/2006 16:27'!center: aPoint	center := aPoint ! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 11:12'!closestPointTo: aPoint	^self center + (self radius * (aPoint - self center) normalized)! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 11:06'!pointAt: anAbscissa	|angle|	angle := 2 * Float pi * anAbscissa.	^ (Point x: angle cos y: angle sin) * self radius + self center.! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 10:24'!radius	^radius! !!DrGCircleItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/3/2006 16:27'!radius: aFlaot	radius := aFlaot ! !!DrGCircleItem methodsFor: 'private' stamp: 'HilaireFernandes 2/1/2008 12:35'!adaptiveDescriptiveName	^ 'This circle %1' translated! !!DrGCircleItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/24/2006 22:55'!intersectionWithCircle: aCircleItem flag: aFlag 	| directionItem aVector aRadius x d |	directionItem := DrGDirectionItem new.	aVector := aCircleItem center - center.	aRadius := aCircleItem radius.	d := aVector dotProduct: aVector.	x := (d + radius squared - aRadius squared) / (2 * d).	directionItem direction: aVector normal.	directionItem origin: x * aVector + center.	^self intersectionWithDirection: directionItem flag: aFlag! !!DrGCircleItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/12/2006 22:10'!intersectionWithDirection: aDirectionItem flag: aFlag|a b c d k vector|	vector := aDirectionItem direction.	a := vector dotProduct: vector.	b := vector dotProduct: (aDirectionItem origin - self center).	c := (aDirectionItem origin squaredDistanceTo: self center) - self radius squared.	d := b squared - (a * c).	(d < 0 or: [a = 0]) ifTrue: [^ nil].	k := (b negated + (aFlag * d sqrt)) / a.	^ aDirectionItem origin + (k * vector)! !!DrGCircleItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/17/2006 17:49'!intersectionWith: aCurveItem flag: aFlag|aPoint|	aCurveItem isLineItem 		ifTrue: [^self intersectionWithDirection: aCurveItem  flag: aFlag].	(aCurveItem isSegmentItem or: [aCurveItem isRayItem])		ifTrue:			[aPoint := self intersectionWithDirection: aCurveItem  flag: aFlag.			aPoint ifNil: [^nil].			(aCurveItem contains: aPoint)				ifTrue: [^aPoint]				ifFalse: [^nil]].	aCurveItem isCircleItem		ifTrue: [^self intersectionWithCircle: aCurveItem flag: aFlag].	aCurveItem isArcItem		ifTrue: [^aCurveItem intersectionWith: self flag: aFlag]! !!DrGCircleItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:35'!isCircleItem	^true! !!DrGCircleItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:35'!isCurveItem	^true! !!DrGCircleItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:35'!isGeometricItem	^true! !!DrGCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 08:55'!nodeName	^'circle'! !!DrGCircleItem commentStamp: '<historical>' prior: 0!Instance variables radius and center are used to cache these values!!DrGCircleMorph methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/21/2006 15:51'!dashedBorder: dashSpec! !!DrGCircleMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 14:23'!center: aPoint radius: aFloat	self bounds: (aPoint - aFloat corner: aPoint + aFloat)! !!DrGCircleMorph methodsFor: 'geometry testing' stamp: 'HilaireFernandes 3/6/2006 10:17'!containsPoint: aPoint	"it is a circle so height and width is the diameter"	(bounds containsPoint: aPoint) ifFalse: [^false].	^((self center dist: aPoint) - (self height / 2)) abs < 10! !!DrGCircleMorph methodsFor: 'drawing' stamp: 'HilaireFernandes 1/21/2006 16:00'!drawOn: aCanvas	aCanvas frameOval: self bounds width: self borderWidth color: self color! !!DrGCircleRadius methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:39'!moveParent: aPoint 	| thePoint |	(parents			noneSatisfy: [:item | item isValueItem])		ifTrue: [^ super moveParent: aPoint].	"we just want to move the center point, not the radius value"	thePoint := parents first.	thePoint moveEvent: aPoint.	^ true! !!DrGCircleRadius methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!update	self doesParentExist		ifTrue: [center := parents first point.			radius := parents second valueItem].! !!DrGCircleRadius methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/22/2008 17:52'!nodeType	^ #radius! !!DrGCircleRadius methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2008 17:51'!parentQty	^ 2! !!DrGCircleSegment methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/28/2008 22:21'!nodeType	^ #segment! !!DrGCircleSegment methodsFor: 'updating' stamp: 'HilaireFernandes 1/28/2008 22:23'!update	self doesParentExist		ifTrue: [center := parents first point.			radius := parents second direction r]! !!DrGCommand methodsFor: 'accessing' stamp: 'HilaireFernandes 12/26/2005 09:01'!domain: aDomain	domain := aDomain.! !!DrGCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/30/2006 23:52'!execute	self subclassResponsibility ! !!DrGCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/30/2006 23:52'!unexecute	self subclassResponsibility ! !!DrGCommandManager methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/18/2008 12:48'!release	stack contents do: [:c | c release].	super release.! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 2/2/2006 09:49'!buildCommandFor: aMathItem	|command|	command := stack nextPut: (DrGMathItemCommand for: aMathItem in: domain).	^command execute! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 1/30/2006 17:05'!buildCommandWith: aBuilder	|command|	command := stack nextPut: (DrGMathItemCommand with: aBuilder in: domain).	^command execute! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 3/2/2006 22:01'!compositeCommandFor: aMathItemSelection|command|	command := stack nextPut: (DrGCompositeCommand with: aMathItemSelection in: domain).	command execute.! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 1/30/2006 17:08'!deleteCommandFor: aMathItem|command|	command := stack nextPut: (DrGDeleteCommand for: aMathItem in: domain).	command execute! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 1/31/2006 11:33'!moveCommandFor: aMathItem with: aPoint	stack nextPut: (DrGMoveCommand for: aMathItem with: aPoint in: domain).! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 1/31/2006 00:14'!redo|command|	command := stack next.	command ifNotNil:	[command execute]! !!DrGCommandManager methodsFor: 'command exec' stamp: 'HilaireFernandes 1/31/2006 00:14'!undo|command|	command := stack previous.	command ifNotNil: [command unexecute]! !!DrGCommandManager methodsFor: 'accessing' stamp: 'HilaireFernandes 1/30/2006 17:03'!domain: aDomain	domain := aDomain! !!DrGCommandManager methodsFor: 'initialization' stamp: 'HilaireFernandes 1/30/2006 16:46'!initialize	stack := DrGCommandStack new! !!DrGCommandStack methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 13:57'!nextPut: aCommand	super nextPut: aCommand.	self truncate.	^ aCommand ! !!DrGCommandStack methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 14:08'!previous	self position = 0 ifTrue: [^nil].	self position: self position - 1.	^self peek.! !!DrGCommandStack methodsFor: 'private' stamp: 'HilaireFernandes 12/21/2005 13:57'!truncate	|oldReadLimit|	oldReadLimit := readLimit.	readLimit := position.	oldReadLimit > readLimit ifTrue:			[readLimit to: oldReadLimit do:				[:index| collection at: index + 1 put: nil]]! !!DrGCommandStack class methodsFor: 'instance creation' stamp: 'HilaireFernandes 12/21/2005 14:20'!new	^self on: Array new! !!DrGCompositeCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 18:18'!compileComposite: theMathItems	mathItems := theMathItems.	compositeItem := DrGCompositeItem newWith: theMathItems.! !!DrGCompositeCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 22:22'!execute	domain triggerEvent: #groupCostumes with: compositeItem.! !!DrGCompositeCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/18/2008 12:47'!release	super release.	compositeItem release.! !!DrGCompositeCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 22:22'!unexecute	domain triggerEvent: #ungroupCostumes with: compositeItem.! !!DrGCompositeCommand class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 22:02'!with: theMathItems in: aDomain	^self new		domain: aDomain ;		compileComposite: theMathItems! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 13:00'!addCostume: aCostume	mathItem subItems: (mathItem subItems add: aCostume mathItem; yourself).	drawable app remove: aCostume.	subCostumes add: aCostume.	! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 11:16'!changed	subCostumes do: [:costume |		costume changed]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 12:03'!color: aColor	subCostumes do: [:aCostume |			aCostume style color: aColor]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 14:57'!dash: anObject	subCostumes do: [:aCostume|		aCostume isCurveCostume ifTrue:			[aCostume dash: anObject]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 22:43'!forceVisible: aBoolean	subCostumes do: [:costume |		costume forceVisible: aBoolean]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:09'!makeBackArrow	subCostumes do: [:aCostume|		aCostume isFinitCurveCostume ifTrue:			[aCostume makeBackArrow]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:08'!makeBothArrows	subCostumes do: [:aCostume|		aCostume isFinitCurveCostume ifTrue:			[aCostume makeBothArrows]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:07'!makeForwardArrow	subCostumes do: [:aCostume|		aCostume isFinitCurveCostume ifTrue:			[aCostume makeForwardArrow]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:10'!makeNoArrows	subCostumes do: [:aCostume|		aCostume isFinitCurveCostume ifTrue:			[aCostume makeNoArrows]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 22:39'!redraw	subCostumes do: [:costume |		costume redraw]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 13:01'!removeCostume: aCostume	mathItem subItems: (mathItem subItems copyWithout: aCostume mathItem).	drawable app add: aCostume.	subCostumes remove: aCostume.! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 14:51'!shape: anObject	subCostumes do: [:aCostume|		aCostume isPointCostume ifTrue:			[aCostume style shape: anObject]]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 18:06'!startBlinking	subCostumes do: [:costume |		costume startBlinking ]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 18:06'!stopBlinking	subCostumes do: [:costume |		costume stopBlinking ]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:52'!updatedMathItem	subCostumes do: [:costume |		costume update]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 22:42'!updateToInvisible	subCostumes do: [:costume |		costume updateToInvisible]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 22:42'!updateToVisible	subCostumes do: [:costume |		costume updateToVisible]! !!DrGCompositeCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 16:27'!width: anInteger	subCostumes do: [:aCostume|		aCostume isCurveCostume ifTrue:			[aCostume width: anInteger]]! !!DrGCompositeCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/2/2006 22:48'!basicType	^#composite! !!DrGCompositeCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/2/2006 22:58'!containsPoint: aPoint	subCostumes do: [:costume|		(costume containsPoint: aPoint) ifTrue:			[^true]].	^false! !!DrGCompositeCostume methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 4/19/2010 13:01'!disband"Disband this composite item"	drawable app ungroupCostumes: mathItem! !!DrGCompositeCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/23/2008 12:15'!initialize	exist := true.	self style: (self styleClass newWith: self).! !!DrGCompositeCostume methodsFor: 'style' stamp: 'HilaireFernandes 3/2/2006 23:42'!styleClass	^DrGCompositeStyle! !!DrGCompositeCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 3/2/2006 19:02'!subCostumes	^subCostumes ! !!DrGCompositeCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 3/2/2006 19:03'!subCostumes: theSubCostumes	subCostumes := theSubCostumes ! !!DrGCompositeCostume commentStamp: '<historical>' prior: 0!I am a costume composed of several costumes!!DrGCompositeCostume class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 23:46'!for: aMathItem in: aDrawable with: theSubCostumes	^ self basicNew 		drawable: aDrawable;		mathItem: aMathItem;		subCostumes: theSubCostumes;		initialize! !!DrGCompositeItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 14:01'!adaptiveDescriptiveName	^ 'This composite object %1' translated! !!DrGCompositeItem methodsFor: 'comparing' stamp: 'HilaireFernandes 3/25/2006 17:56'!hash	^ self subItems hash bitXor: self className hash! !!DrGCompositeItem methodsFor: 'comparing' stamp: 'HilaireFernandes 4/10/2010 12:36'!= aMathItem	^ aMathItem 		ifNil: [false] 		ifNotNil: [self className = aMathItem className 			and: [self subItems = aMathItem subItems]]! !!DrGCompositeItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/1/2006 10:01'!isCompositeItem	^true! !!DrGCompositeItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/3/2006 12:08'!isGeometricItem"if all subitem are geometric item, considere ourself as a geometric item"	subItems do: [:aMathItem |		(aMathItem isGeometricItem) 			ifFalse: [^false]].	^true! !!DrGCompositeItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 18:27'!moveParent: aPoint	^false! !!DrGCompositeItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:39'!move: aPoint	subItems do: [:item|		(item class ~= DrGFreePointItem			and: [item class ~= DrGPointItemOnCurve])			ifTrue:				[item moveEvent: aPoint]].! !!DrGCompositeItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/1/2006 10:26'!subItems	^subItems ! !!DrGCompositeItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/1/2006 10:26'!subItems: theSubItems	subItems := theSubItems ! !!DrGCompositeItem commentStamp: '<historical>' prior: 0!I am the composite item, I represent a set of math items.!!DrGCompositeItem class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 3/2/2006 18:17'!newWith: theSubItems	^self new		subItems: theSubItems! !!DrGCompositeStyle methodsFor: 'menu' stamp: 'jlrr 9/29/2007 15:03'!addMyMenus: theMenu 	super addMyMenus: theMenu.	self addShapeMenu: theMenu.	theMenu		add: 'disband this group' translated		target: costume		action: #disband! !!DrGCompositeStyle methodsFor: 'menu' stamp: 'jlrr 9/30/2007 15:12'!addShapeMenu: theMenu 	| subMenu |	subMenu := MenuMorph new.	#(#cross #round #square )		do: [:aShape | subMenu				add: aShape asString translated				target: self				selector: #shape:				argument: aShape].	theMenu add: 'shape' translated subMenu: subMenu! !!DrGCompositeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 3/3/2006 14:46'!shape	^shape! !!DrGCompositeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 3/3/2006 14:51'!shape: anObject	shape := anObject.	costume shape: anObject! !!DrGComputedValueItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:02'!writeAsXmlTo: aNode 	"return the newly created element"	| node |	node := XMLElement named: self nodeName attributes: Dictionary new.	aNode addElement: node.	node attributeAt: #type put: self nodeType.	node		addElement: ((XMLElement named: #x)				addContent: (XMLStringNode string: position x asString));				addElement: ((XMLElement named: #y)				addContent: (XMLStringNode string: position y asString)).	self writeParentsAsXmlTo: node.	^ node! !!DrGCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 17:31'!addColorMenu: theMenu 	| subMenu |	subMenu := MenuMorph new.	self class colors do: [:aColor | |theColor|		theColor := Color perform: aColor.		subMenu			add: ''			target: self			selector: #color:			argument: theColor .		subMenu lastItem 			icon: ((Form extent: 60@12 depth: 16) fillWithColor: theColor)].	theMenu add: 'colour' translated subMenu: subMenu! !!DrGCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 1/20/2006 21:33'!addMyMenus: theMenu"Add specific subclasses menuItem and subMenu"! !!DrGCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 1/27/2008 10:16'!popupMenu	| menu |	menu := MenuMorph new title: ' edit style... ' translated.	self addColorMenu: menu.	self addMyMenus: menu.	menu		add: 'rename' translated		target: self		action: #rename.	menu		add: (self isHidden				ifTrue: ['show' translated]				ifFalse: ['hide' translated])		target: self		action: #toggleHidden.	menu addStayUpIcons.	menu popUpInWorld: World! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/25/2010 22:32'!baseColor	"Answer color whatever it is hidden or not"	^ color! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2006 23:02'!color	"Answer the value of color"	^isHidden ifTrue: [DrGCostumeStyle hiddenColor] ifFalse: [color]! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 3/3/2006 12:01'!color: anObject	"Set the value of color"	color := anObject.	costume color: color.! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/20/2006 22:55'!costume	"Answer the value of costume"	^ costume! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'CedrickBeler 4/23/2010 16:39'!costume: anObject	"Set the value of costume"	costume := anObject! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/20/2006 17:35'!isHidden	"Answer the value of isHidden"	^ isHidden! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2008 11:04'!isHidden: anObject 	"Set the value of isHidden"	isHidden := anObject.	isHidden 		ifTrue: 			[costume stopBlinking.			costume color: DrGCostumeStyle hiddenColor.			costume changed]		ifFalse: [costume color: self color]! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2006 01:31'!isNotHidden	"Answer the value of isHidden"	^ isHidden not! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/26/2008 21:23'!rename	| |	costume textMorph		ifNil: [costume textMorph: 'edit me' translated].	costume textMorph launchMiniEditor: ActiveEvent! !!DrGCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2006 16:53'!toggleHidden	self isHidden: self isHidden not! !!DrGCostumeStyle methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/22/2006 13:03'!initialize	isHidden := false.	self color: Color black.! !!DrGCostumeStyle class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/22/2006 17:20'!blinkingColor	^Color lightGray lighter lighter! !!DrGCostumeStyle class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/20/2006 22:44'!colors	^#(#black #blue #brown #green #magenta #orange #red #yellow)! !!DrGCostumeStyle class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/22/2006 16:38'!hiddenColor	^Color lightGray lighter lighter lighter! !!DrGCostumeStyle class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/21/2006 10:39'!newWith: aCostume	^self basicNew costume: aCostume; initialize! !!DrGCurveCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/12/2006 22:32'!constraintTextPosition: aPoint|center vector|	center := mathItem closestPointTo: (drawable morphToWorld: aPoint).	anchorAbscissa := mathItem abscissaOf: center.	center := drawable worldToMorph: center.	vector := aPoint - center.	^textPositionDelta := self computeTextPositionDelta: vector.! !!DrGCurveCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/12/2006 22:32'!textPosition	^(drawable worldToMorph: (mathItem pointAt: anchorAbscissa)) + textPositionDelta! !!DrGCurveCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 3/12/2006 22:38'!initialize	super initialize.	anchorAbscissa := 0.5! !!DrGCurveCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:51'!isCurveCostume	^ true! !!DrGCurveCostume methodsFor: 'xml writing' stamp: 'HilaireFernandes 4/25/2010 22:42'!writeAttributesTo: aNode	|attr|	super writeAttributesTo: aNode.	(style lineStyle = #dot or: [style lineStyle =#dashed] )		ifTrue: [attr := 'Dashed']		ifFalse: [attr := 'Normal'].	(style thickness = #large or: [style thickness = #medium]) ifTrue: [attr := 'Thick'].	aNode attributeAt: #thickness put: attr.! !!DrGCurveCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 17:25'!addLineStyleMenu: theMenu	|subMenu |	subMenu := MenuMorph new.	#(dot #dash #plain) do: [:style | 		subMenu 			add: ''			target: self			selector: #lineStyle:			argument: style.		subMenu lastItem 			icon: (DrGIcons segment: self width color: self color dash: (self lineStyleFor: style))].	theMenu add: 'line style' translated subMenu: subMenu.! !!DrGCurveCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 1/21/2006 15:57'!addMyMenus: theMenu	super addMyMenus: theMenu.	self addLineStyleMenu: theMenu.	self addThicknessMenu: theMenu! !!DrGCurveCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 17:29'!addThicknessMenu: theMenu|subMenu|	subMenu := MenuMorph new.	#(#small #medium #large) do: [:aThickness|		subMenu 			add: ''			target: self			selector: #thickness:			argument: aThickness.		subMenu lastItem			icon: (DrGIcons segment: (self widthFor: aThickness) color: self color dash: nil)].	theMenu add: 'size' translated subMenu: subMenu.! !!DrGCurveCostumeStyle methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/21/2006 15:15'!initialize	super initialize.	self lineStyle: #plain.	self thickness: #small.! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/21/2006 14:57'!lineStyle	"Answer the value of lineStyle"	^ lineStyle! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 17:23'!lineStyleFor: aStyle	"possible lineStyle"	aStyle = #dot ifTrue: [^{1. 5 . Color transparent}].	aStyle = #dash ifTrue: [^ {5. 8 . Color transparent}].	^ nil! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 17:22'!lineStyle: aSymbol	"Set the value of lineStyle"	lineStyle := aSymbol.	costume dash: (self lineStyleFor: aSymbol)! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/21/2006 14:49'!thickness	"Answer the value of thickness"	^ thickness! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 16:32'!thickness: anObject	"Set the value of thickness"	thickness := anObject.	costume width: self width.! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 17:17'!width	"give the width"	^ self widthFor: thickness! !!DrGCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 17:17'!widthFor: aThickness	"give the width"	aThickness = #small ifTrue: [^1].	aThickness = #medium ifTrue: [^2].	aThickness = #large ifTrue: [^3].	^ 0! !!DrGDefault class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/28/2008 21:30'!viewXml: filename 	DrGeo serviceViewXml: self examplesPath , FileDirectory slash , filename! !!DrGDefault class methodsFor: 'path' stamp: 'HilaireFernandes 5/19/2010 21:35'!examplesPath	^ (self isEtoys		ifTrue: [self olpcPath]		ifFalse: [self othersPath])		, FileDirectory slash , 'examples'! !!DrGDefault class methodsFor: 'path' stamp: 'HilaireFernandes 1/28/2008 21:17'!olpcPath	^ FileDirectory dirPathFor: (SmalltalkImage current getSystemAttribute: 2)! !!DrGDefault class methodsFor: 'path' stamp: 'HilaireFernandes 1/28/2008 17:28'!othersPath	^ SmalltalkImage current imagePath! !!DrGDefault class methodsFor: 'font' stamp: 'HilaireFernandes 1/26/2008 14:39'!font	^ StrikeFont familyName: self fontName pointSize: self fontPointSize! !!DrGDefault class methodsFor: 'font' stamp: 'HilaireFernandes 2/1/2008 12:37'!fontName	^ 'Accujen'! !!DrGDefault class methodsFor: 'font' stamp: 'HilaireFernandes 5/19/2010 21:35'!fontPointSize	^ self isEtoys		ifTrue: [18]		ifFalse: [12]! !!DrGDefault class methodsFor: 'testing' stamp: 'HilaireFernandes 5/19/2010 21:34'!isEtoys	^ SystemVersion current version beginsWith:  'etoys'! !!DrGDeleteCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/18/2008 16:44'!deleteMathItem: aMathItem 	mathItems := domain factory orderedDependentMathItem: aMathItem.! !!DrGDeleteCommand methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/18/2008 12:47'!release	super release.	mathItems do: [:m | m release].! !!DrGDeleteCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/24/2006 14:25'!execute	domain factory remove: mathItems! !!DrGDeleteCommand methodsFor: 'command' stamp: 'HilaireFernandes 7/18/2008 16:44'!unexecute	mathItems do: [:aMathItem|		domain factory add: aMathItem.		domain triggerEvent: #newMathItem with: aMathItem]	! !!DrGDeleteCommand commentStamp: '<historical>' prior: 0!A command to delete a mathItem and its dependant.!!DrGDeleteCommand class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/24/2006 10:23'!for: aMathItem in: aDomain	^self new		domain: aDomain;		deleteMathItem: aMathItem.! !!DrGDeleteTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/20/2008 09:54'!reset	super reset.	self switchState: DrGDeleteToolState! !!DrGDeleteTool commentStamp: '<historical>' prior: 0!A tool to delete the mathItem. With subclass from StyleTool to have hidden costume to be display, so we can delete these ones aswell.!!DrGDeleteToolState methodsFor: 'handling' stamp: 'HilaireFernandes 4/10/2010 12:54'!handleChoice: aCostumeCollection	aCostumeCollection 		ifNotEmpty: 			[self context presenter 				deleteMathItem: aCostumeCollection first;				move].	self context reset! !!DrGDirectionItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 16:34'!direction	^vector ! !!DrGDirectionItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/26/2005 09:30'!direction: aDirection	vector := aDirection ! !!DrGDirectionItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 16:37'!normal	^ vector normal! !!DrGDirectionItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 16:34'!origin	^origin ! !!DrGDirectionItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/26/2005 09:30'!origin: anOrigin	origin := anOrigin ! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!homothetyUpdate|center|	self doesParentExist ifTrue:		[center := parents second point.		origin := center +			(parents third valueItem * (parents first origin - center)).		vector := parents first direction * parents third valueItem].! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!reflexionUpdate	self doesParentExist ifTrue:		[self origin: (parents first origin							reflexionBy: parents second origin 							direction: parents second direction).		self direction: (parents first direction 								vectorReflexionBy: parents second direction)].! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!rotationUpdate	self doesParentExist ifTrue:		[origin := parents first origin			rotateBy: parents third valueItem negated			about: parents second point.		vector := parents first direction 			rotateVector: parents third valueItem].! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!symmetryUpdate	self doesParentExist ifTrue:		[self origin: (2 * parents second point) - parents first origin.		self direction: parents first direction negated].! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:32'!translationUpdate	self doesParentExist ifTrue: 		[self origin: parents first origin + parents second direction.		self direction: parents first direction].! !!DrGDirectionItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/26/2008 21:34'!update	self doesParentExist ifTrue:		["default behavior for segment, line and ray defined by 2 points"		self origin: (parents at: 1) point.		self direction: (parents at: 2) point - (self origin).		self direction =( 0@0) ifTrue: [exist := false]].! !!DrGDirectionItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/21/2006 10:44'!intersectionWithDirection: aDirectionItem| det c1 c2 p direction |	direction := aDirectionItem  direction.	det := vector crossProduct: direction.	(det closeTo: 0) ifTrue: [^ nil].	c1 := origin crossProduct: vector.	c2 := aDirectionItem  origin crossProduct: direction.	p := ((c1 negated * direction x + (c2 * vector x)) / det) @		((vector y * c2 - (direction y * c1)) / det).	^ p! !!DrGDirectionItem methodsFor: 'testing' stamp: 'HilaireFernandes 12/21/2005 16:39'!isCollinearWith: aVector	^ (vector crossProduct: aVector) closeTo: 0! !!DrGDirectionItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:35'!isDirectionItem	^true! !!DrGDirectionItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:36'!isGeometricItem	^true! !!DrGDirectionItem class methodsFor: 'class initialization' stamp: 'HilaireFernandes 2/22/2006 15:15'!initialize	InvPi := 0.31830988618379067154.	Inv2Pi := 0.636619772367581.	TwoPi	:= 6.28318530717958647692528676655900576! !!DrGDirectionItem class methodsFor: 'constants' stamp: 'HilaireFernandes 2/22/2006 15:16'!inv2Pi	^Inv2Pi! !!DrGDirectionItem class methodsFor: 'constants' stamp: 'HilaireFernandes 12/31/2005 09:25'!invPi	^InvPi! !!DrGDirectionItem class methodsFor: 'constants' stamp: 'HilaireFernandes 1/16/2006 22:47'!twoPi	^TwoPi! !!DrGDrawable methodsFor: 'submorphs-add/remove' stamp: 'HilaireFernandes 4/19/2010 12:42'!addMorph: aMorph 	super addMorph: aMorph .	"XXX, should be unecessary after refactory DrGService layout 	{app horizontalWheel . app verticalWheel . app zoomWheel }  do: [:each | each comeToFront]."! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 10:33'!app	^app! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 10:33'!app: aDrgeo	app := aDrgeo! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 5/13/2010 10:33'!drgeoPresenter	^app presenter! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/20/2010 08:41'!ox	^ ox! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 17:55'!ox: integer	ox := integer asNumber! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/20/2010 08:41'!oy	^ oy! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 17:55'!oy: integer	oy := integer asNumber! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/20/2010 08:42'!scale	^ scale! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 07:44'!scale: increment	scale := (scale + increment) asInteger.	scale < 5 ifTrue: [scale := 4].	scale > 200 ifTrue: [scale := 200].	app redrawCostumes.! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 17:54'!setScaleTo: number	scale := number asNumber! !!DrGDrawable methodsFor: 'accessing' stamp: 'HilaireFernandes 4/20/2010 07:59'!view	^app view! !!DrGDrawable methodsFor: 'genie-drawing' stamp: 'HilaireFernandes 4/19/2010 10:33'!circle: aCRGesture| center aPoint circle|	center := self getCircleCenter: aCRGesture.	aPoint := self getCirclePoint: aCRGesture.	circle := DrGCircle2PointsItem newWith: {center . aPoint}.	app domain createFromMathItem: circle! !!DrGDrawable methodsFor: 'genie-drawing' stamp: 'HilaireFernandes 4/19/2010 10:33'!getCircleCenter: CRGesture|center|	center := app pointCostumeClosestTo: CRGesture bounds center atRange: 15.	center 		ifNotNil: [center := center mathItem]		ifNil: 			[center := DrGFreePointItem newWith: {(self morphToWorld: CRGesture bounds center)}.			app domain createFromMathItem: center].	^center! !!DrGDrawable methodsFor: 'genie-drawing' stamp: 'HilaireFernandes 4/19/2010 10:33'!getCirclePoint: aCRGesture|closestCostume smallestDistance capturedPoints pointItem|	smallestDistance := 15.	capturedPoints := aCRGesture capturedPointsInScreenCoord.	app pointCostumes do: [:aCostume |		capturedPoints do: [:aPoint | |dist|			(dist := aCostume distanceTo: aPoint) < smallestDistance 				ifTrue:					[closestCostume :=  aCostume.					smallestDistance := dist]]].	closestCostume 		ifNotNil: [pointItem := closestCostume mathItem]		ifNil:			[pointItem := DrGFreePointItem newWith: 				{(self morphToWorld: aCRGesture coordinates start)}.			app domain createFromMathItem: pointItem].	^pointItem! !!DrGDrawable methodsFor: 'genie-drawing' stamp: 'HilaireFernandes 3/10/2006 10:54'!segment: aCRGesture	Transcript show: 'segment'; cr.! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!defaultScalePosition	ox := oy := 0.0.	scale := 34.0.	app redrawCostumes ! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!morphAbscissaToWorld: abscissa	"Transform abscissa from DrGeo-Morph to World  system"	^ ox + ((abscissa - self position x - (self extent x / 2)) / scale)! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!morphOrdinateToWorld: ordinate	"Transform point coordinate from DrGeo-Morph to World  system"	^ oy - ((ordinate  - self position y - (self extent y / 2)) / scale)! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!morphToVector: aPoint"Transform vector coordinates in the morph system to the DrGeo system"	^ Point 		x: aPoint x asFloat / scale		y: aPoint y negated asFloat / scale.! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!morphToWorld: aPoint	"Transform point coordinate from DrGeo-Morph to World  system"	^ (Point 		x: ox + ((aPoint x - self position x - (self extent x / 2)) / scale)		y: oy - ((aPoint y - self position y - (self extent y / 2)) / scale))! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!pixelToVector: pixelsPoint"Transform morph pixel unit to Dr. Geo world unit"	^ pixelsPoint / scale! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!pixelToWorld: pixels"Transform morph pixel unit to Dr. Geo world unit"	^ pixels asFloat / scale! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:43'!pixelVectorToWorldVector: pixelVector"Transform morph pixel unit to Dr. Geo world unit"	^ pixelVector / scale! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!vectorToMorph: aVector"Transform vector coordinates in the Dr. Geo system to the morph system"	^ Point 		x: aVector x asFloat * scale		y: aVector y negated asFloat * scale.! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!worldAbscissaToMorph: x	"Transform point abscissa from DrGeo-World to Morph system"	^ (self extent x // 2 + (scale * (x - ox))) asInteger 		+ self position x! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!worldOrdinateToMorph: y	"Transform point ordinate from DrGeo-World to Morph system"	^ (self extent y // 2 + (scale * (oy - y))) asInteger		+ self position y! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!worldToMorph: aPoint	"Transform point coordinate from DrGeo-World to Morph system"	^ (Point 		x: ((self extent x // 2 + (scale * (aPoint x - ox))) asInteger) 		y: ((self extent y // 2 + (scale * (oy - aPoint y)))) asInteger)	+ self position! !!DrGDrawable methodsFor: 'geometry' stamp: 'HilaireFernandes 4/20/2010 08:44'!worldToPixel: aFloat"Transform Dr. Geo world unit to morph unit"	^ (aFloat * scale) asInteger ! !!DrGDrawable methodsFor: 'meta-actions' stamp: 'Hilaire 4/20/2010 07:51'!dismissMorph	super dismissMorph.	app view dismissMorph ! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 4/20/2010 08:36'!down: aNumber	oy := oy + (self pixelToWorld: aNumber).	app redrawCostumes.! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 4/20/2010 08:36'!left: aNumber 	ox := ox + (self pixelToWorld: aNumber).	app redrawCostumes! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 5/13/2010 10:34'!redo	self drgeoPresenter redo! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 4/20/2010 08:37'!right: aNumber 	ox := ox - (self pixelToWorld: aNumber).	app redrawCostumes! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 5/13/2010 10:34'!undo	self drgeoPresenter undo! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 4/20/2010 08:39'!unzoom: extent	scale := scale - ((extent x + extent y) / 5).	scale < 5 ifTrue: [scale := 5].	app redrawCostumes! !!DrGDrawable methodsFor: 'genie-command' stamp: 'HilaireFernandes 4/20/2010 08:40'!up: aNumber	oy := oy - (self pixelToWorld: aNumber).	app redrawCostumes! !!DrGDrawable methodsFor: 'layout' stamp: 'HilaireFernandes 4/19/2010 12:37'!extent: aPoint 	super extent: aPoint.	app redrawCostumes.	" XXX we should not need it as I will turn DrGService as a Morph and wheel widgets will be pluggued with laout	app isService ifTrue: 	[app horizontalWheel right: self right - app view wheelWidth;		 bottom: self bottom.	app verticalWheel right: self right;		 bottom: self bottom - app view wheelWidth.	app zoomWheel right: self right;		 top: self top]"! !!DrGDrawable methodsFor: 'layout' stamp: 'HilaireFernandes 7/27/2008 22:18'!layoutChanged	self updateGrid.	super layoutChanged! !!DrGDrawable methodsFor: 'gridding' stamp: 'HilaireFernandes 5/13/2010 10:33'!gridPoint: ungriddedPoint	self drgeoPresenter isGridded ifFalse: [^ungriddedPoint].	"do it the easy way"	^self worldToMorph: ((self morphToWorld: ungriddedPoint) rounded)! !!DrGDrawable methodsFor: 'gridding' stamp: 'HilaireFernandes 5/13/2010 10:34'!gridWorldPoint: ungriddedPoint	self drgeoPresenter isGridded ifFalse: [^ self morphToWorld: ungriddedPoint].	"do it the easy way"	^(self morphToWorld: ungriddedPoint) rounded! !!DrGDrawable methodsFor: 'gridding' stamp: 'HilaireFernandes 4/20/2010 08:45'!updateGrid	self gridSpecPut: ((self worldToMorph: 0@0) - self position extent: scale@scale).	self changed.! !!DrGDrawable methodsFor: 'event handling' stamp: 'HilaireFernandes 2/22/2006 21:13'!handleMouseMove: anEvent		"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	"Our drawable gets #mouseMove iff		* the hand is not dragging anything,			+ and the receiver is the current mouse focus."	(anEvent hand hasSubmorphs) ifTrue:[^self].	self mouseMove: anEvent.! !!DrGDrawable methodsFor: 'event handling' stamp: 'HilaireFernandes 5/13/2010 10:34'!mouseDown: evt 	"hack for the simple whiteboard without move event	if click on the flapTab area just do nothing"	| submorph |	evt cursorPoint y > (self bottom - 20)		ifTrue: [^ self].	submorph := evt hand mouseOverHandler mouseOverMorphs.	submorph		do: [:aMorph | (aMorph class = IconicButton					or: [aMorph class = FlapTab])				ifTrue: [^ super mouseDown: evt]].	(self drgeoPresenter tool handlePress: evt cursorPoint)		ifFalse: ["super mouseDown: evt"			self view popupMenu]! !!DrGDrawable methodsFor: 'event handling' stamp: 'HilaireFernandes 5/13/2010 10:34'!mouseMove: evt	|submorph|	submorph := evt hand mouseOverHandler mouseOverMorphs.	submorph do: [:aMorph |		(aMorph class = IconicButton or: [aMorph class = FlapTab])			ifTrue: 				[super mouseMove: evt.				^self]].	self submorphsDo: [:aMorph |		aMorph class = SelectionMorph 			ifTrue: [self selection: aMorph selectedItems ]].	self drgeoPresenter tool 		handleMouseAt: evt cursorPoint! !!DrGDrawable methodsFor: 'event handling' stamp: 'HilaireFernandes 5/13/2010 10:34'!mouseUp: evt	self drgeoPresenter tool 		handleRelease: evt cursorPoint! !!DrGDrawable methodsFor: 'balloon target' stamp: 'HilaireFernandes 1/12/2006 11:01'!hideTip	self removeMorph: balloonTarget! !!DrGDrawable methodsFor: 'balloon target' stamp: 'HilaireFernandes 3/6/2006 11:25'!tip: aText at: aPoint	tipOn ifFalse: [^self].	self addMorphBack: balloonTarget.	balloonTarget center: aPoint.	balloonTarget setBalloonText: aText.	balloonTarget showBalloon: (balloonTarget balloonText)! !!DrGDrawable methodsFor: 'balloon target' stamp: 'HilaireFernandes 1/31/2006 12:13'!toggleTip	tipOn := tipOn not! !!DrGDrawable methodsFor: 'initialization' stamp: 'HilaireFernandes 4/21/2010 07:42'!initialize	super initialize.	self color: Color white.	self borderWidth: 0.	tipOn := true.	self defaultScalePosition.	self hResizing: #spacefill;		 vResizing: #spaceFill.	self clipSubmorphs: true.	balloonTarget := RectangleMorph new color: Color transparent;				 extent: 6 @ 6;				 borderWidth: 0.! !!DrGDrawable methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:26'!moveOx: increment	ox := ox - increment.	app redrawCostumes! !!DrGDrawable methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:27'!moveOy: increment	oy := oy + increment.	app redrawCostumes! !!DrGDrawable methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:32'!zoom: extent	scale := (scale + (extent x + extent y / 5)) asInteger.	scale > 200 ifTrue: [scale := 200].	app redrawCostumes ! !!DrGDrawable methodsFor: 'dependents access' stamp: 'HilaireFernandes 8/18/2008 12:42'!release	balloonTarget dismissMorph.	self submorphsDo: [:m | 		self removeMorph: m.		m dismissMorph].	super release.! !!DrGDrawable methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 4/21/2010 07:50'!wantsHalo	^false! !!DrGDrawable commentStamp: '<historical>' prior: 0!I represent the area/place where a Drgeo figure is drawn. It is a subpart of the GeometricView!!DrGDrawable class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/19/2010 10:34'!newOn: aDrgeo	^self basicNew app: aDrgeo ; initialize ! !!DrGDummyBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:01'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint! !!DrGDummyBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:01'!isWanted: aMathItemCollection	^true! !!DrGDummyBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 12/27/2005 11:22'!readyToBuild	^false! !!DrGDummyBuilder commentStamp: '<historical>' prior: 0!A Builder to build nothing. Used in the select mode!!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:17'!app 	^presenter app! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:15'!area 	^presenter area! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/30/2005 09:05'!costume	^costume ! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 16:51'!costumesAt: aPoint"return the list of costume at position aPoint"	^self myCostumesAt: aPoint ! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 3/2/2006 18:06'!costume: aCostume	costume ifNotNil: [costume stopBlinking].	costume := aCostume.	costume ifNotNil: [costume startBlinking]	! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:24'!domain 	^presenter domain! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/18/2005 21:35'!last	^last! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/18/2005 21:35'!last: aPoint	last := aPoint! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/30/2005 09:06'!mathItem	^self costume mathItem! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 23:25'!presenter	^presenter ! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 23:25'!presenter: aPresenter	presenter := aPresenter ! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/30/2005 09:08'!spot	^spot! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/30/2005 09:08'!spot: aPoint	spot := aPoint ! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/12/2005 18:05'!state	^state! !!DrGDynamicTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/12/2005 18:05'!state: aState	state :=	aState ! !!DrGDynamicTool methodsFor: 'handling' stamp: 'HilaireFernandes 5/19/2010 21:48'!chooseCostume: costumes 	| aChoice |	aChoice := UIManager default		chooseFrom: (costumes			collect: [:aCostume | aCostume mathItem descriptiveName])		title: 'Select an object' translated.	aChoice isZero		ifTrue: [^ self handleChoice: {}].	^ self handleChoice: {costumes at: aChoice}! !!DrGDynamicTool methodsFor: 'handling' stamp: 'HilaireFernandes 1/12/2006 10:39'!handleChoice: aCostumeCollection	self state handleChoice: aCostumeCollection ! !!DrGDynamicTool methodsFor: 'handling' stamp: 'HilaireFernandes 1/12/2006 15:01'!handleMouseAt: aPoint	^self state handleMouseAt: aPoint! !!DrGDynamicTool methodsFor: 'handling' stamp: 'HilaireFernandes 1/8/2006 19:17'!handlePress: aPoint	^self state handlePress: aPoint ! !!DrGDynamicTool methodsFor: 'handling' stamp: 'HilaireFernandes 12/12/2005 18:25'!handleRelease: aPoint	self state handleRelease: aPoint ! !!DrGDynamicTool methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 13:17'!gridPoint: ungriddedPoint	^ self area gridPoint: ungriddedPoint.! !!DrGDynamicTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/20/2008 09:54'!switchState: aStateClass	self state: (aStateClass new context: self)! !!DrGDynamicTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/18/2008 16:48'!initialize	costume := nil.	self last: 0@0.! !!DrGDynamicTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/5/2006 17:37'!registerDependant: anObject! !!DrGDynamicTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:23'!release	super release.	self reset.! !!DrGDynamicTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:57'!reset	self costume: nil;		last: nil;		spot: nil.	mathItemUnderMouse := nil! !!DrGDynamicTool methodsFor: 'testing' stamp: 'HilaireFernandes 4/9/2010 21:42'!isGridded	^presenter isGridded! !!DrGDynamicTool methodsFor: 'testing' stamp: 'HilaireFernandes 1/5/2006 17:53'!isWanted: aMathItem	^true! !!DrGDynamicTool methodsFor: 'private' stamp: 'HilaireFernandes 4/19/2010 13:18'!myCostumesAt: aPoint"return the list of costume at position aPoint"	^self app costumes select: [:aCostume |		aCostume style isNotHidden 		and: [self isWanted: {aCostume mathItem}]		and: [aCostume containsPoint: aPoint]]! !!DrGDynamicTool methodsFor: 'private' stamp: 'HilaireFernandes 7/22/2008 16:52'!pointCostumesFirstAt: aPoint 	"When the user moves the mouse over a collection of geometric items, if thereare any point items, we discard all the other geometric items"	| myCostumes pointCostumes |	myCostumes := self myCostumesAt: aPoint.	pointCostumes := myCostumes select: [:aCostume | aCostume isPointCostume].	pointCostumes ifNotEmpty: [ ^ pointCostumes ].	^ myCostumes! !!DrGDynamicTool commentStamp: '<historical>' prior: 0!The root of the class hierarchy to handle tool state 					- 	state of the tool presenter 				- 	from which presenter is used this tool spot 					- 	xy-postition of the selected item when selecting one among several last 					- 	last mouse xy-position (used during drag) mathItem 				- 	selected mathItem during the last multiple choice selection mathItemUnderMouse 	- 	mathItem under mouse !!DrGDynamicToolState methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:21'!area	^self context area! !!DrGDynamicToolState methodsFor: 'accessing' stamp: 'HilaireFernandes 12/12/2005 18:03'!context	^context! !!DrGDynamicToolState methodsFor: 'accessing' stamp: 'HilaireFernandes 12/12/2005 18:02'!context: aContext	context := aContext ! !!DrGDynamicToolState methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 10:38'!view	^self context presenter view! !!DrGDynamicToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 01:18'!handleChoice: aCostumeCollection	^false! !!DrGDynamicToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/22/2008 21:01'!handleMouseAt: aPoint 	"Return true if we display a tip"	| costumes aTip |	costumes := self context costumesAt: aPoint.	costumes size = 1		ifTrue: [aTip := costumes first mathItem descriptiveName].	costumes size >= 2		ifTrue: [aTip := 'Several objects can be selected. Please, select one clicking the mouse.' translated].	aTip		ifNil: [self area hideTip]		ifNotNil: [self area tip: aTip at: aPoint].	^ aTip notNil! !!DrGDynamicToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 01:17'!handlePress: aPoint	^ false! !!DrGDynamicToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 01:12'!handleRelease: aPoint ! !!DrGDynamicToolState methodsFor: 'state' stamp: 'HilaireFernandes 7/20/2008 09:54'!switchState: aStateClass	self context switchState: aStateClass! !!DrGDynamicToolState commentStamp: '<historical>' prior: 0!The context is a tool (selectTool, buildTool, ...) where the state operate.!!DrGEditGroupTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 20:52'!compositeCostumesAt: aPoint	^self myCostumesAt: aPoint! !!DrGEditGroupTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 16:43'!costumesAt: aPoint	^self pointCostumesFirstAt: aPoint! !!DrGEditGroupTool methodsFor: 'initialization' stamp: 'HilaireFernandes 7/18/2008 16:52'!initialize	super initialize.	self reset! !!DrGEditGroupTool methodsFor: 'private' stamp: 'HilaireFernandes 4/19/2010 13:19'!myCostumesAt: aPoint	^self app costumes select: [:aCostume |		aCostume style isNotHidden			and: [aCostume isCompositeCostume]			and: [aCostume containsPoint: aPoint]]! !!DrGEditGroupTool methodsFor: 'private' stamp: 'HilaireFernandes 3/3/2006 17:49'!pointCostumesFirstAt: aPoint	^(super pointCostumesFirstAt: aPoint) select: [:aCostume |		aCostume isCompositeCostume not]! !!DrGEditGroupTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/31/2008 15:07'!release	costume ifNotNil:		[costume stopBlinking].	super release.! !!DrGEditGroupTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/20/2008 09:55'!reset	super reset.	self switchState:  DrGEditGroupToolStateNeutral! !!DrGEditGroupToolStateNeutral methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 09:56'!handleChoice: aCostumeCollection	aCostumeCollection 		ifNotEmpty: 			[self context costume: aCostumeCollection first.			self switchState: DrGEditGroupToolStateSelected.			^true]		ifEmpty:			[self context reset.			^false]		! !!DrGEditGroupToolStateNeutral methodsFor: 'handling' stamp: 'HilaireFernandes 7/22/2008 20:26'!handleMouseAt: aPoint 	| costumes aTip |	costumes := self context compositeCostumesAt: aPoint.	costumes		ifEmpty: [self area hideTip.			^ false].	costumes size > 1		ifTrue: [aTip := 'Several objects can be selected. Please, select one clicking the mouse.' translated]		ifFalse: [aTip := costumes first mathItem descriptiveName].	self area tip: aTip at: aPoint.	^ true! !!DrGEditGroupToolStateNeutral methodsFor: 'handling' stamp: 'HilaireFernandes 3/22/2006 14:14'!handlePress: aPoint	|costumes|	self area hideTip.	costumes := self context compositeCostumesAt: aPoint.	costumes isEmptyOrNil ifTrue: [^false].	costumes size = 1		ifTrue:			[^self handleChoice: costumes.]		ifFalse:			[^self context chooseCostume: costumes].! !!DrGEditGroupToolStateSelected methodsFor: 'handling' stamp: 'HilaireFernandes 8/18/2008 12:35'!handleChoice: aCostumeCollection"if the costume does not bellong to the composite add it, otherwise remove it from the composite"|compositeCostume itemCostume|	aCostumeCollection ifEmpty:			[self context reset.			^false].	compositeCostume := self context costume.	itemCostume := aCostumeCollection first.	(compositeCostume mathItem subItems includes: itemCostume mathItem)		ifTrue:  [compositeCostume removeCostume: itemCostume]		ifFalse: [compositeCostume addCostume: itemCostume].	compositeCostume stopBlinking;startBlinking.	^true.! !!DrGEditGroupToolStateSelected methodsFor: 'handling' stamp: 'HilaireFernandes 7/22/2008 16:44'!handlePress: aPoint	| costumes |	self area hideTip.	costumes := self context costumesAt: aPoint.	costumes size = 1		ifTrue:			[^self handleChoice: costumes].	costumes size > 1 		ifTrue:			[^self context chooseCostume: costumes].	self context reset.	^false.! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:33'!add: aCostume	costumes add: aCostume.! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:33'!costumeOf: aMathItem"Find the costume of the given mathItem"	costumes do: [:costume|		costume mathItem = aMathItem			ifTrue: [^costume]].	^nil! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:34'!costumes	^costumes! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:34'!costumesOf: aMathItemCollection"Find the costumes of the given mathItem collection"	^ aMathItemCollection collect: [:aMathItem | self costumeOf: aMathItem]! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 20:15'!costume: aMathItem 	"new math item event : A new math item has been created, create its costume"	self add: (DrGMathItemCostume for: aMathItem in: self area)! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:35'!deleteCostume: aCostume	aCostume release.	costumes := costumes copyWithout: aCostume.	! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:35'!forceVisible: aBoolean"Force or not the visibility of hidden costume"	costumes do: [:costume |		costume forceVisible: aBoolean].! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 20:14'!groupCostumes: aCompositeItem |compositeCostume subCostumes|	subCostumes := OrderedCollection new.	aCompositeItem subItems do: [:item |		self remove: (subCostumes add: (self costumeOf: item))].	compositeCostume := DrGCompositeCostume 		for: aCompositeItem 		in: self area 		with: subCostumes .	self add: compositeCostume.! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:34'!lastCostume"Find the costume of the factory last mathItem"|lastMathItem|	lastMathItem := domain factory last.	costumes do: [:costume|		costume mathItem = lastMathItem 			ifTrue: [^costume]].	^nil! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:34'!pointCostumeClosestTo: aPoint atRange: anInteger|closestCostume smallestDistance|	smallestDistance := anInteger. 	costumes do: [:aCostume | | dist |		(aCostume isPointCostume and: [(dist := aCostume distanceTo: aPoint)< smallestDistance])			ifTrue:				[closestCostume := aCostume.				smallestDistance := dist]].	^closestCostume ! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:34'!pointCostumes	^ costumes select: [:aCostume | 		aCostume isPointCostume]! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:35'!redrawCostumes"View resized, update the area"	costumes do: [:costume |		costume redraw].	costumes ifEmpty: [self updateGrid]! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:33'!remove: aCostume	aCostume ifNotNil:	 [costumes remove: aCostume].! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:35'!ungroupCostumes: aCompositeItem |compositeCostume |	compositeCostume := self costumeOf: aCompositeItem.	compositeCostume subCostumes do: [:aCostume |		self add: aCostume].	self remove: compositeCostume.! !!DrGeo methodsFor: 'costume' stamp: 'HilaireFernandes 4/18/2010 16:35'!updateCostumes	costumes do: [ :each | each update ]! !!DrGeo methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 20:14'!area	^ view area! !!DrGeo methodsFor: 'accessing' stamp: 'HilaireFernandes 12/10/2005 12:12'!domain	^domain ! !!DrGeo methodsFor: 'accessing' stamp: 'HilaireFernandes 12/10/2005 12:12'!domain: aDomain	domain := aDomain ! !!DrGeo methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 20:16'!presenter	^presenter ! !!DrGeo methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 10:23'!view	^ view! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/21/2010 07:41'!initialize	super initialize.	costumes := OrderedCollection new.	self registerEvents! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 10:24'!initializeApplication	self initialize.	presenter := DrGeoPresenter with: self.	view := DrGeoWindow in: self.	view openInWorld! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 10:24'!initializeService	self initialize.	presenter := DrGeoPresenter with: self.	view := DrGService in: self.! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/18/2010 20:12'!registerEvents	domain		when: #newMathItem		send: #costume:		to: self.	domain		when: #updatedItems		send: #updateCostumes		to: self.	domain		when: #groupCostumes		send: #groupCostumes:		to: self.	domain		when: #ungroupCostumes		send: #ungroupCostumes:		to: self! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 10:23'!release	super release.	self area release.	self removeEvents.	view release.	presenter release.! !!DrGeo methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/18/2010 20:12'!removeEvents	domain removeActionsWithReceiver: self.! !!DrGeo methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/22/2010 07:45'!saveAs: filename 	DrGeoXml new		app: self;		saveAs: filename! !!DrGeo methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/26/2010 13:13'!saveOn: stream	DrGeoXml new		app: self;		saveOn: stream! !!DrGeo methodsFor: 'canvas' stamp: 'HilaireFernandes 4/20/2010 08:46'!scale	self error: 'Implemented in the drawable'! !!DrGeo methodsFor: 'canvas' stamp: 'HilaireFernandes 4/18/2010 20:15'!updateGrid	self area ifNotNil: [self area updateGrid]! !!DrGeo commentStamp: 'HilaireFernandes 6/15/2010 21:29' prior: 0!The application model. It is encapsulating our sub model: geometry model, tree model and script model.Two viewers are proposed: - a service is basicaly a canvas with wheel morphs, it can be embedded in bookmorph ,... - a polymorph window with a friendly graphic user interface!!DrGeo class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/18/2010 20:20'!in: aDomain 	"A new model with an existing domain. For multiple MVP on a same	Domain"	^ super basicNew domain: aDomain;		 initializeApplication! !!DrGeo class methodsFor: 'instance creation' stamp: 'HilaireFernandes 6/15/2010 11:58'!new	"instanciate a standard DrGeo application"	^ DrGDefault isEtoys 		ifFalse: [self in: DrGeoDomain new]		ifTrue: [DrGeo sample openInWorld]! !!DrGeo class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/19/2010 22:00'!sample	^ self service view extent: 600 @ 400! !!DrGeo class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/18/2010 22:38'!service	"instanciate a DrGeo service, to embbed in third party application or for the widgetless Etoys. It is just the canvas with suround menu and icon"	^ self serviceIn: DrGeoDomain new! !!DrGeo class methodsFor: 'instance creation' stamp: 'HilaireFernandes 6/18/2007 16:50'!serviceIn: aDomain 	"A new model with an existing domain. For multiple MVP on a same	Domain"	^ super basicNew domain: aDomain;		 initializeService! !!DrGeo class methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/26/2010 10:22'!newXmlOn: stream 	^ DrGeoXml new loadOn: stream for: #new! !!DrGeo class methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/25/2010 22:02'!newXml: filename 	^ DrGeoXml new load: filename for: #new! !!DrGeo class methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/21/2010 18:21'!serviceViewXml: filename 	(self serviceXml: filename)		do: [:each | each view extent: 500 @ 400;				 center: Display center;				 openInWorld]! !!DrGeo class methodsFor: 'objects from disk' stamp: 'HilaireFernandes 4/22/2010 07:41'!serviceXml: filename 	^ DrGeoXml new load: filename for: #service! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/24/2008 12:15'!altIntersectionOf: wrpCurve1 and: wrpCurve2 "use this one when you want the intersection point when non straight line are involved"	| item |	self preProcessing.	item := DrGIntersectionPointItem newWith: {wrpCurve1 mathItem. wrpCurve2 mathItem. 0 @ 0}.	item k: 1.	^ self finalizePoint: item! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/22/2008 15:10'!finalizePoint: item 	^ self		postProcessing: (DrGWrappedPoint				wrap: (self costumeOf: (drgeo domain createFromMathItemNoStack: item)))! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/24/2008 12:14'!intersectionOf: wrpCurve1 and: wrpCurve2 |item|	self preProcessing.	item := DrGIntersectionPointItem newWith: {wrpCurve1 mathItem. wrpCurve2 mathItem. 0 @ 0}.	item k:-1.	^ self		finalizePoint: (item)! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/24/2008 11:31'!middleOf: wrpSegment	self preProcessing.	^ self		finalizePoint: (DrGMiddlePointSegmentItem newWith: {wrpSegment mathItem})! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/22/2008 15:42'!middleOf: wrappedPoint1 and: wrappedPoint2 	self preProcessing .	^ self finalizePoint: (DrGMiddlePoint2PointsItem newWith: {wrappedPoint1 mathItem . wrappedPoint2 mathItem})! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/22/2008 15:43'!pointOnCurve: wrpCurve at: abscissa 	| item a |	self preProcessing.	item := DrGPointItemOnCurve newWith: {wrpCurve mathItem. 0 @ 0}.	a := abscissa.	abscissa < 0		ifTrue: [a := 0].	abscissa > 1		ifTrue: [a := 1].	item setCurveAbscissa: a.	item := drgeo domain createFromMathItemNoStack: item.	^ self finalizePoint: item! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/22/2008 21:13'!pointX: wrpValue1 Y: wrpValue2	self preProcessing.	^ self		finalizePoint: (DrGPointByCoordinatesItem  newWith: {wrpValue1 mathItem . wrpValue2 mathItem })! !!DrGeoCanvas methodsFor: 'point' stamp: 'HilaireFernandes 1/22/2008 15:13'!point: aPoint 	self preProcessing.	^self finalizePoint: (DrGFreePointItem newWith: {aPoint})! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 12:00'!angle: wrpVect1 to: wrpVect2	self preProcessing.	^ self		finalizeValue: (DrGAngle2VectorsItem newWith: {self aPosition. wrpVect1 mathItem. wrpVect2 mathItem})! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:58'!angle: wrpPt1 to: wrpPt2 to: wrpPt3 	self preProcessing.	^ self		finalizeValue: (DrGAngle3PointsItem newWith: {self aPosition . wrpPt1 mathItem. wrpPt2 mathItem. wrpPt3 mathItem})! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 10:42'!aPosition	^ 10 atRandom - 5 @ (10 atRandom - 5)! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:52'!distance: wrpItem1 to: wrpItem2 	"Distance from a point to a line or another point"	| arg class |	arg := OrderedCollection newFrom: {wrpItem1 mathItem. wrpItem2 mathItem}.	(arg first isLineItem			or: [arg second isLineItem])		ifTrue: [class := DrGValueDistancePointLineItem.			arg first isLineItem				ifTrue: [arg := arg reverse]]		ifFalse: [class := DrGValueDistancePointsItem].	arg addFirst: self aPosition.	self preProcessing.	^ self		finalizeValue: (class newWith: arg)! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:20'!finalizeValue: item 	^ self		postProcessing: (DrGWrappedValue				wrap: (self						costumeOf: (drgeo domain createFromMathItemNoStack: item))) hide! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:19'!freeValue: aNumber 	self preProcessing.	^ self		finalizeValue: ((DrGFreeValueItem newWith: {self aPosition})				valueItem: aNumber)! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:38'!lengthOf: wrpSegmentOrCircleOrArcOrVector 	| class |	self preProcessing.	wrpSegmentOrCircleOrArcOrVector mathItem isSegmentItem		ifTrue: [class := DrGValueSegmentLengthItem].	wrpSegmentOrCircleOrArcOrVector mathItem isCircleItem		ifTrue: [class := DrGValueCircleLengthItem].	wrpSegmentOrCircleOrArcOrVector mathItem isArcItem		ifTrue: [class := DrGValueArcLengthItem].	wrpSegmentOrCircleOrArcOrVector mathItem isVectorItem		ifTrue: [class := DrGValueVectorNormItem].	^ self		finalizeValue: (class newWith: {self aPosition. wrpSegmentOrCircleOrArcOrVector mathItem})! !!DrGeoCanvas methodsFor: 'value' stamp: 'HilaireFernandes 1/24/2008 11:29'!slopeOf: wrpLine	self preProcessing.	^ self		finalizeValue: (DrGValueLineSlopeItem newWith: {self aPosition . wrpLine mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 17:11'!arc: wrpPt1 to: wrpPt2 to: wrpPt3	self preProcessing.	^ self		finalizeCurve: (DrGArc3PointsItem newWith: {wrpPt1 mathItem. wrpPt2 mathItem. wrpPt3 mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 17:57'!circleCenter: wrpCenter radius: wrpValue	self preProcessing.	^ self		finalizeCurve: (DrGCircleRadius  newWith: {wrpCenter mathItem. wrpValue mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 17:57'!circleCenter: wrpCenter to: wrpPt	self preProcessing.	^ self		finalizeCurve: (DrGCircle2PointsItem newWith: {wrpCenter mathItem. wrpPt mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 15:39'!finalizeCurve: item 	^ self		postProcessing: (DrGWrappedCurve				wrap: (self costumeOf: (drgeo domain createFromMathItemNoStack: item)))! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 15:44'!line: wrpPt1 to: wrpPt2	self preProcessing.	^ self		finalizeCurve: (DrGLine2PointsItem newWith: {wrpPt1 mathItem. wrpPt2 mathItem })! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 21:03'!locusOf: wrpPt1 when: wrpPt2 	self preProcessing.	wrpPt2 isPointItemOnCurve ifFalse: [self error: 'The second point provided in the call must be on a curve.'].	^ self		finalizeCurve: (DrGLocusItem newWith: {wrpPt2 mathItem. wrpPt1 mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 21:07'!parallel: wrpDirection at: wrpPtOrPoint	self preProcessing.	^ self		finalizeCurve: (DrGParallelLineItem newWith: {wrpDirection mathItem. wrpPtOrPoint isPoint ifTrue: [wrpPtOrPoint ] ifFalse: [ wrpPtOrPoint mathItem]})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 21:11'!perpendicular: wrpDirection at: wrpPtOrPoint 	self preProcessing.	^ self		finalizeCurve: (DrGPerpendicularlLineItem newWith: {wrpDirection mathItem. wrpPtOrPoint isPoint					ifTrue: [wrpPtOrPoint]					ifFalse: [wrpPtOrPoint mathItem]})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 21:16'!polygon: arguments	self preProcessing.	^ self		finalizeCurve: (DrGPolygonItem  newWith: (arguments collect: [:wrp | wrp mathItem]))! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/22/2008 15:44'!segment: wrpPt1 to: wrpPt2	self preProcessing.	^ self		finalizeCurve: (DrGSegment2PointsItem newWith: {wrpPt1 mathItem . wrpPt2 mathItem})! !!DrGeoCanvas methodsFor: 'curve' stamp: 'HilaireFernandes 1/24/2008 11:56'!vector: wrpPt1 to: wrpPt2 	self preProcessing.	^ self		finalizeCurve: (DrGVector2PointsItem newWith: {wrpPt1 mathItem. wrpPt2 mathItem})! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:02'!canTransform: wrptItem	wrptItem mathItem isGeometricItem		ifFalse: [self error: 'Only geometric object can be transformed.' translated].! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 16:59'!finalizeTransformation: string with: arguments 	| class item |	class := self class environment classNamed: 'DrG', string , arguments first basicType capitalized , 'Item'.	item := class newWith: arguments.	item isPointItem		ifTrue: [^ self finalizePoint: item].	^ self finalizeCurve: item! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:02'!reflect: wrpItem axe: wrpLine 	self canTransform: wrpItem.	self preProcessing.	^ self finalizeTransformation: 'Reflexion' with: {wrpItem mathItem. wrpLine mathItem}! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:03'!rotate: wrpItem center: wrpCenter angle: wrpValue 	self canTransform: wrpItem.	self preProcessing.	^ self finalizeTransformation: 'Rotation' with:  {wrpItem mathItem. wrpCenter mathItem. wrpValue mathItem}.	! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:04'!scale: wrpItem center: wrpCenter factor: wrpValue 	self canTransform: wrpItem.	self preProcessing.	^ self finalizeTransformation: 'Homothety' with: {wrpItem mathItem. wrpCenter mathItem. wrpValue mathItem}! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:03'!symmetry: wrpItem center: wrpCenter 	self canTransform: wrpItem.	self preProcessing.	^ self finalizeTransformation: 'Symmetry' with: {wrpItem mathItem. wrpCenter mathItem}! !!DrGeoCanvas methodsFor: 'transformations' stamp: 'HilaireFernandes 1/22/2008 17:04'!translate: wrpItem vector: wrpVector 	self canTransform: wrpItem.	self preProcessing.	^ self finalizeTransformation: 'Translation' with: {wrpItem mathItem. wrpVector mathItem}! !!DrGeoCanvas methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:09'!costumeOf: anItem 	^ drgeo costumeOf: anItem! !!DrGeoCanvas methodsFor: 'accessing' stamp: 'HilaireFernandes 1/23/2008 10:13'!domain	^ drgeo domain! !!DrGeoCanvas methodsFor: 'initialize-release' stamp: 'HilaireFernandes 6/19/2010 17:38'!initialize	super initialize.	drgeo := DrGeo service.	drgeo view extent: 400@300.	drgeo view openInWorld! !!DrGeoCanvas methodsFor: 'processing' stamp: 'HilaireFernandes 1/22/2008 15:00'!postProcessing: aCostume 	"Called after each item creation command, return aCostume "	^ aCostume! !!DrGeoCanvas methodsFor: 'processing' stamp: 'HilaireFernandes 1/22/2008 14:54'!preProcessing! !!DrGeoCanvas commentStamp: 'HilaireFernandes 1/22/2008 08:55' prior: 0!A canvas to construct programmatically interactive figure!!DrGeoDomain methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 12:03'!actionMap	actionMap ifNil: [^self createActionMap].	^ actionMap ! !!DrGeoDomain methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 16:54'!releaseActionMap	actionMap := nil! !!DrGeoDomain methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 12:03'!updateableActionMap	actionMap ifNil:		[actionMap := self createActionMap].	^actionMap! !!DrGeoDomain methodsFor: 'user interface' stamp: 'HilaireFernandes 6/15/2010 22:18'!addModelItemsToWindowMenu: aMenu 	aMenu addLine.	aMenu		add: 'About Dr. Geo II...'		target: self		selector: #inform:		argument: 'Copyright 1996-2010 Hilaire Fernandes'! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 3/6/2006 09:27'!createCompositeItem: aMathItemSelection	cmdManager compositeCommandFor: aMathItemSelection.! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 11:15'!createFromMathItemNoStack: aMathItem	"return the mathItem (newly created or the one in the pool, in case the caller want to do something with it, without stacking in the undo/redo stack"	(factory pushAsLastWhenInPool: aMathItem) ifTrue: [^factory last].	factory add: aMathItem.	self triggerEvent: #newMathItem with: aMathItem.	^aMathItem! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 11:19'!createFromMathItem: aMathItem	"return the mathItem (newly created or the one in the pool, in case the caller want to do something with it"	(factory pushAsLastWhenInPool: aMathItem) ifTrue:		[^{factory last. false}].	"create a new command and execute it"	cmdManager buildCommandFor: aMathItem.	^{ aMathItem. true }! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 20:35'!createMacro: aBuilder 	(self macroFactory pushAsLastWhenInPool: (aBuilder getItem: self)) ifFalse: 		[ "Create macro and register it in the factory"		self macroFactory add: (aBuilder getItem: self) ]! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 8/23/2008 22:56'!createMathItem: aBuilder 	"return the mathItem (newly created or the one in the pool, in case the caller want to do something with it"	(factory pushAsLastWhenInPool: aBuilder getItem first) ifTrue: 		[ ^ {  (factory last). false  } ].	"create a new command and execute it"	^ {  (cmdManager buildCommandWith: aBuilder). true  }! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 1/30/2006 17:08'!deleteMathItem: aMathItem 	"create a delete command and execute it"	cmdManager deleteCommandFor: aMathItem! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 7/31/2008 23:30'!in: macroTree replaceParent: item with: newItem 	| index |	macroTree do: [ :anItem | 		(anItem parents notNil and: [ (index := anItem parents indexOf: item) ~= 0 ])			ifTrue: [anItem parents at: index put: newItem ] ]! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 1/31/2006 11:40'!moveMathItem: aMathItem with: aPoint	"create a move command"	cmdManager moveCommandFor: aMathItem with: aPoint! !!DrGeoDomain methodsFor: 'building' stamp: 'HilaireFernandes 4/19/2010 13:11'!playMacro: aBuilder in: app 	| answer macroTree |	macroTree := aBuilder getItem.	macroTree 		with: aBuilder constructedNodes		do: 			[ :item :node | 			answer := self createFromMathItem: item.			answer last 				ifTrue: 					[ node isHiddenNode ifTrue: 						[ (app costumeOf: item) ifNotNilDo: 							[ :aCostume | 							aCostume style isHidden: true.							aCostume forceVisible: false ] ] ]				ifFalse: 					[ "item twin in the factory, use it in the macro tree"					self 						in: macroTree						replaceParent: item						with: answer first ] ]! !!DrGeoDomain methodsFor: 'accessing' stamp: 'HilaireFernandes 12/7/2005 10:58'!factory	^factory! !!DrGeoDomain methodsFor: 'accessing' stamp: 'HilaireFernandes 4/9/2010 13:22'!labelString	^ 'Dr. Geo II - ', Date today asString! !!DrGeoDomain methodsFor: 'accessing' stamp: 'HilaireFernandes 7/27/2008 10:54'!macroFactory	^macroFactory ifNil: [macroFactory := DrGMacroFactory new]! !!DrGeoDomain methodsFor: 'accessing' stamp: 'HilaireFernandes 1/31/2006 00:11'!redo	cmdManager redo! !!DrGeoDomain methodsFor: 'accessing' stamp: 'HilaireFernandes 1/31/2006 00:11'!undo	cmdManager undo! !!DrGeoDomain methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/30/2006 17:04'!initialize	super initialize.	factory := DrGMathItemFactory new.	cmdManager := DrGCommandManager new domain: self! !!DrGeoDomain methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:42'!release	super release.	factory release.	cmdManager release.! !!DrGeoDomain methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:49'!moveEvent: aMathItem at: aPoint	aMathItem moveAt: aPoint.	self updateAllMathItems! !!DrGeoDomain methodsFor: 'updating' stamp: 'HilaireFernandes 7/18/2008 13:57'!moveEvent: aMathItem inDirection: aPoint 	aMathItem moveEvent: aPoint.	self updateAllMathItems ! !!DrGeoDomain methodsFor: 'updating' stamp: 'HilaireFernandes 7/18/2008 14:18'!updateAllMathItems	factory updateAllMathItems.	self triggerEvent: #updatedItems! !!DrGeoDomain methodsFor: 'updating' stamp: 'HilaireFernandes 1/25/2008 23:10'!updateAllMathItemsButLocus	factory updateAllMathItemsButLocus.	"We don't need to update the costumem we just want updated mathiteem'"	"self triggerEvent: #updatedItems"! !!DrGeoDomain methodsFor: 'updating' stamp: 'HilaireFernandes 8/4/2008 14:29'!update: symbol	Transcript show: symbol asString;cr.	symbol = #contents ifTrue: [self updateAllMathItems]! !!DrGeoDomain commentStamp: 'HilaireFernandes 4/18/2010 12:42' prior: 0!This is the domain object for DrGeo, aka the top level Model instance for one DrGeo instance!!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:02'!angleButtonData	^ {'Angle' translated.	 #angle .	 #createAngle .	'Angle defined by three points or two vectors.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:03'!arcButtonData	^ {'Arc' translated.	#arc .	 #createArc .	'Arc-circle defined by three points.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:03'!circleButtonData	^ {'Circle' translated. 	#circle . 	#createCircle . 	'Circle defined by its center and a point or by its center and radius, a value.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:04'!coordinatesButtonData	^ {'Coordinates' translated.	#coordinates .	#createCoordinates .	'Vector or point coordinates, circle or line equation.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:28'!distanceButtonData	^ {'Distance, length, value' translated.	#distance .	#createDistance .	'Distance between objects, curve length, free value' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:05'!editGroupButtonData	^ {'Edit group' translated.	#editGroup .	#editSelection .	'Distance between objects, curve length, free value' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:05'!eraserButtonData	^ {'Eraser' translated.	#eraser .	#eraser .	'Erase and object and all its depedencies.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:06'!freePointButtonData	^ {'Point' translated.	#freePoint .	#createFreePoint .	'Click to create a point: free point on the background, on a curve or on two curves intersection.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:07'!gridButtonData	^ {'Grid' translated.	#grid .	#gridOnOff .	'Show or hide grid.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:08'!gridStuckButtonData	^ {'Magnetic Grid' translated.	#gridMagnet .	#gridStuckOnOff .	'Snap to grid.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:08'!groupButtonData	^ {'Create Group' translated.	#group .	#captureSelection .	'Create a selection group. To do a selection: i. set moving object mode, ii. select a zone by shift+drag over a backgroudn area.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:09'!homothetyButtonData	^ {'Homothety (scale)' translated.	#scale .	#createHomothety .	'Object transformation by homothety: select a point, a value and a geometric object.The first selected point is the homothety center.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 4/20/2010 08:12'!horizontalWheel 	 ^ WheelMorph new beHorizontal; 		factor: 0.05; 		setBalloonText: 'Horizontal shift' translated; 		target: self; 		actionSelector: #moveOx:; 		color: Color green twiceDarker! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:09'!lineButtonData	^ {'Line' translated.	#line .	#createLine .	'Line defined by two points' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:10'!locusButtonData	^ {'Locus' translated.	#locus .	#createLocus .	'Locus defined by a free point on a curve and a relative point.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:11'!macroBuildButtonData	^ {'Build macro' translated.	#macroBuild .	#createMacro .	'Construct a macro-construction with input and output items.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:11'!macroDeleteButtonData	^ {'Delete macro' translated.	#eraser .	#deleteMacro .	'Delete a macro-construction from the registry.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:12'!macroExecuteButtonData	^ {'Execute Macro' translated.	#macroExecute .	#executeMacro .	'Execute a pre-built macro-construction on selected input items.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:12'!middleButtonData	^ {'Middle' translated.	#middle .	#createMiddlePoint .	'The midpoint of a segment or between two points.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:13'!moveButtonData	^ {'Select and Move' translated.	#move .	#move .	'Select and move an object.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:14'!multipleModeButtonData	^ {'Create Multiple' translated.	#createMultiple .	#createMultipleOnOff .	'Toggle between the build of several geometric objects and the build of one geometric object then move it.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:15'!parallelButtonData	^ {'Parallel' translated.	#parallel .	#createParallel .	'Line passing through one point and parallel to a line, half-line, etc.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:15'!perpendicularButtonData	^ {'Perpendicular' translated.	#perpendicular .	#createPerpendicular .	'Line passing through one point and orthogonal to a line, half-line, etc.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:16'!pointByCoordinatesButtonData	^ {'Coordinates' translated.	#pointDefinedByCoordinates .	#createPointByCoordinates .	'Point defined by its coordinates. Select two numbers for the abscissa and the ordinate.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:16'!polygonButtonData	^ {'Polygon' translated.	#polygon .	#createPolygon .	'Polygon defined by n points. Last choosen point must be the initial point to terminate the selection.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:16'!propertyButtonData	^ {'Property' translated.	#property .	#property .	'Edit an object property.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:17'!rayButtonData	^ {'Ray' translated.	#ray .	#createRay .	'Half-Line defined by two points, the first selected point is the origin.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:18'!redoButtonData	^ {'Redo' translated.	#redo .	#redo .	'Redo last action.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:18'!reflectionButtonData	^ {'Reflection' translated.	#axialSymmetry .	#createReflection .	'Object transformation by reflexion: select a line and a geometric object. Reflexion axe will be the first selected line.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:18'!rotationButtonData	^ {'Rotation' translated.	#rotation .	#createRotation .	'Object transformation by rotation: select a point, a value and a geometric object.The first selected point is the rotation center.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:19'!scriptButtonData	^ {'Use a script' translated.	#script .	#useScript .	'Insert a Smalltalk script in the drawing area.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:19'!scriptEditButtonData	^ {'Edit a script' translated.	#script .	#editScript .	'Create or edit a Smalltalk script.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:20'!segmentButtonData	^ {'Segment' translated.	#segment .	#createSegment .	'Segment defined by two points.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:20'!styleButtonData	^ {'Edit Style' translated.	#style .	#style .	'Edit an object style.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:20'!symmetryButtonData	^ {'Symmetry' translated.	#centralSymmetry .	#createSymmetry .	'Object transformation by central symmetry: select a point and a geometric object. The first selected point is the symmetry center.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:21'!translationButtonData	^ {'Translation' translated.	#translation .	#createTranslation .	'Object transformation by translation: select a vector and a geometric object.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:21'!undoButtonData	^ {'Undo' translated.	#undo .	#undo .	'Undo last action' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:21'!vectorButtonData	^ {'Vector' translated.	#vector .	#createVector .	'Vector defined by two points.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 4/20/2010 08:11'!verticalWheel 	 ^ WheelMorph new 		beVertical; 		factor: 0.05; 		setBalloonText: 'Vertical shift' translated; 		target: self; 		actionSelector: #moveOy:; 		color: Color green twiceDarker! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 5/14/2010 16:22'!viewerButtonData	^ {'Etoys Viewer' translated.	#viewer .	#openItemViewer .	'Open the Etoys script viewer for a given geometric object.' translated}! !!DrGeoPresenter methodsFor: 'UI definition' stamp: 'HilaireFernandes 4/20/2010 08:31'!zoomWheel 	 ^ WheelMorph new 		beVertical; 		factor: 1; 		setBalloonText: 'Zooming' translated; 		target: self; 		actionSelector: #scale:; 		color: Color orange darker! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 22:56'!app	^ app! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 22:56'!app: aDrgeo	app := aDrgeo! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 07:41'!area	^ self view area! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/10/2010 15:45'!createMultipleString	^ (self isCreateMultipleMode		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'create multiple' translated! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 22:59'!domain	^app domain ! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/10/2010 15:44'!griddedString	^ (self isGridded		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'snap to grid' translated! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/10/2010 15:43'!gridString	^ (self isGridVisible		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'grid' translated! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 12/9/2005 23:19'!model	^model! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 12/9/2005 23:19'!model: aModel	model := aModel! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 16:31'!selection	^selection! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/18/2010 16:31'!selection: aSelection	aSelection 		ifNil: [selection := nil]		ifNotNil:			[selection := aSelection select: [:aMorph |				aMorph isMorphCostume]]! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 12/16/2005 22:41'!tool	^tool! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 07:56'!tool: aTool	tool ifNotNil: [tool release].	tool := aTool.	tool ifNotNil:	[tool registerDependant: self].! !!DrGeoPresenter methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 07:41'!view	^app view! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/18/2010 23:00'!captureSelection|mathItems|	self selection: self area selection.	self selection ifNotNil:		[mathItems := self selection collect: [:aMorph |				aMorph costume mathItem].		self domain createCompositeItem: mathItems].	self area selection: nil! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:15'!createAngle	self selectTool: DrGBuildTool with: DrGAngleBuilder.	selectedTool := #angle.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:10'!createArc	self selectTool: DrGFlyBuildTool with: DrGArcBuilder.	selectedTool := #arc.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:10'!createCircle	self selectTool: DrGFlyBuildTool with: DrGCircleBuilder.	selectedTool := #circle.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/10/2010 14:58'!createCoordinatePoint	self selectTool: DrGBuildTool with: DrGPointByCoordinatesBuilder.	selectedTool := #coordindatePoint.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:16'!createCoordinates" No implemented yet	self selectTool: DrGBuildTool with: DrGCoordinateBuilder.	selectedTool := #coordindates.	self changed: #selectedTool."! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:15'!createDistance	self selectTool: DrGBuildTool with: DrGValueBuilder.	selectedTool := #distance.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 18:41'!createFreePoint	self selectTool: DrGFlyPointBuildTool with: DrGFlyPointBuilder.	selectedTool := #freePoint.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:04'!createHomothety	self selectTool: DrGBuildTool with: DrGHomothetyBuilder.	selectedTool := #homothety.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:05'!createLine	self selectTool: DrGFlyBuildTool with: DrGLineBuilder.	selectedTool := #line.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:12'!createLocus	self selectTool: DrGFlyBuildTool with: DrGLocusBuilder.	selectedTool := #locus.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 11:18'!createMacro	self selectTool: DrGMacroBuildTool with: DrGMacroBuilder.	selectedTool := #macroBuild.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 18:42'!createMiddlePoint	self selectTool: DrGBuildTool with: DrGMiddleBuilder.	selectedTool := #middlePoint.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/10/2010 14:54'!createMultipleOnOff	isCreateMultipleMode := isCreateMultipleMode not.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/10/2010 12:48'!createParallel	self selectTool: DrGBuildTool with: DrGParallelBuilder.	selectedTool := #parallel.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:07'!createPerpendicular	self selectTool: DrGBuildTool with: DrGPerpendicularBuilder.	selectedTool := #perpendicular.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/10/2010 15:01'!createPointByCoordinates	self selectTool: DrGBuildTool with: DrGPointByCoordinatesBuilder.	selectedTool := #pointByCoordinates.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:11'!createPolygon	self selectTool: DrGFlyBuildTool with: DrGPolygonBuilder.	selectedTool := #polygon.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:08'!createRay	self selectTool: DrGFlyBuildTool with: DrGRayBuilder.	selectedTool := #ray.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/15/2010 07:49'!createReflection	self selectTool: DrGBuildTool with: DrGReflectionBuilder.	selectedTool := #reflection.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:03'!createRotation	self selectTool: DrGBuildTool with: DrGRotationBuilder.	selectedTool := #rotation.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:08'!createSegment	self selectTool: DrGFlyBuildTool with: DrGSegmentBuilder.	selectedTool := #segment.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 21:58'!createSymmetry	self selectTool: DrGBuildTool with: DrGSymmetryBuilder.	selectedTool := #symmetry.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:02'!createTranslation	self selectTool: DrGBuildTool with: DrGTranslationBuilder.	selectedTool := #translation.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:09'!createVector	self selectTool: DrGFlyBuildTool with: DrGVectorBuilder.	selectedTool := #vector.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 11:20'!deleteMacro	self selectTool: DrGSelectTool.	selectedTool := #deleteMacro.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/18/2010 23:00'!editScript	|browser|	"We force to select mode, then open a browser on the script classes"	self move.	browser := (Browser newOnClass: DrGeoUserScripts label: 'Edit or create scripts' translated) 		selectMessageCategoryNamed: #examples.	browser addDependent: self domain.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/13/2010 13:01'!editSelection	self selectTool: DrGEditGroupTool! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 19:55'!eraser	self selectTool: DrGDeleteTool.	selectedTool := #eraser.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 11:18'!executeMacro	self selectTool: DrGMacroPlayTool with: DrGMacroPlayer.	selectedTool := #macroPlay.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/10/2010 14:55'!openItemViewer	self selectTool: DrGViewerTool.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/14/2010 07:36'!property ! !!DrGeoPresenter methodsFor: 'callback create' stamp: 'HilaireFernandes 4/9/2010 22:20'!useScript	self selectTool: DrGScriptPlayTool with: DrGScriptPlayer.	selectedTool := #useScript.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 07:44'!deleteMathItem: aCostume	self domain deleteMathItem: aCostume mathItem ! !!DrGeoPresenter methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 07:55'!readyToBuild	"readyToBuild event, the builder is ready to build, request to the domain the construction of the math item under the builder"	self domain createMathItem: self tool builder.	self selectionCleanUp.! !!DrGeoPresenter methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 07:56'!readyToBuildMacro	"readyToBuild event, the builder is ready to build a macro, request to the domain the construction of the math item under the builder"	self domain createMacro: self tool builder.	self move! !!DrGeoPresenter methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 13:11'!readyToPlayMacro	"readyToBuild event, the builder is ready to play a macro (enought input items), request to the domain the construction of the math items under the builder"	self domain playMacro: self tool builder in: app.	self move! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/19/2010 12:57'!gridOnOff	self area gridVisibleOnOff.	self area griddingOnOff.	self changed: #selectedTool! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/19/2010 12:57'!gridStuckOnOff	gridStuck := gridStuck not.	self changed: #selectedTool! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/9/2010 19:33'!move	self selectTool: DrGSelectTool.	selectedTool := #move.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:26'!moveOx: increment	self area moveOx: increment! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:27'!moveOy: increment	self area moveOy: increment ! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/18/2010 23:00'!redo	self domain redo! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/20/2010 13:24'!scale: increment	self area scale: increment ! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/9/2010 19:52'!style	self selectTool: DrGStyleTool.	selectedTool := #style.	self changed: #selectedTool.! !!DrGeoPresenter methodsFor: 'callback canvas' stamp: 'HilaireFernandes 4/18/2010 23:00'!undo	self domain undo! !!DrGeoPresenter methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/9/2010 20:01'!initialize	super initialize.	self move.	isCreateMultipleMode := false.	gridStuck := false.! !!DrGeoPresenter methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 07:42'!release	tool release.	model release.	self view release.	self domain release.! !!DrGeoPresenter methodsFor: 'testing' stamp: 'HilaireFernandes 3/10/2006 18:38'!isCreateMultipleMode	^isCreateMultipleMode! !!DrGeoPresenter methodsFor: 'testing' stamp: 'HilaireFernandes 4/9/2010 21:36'!isGridded	^ gridStuck! !!DrGeoPresenter methodsFor: 'testing' stamp: 'HilaireFernandes 4/9/2010 19:58'!isGridVisible	^ self area gridVisible! !!DrGeoPresenter methodsFor: 'testing' stamp: 'HilaireFernandes 4/9/2010 19:07'!isTool: symbolTool"Do we have this symbolTool selected"	^ selectedTool == symbolTool ! !!DrGeoPresenter methodsFor: 'callback UI' stamp: 'HilaireFernandes 4/26/2010 10:36'!newFigure	DrGeo new! !!DrGeoPresenter methodsFor: 'callback UI' stamp: 'HilaireFernandes 4/26/2010 10:38'!openFigure	| stream |	stream := self view		fileOpen: 'Pick a Dr. Geo file name' 		extensions: #('fgeo').	stream ifNotNil: [DrGeo newXmlOn: stream].! !!DrGeoPresenter methodsFor: 'callback UI' stamp: 'HilaireFernandes 4/26/2010 13:17'!saveFigure| stream |	stream := self view		fileSave: 'Pick a Dr. Geo file name' 		extensions: #('fgeo').	stream ifNotNil: [self app saveOn: stream].! !!DrGeoPresenter methodsFor: 'tool' stamp: 'HilaireFernandes 4/2/2006 11:13'!openViewerForCostume: aCostume	aCostume openViewer.	self selectTool: DrGSelectTool! !!DrGeoPresenter methodsFor: 'tool' stamp: 'CedrickBeler 4/23/2010 16:44'!selectionCleanUp|createdItem|	"a mathItem is just been created, do some clean up"	self tool reset.	createdItem := self domain factory last.	"eventually if not in createMultipleMode we escape from this tool"	(createdItem isFreePointItem 		or: [createdItem isIntersectionPointItem 		or: [createdItem isPointItemOnCurve]])			ifFalse: [self selectToolAfterBuilding].	(tool class = DrGFlyPointBuildTool) ifTrue: [self selectToolAfterBuilding]! !!DrGeoPresenter methodsFor: 'tool' stamp: 'HilaireFernandes 4/9/2010 19:34'!selectToolAfterBuilding	self isCreateMultipleMode		ifFalse:			[self move]! !!DrGeoPresenter methodsFor: 'tool' stamp: 'HilaireFernandes 1/22/2006 17:05'!selectTool: aToolClassName	self tool: nil.	self tool: (aToolClassName new presenter: self).! !!DrGeoPresenter methodsFor: 'tool' stamp: 'HilaireFernandes 1/5/2006 17:51'!selectTool: aToolClassName with: aBuilderClassName	self tool: ((aToolClassName with: aBuilderClassName) presenter: self).! !!DrGeoPresenter commentStamp: 'HilaireFernandes 4/19/2010 21:40' prior: 0!A DrGGeometryPresenter is a presenter for the DrGeo app.It is the interface to callback and button definition.Instance Variables	domain:		<Object>	isCreateMultipleMode:		<Object>	model:		<Object>	selectedTool:		a symbol representing the selected UI tool	tool:		<Object>	view:		<Object>domain	- xxxxxisCreateMultipleMode	- xxxxxmodel	- xxxxxselectedTool	- xxxxxtool	- xxxxxview	- xxxxx!!DrGeoPresenter class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/19/2010 07:47'!with: aDrgeo 	| presenter |	presenter := self basicNew app: aDrgeo."	presenter		model: ((DrGGeometryModel in: aDrgeoModel domain)				presenter: presenter)."	presenter initialize.	^ presenter! !!DrGeoScripts methodsFor: 'accessing' stamp: 'HilaireFernandes 8/24/2008 17:54'!list	"compiledMethod list, for this class and subclasses	DrGeoUserScripts instance list	"	| exclude |	exclude := DrGeoUserScripts allMethodsInCategory: #private.	^DrGeoUserScripts methodDict values reject: [:compiledMethod |		exclude includes: compiledMethod selector].! !!DrGeoScripts methodsFor: 'accessing' stamp: 'HilaireFernandes 8/2/2008 21:29'!selectors	"the selector name for this class and subclasses"	^self list collect: [:method | method selector asString]! !!DrGeoScripts class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/2/2008 20:31'!instance	^self new! !!DrGeoScripts class methodsFor: 'instance creation' stamp: 'HilaireFernandes 8/2/2008 20:31'!new	^ uniqueInstance ifNil: [uniqueInstance := super new]! !!DrGeoUserScripts methodsFor: 'examples' stamp: 'HilaireFernandes 8/6/2008 14:00'!coordinate	"return arbitrary point (coordinate)"	^ (1 / 2) @ (1 / 2)! !!DrGeoUserScripts methodsFor: 'examples' stamp: 'HilaireFernandes 8/4/2008 14:58'!distance: pointA to: pointB"Calculate the distance from pointA to pointB"	^ pointA point dist: pointB point! !!DrGeoUserScripts methodsFor: 'examples' stamp: 'HilaireFernandes 8/4/2008 14:32'!example1	"An example without input items, returning the 'pi' value"	^ Float pi! !!DrGeoUserScripts methodsFor: 'examples' stamp: 'HilaireFernandes 8/4/2008 14:31'!example2	"An example without input items, returning the 'e' value"	^ Float e! !!DrGeoUserScripts methodsFor: 'examples' stamp: 'HilaireFernandes 8/4/2008 14:52'!example3: aPoint 	"An example with one Point item argument returning its abscissa value"	^ aPoint point x! !!DrGeoUserScripts methodsFor: 'scripts' stamp: 'HilaireFernandes 8/6/2008 16:43'!cos: pointItem 	^ pointItem point x @ (pointItem point x cos * 2)! !!DrGeoUserScripts methodsFor: 'scripts' stamp: 'HilaireFernandes 5/29/2010 23:13'!ia: number1 ib: number2 "Product SQRT IA x IB"	^ (number1 valueItem * number2 valueItem) sqrt! !!DrGeoUserScripts methodsFor: 'scripts' stamp: 'HilaireFernandes 8/6/2008 13:14'!myCounter	| tmp |	tmp := self counter.	self counter: tmp + 0.1.	self counter > 10 ifTrue: [self counter: -10].	^tmp! !!DrGeoUserScripts methodsFor: 'scripts' stamp: 'HilaireFernandes 8/13/2008 20:44'!slope: script 	"Calculate the coordinate of M', according to the slope at position M. The script expect the coordinate of the point M, a script"	| m |	m := script valueItem.	^ (m x + 1) @ (m y + (m x sin negated * 2 * 1))! !!DrGeoUserScripts methodsFor: 'private' stamp: 'HilaireFernandes 8/6/2008 13:12'!counter	^ counter ifNil: [counter := -5]! !!DrGeoUserScripts methodsFor: 'private' stamp: 'HilaireFernandes 8/6/2008 13:14'!counter: number	 counter := number! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:15'!app: anObject	app := anObject! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:16'!area	^ app view area! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:16'!domain	^ app domain! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:49'!factory	^ self domain factory! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:42'!ox	 ^ self area ox! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:42'!ox: aNumber	self area ox: aNumber! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:42'!oy	 ^ self area oy! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:42'!oy: aNumber	self area oy: aNumber! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:43'!presenter	^ app presenter! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:42'!scale	 ^ self area scale! !!DrGeoXml methodsFor: 'accessing' stamp: 'HilaireFernandes 4/21/2010 15:41'!setScaleTo: aNumber	self area setScaleTo: aNumber! !!DrGeoXml methodsFor: 'error handling' stamp: 'HilaireFernandes 4/21/2010 17:49'!doesNotUnderstand: aMessage 	| selector stream |	selector := aMessage selector.	(selector startsWith: 'parse')		ifFalse: [^ super doesNotUnderstand: aMessage].	stream := ReadWriteStream with: selector asString.	stream nextPutAll: ' aNode'; cr.	stream nextPutAll: 'self halt.';		 cr;		 nextPutAll: '^ self parseItem: aNode with: DrGMathItemBuilder.'.	self class compile: stream contents classified: 'parse'.	self perform: selector withArguments: aMessage arguments! !!DrGeoXml methodsFor: 'xml read' stamp: 'HilaireFernandes 4/26/2010 10:23'!loadOn: stream for: constructor"One XML document may contain several drgeo figure instances, parse it all,and return a DrGeo for each one"	| doc instances |	doc := XMLDOMParser parseDocumentFrom: stream.	stream close.	instances := OrderedCollection new.	(doc elementAt: #drgenius)		tagsNamed: #drgeo		do: [:each | instances	add: (self parseOneFigure: each for: constructor)].	^ instances! !!DrGeoXml methodsFor: 'xml read' stamp: 'HilaireFernandes 4/26/2010 10:24'!load: filename for: constructor	^ self 		loadOn: (FileStream readOnlyFileNamed: filename) 		for: constructor ! !!DrGeoXml methodsFor: 'xml read' stamp: 'HilaireFernandes 4/21/2010 17:57'!parseFigureFrom: drgeoNode"We parse from the view, because only the view knows both the domain and the view"	| type itemStatut |	self setScaleTo: (drgeoNode attributeAt: #scale ifAbsent: [self scale]).	self ox: (drgeoNode	attributeAt: #'origin_x' ifAbsent: [self ox]).	self oy: (drgeoNode	attributeAt: #'origin_y' ifAbsent: [self oy]).	(drgeoNode attributeAt: #grid) = 'True'	ifTrue: [self presenter gridOnOff].	drgeoNode	elementsDo: [:each | 		type := ((each attributeAt: #type) copyWithoutAll: '_') capitalized asSymbol.		itemStatut := self 			perform: (#parse , each tag capitalized , type , #:) asSymbol 			with: each.		itemStatut second ifTrue: [			self				perform: (#parseStyleOf , each tag capitalized , #':with:') asSymbol				with: itemStatut first				with: each]].	app 		forceVisible: false;		redrawCostumes! !!DrGeoXml methodsFor: 'xml read' stamp: 'HilaireFernandes 4/21/2010 15:36'!parseOneFigure: node for: constructor" Instantiate this node in a DrGeo app and return it"	| drgeo |	drgeo := DrGeo perform: constructor.	self app: drgeo.	self parseFigureFrom: node.	^ drgeo! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:50'!parentsById: aNode 	"return a collection of the item parent given theirs id in the attribute	elements <parent id=xxx>"	|collection|	collection := OrderedCollection new.	aNode	elementsDo: [:each | (each tag = #parent) ifTrue: [collection				add: (self factory findInPoolById: (each attributeAt: 'ref') asSymbol)]].	^collection ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:50'!parseAngle3pts: aNode	^ self parseItem: aNode with: DrGAngleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseAngleVectors: aNode	| itemStatut |	itemStatut := self parseItem: aNode with: DrGAngleBuilder.	self parseNumericPosition: aNode of: itemStatut first.	^ itemStatut! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircle3pts: aNode	^ self parseItem: aNode with: DrGArcBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircleReflexion: aNode	^ self parseReflexion: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircleRotation: aNode	^ self parseRotation: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircleScale: aNode 	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircleSymmetry: aNode 	^ self parseSymmetry: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseArcCircleTranslation: aNode	^self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircle2pts: aNode	^ self parseItem: aNode with: DrGCircleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleRadius: aNode	^ self parseItem: aNode with: DrGCircleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleReflexion: aNode	^ self parseReflexion: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleRotation: aNode	^ self parseRotation: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleScale: aNode	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleSegment: aNode^ self parseItem: aNode with: DrGCircleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleSymmetry: aNode 	^ self parseSymmetry:  aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseCircleTranslation: aNode	^ self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLine2pts: aNode	^self parseItem: aNode with: DrGRayBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLineReflexion: aNode	^self parseReflexion: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLineRotation: aNode	^self parseRotation: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLineScale: aNode 	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLineSymmetry: aNode 	^self parseSymmetry: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseHalfLineTranslation:aNode	^ self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:03'!parseItem: aNode with: builderClass 	| item builder |	builder := builderClass new.	(self parentsById: aNode)		do: [:each | builder addItem: {each} at: 0 @ 0].	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^ self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseLine2pts: aNode	^self parseItem: aNode with: DrGLineBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:46'!parseLineParallel: aNode	^self parseItem: aNode with: DrGParallelBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:51'!parseLinePerpendicular: aNode 	^ self parseItem: aNode with: DrGPerpendicularBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:05'!parseLineReflexion: aNode 	| item builder |	builder := DrGReflectionBuilder new.	(self parentsById: aNode) reverse		do: [:each | builder addItem: {each} at: 0 @ 0].	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^ self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseLineRotation: aNode	^self parseRotation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseLineScale: aNode	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseLineSymmetry: aNode	^ self parseSymmetry: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseLineTranslation: aNode	^self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseLocusNone: aNode	^ self parseItem: aNode with: DrGLocusBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericArclength: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericCircleperimeter: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericComputation: aNode	| itemStatut |	itemStatut := self parseItem: aNode with: DrGValueBuilder.	self parseNumericPosition: aNode of: itemStatut first.	^ itemStatut ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericDistance2pts: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericDistanceptline: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericPosition: aNode of: item	| x y |	x := (aNode elementAt: #x) contentString asNumber.	y := (aNode elementAt: #y) contentString asNumber.	item position: x@y.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericSegmentlength: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericSlope: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:05'!parseNumericValue: aNode	| item|	item := DrGFreeValueItem new.	self parseNumericPosition: aNode of: item.	item valueItem:  (aNode elementAt: #value) contentString asNumber.	item id: (aNode attributeAt: 'id') asSymbol.	^ self domain createFromMathItem: item! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parseNumericVectornorm: aNode	^ self parseNumericComputation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parsePointCoordinate: aNode^ self parseItem: aNode with: DrGPointByCoordinatesBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:00'!parsePointFree: aNode	| point x y|	x := (aNode elementAt: #x) contentString asNumber.	y := (aNode elementAt: #y) contentString asNumber.	point := DrGFreePointItem newWith: {x@y}.	point id: (aNode attributeAt: 'id') asSymbol.	^ self domain createFromMathItem: point		! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:07'!parsePointIntersection: aNode	| item arguments |	arguments := self parentsById: aNode.	item := DrGIntersectionPointItem newWith: (arguments add: 0@0; yourself).	 (aNode attributeAt: 'extra') asInteger = 0 ifTrue: [item k: -1] ifFalse: [item k: 1].	item id: (aNode attributeAt: 'id') asSymbol.	^ self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parsePointMiddle2pts: aNode^ self parseItem: aNode with: DrGMiddleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parsePointMiddlesegment: aNode	^self parseItem: aNode with: DrGMiddleBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:05'!parsePointOncurve: aNode	|item arguments|	arguments := self parentsById: aNode.	item := DrGPointItemOnCurve newWith: (arguments add: 0@0; yourself).	item setCurveAbscissa: (aNode elementAt: #value) contentString asNumber.	item id: (aNode attributeAt: 'id') asSymbol.	^self domain createFromMathItem: item! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:52'!parsePointReflexion: aNode 	^ self parseReflexion:  aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:05'!parsePointRotation: aNode	| item builder |	builder := DrGRotationBuilder new.	(self parentsById: aNode) reverse		do: [:each | builder addItem: {each} at: 0 @ 0].	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:06'!parsePointScale: aNode	| item builder |	builder := DrGHomothetyBuilder new.	(self parentsById: aNode) reverse		do: [:each | builder addItem: {each} at: 0 @ 0].	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:06'!parsePointSymmetry: aNode 	| item builder |	builder := DrGSymmetryBuilder new.	(self parentsById: aNode) reverse		do: [:each | builder addItem: {each} at: 0 @ 0].	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePointTranslation: aNode	^self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 18:04'!parsePolygonNpts: aNode	|item builder arguments|	builder := DrGPolygonBuilder  new.	(arguments := self parentsById: aNode)		do: [:each | builder addItem: {each} at: 0 @ 0].	builder addItem: {arguments first} at: 0@0.	item := builder getItem first.	item id: (aNode attributeAt: 'id') asSymbol.	^self domain createFromMathItem: item.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePolygonReflexion: aNode	^ self parseReflexion: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePolygonRotation: aNode	^ self parseRotation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePolygonScale: aNode 	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePolygonSymmetry: aNode 	^self parseSymmetry: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parsePolygonTranslation: aNode	^self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseReflexion: aNode 	^ self parseItem: aNode with: DrGReflectionBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseRotation: aNode 	^ self parseItem: aNode with: DrGRotationBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseScale: aNode 	^ self parseItem: aNode with: DrGHomothetyBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegment2pts: aNode 	^ self parseItem: aNode with: DrGSegmentBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegmentReflexion: aNode	^ self parseReflexion: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegmentRotation: aNode	^self parseRotation: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegmentScale: aNode	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegmentSymmetry: aNode	^self parseSymmetry: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSegmentTranslation: aNode	^self parseTranslation: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseSymmetry: aNode 	^ self parseItem: aNode with: DrGSymmetryBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:53'!parseTranslation: aNode 	^ self parseItem: aNode with: DrGTranslationBuilder! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:54'!parseVector2pts: aNode	^self parseItem: aNode with: DrGVectorBuilder.! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:54'!parseVectorReflexion: aNode	^self parseReflexion: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:54'!parseVectorRotation: aNode	^self parseRotation: aNode! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:54'!parseVectorScale: aNode 	^self parseScale: aNode ! !!DrGeoXml methodsFor: 'parse item' stamp: 'HilaireFernandes 4/21/2010 15:54'!parseVectorSymmetry: aNode 	^ self parseSymmetry: aNode! !!DrGeoXml methodsFor: 'parse' stamp: 'HilaireFernandes 4/26/2010 10:25'!parseScriptNitems: aNodeself halt.^ self parseItem: aNode with: DrGMathItemBuilder.! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:50'!parseStyleOfAngle: item with: aNode 	self parseStyleOfNumeric: item  with: aNode ! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:50'!parseStyleOfArcCircle: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:50'!parseStyleOfCircle: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 18:02'!parseStyleOfCurve: item with: aNode 	| costume attribute |	costume := app costumeOf: item.	self parseStyleOf: costume with: aNode.	attribute := aNode attributeAt: #thickness.	attribute = 'Dashed'		ifTrue: [costume style lineStyle: #dash].	attribute = 'Thick'		ifTrue: [costume style thickness: #medium]! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:50'!parseStyleOfHalfLine: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:51'!parseStyleOfLine: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:51'!parseStyleOfLocus: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 18:02'!parseStyleOfNumeric: item with: aNode 	| costume |	costume := app costumeOf: item.	self parseStyleOf: costume with: aNode.! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 18:01'!parseStyleOfPoint: item with: aNode 	| costume attribute |	costume := app costumeOf: item.	self parseStyleOf: costume with: aNode.	attribute := aNode attributeAt: #thickness.	attribute = 'Dashed'		ifTrue: [attribute := #small].	attribute = 'Normal'		ifTrue: [attribute := #medium].	attribute = 'Thick'		ifTrue: [attribute := #large].	costume style thickness: attribute.	attribute := aNode attributeAt: #style.	(#('Rectangular' 'RectangularEmpty' ) includes: attribute)		ifTrue: [attribute := #square].	attribute = 'RoundEmpty'		ifTrue: [attribute := #round].	costume style shape: attribute asLowercase asSymbol! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:51'!parseStyleOfPolygon: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:51'!parseStyleOfSegment: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:51'!parseStyleOfVector: item with: aNode 	self parseStyleOfCurve: item with: aNode! !!DrGeoXml methodsFor: 'parse style' stamp: 'HilaireFernandes 4/21/2010 17:50'!parseStyleOf: costume with: aNode 	| attribute |	costume		textMorph: (aNode attributeAt: #name).	(aNode attributeAt: #masked)			= 'True'		ifTrue: [costume style isHidden: true].	attribute := (aNode attributeAt: #color) asLowercase.	attribute = 'darkgrey'		ifTrue: [attribute := #darkGray].	attribute = 'grey'		ifTrue: [attribute := #gray].	attribute = 'darkgreen'		ifTrue: [attribute := #green].	attribute = 'darkblue'		ifTrue: [attribute := #blue].	attribute = 'bordeaux'		ifTrue: [attribute := #red].	costume style		color: (Color perform: attribute asSymbol)! !!DrGeoXml methodsFor: 'xml write' stamp: 'HilaireFernandes 4/26/2010 13:13'!saveAs: filename	self saveOn: (FileStream fileNamed: filename).! !!DrGeoXml methodsFor: 'xml write' stamp: 'HilaireFernandes 4/26/2010 13:12'!saveOn: stream	| doc writer root |	doc := XMLDocument new version: '1.0'.	writer := XMLWriter on: stream.	root := XMLElement named: #drgenius.	self writeAsXmlTo: root.	doc addElement: root.	doc printXMLOn: writer.	stream close! !!DrGeoXml methodsFor: 'xml write' stamp: 'HilaireFernandes 4/22/2010 07:54'!writeAsXmlTo: aNode 	| drgeoNode attr |	attr := Dictionary new.	attr at: #scale put: self scale asString;		 at: #'origin_x' put: self ox asString;		 at: #'origin_y' put: self oy asString;		 at: #grid put: self presenter isGridVisible asString capitalized;		at: #name put: 'A Dr. Geo figure'.	drgeoNode := XMLElement named: #drgeo attributes: attr.	app costumes do: [:each | each writeAsXmlTo: drgeoNode].	aNode addElement: drgeoNode! !!DrGeoXml commentStamp: 'HilaireFernandes 4/18/2010 16:48' prior: 0!A DrGeoXml is an helper to load or save as an XML representation a DrGeo instance.!!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 10:22'!add: item 	self last: item.	pool addLast: item! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 21:56'!at: integer	^ self pool at: integer ifAbsent: [nil]! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:31'!findInPool: item 	"Try to find a twin of this mathItem, if so return the twin, otherwise nil"	^ self at: (self indexOf: item)! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 21:55'!indexOf: anItem 	^ anItem ifNil: [0] ifNotNil: [self pool indexOf: anItem]! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 10:17'!last	^last! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/27/2008 10:59'!last: item 	"push item as the last instantiated item in the pool, purelly artificial however	as the items order in the pool is not changed"	last := item! !!DrGFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 10:18'!pool	^pool ! !!DrGFactory methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/18/2008 10:17'!initialize	super initialize.	pool := OrderedCollection new.! !!DrGFactory methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:42'!release	pool do: [ :item | item release].	super release.! !!DrGFactory methodsFor: 'testing' stamp: 'HilaireFernandes 7/27/2008 11:06'!isAnyInPool: itemList 	^itemList anySatisfy: [:item | (self findInPool: item) isNil not].! !!DrGFactory methodsFor: 'testing' stamp: 'HilaireFernandes 7/27/2008 11:07'!isInPool: item	^ (self findInPool: item) isNil not! !!DrGFactory methodsFor: 'updating' stamp: 'HilaireFernandes 7/27/2008 11:25'!pushAsLastWhenInPool: anItem"if this item has a twin in the pool, push as last this last one andreturn true, otherwise return false"	(self isInPool: anItem) ifTrue:		[self last: (self findInPool: anItem).		^true].	^false! !!DrGFactory methodsFor: 'removing' stamp: 'HilaireFernandes 8/13/2008 20:10'!removeAt: index	| item |	item := self at: index.	last = item ifTrue: [last := nil].	pool removeAt: index! !!DrGFactory methodsFor: 'removing' stamp: 'HilaireFernandes 7/18/2008 10:25'!remove: itemCollection 	pool := pool copyWithoutAll: itemCollection.	itemCollection do: [ :aMathItem | aMathItem release ]! !!DrGFactory commentStamp: 'HilaireFernandes 7/18/2008 10:22' prior: 0!The Factory is where are manufactured new mathematic or macro-constrcution items.It owns a pool of the already manufactured items. In last is the latested created (or recreated) item, Carefull!! last may not be equal to 'pool last' when the user tryto instantiate an already created object, in this case last return the original copy somewhere in the pool.When manufacturing a new item it checks for its unicity.It works with the help of the MathItem and macro Builder.Related patterns: flyweight.!!DrGFinitCurveCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 18:08'!addArrowMenu: theMenu	|subMenu|	subMenu := MenuMorph new.	#(#makeBackArrow #makeForwardArrow #makeBothArrows #makeNoArrows) do: [:anArrow |		self arrow ~= anArrow ifTrue:	[			subMenu 				add: ''				target: self				selector: #arrow:				argument: anArrow.			subMenu lastItem 				icon: (DrGIcons 					segment: self width 					color: self color 					dash: (self lineStyleFor: self lineStyle) 					arrow: anArrow)]].	theMenu add: 'arrow' translated subMenu: subMenu.! !!DrGFinitCurveCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 1/21/2006 18:13'!addMyMenus: theMenu	super addMyMenus: theMenu.	self addArrowMenu: theMenu ! !!DrGFinitCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/21/2006 18:05'!arrow	"Answer the value of arrows"	^ arrow! !!DrGFinitCurveCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 4/28/2010 18:04'!arrow: anObject	"Set the value of arrows"	arrow := anObject.	costume perform: arrow.! !!DrGFinitCurveCostumeStyle methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/28/2010 18:31'!initialize	super initialize.	self arrow: #makeNoArrows! !!DrGFlyBuildTool methodsFor: 'adding' stamp: 'HilaireFernandes 1/7/2006 11:28'!add: aCostume	mathItemTool add: aCostume ! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/8/2006 19:44'!builder"We have two builder, the flyPointBuilder and the other one (line, segment,...)"	flyPointTool builder readyToBuild 		ifTrue: [^flyPointTool builder]		ifFalse: [^mathItemTool builder]! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/7/2006 11:29'!builder: aBuilder	mathItemTool builder: aBuilder.! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:15'!flyingCostume	flyingCostume ifNil: 			[flyingCostume := DrGFlyingCostume with: self mathItemTool builder						in: self area.			self mathItemTool 				when: #selectedCostume				send: #add:				to: flyingCostume].	^flyingCostume! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/7/2006 11:43'!flyPointTool	^flyPointTool! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/7/2006 11:43'!mathItemTool	^mathItemTool! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2006 23:11'!mathItemTool: aBuilderClassName	mathItemTool ifNil: 		[mathItemTool := DrGBuildTool with: aBuilderClassName] ! !!DrGFlyBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 1/7/2006 11:27'!presenter: aPresenter	super presenter: aPresenter.	mathItemTool presenter: aPresenter.	flyPointTool presenter: aPresenter.! !!DrGFlyBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/20/2008 09:56'!initialize	super initialize.	self switchState: DrGFlyBuildToolState.	flyPointTool := DrGFlyPointBuildTool with: DrGFlyPointBuilder! !!DrGFlyBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:26'!registerDependant: anObject	mathItemTool registerDependant: anObject.	flyPointTool registerDependant: anObject! !!DrGFlyBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/31/2008 22:23'!release	super release	mathItemTool release.	flyPointTool release.	flyingCostume release.	flyingCostume := nil.! !!DrGFlyBuildTool methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 11:30'!isWanted: aMathItem	^mathItemTool isWanted: aMathItem! !!DrGFlyBuildTool methodsFor: 'updating' stamp: 'HilaireFernandes 3/10/2006 19:23'!reset"Why do we reset?"	"because intermediate point where created"	flyPointTool builder readyToBuild ifTrue: [flyPointTool reset].	"or the final mathItem was created"	mathItemTool builder readyToBuild ifTrue:			[mathItemTool reset.		flyPointTool reset.		flyingCostume release.		flyingCostume := nil.		self flyingCostume].! !!DrGFlyBuildTool commentStamp: '<historical>' prior: 0!This tool is kind of composite tool, because it integrates 2 tools: a traditional mathItemTool (an instance of BuildTool) and a flyPointTool (instance of FlyPointBuildTool).The flyPointTool allows the user to create pointItem on the fly while  mathItemTool allows the main construction to be conducted (line, segment, ...).This tool only has the FlyBuildToolState, only its component tool change of state.It also fearures a flyingCostume to represent the mathItem on-construction!!DrGFlyBuildTool class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/7/2006 11:25'!with: aBuilderClassName	^self new mathItemTool: aBuilderClassName	! !!DrGFlyBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 2/7/2006 16:27'!handleMouseAt: aPoint 	self context flyingCostume 		moveAt: (self area morphToWorld: aPoint).	self context last: aPoint.	"dispatch handleMouseAt"	(self context mathItemTool handleMouseAt: aPoint) 		ifFalse: 			[(self context mathItemTool builder isWanted: { (DrGPointItem new) }) 				ifTrue: [^self context flyPointTool handleMouseAt: aPoint]				ifFalse: [^false]]		ifTrue: [^true]! !!DrGFlyBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 4/19/2010 13:24'!handlePress: aPoint 	| pointItem |	self context last: aPoint.	(self context mathItemTool handlePress: aPoint) 		ifFalse: 			[((self context mathItemTool builder isWanted: { (DrGPointItem new) }) 				and: [self context flyPointTool handlePress: aPoint]) 					ifTrue: 						[pointItem := self context flyPointTool domain factory last.						self context mathItemTool 							add: self context flyPointTool app lastCostume.						self context mathItemTool builder add: { pointItem }							at: aPoint.						^true]					ifFalse: [^false]]		ifTrue: 			[^true]! !!DrGFlyBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 1/8/2006 19:11'!handleRelease: aPoint	self context mathItemTool handleRelease: aPoint.	self context flyPointTool handleRelease: aPoint.! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'jlrr 9/5/2007 21:07'!add2parents: aCostume 	freePointA		ifNil: ["Update mathItem"			freePointA := aCostume mathItem.			freePointA isValueItem				ifTrue: [						radius		ifNil: [radius := aCostume mathItem.			^ self]]									ifFalse: [movingPoint := DrGFreePointItem new point: freePointA point].			mathItem := mathItem class newWith: {freePointA. movingPoint}.			costume mathItem: mathItem.			self drawable addMorph: costume morph.			self redraw]! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 2/6/2006 22:59'!add3parents: aCostume 	freePointA ifNil: 			[freePointA := aCostume mathItem.			^self].	freePointB 		ifNil: 			[freePointB := aCostume mathItem.			movingPoint := DrGFreePointItem new point: freePointB point + (0.1 @ 0.1).			mathItem := mathItem class newWith: {								freePointA.								freePointB.								movingPoint							}.			costume mathItem: mathItem.			self drawable addMorph: costume morph.			self redraw]		ifNotNil:			[movingPoint := DrGFreePointItem new 									point: aCostume mathItem point + (0.1 @ 0.1).			mathItem parents: (mathItem parents allButLast asOrderedCollection 										add: aCostume mathItem;										add: movingPoint;										yourself).			self redraw]! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:40'!add: aCostume	mathItem parentQty = 2 ifTrue: [self add2parents: aCostume].	mathItem parentQty = 3 ifTrue: [self add3parents: aCostume].! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/9/2006 15:39'!mathItem: aMathItem	mathItem := aMathItem.! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/9/2006 14:56'!morph	^costume morph! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/9/2006 14:56'!morph: aMorph	costume morph: morph! !!DrGFlyingCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/9/2006 14:57'!redraw	costume redraw! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:26'!containsPoint: aPoint	^costume containsPoint: aPoint! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:27'!isArcCostume	^costume isArcCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:27'!isCircleCostume	^costume isCircleCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:27'!isCurveCostume	^costume isCurveCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:27'!isLineCostume	^costume isLineCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:28'!isLocusCostume	^costume isLocusCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:28'!isPointCostume	^costume isPointCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:28'!isRayCostume	^costume isRayCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:28'!isSegmentCostume	^costume isSegmentCostume! !!DrGFlyingCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/9/2006 14:29'!isVectorCostume	^costume isVectorCostume! !!DrGFlyingCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:09'!initialize	|costumeClass|	costumeClass := 'DrG', mathItem basicType capitalized, 'Costume'.	"We don't want initialize to take place in the costume"	costume := (self class environment classNamed: costumeClass) basicNew.	costume	drawable: self drawable; exist: true;		instantiateMorph.	costume morph costume: costume.	style := costume styleClass basicNew 		costume: costume;		color: Color lightRed ;		isHidden: false.	costume style: style.! !!DrGFlyingCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:50'!release	costume release.	super release! !!DrGFlyingCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 17:13'!moveAt: aPoint	movingPoint ifNotNil: [		movingPoint moveAt: aPoint.		mathItem update.		costume update]! !!DrGFlyingCostume commentStamp: '<historical>' prior: 0!A flying costume is an intermediate costume used to display the on construction mathItem (line, ray, segment, circle, vector, arc).- costume is the underneath costume- mathItem is the resulting mathItem- freePointA, B, C are used for the intermediate construction of mathItemIn fact costume rely on mathItem instance, in turn mathItem need the freePointItem instance to be fully workable!!DrGFlyingCostume class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/9/2006 17:58'!with: aBuilder in: aDrawable	^self basicNew 		mathItem: aBuilder mathItemClass new;		drawable: aDrawable;		initialize.! !!DrGFlyPointBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:44'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection ifNotEmpty: 		[curveItemA := aMathItemCollection first].	aMathItemCollection size >= 2 ifTrue:		[curveItemB := aMathItemCollection second]! !!DrGFlyPointBuilder methodsFor: 'private' stamp: 'HilaireFernandes 8/25/2008 14:05'!restoreState: anArray	curveItemA := anArray first.	curveItemB := anArray second.	point := anArray third! !!DrGFlyPointBuilder methodsFor: 'private' stamp: 'HilaireFernandes 8/25/2008 14:04'!saveState	^Array with: curveItemA with: curveItemB with: point! !!DrGFlyPointBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 1/6/2006 10:38'!arguments	(curveItemA notNil and: [curveItemB notNil])		ifTrue: [^{curveItemA . curveItemB . point}].	curveItemA ifNotNil: [^{curveItemA . point}].	^{point}			! !!DrGFlyPointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:33'!isCurveIntersectionValid: aCollection	| item state |	state := self saveState.	self restoreState: aCollection.	[item := self buildItem]		on: Error 		do: [self restoreState: state.			^false].	self restoreState: state.	^ item anyOne exist! !!DrGFlyPointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/23/2008 15:54'!isWanted: aMathItemCollection	^self isWanted: aMathItemCollection  at: 0@0! !!DrGFlyPointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/23/2008 15:53'!isWanted: aMathItemCollection at: aPoint	"click on the background?"	aMathItemCollection ifEmpty: [^true].	"click on two curves?"	(aMathItemCollection size >= 2		and: [aMathItemCollection first isCurveItem]		and: [aMathItemCollection second isCurveItem])	ifTrue: [^ self isCurveIntersectionValid: {aMathItemCollection first. aMathItemCollection second. aPoint}].	"click on one curve?"	^aMathItemCollection first isCurveItem		! !!DrGFlyPointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:32'!readyToBuild	^ curveItemA notNil or: [point notNil]! !!DrGFlyPointBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/21/2010 20:40'!mathItemClass	(curveItemA notNil and: [curveItemB notNil]) 		ifTrue: [^DrGIntersectionPointItem].	curveItemA ifNotNil: [^DrGPointItemOnCurve].	point ifNotNil: [^DrGFreePointItem].	self error: 'Should not be there!!'! !!DrGFlyPointBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:50'!reset	super reset.	curveItemA := curveItemB := nil! !!DrGFlyPointBuilder commentStamp: '<historical>' prior: 0!To build free point and intersection point, it is also used to construct on the fly those point categories.!!DrGFlyPointBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2010 20:57'!costumesAt: aPoint	^self intersectableCurves: ((self myCostumesAt: aPoint) select: 			[:aCostume|				aCostume isCurveCostume])		at: aPoint! !!DrGFlyPointBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2010 20:54'!intersectableCurves: aCollection at: aPoint 	"As long as we can't get proper intersection with the first two, we remove the first one an try again "	aCollection size <= 1 ifTrue: [ ^ aCollection ].	^ (	DrGFlyPointBuilder new isCurveIntersectionValid: { 			(aCollection first mathItem).			(aCollection second mathItem).			aPoint}) 		ifTrue: [ aCollection ]		ifFalse: [self intersectableCurves: aCollection allButFirst at: aPoint ]! !!DrGFlyPointBuildTool methodsFor: 'initialize' stamp: 'HilaireFernandes 7/22/2008 16:29'!initialize	super initialize.	self switchState: DrGFlyPointBuildToolState! !!DrGFlyPointBuildTool commentStamp: '<historical>' prior: 0!This tool lets the user create free point, point on curve and intersection point on the fly.On the fly means create the point in one-clic operation.!!DrGFlyPointBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/22/2008 20:41'!handleMouseAt: aPoint 	| costumes aTip |	costumes := self context costumesAt: aPoint.	costumes size = 1		ifTrue: [aTip := costumes first mathItem descriptiveName].	costumes size > 1		ifTrue: [aTip := 'This intersection' translated].	aTip		ifNil: [self area hideTip]		ifNotNil: [self area tip: aTip at: aPoint].	^ aTip notNil! !!DrGFlyPointBuildToolState methodsFor: 'handling' stamp: 'HilaireFernandes 8/23/2008 15:55'!handlePress: aPoint 	"return true if did something"	| costumes |	self area hideTip.	self context last: (self context gridPoint: aPoint).	costumes := self context costumesAt: aPoint.	"user clicked in the background or in one or several curve item, handle it immediately"	self handleChoice: costumes.	^ true! !!DrGFreePointBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:13'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint.	aMathItemCollection 		ifNotEmpty: [curveItem := aMathItemCollection first].! !!DrGFreePointBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 22:29'!arguments	curveItem ifNotNil: 			[^ OrderedCollection new 			add: curveItem; 			add: point; 			yourself].	^ OrderedCollection new add: point; yourself! !!DrGFreePointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:13'!isWanted: aMathItemCollection	"the user clicked on the background: we can build a free point" 	aMathItemCollection ifEmpty: [^true].	^aMathItemCollection first isCurveItem.! !!DrGFreePointBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 12/19/2005 14:54'!readyToBuild	^ curveItem ~= nil or: [point ~= nil]! !!DrGFreePointBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:57'!mathItemClass	curveItem ifNotNil: [^DrGPointItemOnCurve].	point ifNotNil: [^DrGFreePointItem].	self error: 'Should not be there!!'! !!DrGFreePointBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:49'!reset	super reset.	curveItem := nil.! !!DrGFreePointItem methodsFor: 'comparing' stamp: 'HilaireFernandes 12/21/2005 14:51'!hash	^ super hash bitXor: point hash! !!DrGFreePointItem methodsFor: 'comparing' stamp: 'HilaireFernandes 4/10/2010 12:36'!= aMathItem 	^ aMathItem		ifNil: [false]		ifNotNil: [self basicType = aMathItem basicType 			and: [self nodeType = aMathItem nodeType]			and: [self point = aMathItem point]]! !!DrGFreePointItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 12/29/2005 09:44'!initialize: theParents	super initialize: theParents.	self point: theParents first.! !!DrGFreePointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:26'!isFreePointItem	^true! !!DrGFreePointItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 19:14'!moveAt: aPoint	point := aPoint.	! !!DrGFreePointItem methodsFor: 'updating' stamp: 'HilaireFernandes 12/28/2005 12:35'!move: aPoint	point := point + aPoint.	self update	! !!DrGFreePointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 4/22/2010 07:59'!nodeType	^#Free! !!DrGFreePointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:56'!writeAsXmlTo: aNode	"It is important to return the node"	| node|	node :=  XMLElement named: self nodeName attributes: Dictionary new.	aNode addElement: node.	node attributeAt: #type put: self nodeType.	node addElement:  ((XMLElement named: #x) addContent: (XMLStringNode string: point x asString));		addElement: ((XMLElement named: #y) addContent: (XMLStringNode string: point y asString)).	^node! !!DrGFreePointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/29/2005 09:48'!parents: aCollection	parents := nil! !!DrGFreePointItem commentStamp: '<historical>' prior: 0!I represent a free point in the plane or in a curve (line, segment, ray, circle,...)!!DrGFreeValueCostumeStyle methodsFor: 'menu' stamp: 'jlrr 9/29/2007 14:47'!addMyMenus: theMenu 	super addMyMenus: theMenu.	theMenu		add: 'edit this value' translated		target: self		action: #editValue! !!DrGFreeValueCostumeStyle methodsFor: 'updating' stamp: 'HilaireFernandes 4/19/2010 13:06'!editValue	| answer |	answer := FillInTheBlankMorph request: 'Edit this value' translated initialAnswer: costume valueString.	costume mathItem valueItem: answer asNumber.	costume contents: answer asString.	costume drawable app domain updateAllMathItems! !!DrGFreeValueItem methodsFor: 'comparing' stamp: 'HilaireFernandes 2/2/2006 15:33'!hash	^ (super hash bitXor: position hash) bitXor: value hash! !!DrGFreeValueItem methodsFor: 'comparing' stamp: 'HilaireFernandes 2/2/2006 15:33'!= aMathItem	^super = aMathItem 		and: [self valueItem = aMathItem valueItem]		and: [self position = aMathItem position]! !!DrGFreeValueItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:42'!nodeType	^#value! !!DrGFreeValueItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:05'!writeAsXmlTo: aNode 	"return the newly created element"	| node |	node := XMLElement named: self nodeName attributes: Dictionary new.	aNode addElement: node.	node attributeAt: #type put: self nodeType.	node		addElement: ((XMLElement named: #x)				addContent: (XMLStringNode string: position x asString));				addElement: ((XMLElement named: #y)				addContent: (XMLStringNode string: position y asString));		addElement:  ((XMLElement named: #value) addContent: (XMLStringNode string: value  asString)).	^ node! !!DrGFreeValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2008 10:33'!valueItem: aValue	value := aValue.! !!DrGHomothetyArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:41'!moveParent: aPoint	^false! !!DrGHomothetyArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update|arcItem centerHomothety|	self doesParentExist ifTrue:		[arcItem := parents first.		centerHomothety := parents second point.		center := centerHomothety +			(parents third valueItem * (arcItem center - centerHomothety)).		radius := arcItem radius * parents third valueItem abs.		origin := arcItem origin + (parents third valueItem sign -1 * Float halfPi).		length := arcItem length].! !!DrGHomothetyArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:03'!nodeType	^#Scale! !!DrGHomothetyBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:33'!mathItemClass: aMathItem	|className|	className := 'DrGHomothety', aMathItem basicType capitalized, 'Item'.	^(self class environment classNamed: className)! !!DrGHomothetyCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGHomothetyCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update|centerHomothety|	self doesParentExist ifTrue:		[centerHomothety := parents second point.		radius := parents first radius * parents third valueItem abs.		center := centerHomothety +			(parents third valueItem * (parents first center - centerHomothety))].! !!DrGHomothetyCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGHomothetyLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGHomothetyLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 22:54'!update	self homothetyUpdate ! !!DrGHomothetyLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGHomothetyPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:27'!isConstrainedPointItem	^true! !!DrGHomothetyPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:57'!nodeType	^#Scale! !!DrGHomothetyPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update|center|	self doesParentExist ifTrue:		[center := parents second point.		point := center + 			(parents third valueItem * (parents first point - center))].! !!DrGHomothetyPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGHomothetyPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update|center factor|	self doesParentExist ifTrue:		[center := parents second point.		factor := parents third valueItem.		points := OrderedCollection new.		parents first points do: [:point |			points add: (center + (factor * (point - center)))].		self computeLength].! !!DrGHomothetyPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGHomothetyRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:43'!moveParent: aPoint	^false! !!DrGHomothetyRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 23:00'!update	self homothetyUpdate! !!DrGHomothetyRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGHomothetySegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGHomothetySegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 23:00'!update	self homothetyUpdate ! !!DrGHomothetySegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGHomothetyVectorItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/7/2006 23:07'!initialize: theParents	super initialize: theParents.	self origin: parents second point.! !!DrGHomothetyVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGHomothetyVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update	self doesParentExist ifTrue:		[vector := parents first direction * parents third valueItem].! !!DrGHomothetyVectorItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Scale! !!DrGIcons commentStamp: '<historical>' prior: 0!I just execute-print something like:	(FileStream fileNamed: 'middle-.png') binary contents asByteArray in the class message to get the string!!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:58'!angle	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 9 93 73 68 65 84 120 218 237 90 107 76 147 215 27 255 189 212 118 109 41 72 105 144 75 239 165 88 196 41 136 34 157 12 47 212 133 44 129 13 5 151 177 57 62 240 97 178 108 81 251 69 179 132 100 155 95 220 178 236 195 98 178 65 150 200 134 44 91 140 19 198 36 217 133 218 45 113 153 98 22 116 72 128 181 180 20 74 116 114 81 161 148 123 159 255 135 238 245 69 253 51 160 92 138 218 223 151 183 231 125 207 229 247 60 207 57 207 121 158 115 10 132 16 66 8 33 44 17 136 130 205 224 41 21 120 181 240 8 154 192 193 82 192 226 199 13 11 14 241 199 29 172 226 25 38 216 76 22 72 120 174 239 179 61 3 237 119 165 229 88 117 152 47 225 213 46 216 106 231 183 104 194 171 85 192 229 231 181 66 123 192 66 87 66 176 13 178 114 62 126 153 6 152 175 2 231 18 112 165 55 187 199 110 115 93 168 96 43 213 110 181 142 243 40 214 4 107 224 249 41 96 185 103 226 19 59 227 87 59 136 36 18 137 68 34 9 52 252 13 33 64 204 150 65 7 79 241 79 73 38 60 183 171 201 203 203 203 203 203 123 184 126 8 139 196 194 51 233 162 162 162 162 162 162 144 43 90 36 22 175 56 255 138 8 25 98 129 88 122 69 101 100 100 100 100 100 16 137 197 98 177 88 28 50 196 44 88 126 197 68 69 69 69 69 69 17 25 141 70 163 209 24 50 196 191 120 124 239 1 30 115 4 79 1 219 182 109 219 182 109 27 145 86 171 213 106 181 79 157 33 86 155 192 139 231 179 226 41 120 73 73 73 73 73 9 81 103 167 221 222 209 1 184 221 110 183 219 13 244 247 15 12 220 185 3 120 189 94 239 232 40 87 95 44 22 139 69 34 64 38 147 201 100 50 64 161 80 40 148 74 64 175 215 235 245 122 160 186 186 186 186 186 122 229 143 18 50 51 51 51 51 51 137 60 30 143 199 227 1 90 91 91 91 91 91 23 206 99 217 136 151 149 149 149 149 149 17 89 173 86 171 213 10 116 116 116 116 116 116 0 10 69 66 130 76 6 100 101 109 221 186 118 45 144 158 190 113 163 64 0 40 149 10 69 124 60 240 218 107 239 188 99 181 2 191 253 118 246 236 158 61 192 237 219 253 253 30 15 208 209 225 116 2 192 181 107 109 109 30 15 112 229 74 115 243 205 155 64 79 79 111 239 221 187 64 114 178 193 160 215 3 187 119 239 217 99 50 1 21 21 21 21 149 149 79 209 41 170 217 108 54 155 205 68 42 149 74 165 84 114 241 115 110 110 78 142 193 192 149 29 142 198 198 164 36 34 151 235 226 69 165 242 209 39 91 207 233 180 88 18 19 185 247 221 221 23 47 202 229 254 167 66 65 212 213 101 177 168 213 92 253 252 252 189 123 19 18 184 178 74 165 82 41 20 68 102 179 217 124 244 232 242 185 46 185 92 46 151 203 137 10 11 11 11 11 11 131 224 34 77 38 147 105 207 30 78 240 157 59 141 70 181 154 168 174 174 162 34 37 197 175 72 173 150 200 229 178 88 20 10 174 30 91 254 251 239 31 127 212 106 137 174 93 171 175 79 73 225 190 55 52 84 85 237 216 65 244 211 79 95 125 149 154 74 116 233 210 183 223 174 95 79 116 253 122 125 253 76 131 118 118 254 242 139 86 203 25 232 194 133 202 74 157 142 40 59 219 104 212 104 184 122 38 147 201 148 147 179 244 10 218 191 127 255 254 253 251 137 116 58 157 78 167 91 120 255 1 47 153 228 100 131 33 41 137 168 189 189 163 195 102 227 222 119 117 89 44 26 141 255 183 207 7 76 79 251 124 60 30 48 53 53 53 69 4 12 13 121 189 12 3 100 100 20 22 58 157 192 215 95 127 242 137 86 11 120 189 99 99 12 3 140 142 142 143 19 1 68 68 236 130 102 24 128 97 24 198 231 3 14 31 62 113 194 233 4 170 170 62 252 80 163 1 100 50 169 116 205 26 64 167 83 40 248 124 32 50 82 36 26 26 2 134 135 39 39 149 74 96 227 198 220 220 203 151 57 126 27 54 36 39 107 181 64 91 91 123 187 211 185 212 46 99 225 174 104 193 4 212 106 255 210 246 120 134 135 7 6 128 207 63 127 239 61 153 12 48 26 55 111 6 0 149 42 39 199 237 6 90 90 26 26 82 82 0 151 171 183 119 98 2 24 24 184 115 103 114 18 184 113 195 110 159 152 0 174 95 111 107 27 27 3 156 78 183 123 124 28 184 117 171 191 127 98 2 24 25 241 122 167 167 185 241 36 18 177 152 207 7 226 226 214 173 147 72 128 196 68 141 70 42 5 82 82 18 19 137 0 181 58 62 158 8 136 136 8 15 7 0 157 78 173 142 137 1 118 237 122 245 213 166 38 160 179 179 177 209 96 0 254 252 243 198 141 145 17 224 237 183 79 156 184 125 27 136 136 136 136 88 187 22 112 56 92 174 190 190 197 27 34 50 50 50 50 50 146 104 104 104 104 104 104 104 25 12 192 206 248 254 254 190 190 158 30 160 166 230 163 143 164 82 96 195 6 157 142 199 243 219 158 97 128 225 225 209 81 161 16 216 180 41 47 207 102 3 14 29 42 46 142 139 3 44 150 63 254 184 119 15 176 219 187 186 70 71 1 141 70 165 138 142 6 182 108 73 75 75 73 1 12 134 245 235 147 147 1 135 195 225 176 219 129 236 236 93 187 94 120 1 168 171 171 171 171 175 7 164 210 232 232 184 56 160 185 185 185 249 175 191 128 206 78 135 195 233 4 146 146 180 218 136 8 32 39 199 104 12 15 7 42 43 191 249 230 214 45 192 98 57 115 102 203 22 64 46 95 183 110 98 2 16 10 215 172 25 30 6 218 219 29 142 201 73 224 141 55 142 31 239 235 3 98 99 99 99 227 226 128 27 55 218 218 220 238 192 13 193 230 7 74 165 82 169 84 2 181 181 181 181 181 181 115 247 55 231 113 52 235 59 89 87 211 223 63 56 56 54 230 159 129 97 97 156 226 239 221 27 25 17 137 128 150 22 155 205 231 243 71 57 145 145 156 66 132 66 145 40 58 26 120 247 221 99 199 14 29 2 210 211 183 110 205 206 6 106 107 235 235 47 93 98 152 246 118 187 189 191 31 56 123 246 252 249 95 127 101 24 139 197 106 189 122 21 176 88 172 214 43 87 24 102 106 106 122 154 97 88 197 51 76 118 118 118 118 86 22 32 18 133 135 199 199 115 227 100 101 165 167 71 68 0 54 91 87 215 221 187 64 103 103 79 15 235 10 249 124 63 111 30 15 232 235 27 28 156 154 98 21 15 228 230 238 221 251 220 115 129 239 17 26 141 70 163 209 0 189 189 189 189 189 189 129 246 50 3 108 84 227 47 17 189 255 254 225 195 26 13 183 217 177 239 91 90 46 92 216 176 129 232 179 207 62 248 64 171 37 74 74 210 104 132 66 238 123 73 201 235 175 191 248 34 81 77 205 153 51 167 79 19 21 20 20 20 20 20 112 130 46 85 185 180 180 180 180 180 148 27 87 175 87 171 69 34 162 143 63 62 126 92 173 246 111 226 51 55 121 54 154 58 121 210 108 142 138 226 222 155 205 102 243 145 35 129 27 98 201 50 100 149 74 165 82 169 136 210 210 158 125 86 169 228 194 62 151 203 98 145 203 137 108 182 159 127 246 123 97 78 96 161 144 72 36 18 10 121 60 162 99 199 204 230 226 98 162 154 154 154 154 47 191 124 84 241 139 197 108 134 40 47 47 47 47 47 39 18 139 69 34 62 159 51 4 203 179 181 181 161 193 96 120 48 172 149 203 137 114 114 118 236 136 137 33 98 247 184 64 121 73 165 82 169 84 186 8 57 203 202 202 202 14 29 122 244 170 142 37 202 26 160 169 233 220 57 189 158 200 191 228 185 122 199 142 29 61 122 224 128 127 198 87 85 45 189 226 23 106 8 150 23 203 179 190 254 139 47 210 210 136 156 206 198 198 153 97 234 195 79 54 145 92 40 31 129 64 32 16 8 22 33 175 63 76 35 202 203 51 153 20 10 162 206 206 198 198 245 235 231 186 188 38 58 120 240 192 1 163 113 229 20 63 151 33 246 237 219 183 239 229 151 31 117 77 15 63 217 137 229 143 150 136 76 166 221 187 211 211 137 12 6 131 129 203 55 230 15 134 97 24 134 89 180 220 68 231 206 125 250 105 108 172 63 19 85 169 56 159 217 212 84 91 187 101 11 81 82 146 86 43 145 16 109 220 104 48 196 196 16 85 87 87 85 157 58 181 242 138 159 203 16 108 57 53 53 53 53 53 149 115 73 13 13 167 79 103 100 60 152 105 43 20 68 167 78 157 60 201 181 95 126 3 220 143 130 222 122 171 180 52 55 151 72 167 83 42 5 2 96 251 246 77 155 248 124 192 231 35 226 241 128 241 241 169 169 200 72 224 242 229 182 54 141 6 176 217 156 78 143 7 40 46 126 229 149 220 92 224 252 249 239 191 183 88 252 97 99 93 29 195 4 203 16 15 143 207 150 243 243 243 243 243 243 1 187 221 229 26 29 5 6 7 7 7 111 221 2 124 62 159 47 44 140 83 247 75 47 109 223 126 245 42 144 144 144 144 16 27 203 29 30 206 119 124 62 159 207 231 243 3 32 190 115 231 243 207 111 222 60 251 82 101 207 102 222 124 179 184 120 230 153 205 227 246 76 75 75 78 22 8 30 221 132 231 215 126 54 4 222 254 126 162 144 152 168 209 200 100 68 71 142 28 60 8 0 5 5 57 57 66 225 191 149 152 255 223 205 195 239 103 171 55 95 60 156 182 16 249 87 32 159 207 229 27 60 30 195 76 78 114 101 134 241 31 121 204 197 107 122 218 223 79 88 24 48 49 241 95 28 24 134 97 128 138 138 31 126 72 77 5 106 106 190 251 174 165 5 232 238 238 238 238 238 158 45 177 10 252 191 176 247 255 154 248 207 63 125 125 94 47 32 145 8 133 207 60 3 56 157 61 61 99 99 129 41 114 169 177 84 60 102 222 51 204 5 189 94 38 251 253 119 96 96 96 96 96 114 114 174 218 115 77 189 217 51 226 251 6 24 25 241 122 199 198 128 145 145 241 241 152 24 192 225 184 121 51 44 12 16 137 252 105 213 192 192 221 187 97 97 0 155 145 62 233 240 122 199 198 124 62 255 5 145 203 53 223 86 179 249 132 255 104 241 96 113 181 93 249 61 233 152 97 160 229 58 34 120 82 202 43 134 96 11 186 218 203 33 197 63 105 138 15 33 132 16 66 8 30 254 7 195 86 167 231 229 37 138 50 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:58'!arc	^self formFromGraphic:  #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 7 221 73 68 65 84 120 218 237 90 203 79 147 89 20 63 95 203 163 60 74 65 10 5 132 2 37 136 18 27 98 16 17 137 129 21 134 168 33 237 2 67 38 153 132 133 75 137 18 163 9 175 70 94 49 6 212 68 131 11 23 147 204 31 160 49 51 106 52 136 102 76 88 32 105 124 67 38 12 146 182 137 82 138 188 218 210 150 199 157 197 153 147 27 202 212 66 31 130 245 251 109 126 185 95 239 215 246 158 115 238 185 231 113 1 68 136 16 33 66 132 8 17 34 68 136 248 89 193 216 70 254 121 32 217 217 159 255 249 4 238 141 168 240 126 189 47 1 11 194 78 47 124 183 32 204 130 216 174 133 11 66 119 119 119 119 119 55 99 211 211 211 211 211 211 0 209 209 81 81 81 81 0 215 175 223 184 113 227 70 228 41 46 204 59 96 235 232 237 237 237 237 237 101 204 100 50 153 76 38 128 153 153 153 153 153 25 0 133 34 41 41 41 105 167 255 93 248 16 182 51 224 249 243 11 23 46 92 216 250 252 193 193 193 193 193 65 128 145 145 145 145 145 17 0 139 197 98 177 88 0 60 158 149 149 149 21 128 174 174 174 174 174 174 200 59 51 66 174 128 135 15 209 133 28 63 126 251 246 237 219 91 127 111 104 104 104 104 104 8 96 97 97 97 97 97 1 96 121 121 121 121 121 25 96 126 126 126 126 126 158 143 69 248 129 205 166 209 104 52 222 97 229 246 185 186 186 186 186 186 154 177 166 166 166 166 166 166 200 179 124 66 200 118 192 219 183 58 157 78 199 152 82 57 57 57 57 233 127 126 81 81 81 81 81 209 230 231 101 101 101 101 101 101 0 114 185 92 46 151 3 200 100 50 153 76 182 211 98 10 31 66 166 0 173 246 254 253 251 247 253 207 43 47 47 47 47 47 7 136 142 142 142 142 142 222 252 60 33 33 33 33 33 1 96 109 109 109 109 109 13 96 118 118 118 118 118 22 128 162 163 157 22 88 168 17 180 2 222 191 63 117 234 212 41 255 130 169 172 172 172 172 172 4 112 187 221 110 183 27 64 42 149 74 165 82 128 138 138 138 138 138 10 0 133 66 161 80 40 0 146 146 48 234 161 207 237 118 187 221 110 7 88 90 90 90 90 90 218 105 113 133 30 65 135 161 5 5 47 95 190 124 201 199 70 35 242 111 191 197 199 199 199 3 124 248 112 244 232 209 163 0 115 115 115 115 115 115 220 178 227 226 226 226 226 226 184 224 85 42 149 74 165 226 59 192 225 112 56 28 14 238 130 200 37 69 26 2 222 1 207 158 93 186 116 233 18 99 50 25 70 45 132 215 175 145 191 126 213 104 52 26 128 213 213 213 213 213 85 0 137 68 34 145 72 184 64 73 240 153 153 153 153 153 153 0 249 249 249 249 249 249 0 3 3 3 3 3 3 130 144 157 157 157 157 157 13 144 155 155 155 155 155 11 208 214 214 214 214 214 230 43 17 251 113 93 83 192 59 64 165 250 248 241 227 71 62 254 242 5 249 159 127 144 237 246 140 140 140 12 128 152 24 28 199 198 198 198 198 198 114 11 79 75 75 75 75 75 3 200 201 201 201 201 201 1 232 232 232 232 232 232 224 2 238 233 233 233 233 233 137 188 204 215 27 1 43 32 53 245 211 167 79 159 248 120 106 10 217 102 67 139 246 120 240 144 149 203 209 226 211 211 211 211 211 211 57 99 98 21 249 2 246 135 128 93 144 92 254 229 11 89 61 0 128 197 130 188 178 162 84 42 149 220 229 36 38 38 38 38 38 2 100 101 101 101 101 101 137 130 247 70 192 10 144 201 22 23 23 23 249 216 102 67 94 94 198 195 50 42 10 139 104 164 0 131 193 96 48 24 68 193 123 35 96 23 36 149 98 141 134 143 145 61 30 140 126 40 206 39 159 31 24 182 123 184 110 117 254 238 49 132 128 119 192 218 26 10 152 150 156 150 134 28 23 135 241 58 237 128 224 50 89 18 148 63 14 116 254 206 35 96 5 184 92 152 48 209 146 114 115 145 21 10 12 75 5 65 16 4 129 43 66 196 255 35 96 5 44 46 98 226 68 208 104 144 51 50 176 116 192 24 99 140 241 196 43 50 17 124 47 59 96 5 204 206 98 226 68 72 76 68 214 106 177 145 34 149 98 9 33 50 203 200 161 75 252 2 86 192 231 207 251 247 239 223 191 249 57 61 83 169 176 42 74 37 133 31 11 190 202 228 161 71 208 135 146 195 33 151 203 229 140 197 199 227 225 235 114 225 243 63 255 196 195 247 143 63 234 235 235 235 1 10 11 11 11 11 11 1 218 219 219 219 219 219 119 223 97 184 17 129 247 178 173 86 171 213 106 229 81 96 127 127 127 127 127 191 239 245 6 93 13 253 251 239 99 199 142 29 227 99 42 49 87 86 186 92 46 23 64 81 209 232 232 232 40 239 116 125 123 193 63 94 77 167 174 174 174 174 174 142 177 209 81 92 231 212 212 212 212 212 20 47 62 250 67 208 241 201 161 67 79 158 60 121 34 8 40 58 46 192 244 116 100 157 14 107 70 191 255 142 59 96 35 118 171 192 201 98 253 255 63 179 217 108 54 155 249 89 71 85 94 74 64 253 33 100 13 153 87 175 106 107 107 107 1 36 255 125 35 133 158 197 197 200 87 175 62 120 240 224 1 192 197 139 231 206 157 59 231 123 97 205 205 205 205 205 205 187 85 49 155 97 52 26 141 70 35 143 250 168 108 78 229 117 127 8 153 2 142 28 121 252 248 241 99 65 248 252 121 239 222 189 123 125 207 235 235 187 117 235 214 173 205 207 245 122 189 94 175 231 77 248 157 197 246 13 96 124 124 124 124 124 156 91 62 149 219 253 33 228 183 34 94 188 104 104 104 104 216 254 123 30 143 199 227 241 0 196 196 196 196 80 9 251 123 224 209 163 43 87 174 92 217 250 25 116 228 8 246 57 188 81 90 90 90 90 90 202 19 79 90 143 63 132 92 1 191 252 210 215 215 215 39 8 119 239 234 116 58 221 214 223 171 175 223 104 65 225 198 235 215 122 189 94 207 88 109 173 193 96 48 248 159 95 91 123 240 224 193 131 0 11 11 27 123 217 90 173 86 171 213 114 223 79 13 40 138 134 176 175 225 91 177 97 187 152 53 51 131 183 27 182 138 95 127 157 152 152 152 0 104 105 185 115 231 206 29 128 191 254 58 121 242 228 201 208 157 5 70 227 153 51 103 206 48 230 112 236 217 179 103 15 99 37 37 247 238 221 187 231 255 189 211 167 75 74 74 74 0 44 22 44 173 172 175 175 175 175 175 3 20 23 23 23 23 23 115 87 147 156 156 156 156 156 204 203 240 91 237 101 239 178 187 161 190 223 52 153 14 28 56 112 0 96 122 26 23 62 55 87 80 80 80 0 112 226 196 181 107 215 174 9 194 211 167 151 47 95 190 204 24 53 138 50 50 198 198 198 198 0 178 178 222 189 123 247 206 247 239 140 141 33 15 14 34 191 121 147 154 154 154 10 96 181 238 219 183 111 31 128 217 140 209 141 211 233 116 58 157 220 197 164 164 164 164 164 164 240 142 30 141 41 26 162 34 36 125 222 218 218 218 218 218 186 57 31 8 147 2 252 11 254 252 121 108 220 220 188 105 179 81 47 1 0 192 237 70 166 242 54 193 123 188 93 56 157 200 212 185 163 203 3 164 28 139 5 21 59 63 159 151 151 151 199 51 120 202 95 200 242 233 214 134 90 173 86 171 213 0 5 5 104 8 212 104 194 222 53 99 241 241 88 150 111 105 105 105 105 105 241 157 136 125 119 5 84 85 85 85 85 85 1 172 172 96 63 97 120 120 120 120 120 24 224 236 89 180 188 195 135 113 193 106 53 250 210 236 108 124 79 169 68 166 139 186 177 177 200 235 235 200 148 129 83 147 200 106 69 54 153 144 39 38 144 205 102 180 204 175 95 177 217 111 183 163 32 221 238 141 190 157 92 9 9 158 174 201 40 149 104 56 121 121 168 168 96 27 77 223 77 1 53 53 53 53 53 53 60 69 39 223 73 241 51 221 134 166 123 67 106 53 250 80 165 18 21 146 144 128 28 19 131 174 64 34 193 121 36 160 213 85 20 144 219 141 205 127 151 11 227 113 167 19 125 51 250 126 128 165 37 100 250 93 239 219 26 222 97 36 89 50 29 178 222 151 7 130 69 216 206 128 198 198 198 198 198 70 94 27 33 11 162 219 16 116 237 132 158 219 108 232 138 72 160 4 242 169 228 131 105 231 16 211 124 239 247 8 36 96 98 50 0 239 142 29 9 156 124 249 183 175 193 132 14 97 107 149 80 84 64 32 11 162 123 64 219 45 202 161 229 49 70 190 217 229 194 90 19 237 24 234 59 144 34 72 224 164 96 186 22 67 150 78 130 239 236 236 236 236 236 220 237 197 65 17 34 68 136 16 17 137 248 23 96 111 227 207 148 31 36 213 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:58'!axialSymmetry	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 63 73 68 65 84 120 218 237 154 63 170 194 48 28 199 211 135 139 131 155 139 32 20 133 174 122 0 111 32 226 9 164 8 221 68 236 238 1 220 123 128 130 20 79 32 226 228 234 1 116 21 132 130 224 226 230 224 82 200 27 106 120 188 188 23 211 104 106 147 248 251 44 90 11 53 126 63 249 31 17 2 0 0 0 0 0 0 0 64 13 48 254 253 154 31 95 178 31 120 187 249 190 239 231 95 240 124 208 181 220 8 161 205 166 209 104 52 48 62 28 28 199 113 48 86 83 4 93 179 233 242 241 238 203 71 90 11 88 44 46 151 203 5 161 56 78 146 36 65 232 116 90 175 215 107 93 90 4 171 124 150 85 116 201 132 25 14 43 149 74 5 99 53 91 4 171 134 191 191 230 75 199 117 93 215 117 127 10 94 180 8 207 243 60 207 99 125 143 65 2 232 224 139 22 65 7 255 191 8 3 91 130 234 34 82 68 131 7 17 146 16 13 88 195 224 105 212 18 193 15 254 241 152 161 49 197 136 200 62 191 207 54 102 24 192 123 68 100 15 246 99 130 167 201 71 132 188 224 65 196 157 108 34 216 65 125 108 176 162 136 138 72 63 101 183 136 201 100 60 30 141 32 120 97 120 34 82 84 221 226 48 8 86 240 228 93 209 91 28 134 195 14 94 141 5 157 241 252 29 92 213 90 208 25 11 127 165 10 34 94 164 223 159 78 59 29 140 219 237 94 175 217 124 126 239 5 68 8 66 130 127 44 64 28 16 113 135 4 74 7 77 238 211 193 203 18 64 208 93 132 244 127 69 16 104 17 132 221 110 181 58 30 229 157 181 70 81 20 69 145 101 145 224 233 235 249 252 122 189 94 45 75 213 51 107 105 2 226 120 191 63 159 139 250 25 250 138 16 22 64 47 237 101 215 232 87 209 77 68 102 1 36 248 48 12 195 48 180 44 209 61 22 219 110 181 106 53 118 215 36 27 93 68 8 215 92 90 4 43 80 86 151 68 68 16 150 203 217 108 187 205 191 5 177 68 144 107 50 88 15 6 213 106 181 138 144 109 151 74 165 18 66 245 122 183 219 237 34 84 46 7 65 16 200 47 231 211 15 228 213 100 34 128 116 81 244 236 167 168 174 75 85 17 194 176 230 247 116 208 170 110 7 235 62 125 69 116 224 188 224 65 132 36 76 61 226 123 86 196 219 10 104 106 240 52 89 69 176 238 231 142 41 65 243 224 137 120 123 240 159 122 214 90 120 240 64 10 4 15 0 0 0 0 134 241 13 162 86 226 137 186 18 79 185 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:58'!centralSymmetry	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 3 73 68 65 84 120 218 237 154 209 141 194 48 12 134 233 233 150 224 9 137 1 96 0 86 64 44 209 55 132 24 128 1 24 0 33 222 186 4 98 5 6 128 1 144 120 98 140 242 148 67 245 93 206 73 157 196 105 251 127 47 149 64 77 157 223 142 237 90 29 141 0 0 0 0 16 128 186 110 94 121 190 180 77 238 7 238 130 83 190 181 77 239 6 54 129 139 66 186 178 120 129 97 224 27 225 238 142 65 10 82 6 14 32 148 101 89 150 37 141 120 121 170 1 12 84 248 191 29 65 187 28 238 10 188 9 35 188 187 35 112 180 254 197 53 146 77 138 242 79 93 168 1 34 138 162 121 98 140 224 168 25 129 176 167 20 191 154 161 78 119 138 22 39 172 155 240 116 223 106 248 26 16 202 96 127 199 74 133 207 204 17 210 7 182 189 95 126 178 252 132 77 165 71 54 15 226 4 110 239 128 237 118 179 89 175 67 11 207 235 18 168 90 211 46 32 22 241 102 50 105 236 254 109 143 176 13 77 37 124 87 225 245 105 233 128 248 194 119 123 38 19 77 159 248 197 164 219 51 153 104 207 75 223 207 166 158 201 104 233 195 28 145 92 114 124 232 153 12 183 158 235 126 229 250 244 100 22 20 106 38 147 78 120 71 114 121 179 147 206 100 220 215 107 167 135 162 0 177 8 59 10 176 237 199 117 159 217 204 116 252 13 90 173 118 187 197 162 174 231 243 229 114 58 229 239 139 59 147 233 28 237 35 194 8 239 235 0 67 207 133 253 129 249 46 200 94 100 140 160 147 201 108 54 30 127 126 63 159 247 251 235 245 115 223 243 121 191 191 94 238 6 153 153 204 225 112 60 158 78 159 226 90 85 85 85 85 218 221 88 120 90 111 200 230 0 138 113 192 237 118 185 60 30 253 19 80 138 184 13 245 141 112 208 196 217 1 52 7 35 162 195 192 58 128 230 96 223 98 104 82 148 41 198 218 27 206 13 231 8 166 142 176 9 106 75 73 92 177 30 42 222 2 112 145 76 139 46 109 63 145 186 154 136 63 79 167 17 111 4 238 123 251 168 134 137 104 122 53 255 15 229 5 42 57 3 31 9 232 1 225 51 1 66 43 17 247 123 25 0 0 0 0 0 37 222 28 134 87 22 39 202 104 13 0 0 0 0 73 69 78 68 174 66 96 130)  ! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:58'!circle	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 11 6 73 68 65 84 120 218 237 90 89 76 84 247 23 62 195 62 3 195 54 80 96 216 226 64 21 172 136 49 77 80 145 64 92 74 77 120 16 77 109 40 47 188 25 18 86 31 36 225 161 66 99 2 24 21 100 107 66 82 19 107 31 140 90 104 19 105 155 136 177 46 149 132 88 75 193 34 9 160 172 14 21 134 25 134 1 134 97 185 125 56 249 114 203 181 83 96 24 168 252 255 243 189 124 222 59 227 112 239 57 191 223 89 190 243 35 114 192 1 7 28 112 192 1 7 28 112 192 129 77 135 236 191 126 0 107 184 119 239 236 217 179 103 5 33 40 168 171 171 171 139 72 165 122 245 234 213 43 34 165 114 116 116 116 148 200 195 195 104 52 26 137 156 157 231 231 231 231 137 22 23 93 93 93 93 137 204 102 111 111 111 111 34 163 49 40 40 40 136 72 167 219 182 109 219 54 162 209 209 216 216 216 88 162 163 71 47 94 188 120 81 246 206 190 247 166 227 219 111 175 92 185 114 69 16 158 63 79 75 75 75 19 132 217 89 31 31 31 31 65 16 4 34 162 213 243 210 210 234 190 55 61 173 84 42 149 130 240 219 111 169 169 169 169 130 112 243 230 229 203 151 47 243 167 255 87 232 232 72 79 79 79 95 217 96 90 45 115 107 43 243 173 91 204 95 126 201 220 208 192 220 212 196 252 236 25 179 193 192 188 176 176 156 173 253 157 182 182 99 199 142 29 219 124 71 108 218 86 108 110 62 127 254 252 121 65 72 72 184 122 245 234 85 34 149 234 229 203 151 47 197 207 77 38 230 158 30 230 246 118 230 190 62 230 241 241 144 144 144 16 162 249 249 128 128 128 0 162 217 89 165 82 169 36 178 88 20 10 133 130 72 46 159 154 154 154 34 242 241 153 156 156 156 36 10 14 214 233 116 58 162 184 184 177 177 177 49 162 152 24 254 157 200 72 102 87 215 229 207 231 228 196 172 213 134 134 134 134 18 61 124 152 153 153 153 73 148 145 113 225 194 133 11 27 23 178 54 220 1 247 239 23 22 22 22 10 66 82 82 109 109 109 173 24 179 129 174 46 230 159 127 102 238 238 246 244 244 244 36 210 235 53 26 141 134 200 100 98 195 91 44 46 46 46 46 68 50 153 76 38 147 17 185 184 240 181 171 43 199 126 92 227 115 65 224 213 237 236 108 50 153 76 68 65 65 236 240 253 251 153 19 19 205 102 179 153 232 189 247 254 217 17 139 139 252 123 141 141 236 136 79 63 189 118 237 218 53 251 59 98 195 28 0 195 167 164 84 86 86 86 138 247 167 166 152 31 63 102 126 244 136 121 96 96 215 174 93 187 136 38 39 35 35 35 35 255 110 64 103 103 103 103 34 119 119 119 119 119 119 34 133 130 87 188 167 39 59 10 44 151 203 229 114 185 248 253 197 197 197 197 197 69 162 217 217 217 217 217 89 162 233 233 233 233 233 105 145 119 236 120 250 244 233 83 162 244 116 78 242 97 97 252 28 10 197 242 247 48 26 153 155 154 50 50 50 50 136 102 103 19 19 19 19 137 114 114 114 114 114 114 214 239 16 187 59 0 161 38 53 181 180 180 180 84 92 241 35 35 252 249 79 63 49 183 181 169 84 42 21 145 193 16 23 23 23 71 100 50 177 97 177 130 97 104 31 31 31 31 31 31 34 95 95 95 95 95 95 241 26 134 119 115 115 115 115 115 179 110 144 218 218 218 218 218 90 65 176 88 44 22 139 69 116 192 228 36 135 42 23 151 158 158 158 30 162 228 228 7 15 30 60 32 218 191 223 96 48 24 136 188 188 248 255 47 46 50 247 245 177 99 155 155 179 178 178 178 136 220 221 227 227 227 227 137 242 242 242 242 242 242 108 119 132 221 29 48 62 174 209 104 52 130 128 24 143 21 127 243 38 243 227 199 225 225 225 225 68 19 19 187 119 239 222 77 180 176 192 43 29 161 4 6 14 12 12 12 12 12 36 10 8 224 152 175 84 114 204 183 215 202 131 99 166 166 56 119 232 245 92 222 126 252 113 99 99 99 35 81 98 226 208 208 208 16 145 179 51 127 127 102 134 185 165 133 159 231 215 95 79 159 62 125 154 40 36 132 67 164 173 207 101 55 7 160 170 137 139 107 106 226 138 132 241 227 143 204 223 125 199 43 126 116 116 223 190 125 251 68 195 99 165 171 84 252 121 80 16 215 239 184 206 207 207 207 207 207 223 248 186 189 186 186 186 186 186 90 16 12 6 118 68 86 86 67 67 67 3 81 120 248 248 248 248 184 184 19 116 58 230 111 190 217 179 103 207 30 162 169 169 227 199 143 31 39 42 41 41 41 41 41 89 251 115 58 173 247 193 81 199 75 13 143 228 138 24 143 80 35 53 60 12 30 25 201 177 31 43 106 179 12 15 32 148 4 6 242 14 189 119 239 212 169 83 167 222 254 158 74 197 28 31 223 222 222 222 78 100 52 246 245 245 245 17 85 84 84 84 84 84 172 189 140 93 247 11 162 129 250 224 131 59 119 238 220 17 203 201 175 191 102 254 229 23 78 174 6 67 68 68 68 132 24 106 130 131 131 131 131 131 69 195 23 23 23 23 23 23 191 123 29 234 195 135 71 142 28 57 34 8 73 73 45 45 45 45 226 78 24 24 96 254 234 171 152 152 152 24 34 139 37 45 45 45 141 40 34 130 223 115 181 185 97 221 59 32 42 234 209 35 172 114 34 177 142 71 57 137 170 6 201 21 49 30 43 223 207 207 207 207 207 239 191 54 179 117 252 241 199 201 147 39 79 18 25 141 44 113 32 39 160 106 210 104 88 34 209 233 184 239 48 26 89 34 89 45 108 118 0 180 26 15 15 174 38 0 52 80 168 227 81 78 34 228 32 185 34 198 103 103 103 103 103 103 175 119 229 111 92 7 139 231 235 236 76 78 78 78 22 239 195 17 161 161 115 115 115 115 68 110 110 189 189 189 189 68 122 189 94 175 215 19 213 212 212 212 212 212 172 252 92 54 59 0 34 25 48 58 202 140 206 213 100 226 16 131 186 28 43 31 85 205 102 199 248 245 98 112 240 208 161 67 135 222 190 143 157 32 151 191 126 253 250 181 88 222 206 204 204 204 160 114 250 55 216 236 0 168 147 64 127 63 51 36 3 139 133 99 61 26 40 212 241 40 39 183 26 62 251 172 176 176 176 80 38 27 28 100 85 21 59 32 32 128 217 211 147 251 7 105 195 183 18 108 118 0 100 97 96 120 152 25 90 141 181 134 202 94 117 252 127 133 63 255 220 185 115 231 78 241 218 219 155 217 213 149 87 252 252 60 55 158 112 0 250 13 107 191 103 179 3 160 199 3 227 227 204 16 201 160 205 160 99 133 35 182 58 244 250 168 168 168 40 241 218 221 157 217 201 137 115 1 28 96 54 179 214 132 107 107 112 177 245 65 164 162 26 182 36 212 73 148 155 112 0 66 209 218 176 214 228 186 218 239 219 190 3 33 14 2 60 135 32 90 90 90 90 90 90 18 121 110 142 29 2 77 202 26 108 222 1 152 64 225 149 3 3 153 33 11 99 7 120 120 120 120 120 120 216 26 122 240 253 149 216 214 239 175 29 210 208 107 54 51 47 44 112 177 1 7 192 240 184 182 187 3 48 250 195 43 65 103 135 30 47 149 141 255 87 32 45 62 16 134 231 230 150 239 112 24 30 101 184 53 216 236 0 204 92 1 141 134 25 131 16 252 225 149 182 224 86 67 112 240 139 23 47 94 136 215 111 222 48 155 205 203 171 59 39 39 39 39 39 39 113 33 90 131 205 14 192 176 27 128 124 139 9 20 6 33 208 227 87 170 6 222 117 220 186 197 207 175 86 119 118 118 118 138 247 7 7 153 103 102 184 204 134 225 209 255 224 218 26 108 118 128 86 203 26 136 20 184 135 9 20 202 49 206 1 248 214 214 115 132 84 114 65 147 213 219 203 60 61 237 239 239 239 47 26 28 69 7 28 97 13 54 71 231 143 62 186 116 233 210 37 153 12 167 12 20 10 78 190 200 5 24 253 125 242 201 242 142 121 99 176 241 125 197 142 29 119 239 222 189 43 94 163 241 28 26 226 34 99 106 138 29 224 225 177 188 248 64 53 104 13 235 22 227 60 61 217 240 48 129 92 206 140 153 235 86 71 123 251 137 19 39 78 8 130 66 49 49 49 49 33 222 231 211 23 68 19 19 203 71 168 152 208 161 252 94 169 250 91 183 3 172 65 173 254 231 251 101 101 101 101 101 101 111 223 175 170 170 170 170 170 18 4 240 230 152 215 58 126 248 161 180 180 180 84 16 226 227 121 66 6 32 1 35 15 152 76 44 63 35 244 72 103 213 43 97 211 11 68 157 142 69 171 242 242 242 242 242 114 65 64 195 210 215 199 131 13 108 89 56 162 160 160 160 160 160 96 243 165 11 28 159 1 176 250 91 90 152 135 135 89 146 48 155 209 241 115 200 129 228 178 218 206 223 78 59 96 245 6 74 77 189 125 251 246 109 162 145 17 54 120 127 127 127 127 127 63 209 200 200 200 200 200 8 145 193 192 162 22 134 232 155 141 161 161 189 123 247 238 21 4 127 255 129 1 12 93 136 136 248 96 24 81 71 7 107 93 147 147 92 5 98 229 123 121 121 121 121 121 137 162 99 110 110 110 110 110 238 38 12 100 214 138 163 71 181 90 173 150 40 47 239 198 141 27 55 136 148 202 238 238 238 110 209 224 136 161 43 37 47 123 1 161 70 167 139 140 140 140 20 132 176 176 103 207 16 223 137 136 158 60 97 190 127 159 171 25 131 129 39 124 136 249 8 53 144 217 177 3 86 11 59 133 160 181 199 236 247 223 231 228 45 8 173 173 173 173 68 215 175 71 71 71 71 19 117 116 112 121 107 155 118 180 122 32 185 198 199 159 59 119 238 220 219 159 195 240 223 127 207 60 50 146 144 144 144 64 52 51 195 161 5 11 5 131 37 12 154 214 122 76 101 195 39 81 159 127 126 224 192 129 3 68 95 124 241 228 9 94 138 136 136 207 106 138 64 173 172 215 243 138 122 254 60 37 37 37 133 104 104 232 240 225 195 135 137 50 51 207 156 57 115 102 237 185 0 13 20 234 120 148 147 210 170 6 255 70 168 193 138 135 225 141 70 14 45 168 235 177 226 49 211 182 245 84 196 134 37 225 186 186 186 186 186 58 162 158 30 62 248 68 196 14 184 126 157 147 149 78 199 101 42 78 25 64 174 240 243 227 198 45 41 169 185 185 185 153 136 136 249 224 193 216 216 216 88 65 128 30 15 89 24 234 36 68 50 104 53 144 12 212 234 191 55 128 111 3 85 13 146 43 98 60 66 13 86 60 12 143 25 182 90 173 86 171 213 162 35 108 197 6 237 0 153 172 190 190 190 190 190 94 16 6 6 56 153 117 117 113 67 166 213 114 14 56 120 144 147 111 90 26 159 187 129 172 129 17 159 180 123 252 183 110 114 53 64 231 138 6 10 113 30 229 36 170 26 36 87 105 93 47 53 60 14 21 172 247 100 220 58 119 128 245 63 140 83 2 99 99 172 13 45 44 44 44 44 44 136 73 171 173 109 251 246 237 219 137 126 255 157 87 112 116 52 151 167 31 126 200 106 106 68 4 127 31 14 193 42 195 4 10 249 1 82 47 154 62 168 147 16 201 160 213 64 50 64 231 138 6 10 117 252 220 28 39 125 188 17 170 26 233 129 49 172 248 119 246 108 104 101 101 101 101 101 165 32 32 244 12 15 15 15 15 15 139 19 34 233 17 68 172 52 56 10 125 65 68 4 139 121 1 1 236 16 79 79 102 55 55 30 253 97 2 5 217 23 122 60 100 97 168 147 16 201 160 213 64 50 192 223 69 25 9 233 0 51 107 105 114 45 42 42 42 42 42 178 127 63 98 247 28 128 17 28 84 80 200 209 120 65 188 80 88 88 88 88 88 152 24 91 113 95 58 192 48 153 248 119 222 188 89 62 115 5 75 39 81 82 192 192 96 185 156 23 128 116 98 135 5 129 80 227 237 205 243 142 245 134 152 77 119 0 98 38 26 18 0 199 199 113 244 16 91 25 231 110 164 114 53 12 106 237 120 57 118 148 116 244 135 255 39 149 133 81 214 98 33 72 37 3 116 174 171 109 160 236 133 13 251 67 144 18 208 96 97 197 21 22 242 241 14 91 127 23 142 66 78 1 75 39 80 24 132 192 17 152 204 129 183 250 233 12 7 28 112 192 1 59 224 47 137 64 226 59 103 178 13 148 0 0 0 0 73 69 78 68 174 66 96 130) ! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:59'!coordinates	^self formFromGraphic:  #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 14 73 68 65 84 120 218 237 154 193 21 194 32 12 134 169 207 17 220 194 33 28 192 147 87 174 234 115 130 78 209 21 60 115 245 228 0 14 225 22 238 80 79 60 159 244 97 8 80 146 216 124 151 190 182 208 134 252 16 82 168 49 138 162 40 82 25 71 106 11 164 211 229 85 139 57 190 203 124 222 114 65 58 44 181 199 171 16 141 208 16 84 202 138 218 128 165 179 198 21 215 30 207 12 21 164 20 13 65 196 168 0 196 44 116 14 8 219 65 151 54 35 71 128 55 84 106 158 207 175 3 77 4 216 239 251 126 183 227 103 104 26 222 238 240 200 151 232 8 240 66 200 22 196 195 119 233 100 98 0 228 240 211 105 24 94 47 106 179 167 28 14 198 60 159 232 230 119 214 90 107 237 56 58 231 156 115 211 243 230 13 9 123 254 111 65 184 142 140 88 40 250 28 189 163 125 141 240 156 12 92 200 97 96 240 79 187 4 11 129 107 40 23 210 29 31 30 133 56 158 107 150 145 234 232 105 121 33 142 135 26 78 13 236 120 239 232 219 205 152 237 86 124 232 9 27 78 13 236 120 127 238 5 136 221 23 38 4 95 67 99 142 21 62 2 184 206 1 31 32 199 66 35 64 24 124 13 135 70 0 181 125 149 224 215 144 203 229 124 62 30 211 71 128 112 228 53 132 155 0 11 221 15 224 195 194 246 3 248 161 91 146 196 8 21 0 10 133 165 161 178 221 234 47 82 128 212 252 191 118 185 176 124 44 4 66 247 75 159 239 175 215 19 98 230 57 32 102 48 214 81 212 142 79 109 23 158 70 33 40 52 184 246 36 30 62 31 235 152 210 250 100 96 99 101 110 108 205 189 159 122 125 46 187 96 26 127 7 104 250 90 153 90 217 66 173 45 80 40 132 64 107 65 216 228 161 156 153 230 0 108 79 175 53 249 65 73 2 244 30 168 126 234 28 150 46 144 208 239 0 170 80 134 125 47 44 196 58 183 98 89 121 46 180 178 59 62 114 34 2 148 230 231 165 121 251 191 220 135 253 41 52 4 229 115 189 246 253 102 211 234 109 112 71 46 84 112 174 15 171 250 196 126 56 187 223 135 225 241 96 243 123 122 232 208 250 107 31 202 55 127 31 130 160 95 45 153 254 253 45 110 77 68 81 242 120 3 185 219 205 252 208 44 95 233 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/22/2006 10:37'!createAndMove	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 6 0 0 0 224 119 61 248 0 0 0 9 112 72 89 115 0 0 11 18 0 0 11 18 1 210 221 126 252 0 0 3 152 73 68 65 84 72 199 181 150 111 76 155 85 20 198 127 183 45 157 64 9 89 72 216 194 212 18 144 66 178 4 54 162 4 170 147 15 68 81 214 26 23 18 135 113 115 24 13 146 169 153 201 18 12 81 99 244 203 20 17 93 92 182 15 203 134 154 105 130 75 220 146 206 40 206 178 17 54 33 197 132 145 77 201 168 150 117 98 97 64 11 133 240 167 127 222 30 63 16 154 17 186 63 17 56 95 222 188 231 189 247 62 247 156 231 62 247 121 149 136 8 235 24 58 214 57 12 171 153 124 163 194 188 236 61 219 233 93 251 10 178 157 222 132 11 175 25 64 83 83 19 74 41 46 5 22 18 15 144 251 8 64 18 13 181 150 149 198 243 214 178 210 132 115 87 112 160 148 90 2 6 192 110 183 211 213 241 13 67 158 97 148 82 136 8 74 41 182 109 43 162 175 239 10 197 197 197 0 164 164 154 120 220 90 22 95 231 242 111 221 43 43 0 228 187 83 159 201 192 181 159 226 59 3 228 214 205 11 210 223 115 58 158 123 181 246 121 25 245 58 197 102 179 73 67 67 131 136 136 52 54 54 138 136 72 77 77 141 12 14 14 198 43 90 193 65 118 246 131 232 245 58 234 234 234 226 185 152 166 33 154 6 128 217 108 102 239 238 103 24 241 141 210 217 217 73 85 85 21 0 149 149 149 0 212 215 215 223 153 100 17 225 248 241 54 50 50 54 242 70 221 206 120 187 208 4 137 45 2 60 105 221 202 35 57 89 56 157 61 24 141 70 154 155 155 201 207 51 83 94 94 14 16 127 222 241 20 181 126 253 3 63 183 119 145 102 50 113 244 139 247 151 241 1 80 251 226 179 104 225 8 151 187 175 16 12 6 41 45 202 162 227 220 49 242 243 22 53 225 114 185 238 14 32 34 156 56 121 142 52 83 10 59 118 60 122 251 7 0 242 114 178 184 229 27 227 204 143 93 188 190 207 198 158 93 21 124 220 210 138 165 160 16 151 203 69 110 110 110 98 0 165 20 118 187 29 0 103 71 7 215 7 135 216 148 153 193 168 247 34 74 167 72 51 165 114 179 255 12 177 72 20 145 197 118 29 124 173 26 223 200 56 191 116 184 112 56 28 148 148 148 36 22 154 82 138 192 120 47 219 139 30 142 131 52 127 126 2 4 174 94 29 68 161 103 120 100 10 148 14 68 72 75 125 128 191 46 181 226 247 7 57 223 217 139 165 160 16 0 191 223 127 119 37 191 125 224 21 172 37 249 216 237 118 206 58 156 40 93 18 55 134 103 209 27 146 233 31 248 7 141 36 46 254 254 47 161 185 8 11 179 33 66 209 8 223 158 189 64 75 75 11 110 183 155 64 32 64 32 16 160 189 189 125 249 101 183 36 30 255 88 47 213 187 42 49 110 48 208 221 221 141 94 103 36 197 148 206 184 127 146 212 180 141 16 213 8 71 21 198 13 41 76 79 5 112 252 218 131 165 160 144 218 125 47 175 216 249 146 208 12 183 147 123 244 200 135 236 174 174 226 233 138 39 120 110 231 83 8 26 254 137 49 98 209 116 82 146 147 153 14 78 176 48 59 201 223 158 25 68 9 159 28 105 227 94 118 178 172 69 251 223 252 128 119 222 253 148 172 45 155 144 152 70 76 34 20 109 125 136 140 140 116 54 111 206 36 18 137 226 243 186 65 193 87 109 231 177 217 108 247 188 12 85 34 71 203 201 201 225 212 201 67 88 44 102 36 166 161 133 66 12 251 102 144 249 49 194 161 57 220 67 195 28 250 242 123 174 187 189 255 207 209 60 30 15 47 188 116 0 127 96 10 4 20 138 45 153 201 40 3 204 204 206 163 79 210 175 222 50 183 23 63 70 56 28 1 5 162 19 68 52 230 230 34 204 135 163 24 12 134 248 209 92 149 101 94 27 112 19 156 206 68 162 81 36 18 101 98 114 134 254 63 61 8 178 54 166 239 243 141 177 255 173 143 64 167 136 41 56 248 222 97 14 31 59 77 223 31 19 56 28 142 251 2 80 235 253 219 242 31 185 225 254 15 195 173 162 18 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/22/2006 10:36'!createMultiple	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 18 0 0 11 18 1 210 221 126 252 0 0 1 56 73 68 65 84 56 203 205 84 193 74 195 64 16 125 43 57 169 151 176 224 41 164 129 37 119 9 4 154 4 9 84 66 32 247 254 67 126 163 183 146 175 80 193 143 232 161 55 211 210 222 60 26 3 181 244 28 207 222 198 195 74 12 177 45 155 26 196 119 88 134 217 157 199 188 97 246 49 34 66 31 56 67 79 208 58 189 126 187 29 212 177 53 223 254 170 35 107 190 109 81 156 72 148 101 25 99 236 233 253 163 125 65 93 224 123 67 89 226 123 195 214 149 118 68 118 11 129 239 229 139 165 227 56 0 206 47 46 3 223 147 249 124 177 252 146 118 72 246 94 68 81 4 192 117 221 124 177 52 7 214 221 253 131 100 84 157 81 224 123 47 197 43 128 36 73 0 196 113 12 32 77 211 239 23 155 145 249 124 99 60 94 95 109 70 230 145 209 148 101 249 115 46 68 84 20 133 204 67 101 192 187 221 142 136 38 147 9 17 173 86 171 230 89 19 41 73 51 12 3 64 24 134 0 116 93 7 32 132 88 175 215 66 136 83 54 91 18 217 182 13 128 115 206 57 175 170 170 219 66 54 11 14 37 149 58 154 78 167 227 241 88 138 106 97 54 155 201 128 169 216 72 189 123 123 33 23 146 245 229 71 154 186 81 116 54 182 78 63 230 79 28 178 169 78 29 236 223 153 127 111 68 159 143 145 6 176 10 10 137 148 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:59'!distance		^self formFromGraphic:  #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 212 73 68 65 84 120 218 237 153 59 170 2 49 24 133 227 221 128 133 165 157 149 224 62 132 108 69 16 23 32 86 174 64 132 244 46 65 16 2 22 130 59 176 180 16 5 221 132 221 88 92 66 32 26 50 143 252 127 226 120 190 102 8 153 201 227 156 147 76 116 132 0 32 62 69 145 122 4 64 8 1 35 178 1 70 100 2 140 96 194 8 237 94 221 122 64 140 207 0 183 30 68 166 106 226 91 99 68 217 137 134 146 73 213 63 245 243 201 169 187 212 115 19 142 207 136 63 174 142 104 48 66 117 58 113 219 53 237 209 27 241 165 6 80 9 111 219 223 239 215 235 201 196 237 47 62 145 39 16 18 198 55 145 178 66 114 11 111 25 143 167 83 165 170 142 183 53 80 111 5 70 120 123 56 48 229 251 253 112 232 247 237 53 246 120 50 223 130 248 19 175 148 82 74 217 196 239 118 231 243 124 110 235 255 141 112 199 215 58 210 37 254 115 255 118 5 28 143 155 77 175 87 20 171 213 98 49 24 52 95 17 153 173 0 254 196 155 242 112 56 26 109 183 118 5 152 251 77 249 118 123 60 158 79 33 78 167 203 165 219 21 98 54 91 46 175 87 115 223 215 191 19 242 217 227 221 107 40 241 82 74 41 101 253 241 39 118 46 221 169 198 36 222 71 40 241 70 120 173 181 214 250 189 156 82 213 82 194 80 183 207 149 248 47 91 1 72 124 34 144 120 31 1 231 154 38 22 137 143 54 209 106 245 72 124 89 42 58 233 75 180 59 64 36 158 24 95 226 233 62 180 180 37 241 46 13 157 197 30 159 9 72 124 93 152 191 7 132 159 71 226 163 80 53 81 191 147 120 23 98 231 195 95 200 144 120 22 222 79 77 191 154 120 23 246 255 130 144 248 36 32 241 62 200 223 1 72 124 18 144 248 178 68 255 29 128 196 103 1 18 207 206 103 97 32 60 59 33 35 32 60 19 62 35 32 60 51 62 35 124 245 16 158 136 144 208 16 158 9 8 159 9 16 30 0 0 146 243 2 254 23 48 217 74 149 99 100 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/22/2006 10:35'!editGroup	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 1 41 73 68 65 84 56 203 173 149 49 110 132 48 16 69 191 131 197 5 182 163 247 17 246 12 72 78 144 184 4 72 73 15 21 169 178 29 37 82 34 238 177 65 162 65 162 206 17 124 3 76 68 109 26 82 16 33 194 238 26 47 97 42 100 164 55 223 255 15 3 25 134 1 123 20 5 240 248 252 70 8 217 140 24 134 225 243 227 149 2 32 132 156 223 147 205 160 167 151 19 128 7 236 84 116 122 10 195 176 105 154 190 239 167 19 203 178 28 199 201 243 252 62 144 148 50 77 83 198 216 116 34 132 136 162 232 110 69 74 169 57 5 0 99 108 18 24 4 129 148 82 163 151 26 54 108 219 86 175 215 212 108 189 222 61 83 187 9 170 170 202 247 125 0 156 115 206 57 0 207 243 202 178 92 55 123 81 89 150 93 53 197 117 221 21 69 182 109 11 33 204 77 185 162 104 252 62 186 174 139 227 88 41 245 223 201 174 235 122 254 98 244 69 83 66 8 74 233 31 208 33 57 126 159 190 12 59 79 13 40 165 243 157 241 139 52 103 21 69 177 98 246 33 57 238 54 71 115 214 34 196 75 83 116 115 52 191 221 101 136 11 83 110 130 22 30 45 66 52 189 154 121 106 58 69 35 101 92 189 219 150 63 0 178 215 239 232 7 171 231 143 35 141 123 83 50 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 18:59'!eraser	^self formFromGraphic:  #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 9 239 73 68 65 84 120 218 237 90 91 76 92 85 27 93 231 54 55 152 2 214 182 64 165 23 27 72 109 129 137 144 106 133 146 42 84 45 137 6 155 246 129 55 83 245 193 7 180 49 26 77 154 152 244 197 24 19 125 52 49 233 19 154 152 38 53 40 15 42 38 26 172 166 25 40 49 150 166 173 45 246 70 129 82 58 148 12 12 157 203 185 109 31 190 255 251 247 204 80 34 197 78 161 237 172 4 14 251 156 189 55 103 214 218 123 125 223 222 123 128 60 242 200 35 143 60 242 200 35 143 60 242 200 35 143 60 242 120 152 160 44 245 11 204 135 221 187 119 239 126 249 101 33 250 250 250 250 126 255 125 169 223 6 136 70 163 209 104 84 185 235 124 45 59 1 246 236 217 179 103 223 62 33 82 41 211 92 181 10 168 174 174 174 110 110 6 132 160 31 134 101 89 150 227 0 66 184 174 101 1 182 237 186 174 11 56 142 109 11 1 40 138 108 67 127 187 174 227 200 246 174 75 189 101 223 87 20 69 81 20 192 113 132 72 165 128 174 174 163 71 63 252 48 119 2 168 75 77 56 163 181 181 181 181 181 85 136 222 222 222 222 159 127 6 170 171 107 106 154 155 1 215 101 98 29 199 113 0 203 178 109 38 222 113 232 190 16 146 120 215 117 28 219 166 50 61 183 109 203 146 253 240 53 155 120 134 16 66 8 1 12 14 254 249 231 79 63 229 254 115 47 185 0 7 14 28 56 112 224 128 16 225 112 56 28 14 3 29 29 111 191 221 217 121 59 98 120 36 19 65 92 6 84 85 85 1 85 165 146 162 168 170 166 205 157 49 11 197 216 216 216 216 153 51 192 35 143 148 148 148 151 231 254 243 47 185 0 157 157 157 157 157 157 192 59 239 188 247 222 215 95 203 251 76 164 162 48 181 124 63 243 135 159 26 134 97 80 125 178 16 85 101 97 52 77 215 101 125 22 48 27 60 51 38 39 35 145 75 151 128 141 27 55 109 218 182 237 1 22 160 184 184 184 184 184 88 136 215 94 123 253 245 79 62 1 52 77 81 104 84 51 129 153 126 75 116 166 11 65 53 52 77 211 52 77 122 186 166 209 125 238 135 173 198 117 133 112 221 249 223 103 116 116 100 164 175 15 168 168 168 168 168 173 5 10 11 11 10 124 190 220 243 160 223 107 226 219 219 219 219 219 219 133 16 66 81 54 108 0 86 174 124 244 209 245 235 165 151 43 10 224 186 146 64 121 117 93 46 3 233 22 67 191 229 172 96 233 92 151 37 35 226 89 80 110 37 132 162 0 211 211 211 211 99 99 192 173 91 241 120 44 6 212 214 214 214 110 221 10 152 166 101 217 118 238 249 184 103 51 160 163 163 163 163 163 67 136 158 158 158 158 158 30 250 160 207 62 75 65 147 9 33 106 136 182 116 139 73 31 251 60 19 88 24 38 54 187 44 99 2 205 16 69 81 20 77 227 62 164 48 103 207 158 57 211 211 3 212 215 215 215 191 248 34 160 105 186 174 40 148 101 89 214 3 36 192 241 227 199 143 159 58 5 116 116 188 245 214 225 195 233 132 18 45 76 180 28 201 154 150 62 162 165 167 83 59 69 33 193 164 101 105 26 181 167 145 205 245 185 63 182 42 77 211 117 77 3 70 70 174 94 253 227 15 96 211 166 202 202 167 159 6 130 193 96 176 168 8 72 36 18 9 203 2 226 241 120 124 102 230 1 16 32 20 10 133 154 155 133 216 177 163 169 169 189 29 240 251 3 129 96 48 189 70 118 72 36 33 152 64 77 35 33 184 156 253 92 8 114 255 249 130 43 11 195 87 33 92 55 149 2 70 71 71 71 79 159 6 182 108 121 226 137 237 219 1 211 52 77 74 79 169 159 104 52 26 189 113 227 62 22 96 255 254 253 251 247 239 23 162 170 170 170 170 174 14 40 45 45 43 123 252 241 219 213 204 14 182 50 185 164 17 76 115 68 215 117 157 5 97 43 161 214 50 216 210 58 128 130 45 7 101 238 207 227 209 117 93 7 6 7 7 7 127 252 17 216 182 237 169 167 218 218 50 179 38 0 176 109 219 118 93 224 216 177 95 127 253 226 11 160 178 178 178 178 178 242 62 20 224 220 185 243 231 35 17 160 166 38 20 106 105 89 192 139 252 143 0 182 34 190 74 194 217 162 50 45 137 5 20 130 131 181 140 10 220 175 174 3 215 174 141 141 157 61 11 20 20 20 20 20 21 1 171 87 175 94 189 110 29 165 159 0 144 74 165 82 150 37 189 127 235 214 234 234 93 187 128 129 129 129 129 129 129 187 191 2 206 153 0 85 85 85 85 79 62 41 68 75 75 75 203 171 175 74 11 89 240 11 169 183 15 194 210 146 200 195 179 211 80 77 203 204 154 120 228 235 58 89 207 185 115 231 206 253 242 11 80 87 87 87 183 107 151 252 127 108 57 241 120 60 110 154 192 55 223 28 61 250 193 7 192 198 141 27 54 20 20 0 109 109 109 109 109 109 139 89 210 45 12 119 45 13 13 133 66 161 29 59 132 104 104 104 108 220 183 239 118 94 255 111 200 76 19 21 133 214 5 236 236 186 78 22 98 219 182 109 219 153 158 158 30 140 53 205 48 12 67 182 159 152 24 31 63 127 30 88 183 110 253 250 80 136 250 241 120 0 219 182 44 215 5 18 137 100 50 149 154 155 245 196 98 177 88 52 10 116 119 119 119 119 119 47 227 25 208 212 212 212 244 202 43 66 212 214 134 66 205 205 192 99 143 85 84 108 222 44 159 115 126 47 61 250 118 59 48 115 133 72 183 154 244 167 60 163 116 157 102 134 174 27 70 250 125 190 222 184 49 49 113 225 2 112 226 196 137 19 93 93 64 77 77 77 77 99 163 220 196 75 165 76 211 178 164 245 124 251 109 87 215 193 131 192 206 157 59 119 238 220 41 137 207 245 12 88 180 178 188 146 205 213 139 253 87 172 89 179 102 77 105 41 176 121 243 230 205 47 188 64 155 123 13 13 68 184 227 208 194 43 149 2 174 95 31 31 31 26 2 188 94 143 103 108 12 56 114 228 200 145 175 190 146 196 231 122 6 252 103 11 234 237 125 243 205 131 7 129 217 217 120 60 30 151 158 204 150 192 150 33 199 62 239 241 240 182 175 101 153 102 122 90 73 121 188 162 144 197 112 62 147 93 214 52 42 235 58 197 4 85 165 25 243 238 187 199 143 255 240 3 112 242 228 153 51 167 79 3 207 61 215 210 82 83 35 131 173 244 252 217 217 217 89 224 242 229 75 151 194 97 224 228 201 147 39 143 29 155 75 252 161 67 135 14 29 58 36 4 93 239 190 16 119 44 0 143 252 149 43 11 11 131 65 242 202 217 89 73 168 105 90 86 50 9 88 150 227 88 150 36 84 85 105 133 169 235 114 43 64 8 18 136 77 201 178 136 88 195 0 52 77 8 190 79 2 8 145 105 70 170 74 94 79 105 231 244 116 42 101 154 192 216 216 196 196 245 235 178 150 207 231 245 122 60 210 202 226 241 68 194 52 129 161 161 191 255 254 237 183 249 137 231 114 174 136 95 180 0 140 206 206 189 123 223 120 99 238 72 54 12 195 208 117 32 16 8 4 252 126 34 138 151 246 142 3 24 6 237 78 186 46 29 164 56 14 187 120 230 246 155 16 142 147 190 48 50 12 175 151 219 1 233 231 3 212 239 151 95 14 14 246 247 3 229 229 229 229 229 229 64 36 50 57 57 57 73 239 99 24 178 221 236 108 44 54 53 5 248 253 62 159 162 200 44 39 155 248 92 91 15 99 209 65 152 211 62 30 149 193 96 48 88 88 40 137 103 139 160 92 132 136 231 116 146 218 19 49 154 70 130 249 124 62 159 199 3 148 148 172 88 177 98 5 80 82 82 84 84 84 4 20 23 83 57 24 244 251 3 1 96 197 138 194 194 64 0 8 4 168 126 32 16 8 4 2 64 56 124 241 226 249 243 192 199 31 63 255 252 222 189 233 66 146 101 205 204 204 204 196 227 192 240 240 240 240 224 32 189 175 105 206 13 182 217 214 147 107 1 22 60 3 216 122 250 251 223 127 255 163 143 0 219 166 244 205 113 40 157 99 41 88 16 199 81 85 215 165 160 103 154 116 196 7 0 94 111 230 74 214 182 229 238 165 109 147 69 80 44 201 76 43 29 135 44 200 227 161 25 164 170 126 191 174 3 87 174 68 163 55 111 210 127 86 20 160 162 98 237 218 244 131 148 100 210 52 77 19 152 154 154 154 154 156 36 65 98 177 249 137 191 87 214 115 199 2 52 54 110 223 254 204 51 64 48 232 245 22 20 0 138 226 243 21 22 206 221 26 96 200 147 43 69 73 183 18 0 184 93 125 18 13 176 109 211 164 35 71 110 79 87 185 25 199 91 20 36 208 247 223 247 247 247 246 2 189 189 159 125 246 249 231 128 235 70 163 177 88 186 0 228 249 87 174 92 190 124 226 4 16 14 135 195 223 125 55 63 241 247 202 122 238 88 128 210 82 211 36 34 2 1 159 15 112 28 191 223 48 36 65 138 66 158 205 87 41 4 121 53 91 145 244 122 185 128 250 255 203 232 228 245 148 5 81 16 230 45 6 106 153 254 70 20 188 7 6 134 135 47 92 0 20 133 118 49 45 107 122 122 118 86 214 26 31 191 118 237 175 191 128 181 107 43 42 54 110 4 218 218 86 175 94 14 196 51 22 28 3 182 108 41 45 173 168 32 66 57 173 164 223 68 168 227 144 199 243 209 158 116 123 143 199 235 5 92 151 60 219 117 41 109 116 93 143 71 215 1 199 49 12 143 71 182 119 28 154 31 150 69 177 193 113 232 234 186 30 15 157 245 82 48 22 194 239 247 122 129 161 161 241 241 209 81 192 52 147 201 68 2 152 152 32 171 97 68 34 145 200 197 139 128 101 165 82 67 67 75 239 249 217 88 240 12 176 109 202 227 109 155 22 48 201 228 212 212 244 52 61 35 139 161 145 234 186 84 143 13 71 211 232 32 132 211 80 222 163 231 153 160 170 180 53 144 157 231 243 186 129 251 179 109 90 185 242 174 102 60 78 49 163 189 189 190 190 161 1 184 121 115 98 226 198 13 96 102 38 22 75 183 160 178 178 178 50 85 93 62 158 191 104 1 70 70 110 222 140 68 104 223 60 145 144 249 59 125 101 132 238 155 38 144 76 38 147 201 36 221 231 44 136 199 149 16 128 174 123 60 134 33 133 224 249 194 66 102 30 35 146 240 188 14 224 5 89 122 12 73 36 40 200 143 143 15 15 95 189 10 148 148 148 148 148 148 200 231 255 70 252 82 89 207 29 11 224 243 145 149 156 58 53 58 58 50 2 172 90 101 24 100 45 252 61 155 204 19 42 199 225 163 196 116 138 129 84 138 206 90 169 13 45 184 210 219 101 7 95 69 161 172 135 173 143 131 176 215 75 11 172 91 183 82 169 68 2 8 4 10 11 11 10 128 151 94 58 124 248 211 79 229 23 169 150 43 241 140 59 126 129 229 190 7 180 80 226 115 189 197 144 51 100 239 14 222 239 229 251 22 75 77 220 67 75 124 54 150 154 200 135 150 248 60 242 200 35 143 60 242 200 35 143 60 242 88 60 254 1 118 124 0 146 139 47 157 2 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:02'!freePoint	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 0 174 73 68 65 84 120 218 237 215 65 10 131 48 16 5 80 45 61 128 11 23 222 255 162 118 81 178 104 48 104 19 219 76 224 189 141 8 46 134 255 157 160 211 4 0 0 0 0 0 0 192 177 125 255 188 142 231 209 123 128 58 227 6 158 123 246 30 224 88 41 224 121 238 61 217 221 6 219 128 111 139 201 159 143 183 57 131 21 112 85 10 58 21 147 223 199 17 180 128 214 160 74 193 219 128 31 41 29 53 241 55 32 220 64 111 173 111 106 252 224 147 96 27 112 53 248 82 160 227 28 61 73 176 2 206 212 6 31 191 136 32 242 63 219 82 96 103 159 151 241 63 63 7 213 26 188 34 110 34 216 191 219 182 117 93 22 193 3 0 0 0 0 64 133 23 160 158 76 100 195 246 158 5 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 16:09'!grid  ^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 0 48 73 68 65 84 56 203 99 252 255 255 63 3 53 0 19 3 149 0 212 32 70 70 70 100 81 50 184 140 131 213 107 163 129 61 26 216 163 129 61 26 216 163 129 77 187 192 6 0 194 118 18 100 92 224 214 144 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/21/2006 16:10'!gridMagnet  ^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 1 2 73 68 65 84 56 203 99 252 255 255 63 3 53 0 19 3 149 0 212 32 70 70 70 100 81 50 184 140 131 213 107 131 200 32 22 120 128 161 5 214 235 215 175 25 24 24 126 109 110 254 243 225 5 166 182 47 151 95 104 207 63 132 172 23 123 96 223 190 125 251 229 139 231 12 12 12 255 67 195 112 57 65 192 90 78 119 237 41 116 23 161 129 151 47 158 159 58 121 156 129 129 65 245 223 63 44 70 48 49 49 48 48 124 56 250 104 159 165 186 211 241 155 80 119 145 17 253 135 37 36 32 140 15 255 254 249 190 122 69 126 96 219 190 120 193 38 206 67 157 148 205 165 34 132 38 11 53 8 205 131 4 185 76 124 28 104 178 3 154 32 175 38 218 125 57 247 12 123 130 196 4 175 95 191 254 251 247 239 223 109 109 104 9 242 199 253 55 191 158 124 248 245 242 11 3 3 3 60 202 112 166 236 219 183 111 223 186 113 133 129 129 129 175 106 21 46 155 62 192 146 24 68 47 11 214 224 124 249 226 249 205 155 183 112 37 72 52 183 64 244 14 255 242 104 16 149 217 0 164 159 137 204 211 219 129 157 0 0 0 0 73 69 78 68 174 66 96 130) ! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/22/2006 10:35'!group	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 1 13 73 68 65 84 56 203 173 85 65 106 133 48 20 156 212 224 33 220 231 44 66 90 193 75 40 180 123 93 181 171 118 231 82 104 241 30 173 224 70 240 28 185 129 17 92 199 77 186 248 16 196 95 53 166 153 85 120 129 121 147 153 199 11 209 90 195 7 40 128 199 231 119 66 136 51 133 214 250 231 235 141 2 32 132 124 127 190 58 19 61 189 124 0 120 128 39 80 115 202 243 124 28 199 101 89 76 37 8 130 40 138 154 166 185 70 36 165 172 170 138 49 102 42 66 136 162 40 46 43 82 74 173 89 0 48 198 140 192 44 203 164 148 7 122 169 101 195 105 154 142 245 218 154 125 172 215 103 106 187 68 125 223 167 105 10 128 115 206 57 7 144 36 73 215 117 231 102 111 80 215 245 159 166 196 113 124 162 40 12 67 33 132 189 41 187 138 230 121 46 203 82 41 245 223 201 30 134 97 125 113 243 229 0 66 8 74 233 185 71 123 48 13 40 165 235 157 113 153 168 109 219 107 241 123 155 163 77 136 247 166 216 206 209 125 136 27 83 108 137 54 33 186 63 205 101 142 180 214 183 189 235 188 252 1 16 95 223 209 47 26 227 127 226 181 183 68 199 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:03'!intersection	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 11 48 73 68 65 84 120 218 237 91 91 76 84 231 22 94 123 102 24 174 51 80 112 0 47 132 80 165 197 20 4 163 216 24 19 53 68 171 181 1 155 244 73 49 177 16 105 26 193 32 134 6 212 86 130 137 138 66 50 76 100 30 154 84 211 135 19 209 135 182 52 37 16 155 166 218 23 99 172 161 42 180 160 92 172 145 84 164 168 204 48 195 48 215 125 30 214 249 206 150 61 103 156 97 152 1 60 229 123 217 217 123 246 236 203 250 254 127 253 107 125 107 109 162 69 252 147 32 138 243 253 4 11 13 138 249 126 128 127 58 22 9 152 103 44 18 48 207 152 49 1 54 91 101 101 101 101 160 190 28 231 201 207 247 117 124 17 62 241 211 79 25 25 25 25 162 216 223 159 153 153 153 41 138 179 35 98 209 240 128 16 232 137 31 127 172 209 104 52 162 184 111 223 146 37 75 150 16 165 167 171 84 42 21 209 138 21 187 118 237 218 69 20 29 109 48 24 12 130 143 235 249 50 184 224 243 254 63 252 112 246 236 217 179 162 168 213 62 125 250 244 41 81 92 220 179 103 207 158 17 69 69 77 76 76 76 16 69 68 76 77 77 77 17 41 20 110 183 219 77 228 241 40 149 74 37 145 211 25 21 21 21 69 100 179 105 52 26 13 145 197 146 152 152 152 72 100 54 167 166 166 166 18 21 21 213 212 212 212 8 1 191 247 130 33 32 180 68 120 255 254 203 47 71 142 28 57 34 138 201 201 131 131 131 131 146 129 67 13 135 35 50 50 50 146 104 100 36 35 35 35 131 168 160 224 85 207 27 126 4 124 227 61 123 246 236 217 179 71 20 91 91 91 91 91 91 5 97 118 68 0 210 204 24 24 216 177 99 199 14 239 51 94 188 224 17 254 244 169 203 229 114 17 141 141 241 214 100 242 120 60 30 34 149 138 207 211 106 21 10 133 130 40 37 133 159 35 53 53 34 34 34 130 40 42 138 143 3 10 31 171 222 208 80 86 86 86 22 209 123 239 205 45 33 126 111 36 55 124 176 68 124 243 141 193 96 48 136 226 71 31 85 86 86 86 122 223 167 167 103 251 246 237 219 137 254 250 203 233 116 58 137 6 7 29 14 135 131 232 201 19 222 55 153 216 165 136 34 111 93 174 232 232 232 104 34 183 91 173 86 171 137 212 106 187 221 110 39 138 142 230 153 19 31 63 57 57 57 73 148 158 206 251 105 105 76 136 78 199 207 167 82 9 194 203 102 6 49 47 94 104 181 90 45 209 253 251 235 214 173 91 71 180 111 95 109 109 109 109 248 8 9 122 6 248 34 226 235 175 217 71 203 241 224 1 19 242 214 91 29 29 29 29 222 191 55 55 111 220 184 113 35 209 240 48 143 88 155 77 167 211 233 136 236 118 54 136 219 205 62 30 80 169 96 72 222 42 149 252 187 32 176 97 69 81 20 69 145 72 161 96 98 52 154 177 177 177 49 162 204 76 147 201 100 34 122 231 29 190 79 124 252 244 235 130 8 183 155 127 191 125 59 47 47 47 143 168 184 248 204 153 51 103 66 79 196 140 47 232 143 8 62 43 240 40 231 243 207 243 243 243 243 137 158 63 95 182 108 217 50 162 169 169 164 164 164 164 151 13 200 134 128 161 35 35 217 135 199 198 198 198 198 198 74 251 216 226 124 143 135 93 148 221 206 4 96 59 53 197 51 34 37 229 241 227 199 143 137 222 125 247 249 243 231 207 137 116 58 38 66 173 158 238 178 108 54 190 206 173 91 185 185 185 185 68 101 101 77 77 77 77 161 35 34 232 11 189 154 136 192 175 243 233 167 197 197 197 197 68 118 59 187 18 32 42 138 163 25 181 154 143 107 52 236 122 180 90 158 17 209 209 236 130 14 29 58 116 232 208 33 255 6 57 127 254 252 249 243 231 69 17 4 88 173 86 171 213 74 36 8 28 101 173 94 253 240 225 195 135 68 89 89 188 230 96 237 240 120 120 32 140 140 48 17 191 253 182 126 253 250 245 68 85 85 13 13 13 13 179 39 98 214 23 144 19 113 231 206 222 189 123 247 138 98 94 222 165 75 151 46 249 255 127 73 73 73 73 73 137 52 194 49 130 221 110 54 68 106 42 135 143 216 86 84 84 84 84 84 132 110 4 234 245 122 189 94 47 138 102 51 207 132 188 188 158 158 158 30 162 183 223 102 130 20 10 118 105 14 7 19 112 231 14 175 37 143 30 109 218 180 105 19 209 241 227 199 143 31 63 30 252 243 132 236 69 174 95 175 174 174 174 22 197 21 43 186 187 187 187 137 86 173 186 122 245 234 213 192 255 95 89 201 139 179 201 196 62 26 68 164 167 167 167 167 167 19 213 213 213 213 213 213 133 63 58 105 108 60 125 250 244 105 81 220 188 249 214 173 91 183 136 146 146 108 54 155 141 200 227 225 223 39 38 120 96 92 191 206 65 135 203 181 118 237 218 181 68 53 53 193 229 23 33 211 130 130 53 60 96 48 24 12 6 131 228 171 225 195 205 102 179 217 108 38 106 108 108 108 108 108 12 127 6 253 217 103 199 142 29 59 38 8 191 255 206 62 95 14 141 134 215 138 244 244 39 79 158 60 33 178 90 71 71 71 71 137 154 155 155 155 155 155 103 254 124 179 38 0 9 84 160 134 47 43 43 43 43 43 243 62 206 18 7 209 197 139 201 201 201 201 210 12 152 156 228 112 210 102 227 145 56 87 40 45 173 175 175 175 23 132 251 247 87 173 90 181 202 59 127 64 190 161 84 14 13 13 13 17 141 143 143 143 143 143 207 252 62 179 38 0 153 171 255 23 42 45 45 45 37 234 235 235 235 235 235 147 142 115 248 74 244 232 17 39 88 195 195 28 166 26 141 124 28 139 111 76 76 76 76 76 76 152 173 254 63 240 193 7 70 163 209 40 8 54 27 162 44 62 142 168 73 167 227 181 3 51 181 169 169 169 169 169 41 240 153 16 52 1 208 106 252 73 6 88 100 123 123 123 123 123 123 137 214 172 89 179 102 205 26 162 252 124 14 63 223 120 227 192 129 3 7 136 254 245 47 142 211 229 68 212 215 179 75 170 174 174 174 174 174 158 63 201 96 120 120 229 202 149 43 95 50 220 127 22 231 196 68 142 146 148 74 118 69 22 139 197 98 177 4 126 221 160 9 128 72 6 252 250 235 182 109 219 182 17 157 56 193 134 45 43 219 191 127 255 126 41 49 202 206 206 206 206 206 38 234 234 234 234 234 234 34 218 178 101 203 150 45 91 136 250 251 251 251 251 251 137 56 129 19 4 95 68 204 76 125 13 61 222 127 95 175 215 235 189 7 0 102 130 74 197 193 3 194 219 64 215 132 160 9 128 58 9 64 171 153 152 136 143 143 143 39 114 185 166 39 80 9 9 9 9 9 9 68 133 133 133 133 133 133 68 3 3 3 3 3 3 68 237 237 237 237 237 237 82 30 177 208 137 120 246 44 37 37 37 69 114 69 90 45 18 56 94 171 144 103 96 27 54 2 32 11 3 16 201 60 158 184 184 184 56 105 228 35 97 210 233 88 90 56 118 140 163 140 182 182 182 182 182 54 239 76 122 161 19 97 54 51 1 64 76 12 191 167 82 201 174 210 233 100 237 42 236 4 200 125 63 212 73 232 241 208 102 176 120 130 8 57 124 73 26 11 149 8 171 149 227 127 201 14 60 211 5 129 159 11 9 36 194 233 150 150 150 150 150 22 223 207 23 52 1 40 132 0 144 133 161 78 202 181 27 127 146 193 235 66 196 135 31 202 19 46 94 132 69 145 7 32 242 23 151 11 30 129 247 67 78 0 42 80 0 244 120 200 194 136 227 161 229 4 138 133 78 196 247 223 159 59 119 238 156 116 125 135 131 9 192 154 7 17 17 51 33 108 4 56 157 60 178 1 36 38 208 227 65 0 92 209 76 177 80 137 208 104 56 238 7 172 86 16 192 239 15 128 8 127 8 154 0 155 141 85 73 0 21 40 20 66 192 188 191 17 240 186 17 161 213 142 140 140 140 72 251 38 19 223 207 233 156 62 211 17 132 132 141 0 20 187 1 200 183 168 64 41 149 92 209 194 98 52 91 44 20 34 18 18 88 3 2 70 71 217 213 56 157 92 159 248 175 97 21 88 156 95 77 68 208 4 152 76 211 195 49 0 165 63 84 160 64 0 244 248 215 149 136 159 127 174 173 173 173 149 254 103 183 243 204 70 9 213 110 231 104 15 6 199 26 224 207 21 5 77 192 238 221 92 43 69 151 129 164 145 176 47 68 233 15 34 90 160 113 241 66 37 162 160 160 161 161 161 65 82 123 145 120 254 253 55 27 220 110 231 25 128 232 15 4 32 47 8 57 1 0 218 59 0 20 187 81 115 77 77 29 30 30 30 150 82 244 80 99 110 136 240 254 125 96 128 93 236 228 228 244 18 170 188 54 29 54 23 4 248 234 171 65 177 27 53 87 148 254 80 129 154 27 34 164 138 157 47 34 184 107 67 110 104 81 252 246 219 87 63 231 159 127 50 1 14 7 175 133 48 52 124 127 68 4 187 98 127 97 120 200 212 197 31 127 228 145 244 230 155 44 55 35 242 65 41 239 143 63 152 144 190 190 13 27 54 108 32 58 113 226 228 201 147 39 195 173 110 250 238 200 243 215 197 225 11 122 61 119 111 60 120 192 25 241 212 20 111 97 112 108 147 147 185 174 225 175 146 23 178 138 24 26 154 208 87 131 53 1 93 6 40 118 231 230 114 229 12 165 191 153 25 114 166 91 223 215 195 140 152 233 123 14 13 241 136 134 225 49 242 33 185 204 180 126 17 242 246 116 52 52 161 175 6 64 152 138 98 55 106 174 23 47 214 213 213 213 249 51 24 12 53 211 173 239 235 193 53 125 247 93 115 115 115 115 224 239 103 179 45 93 186 116 233 203 239 197 218 23 164 7 172 117 216 159 115 2 208 73 134 134 38 244 213 160 189 3 133 12 20 187 55 111 190 121 243 230 77 162 246 246 131 7 15 30 12 151 132 32 17 3 195 127 242 73 90 90 90 26 81 78 78 103 103 103 103 224 87 250 234 171 203 151 47 95 246 238 87 66 233 20 97 55 154 11 252 173 121 97 251 64 3 157 100 104 104 66 95 13 214 4 172 17 216 102 101 113 105 179 187 187 168 168 168 72 20 59 59 171 170 170 170 102 75 136 52 19 16 199 127 241 5 90 21 239 222 189 123 55 248 38 130 11 23 46 92 184 112 65 42 69 202 219 106 16 118 251 171 101 207 89 137 79 175 103 3 232 116 247 238 221 187 71 180 122 53 71 17 232 50 0 124 53 207 162 16 2 61 126 114 146 125 240 238 221 172 78 66 36 131 86 3 201 64 158 185 2 129 26 30 53 107 249 98 205 225 43 81 77 13 207 108 52 140 97 6 32 250 89 178 132 159 179 170 170 170 170 170 202 219 53 206 121 141 245 212 169 83 167 78 157 18 197 168 40 94 140 209 222 1 49 15 37 62 184 42 127 196 4 10 100 174 72 160 10 10 174 93 187 118 205 247 249 185 185 60 115 151 47 95 190 124 249 114 162 142 14 206 27 248 67 21 239 38 228 47 191 228 227 24 249 144 225 125 25 126 222 8 0 206 158 229 162 62 250 106 208 222 129 46 3 20 187 65 8 74 127 168 64 161 16 2 61 30 178 48 212 73 136 100 208 106 32 25 140 141 241 255 206 157 187 113 227 198 13 239 231 66 179 64 78 78 78 78 78 14 81 119 55 15 20 16 226 114 93 185 114 229 10 209 236 218 242 23 0 1 0 138 215 232 171 129 79 69 151 1 138 221 168 185 162 244 135 10 20 10 33 208 227 33 11 187 92 60 2 29 14 14 7 161 213 64 50 144 55 255 34 126 71 229 14 134 223 186 117 235 214 173 91 137 110 222 228 96 97 231 206 157 59 119 238 36 186 125 251 232 209 163 71 103 79 132 202 191 137 194 139 195 135 15 31 62 124 88 122 80 244 213 88 44 236 83 17 214 89 44 60 181 161 173 200 11 30 190 68 47 121 134 170 86 243 76 130 193 17 70 202 227 120 142 94 4 33 49 49 49 49 49 81 20 209 60 16 23 23 23 23 23 39 138 151 47 191 156 71 72 223 71 176 179 146 36 14 127 68 204 251 12 240 7 204 16 121 183 1 22 59 196 219 114 245 17 134 135 54 35 47 145 194 240 216 202 7 130 28 193 126 168 146 153 217 223 223 223 255 26 19 224 11 70 163 209 104 52 138 162 220 240 114 2 228 68 148 151 151 151 151 151 7 47 129 204 236 67 149 133 243 49 224 255 29 96 120 95 251 139 152 35 44 26 254 53 199 191 1 200 20 199 16 138 17 10 59 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:03'!line	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 149 73 68 65 84 120 218 237 155 61 174 130 64 20 133 103 172 97 17 20 108 107 98 50 157 49 178 25 151 96 193 10 168 220 137 149 137 37 189 13 201 125 5 121 49 206 123 58 255 204 85 206 215 65 32 145 243 225 56 3 71 33 0 47 136 250 190 239 137 74 127 142 213 113 62 55 77 211 16 93 46 109 219 182 68 16 81 8 83 196 253 222 117 93 7 17 185 216 152 59 78 167 113 28 71 33 174 215 105 154 38 33 110 183 97 24 6 33 32 34 51 74 41 165 212 35 224 237 182 174 235 154 40 238 27 241 123 28 196 189 196 12 62 141 8 51 120 8 176 226 42 98 222 178 5 12 1 193 216 68 204 216 68 32 248 104 222 139 128 128 197 136 21 161 181 214 90 63 206 55 183 129 35 177 67 17 130 79 74 232 80 4 17 38 27 191 195 93 131 147 210 220 51 79 95 133 56 30 171 170 170 74 95 54 31 60 5 216 144 242 249 14 151 114 158 190 98 101 157 136 215 179 28 219 143 109 154 149 53 248 131 45 120 136 200 132 111 240 16 145 136 216 224 243 60 244 91 33 190 11 172 60 15 253 86 200 225 176 223 239 118 225 43 91 136 96 66 168 8 188 42 77 12 68 48 1 67 19 19 32 130 9 16 193 4 136 96 2 68 48 1 34 152 0 17 76 128 8 38 64 4 19 150 17 129 218 141 21 84 46 153 128 202 37 19 80 185 100 66 234 202 37 122 78 129 152 34 158 131 68 193 108 49 254 15 114 57 17 50 244 196 239 36 246 142 150 222 121 38 110 198 125 42 241 149 203 208 5 29 4 56 129 202 101 102 80 185 44 14 154 126 133 136 13 222 85 4 90 28 22 82 255 149 202 20 81 250 250 216 18 219 244 3 31 206 15 224 42 63 94 246 95 66 123 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/28/2005 09:19'!locus	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 8 6 0 0 0 87 2 249 135 0 0 0 6 98 75 71 68 0 99 0 99 0 99 185 251 243 121 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 0 7 116 73 77 69 7 213 11 28 8 18 45 208 0 131 20 0 0 0 29 116 69 88 116 67 111 109 109 101 110 116 0 67 114 101 97 116 101 100 32 119 105 116 104 32 84 104 101 32 71 73 77 80 239 100 37 110 0 0 3 87 73 68 65 84 104 222 237 152 201 139 19 65 20 198 127 17 241 232 93 196 187 127 136 224 217 131 94 20 81 90 16 65 16 84 80 65 208 163 140 163 40 110 12 58 174 131 251 46 138 184 226 134 131 136 136 3 234 136 224 174 227 160 102 50 49 147 69 103 62 15 121 5 25 237 116 58 109 119 18 49 15 138 110 146 234 170 239 171 122 239 213 247 10 218 214 182 182 181 173 109 255 189 149 64 5 208 191 128 53 7 26 174 192 154 114 4 42 59 141 1 63 128 97 96 170 245 9 48 85 142 149 132 141 128 198 128 209 50 86 138 246 44 185 73 243 32 25 112 128 9 246 71 10 248 9 100 170 19 169 36 158 74 98 181 221 98 230 129 172 97 201 216 123 190 218 164 251 65 211 129 41 192 100 96 146 177 159 60 190 91 42 41 2 35 32 183 218 57 96 0 120 14 204 143 50 199 102 208 19 208 183 50 216 106 45 54 203 130 190 130 222 128 238 213 51 182 231 121 129 157 15 39 76 224 59 40 11 26 0 61 14 49 166 47 94 247 227 239 79 31 191 31 215 106 145 15 3 126 8 244 30 116 57 0 124 32 190 106 127 250 116 86 156 36 178 230 158 175 171 0 15 129 167 246 54 213 2 31 213 149 178 160 180 249 251 77 159 239 35 129 174 145 239 199 181 231 21 239 215 35 16 248 6 122 7 186 20 2 124 28 246 199 106 219 224 42 130 62 131 186 234 32 145 1 13 90 134 75 18 116 53 2 227 38 115 169 239 92 29 4 6 65 253 160 3 62 227 37 174 71 126 159 44 109 250 228 33 104 93 72 18 239 65 189 173 0 222 243 60 165 65 35 150 73 14 133 32 240 25 244 10 116 173 34 123 53 13 60 101 209 167 2 232 11 232 10 104 118 13 18 3 160 23 21 46 215 16 240 65 129 150 181 64 30 2 221 5 45 8 32 48 104 7 214 19 219 173 166 131 119 170 177 104 113 112 31 180 40 128 192 71 115 159 7 160 93 205 216 1 63 203 27 129 140 9 176 133 1 4 222 153 251 220 1 109 142 97 7 38 196 65 192 105 220 81 211 232 185 128 190 211 32 85 50 141 63 6 116 119 119 167 154 78 192 85 113 133 242 233 202 113 72 5 173 108 209 14 147 137 173 224 62 148 129 43 103 210 162 51 132 91 244 130 110 129 246 180 74 29 238 2 248 118 29 121 253 1 232 60 104 101 179 73 20 44 128 7 65 61 33 179 138 231 121 234 179 128 63 80 35 232 27 146 129 50 160 62 208 234 58 118 224 145 165 220 11 160 245 205 34 224 192 247 71 212 52 55 64 87 65 251 154 225 74 5 171 97 95 131 142 68 208 52 174 223 101 208 41 59 212 230 52 138 132 3 255 22 116 210 71 207 215 123 178 159 6 29 179 131 109 73 146 36 138 166 58 211 160 151 160 19 49 20 35 174 127 15 232 32 104 27 104 45 104 94 156 68 138 166 54 179 160 79 166 99 58 99 4 239 158 59 173 170 219 14 218 8 90 243 183 36 138 160 60 232 187 73 229 103 230 175 113 214 174 126 223 111 2 109 5 109 1 117 88 219 16 68 166 4 42 89 62 47 84 128 30 178 21 239 3 157 177 52 153 68 225 237 55 206 10 75 175 157 70 100 7 104 183 37 140 75 38 219 31 57 60 14 120 206 238 104 62 128 158 218 85 71 23 104 113 3 110 13 170 141 55 23 180 220 200 116 152 123 237 5 29 5 157 117 184 210 160 143 182 210 23 45 144 150 129 102 132 188 108 74 186 226 115 54 19 52 11 52 31 180 20 180 42 202 221 105 210 53 108 34 243 52 10 252 95 205 27 246 110 180 209 250 189 46 28 173 2 58 18 174 86 5 223 168 4 210 182 168 246 11 175 92 10 76 202 252 154 245 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 09:20'!macroBuild	^ self formFromGraphic: #(			137			80			78			71			13			10			26			10			0			0			0			13			73			72			68			82			0			0			0			48			0			0			0			48			16			6			0			0			0			7			146			37			196			0			0			0			6			98			75			71			68			255			255			255			255			255			255			9			88			247			220			0			0			0			9			112			72			89			115			0			0			0			72			0			0			0			72			0			70			201			107			62			0			0			16			223			73			68			65			84			120			218			237			90			123			80			84			231			21			255			221			221			187			187			44			203			99			129			229			177			203			35			192			138			32			10			10			40			104			89			17			43			160			213			196			198			154			76			195			24			107			211			214			209			38			182			206			244			49			157			206			116			226			180			51			109			30			181			173			147			56			182			102			106			219			212			8			141			160			81			51			2			106			70			81			20			34			6			80			43			6			20			17			129			240			208			229			177			60			118			97			95			95			255			56			249			230			2			134			65			35			15			147			122			102			244			114			247			222			251			221			239			59			231			252			126			231			247			157			93			224			137			61			177			39			54			105			198			216			232			227			215			197			166			110			93			194			228			78			112			220			215			76			210			123			166			219			166			126			93			147			236			152			175			75			32			166			111			29			83			228			144			175			106			32			166			127			222			83			236			136			175			74			32			102			110			158			178			169			93			216			227			226			224			199			119			254			211			236			160			241			50			109			166			2			53			243			243			153			98			4			60			234			194			30			85			246			61			236			243			211			159			8			211			28			128			241			22			58			214			81			147			173			183			39			26			127			230			168			242			49			225			232			169			42			130			143			191			8			152			33			4			112			155			233			29			243			76			191			127			198			2			48			243			11			127			92			230			35			206			204			107			39			170			1			51			53			143			39			54			198			166			91			5			61			177			255			59			155			49			8			38			38			38			38			38			37			49			22			26			26			30			30			29			13			248			248			248			248			4			4			0			173			173			45			45			245			245			0			99			110			183			195			1			148			151			151			151			151			151			79			76			21			161			161			161			161			161			161			140			133			132			232			245			97			97			244			188			32			0			22			139			197			210			219			11			180			180			180			180			52			54			2			169			169			169			169			105			105			192			249			243			231			207			151			149			205			60			5			77			123			13			8			15			15			15			15			15			103			108			233			210			101			203			86			175			6			102			205			154			61			59			49			17			144			203			229			114			185			28			232			239			239			239			79			77			5			246			237			251			219			223			94			127			125			226			241			182			108			217			178			101			203			22			198			42			42			202			203			47			93			2			182			110			125			229			149			29			59			128			190			62			114			188			203			229			118			59			157			64			71			71			123			123			107			43			240			175			127			237			219			183			115			231			248			227			205			157			59			119			238			220			185			140			13			13			13			13			13			13			241			115			224			216			177			99			199			142			29			155			252			128			125			105			21			180			113			227			198			141			27			55			50			22			31			31			31			31			31			207			88			112			112			72			136			193			192			216			143			126			180			121			243			214			173			227			115			111			76			76			76			76			124			60			112			243			102			67			67			93			29			80			87			87			91			91			83			3			244			247			247			245			89			44			128			74			165			84			170			213			192			130			5			201			201			139			23			3			217			217			217			217			217			217			227			143			215			208			208			208			208			208			0			196			198			198			197			37			36			72			227			12			14			14			14			14			12			0			78			167			195			225			116			2			90			173			175			175			159			31			32			147			201			100			10			197			253			227			228			230			230			230			230			230			50			102			181			90			173			86			43			33			37			35			3			80			171			53			26			63			63			32			41			41			41			41			57			153			177			184			184			184			184			184			56			198			114			114			114			114			114			114			30			189			198			60			112			68			55			111			222			188			121			243			102			198			138			139			139			139			139			139			129			144			144			144			144			208			80			96			237			218			103			159			125			233			37			192			108			238			238			238			236			4			14			30			204			207			223			187			23			48			153			76			166			244			116			160			176			176			160			160			160			64			202			156			196			196			249			243			147			146			24			211			106			253			252			12			6			96			217			178			204			204			85			171			0			15			15			15			15			79			79			114			144			76			6			168			84			42			149			90			13			92			187			246			223			255			86			86			2			183			110			221			186			85			87			7			216			237			195			195			195			195			192			189			123			247			238			181			183			3			203			151			47			95			190			102			13			16			27			59			103			206			252			249			0			207			92			128			74			48			71			86			91			219			103			159			181			180			0			133			133			7			15			190			243			14			160			84			42			149			226			8			252			107			181			126			126			58			29			176			102			205			51			207			188			248			34			160			215			235			245			17			17			128			74			229			225			225			225			1			200			229			52			47			171			213			102			179			90			129			63			252			225			183			191			253			201			79			128			89			179			98			98			140			70			160			172			172			172			236			203			80			218			132			15			240			204			56			119			238			220			185			243			231			1			157			46			56			56			52			20			216			182			109			219			182			29			59			128			254			254			129			1			139			5			176			90			41			227			42			43			47			94			44			45			5			44			150			158			158			123			247			0			187			221			225			176			217			128			206			206			206			206			206			78			192			233			116			58			157			78			32			51			147			28			183			112			225			162			69			25			25			128			219			237			118			187			221			128			211			233			114			57			157			128			32			48			230			118			3			114			185			66			161			84			2			54			155			213			58			56			8			244			246			90			44			221			221			128			167			39			33			69			167			11			10			10			14			6			6			7			109			182			193			65			226			126			64			10			164			76			38			151			203			100			128			66			161			80			120			120			0			102			179			217			220			222			14			216			108			116			191			70			163			209			120			123			3			190			190			62			62			90			45			48			60			76			1			230			243			49			155			205			230			206			78			224			192			129			127			255			123			247			110			96			222			188			196			196			148			20			96			201			146			37			75			50			51			129			252			252			247			222			219			179			7			184			117			171			177			177			161			97			10			2			144			145			145			145			145			145			193			88			86			214			202			149			185			185			64			73			73			81			81			97			33			81			200			167			159			2			155			54			109			218			180			125			59			16			20			20			28			172			215			3			130			32			8			124			193			74			37			32			138			162			40			138			128			82			169			82			121			120			144			99			228			114			224			220			185			179			103			139			139			129			207			62			107			109			109			106			2			122			123			187			187			239			222			5			26			26			110			222			188			126			29			80			171			61			61			61			60			104			28			181			26			112			185			92			46			0			240			240			208			104			84			42			64			163			161			204			116			185			156			78			135			3			24			24			24			28			164			0			0			50			25			57			210			102			3			100			50			65			96			12			240			242			242			242			242			241			1			162			163			141			198			57			115			0			133			66			169			244			244			4			210			211			77			166			236			108			64			173			86			171			61			61			1			171			149			2			45			8			130			32			8			64			93			93			93			221			213			171			192			225			195			5			5			127			255			59			176			115			231			174			93			121			121			20			56			31			31			224			205			55			95			123			237			167			63			5			210			210			82			83			83			83			129			210			210			179			103			203			203			249			58			38			14			200			132			55			164			167			167			167			167			167			51			246			253			239			255			240			135			191			254			53			101			176			219			13			156			60			121			226			196			161			67			128			40			202			229			162			8			36			39			47			92			104			50			1			14			135			195			97			183			143			120			193			231			11			113			58			201			133			127			252			227			235			175			255			226			23			192			240			48			81			197			142			29			191			251			221			91			111			1			158			158			106			181			151			23			57			194			195			3			8			8			208			233			244			122			10			156			66			1			132			134			234			245			58			29			16			23			23			27			27			25			9			248			248			120			123			139			34			64			249			14			220			186			213			208			112			247			46			208			222			126			247			110			119			55			48			56			56			48			96			181			2			29			29			132			60			179			153			40			75			20			229			114			165			18			200			203			59			112			96			239			94			160			186			186			170			170			188			28			120			238			185			231			159			255			193			15			168			246			124			227			27			0			99			132			37			62			255			75			151			42			43			203			202			36			53			101			183			219			237			195			195			132			252			254			126			105			189			27			55			110			218			244			227			31			3			251			247			191			251			238			95			255			58			113			32			38			84			65			114			185			40			170			84			64			113			113			81			81			65			1			16			20			20			20			20			30			78			153			44			138			64			124			252			220			185			201			201			128			151			151			183			183			143			143			196			209			78			39			101			166			203			69			148			35			8			130			32			151			3			105			105			139			23			103			102			2			151			47			87			87			151			151			3			71			143			30			57			178			127			63			113			181			82			73			114			242			169			167			40			51			159			126			154			206			195			194			164			226			201			19			192			110			119			56			104			134			84			8			25			147			201			24			3			148			74			133			66			161			0			218			219			45			150			158			30			224			234			213			154			154			202			74			160			162			162			188			252			204			25			66			164			92			14			220			188			121			227			198			181			107			192			188			121			9			9			201			201			64			112			176			193			16			30			46			173			155			49			26			87			165			82			169			84			42			32			43			43			39			231			217			103			169			118			168			84			210			125			78			167			211			105			183			75			181			199			219			155			252			48			48			208			223			223			221			253			8			20			20			18			18			18			18			18			194			88			88			24			233			244			13			27			190			247			189			237			219			73			38			246			244			80			113			172			174			6			174			92			169			169			249			248			99			130			180			74			69			106			195			215			151			138			98			82			18			16			21			21			21			21			23			71			84			34			138			128			40			114			78			167			204			113			185			24			115			185			168			102			116			119			3			21			21			23			46			20			21			1			55			110			220			184			209			208			64			84			50			178			168			138			162			40			42			149			128			32			200			100			110			55			101			180			66			65			212			97			179			1			196			250			68			67			140			73			212			104			50			45			91			182			114			37			16			31			63			103			78			98			34			33			213			229			146			138			189			219			237			118			187			92			128			195			97			183			219			237			180			30			165			18			184			115			231			246			237			250			122			224			244			233			51			103			142			31			31			73			81			244			207			100			90			186			52			43			11			136			143			143			143			95			184			16			104			111			239			236			108			106			2			222			121			103			207			158			55			222			32			164			216			237			227			35			224			190			11			92			246			53			53			53			53			53			53			17			247			202			100			18			39			207			158			29			19			147			152			8			168			84			106			181			70			3			132			133			69			68			68			69			17			50			66			67			129			210			210			211			167			143			29			163			0			85			85			1			171			87			175			89			243			194			11			64			120			56			221			199			152			219			77			234			132			215			6			10			156			90			237			233			169			209			144			26			82			171			73			117			200			229			18			165			13			15			19			228			121			77			81			171			169			6			48			70			52			100			179			89			173			67			67			228			126			185			92			66			6			47			194			110			183			203			69			69			158			144			57			52			52			52			100			179			73			1			118			185			168			248			51			70			185			207			85			217			63			255			249			143			127			236			220			73			251			129			133			11			129			148			148			69			139			150			46			5			46			95			190			124			185			188			28			104			107			107			109			109			110			6			250			251			9			113			109			109			109			109			183			111			3			222			222			180			177			124			104			10			58			117			234			212			169			83			167			4			129			111			72			222			124			243			207			127			62			120			16			248			217			207			182			111			127			225			5			160			166			166			166			166			162			2			120			235			173			61			123			242			243			129			150			150			230			230			230			102			138			180			195			65			16			212			106			137			27			7			7			129			136			136			200			200			89			179			200			241			148			177			68			1			54			27			45			188			182			246			218			181			170			42			224			211			79			105			63			96			54			155			205			29			29			128			32			144			35			77			166			244			244			172			44			96			206			156			121			243			82			82			0			133			66			20			21			10			192			98			33			23			115			135			113			213			35			151			211			245			214			214			59			119			26			27			129			43			87			174			94			173			172			4			46			94			172			168			56			125			154			50			29			0			22			45			74			77			93			186			20			200			204			92			177			226			153			103			40			160			35			145			192			229			107			114			114			114			178			201			4			52			55			55			55			223			186			37			81			147			94			31			18			18			21			5			204			154			101			52			38			36			0			255			249			79			94			222			158			61			192			119			191			155			155			187			101			11			80			84			116			252			120			97			225			196			20			116			95			0			56			2			218			218			218			218			218			218			36			142			251			230			55			87			172			88			189			154			168			68			46			39			71			80			166			1			46			151			164			110			62			250			232			228			201			163			71			129			236			236			149			43			215			173			3			2			3			3			3			131			131			137			186			250			250			128			174			46			146			117			101			101			165			165			197			197			36			99			251			250			128			164			164			228			228			37			75			136			194			252			253			129			161			33			170			37			71			143			126			240			193			190			125			36			63			205			102			96			217			178			229			203			215			174			165			140			118			58			9			65			74			165			116			180			88			122			122			122			122			128			195			135			63			248			224			221			119			105			188			128			0			96			195			134			23			95			124			229			21			82			81			26			13			112			254			124			105			105			73			9			80			83			243			201			39			23			46			72			28			207			29			239			112			80			237			138			138			50			26			99			99			165			117			37			36			36			36			52			54			74			129			230			148			60			182			38			60			168			77			136			0			128			56			154			23			87			0			32			14			166			162			202			101			167			74			165			82			41			149			64			87			87			87			87			103			39			112			242			100			73			201			161			67			64			99			35			201			85			95			95			63			63			127			127			192			229			114			56			28			14			32			50			50			58			218			104			4			230			205			155			55			47			57			89			82			61			60			80			50			25			169			43			139			197			98			89			183			142			84			72			105			41			144			157			157			147			243			220			115			0			165			2			81			5			151			171			74			37			112			249			242			149			43			151			46			73			153			186			122			245			211			79			63			255			60			224			235			235			235			171			211			209			248			189			189			192			252			249			164			118			46			95			38			68			31			63			254			225			135			249			249			64			79			79			111			175			217			12			52			53			53			54			222			188			73			136			112			58			1			131			193			96			8			11			35			255			28			57			2			172			93			251			237			111			111			216			48			122			227			71			148			39			147			61			204			110			96			66			4			48			54			186			107			238			112			16			213			8			2			233			107			190			84			190			41			247			243			243			243			11			12			36			121			185			123			55			181			10			174			95			151			40			166			178			146			28			249			210			75			155			55			191			255			62			201			79			141			134			118			182			189			189			18			231			187			92			180			176			192			192			160			32			189			30			184			113			163			190			254			218			53			137			178			56			215			139			34			169			49			183			91			16			220			110			224			234			213			234			234			139			23			1			157			78			167			11			12			4			22			44			88			176			32			53			21			168			175			175			175			175			173			149			184			95			173			86			171			189			189			169			120			38			39			3			167			78			157			56			113			248			48			240			242			203			219			182			253			234			87			128			40			82			109			10			15			15			13			141			136			160			158			146			203			5			236			220			249			198			27			175			190			42			213			42			155			141			118			198			220			184			106			156			68			4			124			177			113			21			64			81			167			64			240			0			120			123			3			70			163			209			56			107			22			81			131			66			1			164			165			165			165			101			102			74			250			89			162			14			42			170			60			211			120			6			57			28			14			7			237			132			69			81			38			3			60			61			61			61			125			124			168			200			81			209			235			235			235			235			147			174			43			149			164			142			184			40			168			171			171			171			187			114			5			208			106			253			253			253			253			1			167			147			28			200			119			184			110			55			117			91			249			121			104			104			120			120			68			4			144			144			48			127			254			194			133			64			79			79			119			119			87			151			244			220			192			0			245			152			134			134			236			118			155			77			218			31			140			53			198			232			254			71			70			0			111			29			140			118			185			116			36			45			67			231			132			18			250			156			23			69			126			116			56			168			25			198			101			163			221			78			25			238			118			147			158			151			203			61			61			73			50			114			210			24			141			56			202			107			96			254			124			114			204			214			173			47			191			252			203			95			74			77			55			9			125			244			191			183			183			143			143			175			47			176			113			99			110			110			78			142			20			24			106			75			72			142			115			187			233			125			92			6			187			92			78			39			201			80			162			72			142			68			174			186			248			123			100			159			183			47			121			49			31			107			46			23			169			173			7			181			251			186			161			28			1			252			92			46			39			25			199			51			158			191			96			164			195			8			5			84			132			165			137			72			170			135			22			79			181			130			38			15			48			70			174			21			4			82			47			35			199			34			105			201			51			149			138			188			195			225			116			218			108			180			193			25			24			0			122			123			123			123			123			122			232			216			219			43			245			253			135			134			108			54			155			77			234			57			241			13			35			47			174			163			223			66			243			18			4			66			210			232			235			247			167			30			79			48			186			95			46			255			34			4			140			125			203			68			54			46			2			6			7			7			7			173			86			224			230			205			250			250			235			215			1			141			198			203			203			219			27			176			217			134			134			172			86			234			133			120			121			17			229			4			4			124			62			216			23			236			171			185			60			20			4			162			22			158			57			252			11			19			94			204			185			35			70			135			149			238			228			1			226			71			250			91			66			34			253			117			63			18			57			21			140			108			41			240			55			112			170			227			72			96			204			229			26			249			102			183			155			183			245			248			58			4			65			20			169			59			170			86			3			62			62			212			222			238			239			31			24			24			217			138			80			42			169			119			245			165			3			192			17			144			150			150			150			182			120			49			99			175			189			246			251			223			255			252			231			128			201			148			145			145			149			69			197			45			36			4			168			170			170			170			170			168			0			78			159			254			232			163			163			71			41			51			123			123			239			215			229			252			40			229			56			133			128			23			53			198			36			46			229			8			161			59			249			167			99			29			52			58			64			220			73			114			57			33			204			229			162			251			36			10			148			40			129			198			31			141			84			190			63			225			189			170			209			244			55			50			179			9			33			29			29			237			237			183			111			3			231			207			159			61			123			228			8			96			48			132			133			205			158			77			45			150			101			203			128			253			251			247			239			223			179			135			84			227			131			200			209			113			17			192			3			145			146			146			146			178			104			17			99			37			37			69			69			135			14			145			156			243			245			5			172			214			129			129			174			46			250			10			177			177			145			54			104			213			213			130			96			52			26			141			70			35			45			159			103			56			45			156			115			239			200			28			3			212			106			234			146			106			52			164			207			221			110			169			186			144			204			37			80			75			148			55			26			248			60			79			71			214			36			122			150			90			20			162			72			45			16			127			127			127			127			157			78			250			188			171			139			18			163			175			175			191			223			98			145			2			205			17			33			133			159			183			64			104			156			216			216			216			216			216			88			32			50			242			169			167			12			6			160			168			136			122			100			45			45			45			45			205			205			146			250			234			236			236			232			104			107			155			88			144			142			91			3			120			32			170			170			170			170			46			93			18			4			147			201			100			50			153			128			142			142			142			142			142			14			65			232			234			234			234			106			111			151			28			159			149			149			149			149			149			197			24			47			90			162			200			101			34			231			86			90			24			239			158			218			108			36			7			47			93			250			228			147			138			10			32			63			63			47			111			239			94			224			196			137			146			146			130			2			10			108			67			131			212			178			224			27			159			145			249			57			178			120			243			240			140			252			66			71			165			2			202			202			206			156			57			113			2			120			251			237			93			187			126			243			27			32			63			255			192			129			191			252			5			168			168			40			43			43			42			162			98			59			60			76			251			8			133			66			170			85			92			102			250			249			105			181			1			1			18			82			188			188			188			188			188			188			128			218			218			218			218			218			90			234			89			213			215			75			254			161			64			72			254			123			100			4			140			119			94			82			82			82			82			82			114			255			117			189			94			175			215			235			25			59			126			252			248			241			130			2			96			213			170			111			125			235			59			223			145			90			8			190			190			90			173			191			63			125			55			187			123			55			16			28			28			18			162			211			209			247			12			135			15			19			226			82			82			24			235			234			50			155			91			91			201			17			90			173			212			28			147			40			137			103			42			167			48			58			242			162			219			215			71			148			152			151			247			222			123			111			191			13			92			191			126			253			250			181			107			247			207			55			43			43			59			91			173			102			44			48			48			48			208			96			160			12			14			10			2			238			220			105			110			110			108			4			118			237			250			211			159			94			125			21			232			236			188			123			183			189			157			118			214			222			222			36			115			235			234			198			247			207			88			49			243			208			54			54			130			15			123			190			98			197			138			21			43			86			48			198			247			19			81			81			81			81			209			209			140			5			4			4			4			4			4			48			182			126			253			250			245			235			215			143			255			124			102			102			102			102			102			38			99			179			103			207			158			61			103			14			99			43			87			174			90			181			110			29			99			199			142			21			21			93			189			202			88			97			225			145			35			31			127			204			216			251			239			23			22			94			184			192			88			126			254			193			131			231			206			49			118			228			200			135			31			86			87			51			70			148			246			224			243			53			24			12			6			131			129			126			85			161			215			51			22			25			25			17			17			29			45			93			207			201			201			201			89			185			242			203			251			99			202			2			49			217			129			27			123			30			29			29			29			29			29			205			24			255			53			5			71			152			78			167			211			233			116			140			105			181			90			173			86			203			88			80			80			80			80			80			16			99			70			163			209			24			19			195			88			100			100			100			100			100			36			99			147			61			159			105			115			252			84			7			238			97			207			199			254			10			225			255			214			177			147			237			248			201			30			111			186			17			251			216			218			100			79			124			170			29			245			149			117			244			116			219			215			38			67			159			216			19			123			98			79			108			230			237			127			37			64			140			158			47			166			2			126			0			0			0			0			73			69			78			68			174			66			96			130		)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 09:21'!macroExecute	^ self formFromGraphic: #(			137			80			78			71			13			10			26			10			0			0			0			13			73			72			68			82			0			0			0			48			0			0			0			48			16			6			0			0			0			7			146			37			196			0			0			0			6			98			75			71			68			255			255			255			255			255			255			9			88			247			220			0			0			0			9			112			72			89			115			0			0			0			72			0			0			0			72			0			70			201			107			62			0			0			20			29			73			68			65			84			120			218			237			91			123			80			84			231			221			126			14			123			99			129			133			133			93			46			203			45			192			202			93			80			64			193			148			5			73			92			208			106			98			99			77			166			161			9			53			73			107			77			147			180			206			52			189			206			180			201			52			51			109			46			181			109			154			56			182			185			181			77			141			210			168			49			106			70			192			152			49			70			16			34			6			188			20			17			4			87			4			228			230			2			187			44			123			191			188			223			31			191			239			157			131			90			199			92			208			164			223			199			111			70			215			179			231			236			57			231			253			93			158			223			243			62			239			43			48			103			115			54			103			115			54			103			55			219			202			202			202			202			202			202			24			139			137			137			137			137			137			97			236			203			126			31			110			194			151			253			2			183			202			162			163			163			163			181			90			198			188			94			159			207			235			5			178			178			114			115			211			211			1			169			52			40			72			161			0			154			154			142			28			57			122			84			184			229			254			248			210			2			112			239			189			53			53			43			86			48			118			225			130			201			116			241			34			48			49			97			54			91			173			64			72			136			74			165			80			0			126			191			207			23			8			0			193			193			74			165			92			14			56			157			14			135			219			13			200			229			50			153			92			14			120			60			46			215			204			243			81			81			26			141			90			13			248			124			94			47			99			128			74			21			26			170			82			1			117			117			251			246			125			240			129			32			132			133			169			84			33			33			140			189			246			218			187			239			254			250			215			128			223			79			85			176			113			227			183			191			253			194			11			64			110			110			78			78			110			46			112			228			200			71			31			53			53			221			186			64			220			180			7			61			244			208			35			143			212			212			48			54			60			60			54			214			223			15			152			76			38			83			95			31			160			80			40			149			50			25			16			27			155			152			168			86			3			69			69			165			165			89			89			64			70			70			94			94			98			34			16			8			8			2			99			128			84			42			8			18			9			224			245			6			2			62			31			224			241			120			189			110			55			32			8			64			80			16			160			80			200			100			50			153			248			60			159			207			239			15			4			128			64			128			177			64			0			168			171			219			182			237			216			49			160			183			183			163			99			120			24			184			112			161			167			103			96			0			120			237			181			253			251			127			241			11			128			49			198			4			129			2			233			245			2			63			251			217			186			117			155			55			139			129			14			9			9			9			9			13			5			38			39			39			38			38			39			111			94			64			102			253			198			121			121			11			22			228			230			50			150			158			158			155			27			31			15			76			78			90			44			22			11			176			106			85			117			117			73			9			160			84			170			213			148			193			228			80			198			128			64			0			240			249			2			1			143			7			8			4			252			126			191			159			28			77			142			165			239			1			186			142			49			65			16			4			64			34			97			76			38			3			130			130			40			80			140			9			130			223			15			72			36			130			64			223			3			82			41			48			54			54			56			232			112			0			111			189			181			121			115			125			61			240			228			147			155			54			221			119			159			248			59			110			140			5			2			130			0			120			189			110			183			199			3			188			250			234			51			207			28			56			0			92			186			116			241			226			232			40			224			116			58			157			78			231			236			7			66			58			91			55			90			184			176			160			32			63			159			177			236			236			194			194			228			100			192			104			92			179			102			225			66			202			104			159			15			176			88			236			246			203			151			129			137			9			155			109			116			20			240			251			201			209			62			31			7			3			126			236			241			80			38			123			189			228			112			198			24			3			4			129			28			47			8			65			65			220			97			0			32			145			72			165			244			13			55			186			78			38			35			168			106			106			58			112			224			236			89			64			46			87			42			37			18			192			229			10			4			166			167			1			175			215			227			113			185			0			175			215			229			242			249			0			192			235			245			251			1			198			130			130			4			1			8			4			168			242			110			150			227			103			61			0			163			163			99			99			35			35			128			209			168			215			207			159			15			216			108			14			199			228			36			224			112			120			60			102			51			96			181			78			77			77			79			3			140			249			124			140			1			19			19			163			163			118			59			208			217			249			201			39			35			35			192			229			203			151			46			77			77			1			86			235			248			184			211			9			168			213			26			141			74			69			16			225			243			1			26			77			116			116			100			36			32			151			43			20			50			25			112			249			242			232			232			196			4			160			84			134			134			42			20			128			66			161			80			72			165			228			88			191			31			240			120			60			30			159			15			232			235			235			233			185			116			9			48			24			238			185			39			51			19			112			58			109			54			155			13			112			187			109			54			183			27			240			120			28			14			159			15			216			189			251			245			215			219			219			129			168			168			232			232			136			8			192			100			58			119			110			112			240			230			247			130			89			11			128			195			97			183			59			157			64			120			120			92			156			32			0			253			253			151			46			153			76			192			217			179			109			109			67			67			64			103			103			107			235			208			16			48			53			53			49			225			114			1			145			145			106			181			90			13			100			100			100			101			165			167			3			205			205			29			29			221			221			226			128			199			198			134			135			45			22			241			254			125			125			189			189			195			195			159			253			189			162			162			98			98			84			42			198			10			11			13			134			228			100			192			233			156			156			116			58			129			237			219			255			252			231			99			199			168			82			100			50			160			191			191			183			119			124			92			16			232			243			102			187			125			22			173			172			172			172			204			96			96			44			58			58			38			70			163			97			236			254			251			191			255			125			163			145			49			189			62			55			55			62			158			49			163			113			245			234			146			146			47			143			119			199			196			232			116			26			13			99			149			149			107			215			46			92			200			88			86			86			65			65			66			194			87			103			30			48			11			3			164			137			77			126			126			126			126			94			30			99			21			21			119			222			89			94			254			213			25			96			118			118			78			78			86			22			99			139			23			47			89			82			80			240			213			121			175			57			155			179			57			155			179			57			155			179			47			77			11			202			207			207			207			47			40			96			44			33			33			41			41			45			13			8			15			15			15			215			104			128			193			193			129			129			238			110			154			104			121			189			64			115			115			115			115			115			243			141			249			120			66			66			66			66			66			2			99			113			113			58			93			98			162			56			179			181			90			173			86			139			5			24			24			24			24			48			153			128			226			226			226			226			146			18			160			169			169			169			169			177			241			214			139			111			87			219			172			205			3			62			173			37			37			37			37			37			37			49			86			86			182			116			233			202			149			192			188			121			25			25			249			249			128			68			34			145			72			36			128			205			102			179			21			23			3			111			188			241			215			191			62			247			220			141			239			183			97			195			134			13			27			54			48			214			210			210			220			124			252			56			240			232			163			143			63			254			244			211			192			212			20			57			222			239			167			25			237			200			200			240			240			224			32			240			143			127			188			241			198			166			77			215			191			95			110			110			110			110			110			46			99			46			151			203			229			114			241			99			96			223			190			125			251			246			237			155			253			128			5			125			222			31			214			212			212			212			212			212			48			150			147			147			147			147			147			195			88			108			108			92			92			124			60			99			223			251			222			250			245			143			62			122			125			186			151			158			158			158			158			147			3			244			244			244			246			118			117			1			93			93			103			206			156			56			1			216			108			83			83			86			43			160			80			200			229			74			37			176			112			97			97			225			146			37			64			101			101			101			101			101			229			245			239			215			219			219			219			219			219			11			100			102			102			101			229			229			137			247			177			219			237			246			233			105			82			71			125			62			64			173			142			136			136			140			4			130			130			130			130			102			138			120			220			170			171			171			171			171			171			25			115			56			28			14			135			131			42			165			188			156			102			218			145			145			64			65			65			65			65			97			33			99			89			89			89			89			89			89			140			85			85			85			85			85			85			125			113			90			251			169			35			186			126			253			250			245			235			215			51			86			95			95			95			95			95			15			196			197			197			197			37			36			0			171			87			223			115			207			195			15			3			102			243			196			196			232			40			176			99			71			109			237			43			175			0			6			131			193			80			90			10			236			218			181			115			231			206			157			98			230			228			231			47			88			80			80			192			152			90			29			25			25			31			15			44			93			90			81			177			98			5			16			28			28			28			28			18			66			14			34			181			83			161			80			42			129			142			142			127			255			187			181			21			56			127			254			252			249			174			46			192			227			113			187			221			110			224			242			229			203			151			135			135			129			59			238			184			227			142			85			171			128			204			204			236			236			5			11			0			158			185			0			9			125			188			178			134			134			46			93			26			24			0			118			237			218			177			227			213			87			1			185			92			46			151			206			168			127			181			58			50			82			171			5			86			173			186			251			238			7			31			4			116			58			157			46			57			25			80			40			130			131			131			131			1			137			132			222			203			225			112			58			29			14			224			119			191			251			205			111			126			248			67			96			222			188			244			116			189			30			104			108			108			108			252			60			144			118			195			31			240			204			56			114			228			200			145			166			38			64			171			141			141			77			72			0			158			120			226			137			39			158			126			26			176			217			166			167			173			86			146			34			166			167			129			214			214			99			199			14			31			6			172			214			201			201			203			151			73			245			116			58			129			209			209			209			209			209			81			192			231			243			249			124			62			160			162			130			28			183			104			209			226			197			229			229			36			126			145			42			234			247			251			124			128			32			144			220			38			145			144			168			230			116			58			28			118			59			96			177			88			173			19			19			64			72			8			85			138			86			27			19			19			27			11			216			237			78			167			221			46			138			116			60			144			65			65			18			73			80			16			73			14			193			193			128			217			108			54			15			15			147			200			102			183			3			161			161			180			110			16			17			17			30			174			86			3			110			55			5			152			191			143			217			108			54			143			142			2			219			182			253			243			159			155			55			3			243			231			231			231			23			21			1			183			223			126			251			237			21			21			64			109			237			91			111			109			217			2			156			63			111			50			245			246			222			132			0			148			151			151			151			151			151			51			102			52			46			95			94			93			13			52			52			212			213			237			218			69			16			114			246			44			176			110			221			186			117			27			55			2			49			49			177			177			58			29			105			145			124			192			114			57			32			149			74			165			82			41			137			104			193			193			228			24			137			132			22			62			234			235			129			75			151			6			7			251			250			0			139			101			98			98			108			12			232			237			237			233			233			236			4			148			202			144			144			224			96			186			143			82			201			181			82			32			56			152			196			183			208			80			202			76			191			159			86			184			166			167			237			118			10			0			73			209			110			183			219			237			116			146			236			204			24			16			22			22			22			22			30			14			164			165			233			245			217			217			128			76			38			151			135			132			0			165			165			6			67			101			37			160			84			42			149			33			33			128			195			65			129			230			234			107			87			87			87			215			233			211			192			238			221			59			119			190			254			58			176			105			211			139			47			110			223			78			129			11			15			7			94			120			225			217			103			127			244			35			160			164			164			184			184			184			24			56			124			248			163			143			154			155			249			56			110			28			144			27			94			80			90			90			90			90			90			202			216			67			15			125			247			187			191			252			37			101			112			32			0			188			255			254			129			3			239			188			3			72			165			18			137			84			10			20			22			46			90			100			48			0			94			175			215			203			245			123			64			28			136			207			71			46			252			253			239			159			123			238			39			63			1			220			110			130			138			167			159			126			230			153			151			94			2			66			66			148			202			176			48			114			68			112			48			160			209			104			181			58			157			168			126			38			36			232			116			90			45			144			149			149			153			153			146			2			132			135			171			84			82			41			173			17			0			192			249			243			189			189			99			99			192			240			240			216			216			196			4			96			183			79			79			59			28			192			200			8			85			158			217			76			144			37			149			74			36			114			57			176			125			251			182			109			175			188			2			180			183			183			181			53			55			3			247			222			123			223			125			143			60			66			189			231			107			95			35			25			60			16			16			223			255			248			241			214			214			198			70			145			77			121			60			30			143			219			77			149			111			179			137			227			173			169			89			183			238			7			63			0			182			110			125			243			205			191			252			229			198			129			184			33			11			146			72			164			82			133			2			168			175			175			171			219			185			147			180			159			164			36			202			100			169			20			200			201			201			205			45			44			4			194			194			84			170			240			112			17			163			125			62			202			76			191			159			32			71			16			104			1			164			164			100			201			146			138			10			224			228			201			246			246			230			102			96			239			222			61			123			182			110			37			172			150			203			137			78			222			118			27			101			230			93			119			209			113			98			162			216			60			121			2			120			60			94			47			189			33			53			66			198			130			130			24			163			37			75			153			12			24			30			182			90			39			39			129			211			167			79			156			104			109			5			90			90			154			155			63			252			144			42			82			34			1			122			122			206			157			235			232			0			230			207			207			203			43			44			4			98			99			227			227			147			146			196			113			211			42			4			245			34			133			2			48			26			171			170			238			185			135			122			135			66			33			94			231			243			249			124			30			143			216			123			84			42			242			195			244			180			205			54			49			241			5			32			40			46			46			46			46			46			142			177			196			68			226			233			15			60			240			157			239			108			220			72			52			113			114			146			154			99			123			59			112			234			212			137			19			31			127			76			37			173			80			16			219			136			136			160			166			88			80			0			164			166			166			166			102			101			17			148			72			165			128			84			202			49			157			50			199			239			103			204			239			167			158			49			49			1			180			180			28			61			90			87			7			156			59			119			238			92			111			47			65			201			204			166			42			149			74			165			114			57			45			204			4			2			148			209			50			25			65			135			211			9			16			234			19			12			49			38			66			163			193			176			116			233			242			229			64			78			78			118			118			126			62			85			170			223			47			54			251			64			32			16			240			251			105			61			193			227			161			241			200			229			192			197			139			23			46			116			119			3			135			14			125			248			225			254			253			51			33			138			254			24			12			101			101			70			35			144			147			147			147			179			104			17			48			60			60			58			218			215			7			188			250			234			150			45			207			63			79			149			226			241			92			191			2			174			57			193			105			95			95			95			95			95			95			31			97			111			80			144			136			201			25			25			233			233			249			249			180			182			27			26			10			36			38			38			39			167			166			82			101			36			36			0			135			15			31			58			180			111			31			5			168			173			13			88			185			114			213			170			251			239			7			146			146			232			58			198			2			1			98			39			188			55			80			224			148			74			90			131			13			14			14			14			86			42			137			117			208			154			48			65			154			219			77			37			207			123			138			82			73			61			128			47			105			58			157			14			135			203			69			238			167			165			70			202			96			222			132			3			1			90			51			230			149			233			114			185			92			78			167			24			96			191			159			154			63			95			129			227			172			236			239			127			255			219			223			54			109			162			249			192			162			69			64			81			209			226			197			101			101			192			201			147			39			79			54			55			3			67			67			131			131			253			253			128			205			70			21			55			52			52			52			116			225			2			160			82			209			196			242			51			67			208			193			131			7			15			30			60			40			8			124			66			242			194			11			127			252			227			142			29			192			143			127			188			113			227			253			247			3			39			78			156			56			209			210			2			188			244			210			150			45			181			181			192			192			64			127			127			127			63			69			218			235			165			18			84			171			9			27			237			118			32			57			57			37			101			222			60			114			60			101			44			65			128			211			73			3			63			115			166			163			163			173			13			56			123			150			230			3			102			179			217			60			50			2			8			2			57			210			96			40			45			53			26			129			236			236			249			243			139			138			0			153			76			42			149			201			0			171			149			92			204			29			198			89			143			68			66			231			7			7			47			94			52			153			128			83			167			78			159			110			109			5			142			29			107			105			57			116			136			50			29			0			22			47			46			46			46			43			3			42			42			150			45			187			251			110			10			232			204			74			224			244			181			176			176			176			208			96			0			250			251			251			251			207			159			23			161			73			167			139			139			75			77			5			230			205			211			235			243			242			128			127			253			107			251			246			45			91			128			111			125			171			186			122			195			6			160			174			110			255			254			93			187			110			12			65			215			4			128			87			192			208			208			208			208			208			144			136			113			119			222			185			108			217			202			149			4			37			18			9			57			130			47			106			251			253			34			187			249			224			131			247			223			223			187			23			168			172			92			190			124			205			26			218			143			19			27			75			208			53			53			5			140			143			19			173			107			108			60			124			184			190			158			104			236			212			20			80			80			80			88			120			251			237			4			97			81			81			128			203			69			189			100			239			222			119			223			125			227			13			162			159			102			51			176			116			233			29			119			172			94			77			25			237			243			81			5			201			229			226			167			213			58			57			57			57			9			236			222			253			238			187			111			190			73			247			211			104			128			7			30			120			240			193			199			31			39			22			21			26			10			52			53			29			62			220			208			0			156			56			241			201			39			71			143			138			24			207			29			239			245			82			239			74			77			213			235			51			51			197			113			229			229			229			229			153			76			98			160			57			36			95			221			19			62			173			221			176			2			0			194			104			222			92			1			128			48			152			154			42			167			157			10			133			66			33			151			3			227			227			227			227			163			163			192			251			239			55			52			188			243			14			96			50			17			93			141			136			136			140			140			138			2			252			126			175			215			235			5			82			82			210			210			244			122			96			254			252			249			243			11			11			69			214			195			3			21			20			68			236			202			106			181			90			215			172			33			22			114			248			48			80			89			89			85			117			239			189			0			165			2			65			5			167			171			114			57			112			242			228			169			83			199			143			139			153			186			114			229			93			119			221			119			31			16			17			17			17			161			213			210			253			45			22			96			193			2			98			59			39			79			82			69			239			223			255			222			123			181			181			180			139			195			108			6			250			250			76			166			158			30			113			113			62			62			62			62			62			49			145			252			179			103			15			176			122			245			55			190			241			192			3			87			78			252			8			242			104			81			255			115			7			224			234			10			160			29			9			226			121			175			151			160			70			16			136			95			243			161			242			73			121			100			100			100			100			116			52			209			203			205			155			73			42			232			236			20			33			166			181			149			28			249			240			195			235			215			191			253			54			209			207			208			80			154			217			90			44			34			230			251			253			52			176			232			232			152			24			157			14			56			119			174			187			187			163			67			132			44			142			245			82			41			177			177			64			64			16			2			1			224			244			233			246			246			99			199			0			173			86			171			141			142			6			22			46			92			184			176			184			24			232			238			238			238			62			115			70			196			126			165			82			169			84			169			168			121			22			22			2			7			15			30			56			176			123			55			240			216			99			79			60			241			243			159			3			82			41			245			166			164			164			132			132			228			100			210			148			252			126			96			211			166			231			159			127			234			41			177			87			57			157			52			51			230			198			89			227			44			86			192			127			54			206			2			40			234			20			8			30			0			149			10			208			235			245			250			121			243			8			26			100			50			160			164			164			164			164			162			66			228			207			34			116			80			83			229			153			198			51			200			235			165			109			41			124			219			73			72			72			72			72			120			56			53			57			106			122			83			83			83			83			226			121			185			156			216			17			39			5			93			93			93			93			167			78			1			106			117			84			84			84			20			237			47			242			251			197			25			110			32			64			106			43			63			78			72			72			74			74			78			166			125			77			139			22			209			134			172			241			113			241			119			211			211			164			49			185			92			30			143			211			41			206			15			174			54			198			232			250			47			92			1			92			58			184			210			229			226			39			113			25			58			230			251			118			120			61			204			108			142			94			47			137			97			156			54			122			60			148			225			129			0			241			121			137			36			36			132			40			35			7			141			43			43			142			242			26			88			176			128			28			243			232			163			143			61			246			211			159			138			162			155			88			125			244			183			74			21			30			30			17			1			212			212			84			87			87			85			137			129			33			89			66			116			92			32			64			207			227			52			216			239			247			249			136			134			18			68			242			74			228			172			139			63			135			239			65			226			205			252			106			243			251			137			109			125			90			187			70			13			229			21			192			143			37			18			162			113			60			227			249			3			102			58			140			170			128			154			176			248			34			34			235			161			193			243			45			85			226			14			55			154			105			18			123			153			121			47			162			150			60			83			169			201			123			189			62			159			211			73			19			156			233			105			192			98			177			88			38			39			233			211			98			17			117			127			151			203			233			116			58			69			205			137			79			24			121			115			189			242			41			244			94			180			211			78			36			21			87			219			204			132			224			91			26			37			18			137			228			63			85			192			213			79			185			145			93			183			2			236			118			187			221			225			0			122			122			186			187			59			59			129			208			208			176			48			149			10			112			58			93			46			135			131			180			144			176			48			130			28			141			230			127			111			246			31			230			213			156			30			10			130			184			227			140			6			66			11			38			188			153			115			71			92			25			86			186			146			7			136			127			210			191			197			74			164			127			93			91			137			28			10			102			74			10			252			9			28			234			120			37			48			198			119			232			241			223			112			89			143			143			67			16			164			82			82			71			149			74			32			60			156			228			109			155			109			122			122			166			20			33			151			147			118			245			185			3			192			43			160			164			164			164			100			201			18			198			158			125			246			183			191			125			242			73			192			96			40			47			55			26			169			185			197			197			1			109			109			109			109			45			45			192			161			67			31			124			176			119			47			101			166			197			114			45			47			231			159			98			142			83			8			120			83			227			123			61			105			144			51			115			147			127			123			181			131			174			12			16			119			146			68			66			21			230			247			211			117			34			4			138			144			64			247			191			178			82			249			252			132			107			85			87			194			223			204			204			166			10			25			25			25			30			190			112			1			104			106			250			232			163			61			123			128			248			248			196			196			140			12			146			88			150			46			5			182			110			221			186			117			203			22			98			141			159			134			142			94			183			2			120			32			138			138			138			138			22			47			102			172			161			161			174			238			157			119			136			206			69			68			0			14			199			244			244			248			56			45			33			154			76			52			65			107			111			23			4			189			94			175			215			235			105			248			60			195			105			224			28			123			103			230			24			160			84			146			74			26			26			74			252			60			16			16			187			11			209			92			42			106			17			242			174			44			124			158			167			51			123			18			253			150			36			10			169			148			36			144			168			168			168			40			173			86			252			126			124			156			18			99			106			202			102			179			90			197			64			243			138			16			195			207			37			16			186			79			102			102			102			102			102			38			144			146			114			219			109			241			241			64			93			29			105			100			3			3			3			3			253			253			34			251			26			29			29			25			25			26			186			49			33			189			110			15			224			129			104			107			107			107			59			126			92			16			12			6			131			193			96			0			70			70			70			70			70			70			4			97			124			124			124			124			120			88			116			188			209			104			52			26			141			140			241			166			37			149			114			154			200			177			149			6			198			213			83			167			147			232			224			241			227			159			124			210			210			2			212			214			110			223			254			202			43			192			129			3			13			13			59			119			82			96			123			123			69			201			130			79			124			102			230			231			204			230			205			195			51			115			65			71			161			0			26			27			63			252			240			192			1			224			229			151			95			124			241			87			191			2			106			107			183			109			251			211			159			128			150			150			198			198			186			58			106			182			110			183			184			69			145			247			42			78			51			35			35			213			106			141			70			172			148			176			176			176			176			176			48			224			204			153			51			103			206			156			33			205			170			187			91			244			15			5			66			244			223			23			174			128			235			29			55			52			52			52			52			52			92			123			94			167			211			233			116			58			198			246			239			223			191			127			231			78			96			197			138			175			127			253			155			223			20			37			132			136			8			181			58			42			138			214			102			55			111			6			98			99			227			226			180			90			90			103			216			189			155			42			174			168			136			177			241			113			179			121			112			144			28			161			86			139			226			152			8			73			87			238			154			230			21			198			155			238			212			20			65			226			246			237			111			189			245			242			203			64			103			103			103			103			71			199			181			239			107			52			86			86			42			149			140			69			71			71			71			199			199			83			6			199			196			0			23			47			246			247			155			76			192			139			47			254			225			15			79			61			69			155			143			135			135			105			102			173			82			17			205			237			234			186			190			127			174			38			51			159			217			174			142			224			103			61			94			182			108			217			178			101			203			24			227			243			137			212			212			212			212			180			52			198			52			26			141			70			163			97			108			237			218			181			107			215			174			189			254			239			43			42			42			42			42			42			24			203			200			200			200			200			206			102			108			249			242			21			43			214			172			97			108			223			190			186			186			211			167			25			219			181			107			207			158			143			63			102			236			237			183			119			237			58			122			148			177			218			218			29			59			142			28			97			108			207			158			247			222			107			111			103			140			32			237			211			191			111			124			124			124			124			124			60			237			170			208			233			24			75			73			73			78			78			75			19			207			87			85			85			85			45			95			254			249			253			113			211			2			49			219			129			187			250			56			45			45			45			45			45			141			49			190			155			130			87			152			86			171			213			106			181			140			169			213			106			181			90			45			254			231			59			189			94			175			79			79			103			44			37			37			37			37			37			133			177			217			126			159			91			230			248			155			29			184			207			122			124			245			46			132			255			183			142			157			109			199			207			246			253			110			117			197			126			101			109			182			95			252			102			59			234			191			214			209			183			218			254			207			100			232			156			205			217			156			205			217			151			111			255			3			80			244			143			206			188			145			181			235			0			0			0			0			73			69			78			68			174			66			96			130		)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/28/2005 08:54'!middle	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 193 73 68 65 84 120 218 237 154 75 170 131 48 20 134 79 46 119 168 139 112 224 182 164 224 172 148 186 153 174 197 81 119 210 81 161 123 232 68 200 29 200 69 140 143 228 228 97 212 252 223 36 40 88 234 255 229 101 56 68 0 0 0 0 56 35 82 142 91 160 242 19 230 103 17 184 41 191 118 143 45 5 44 68 236 23 58 26 158 71 64 44 49 199 29 113 129 166 32 96 138 165 0 243 30 93 215 117 93 215 67 15 85 175 185 84 85 85 85 213 113 123 188 103 212 93 206 114 235 26 252 63 243 2 146 19 98 30 188 218 134 25 1 199 21 192 156 130 76 95 116 58 69 189 94 101 89 150 68 143 71 150 101 89 236 215 222 15 158 23 97 33 198 61 92 136 203 37 207 243 156 232 253 238 186 174 35 250 124 218 182 109 137 190 223 166 105 154 227 246 220 72 44 77 45 250 197 182 23 33 229 243 89 20 69 33 101 63 34 164 212 137 88 159 114 116 109 2 232 130 143 35 34 1 184 193 135 17 145 160 0 215 224 213 158 204 21 113 182 93 144 53 220 15 44 53 184 48 34 84 78 40 230 126 191 221 174 87 251 47 91 223 34 230 73 104 74 178 37 140 8 4 207 198 143 136 105 240 56 51 98 194 21 209 223 69 240 222 209 137 232 25 130 183 91 35 128 22 93 240 126 22 107 96 200 16 124 152 93 19 88 96 57 120 136 8 138 121 240 16 17 8 110 240 16 17 8 221 182 18 34 118 2 68 236 4 156 53 237 132 109 206 154 32 64 139 169 136 254 74 23 48 4 88 195 61 226 48 107 1 155 117 17 124 1 190 10 206 146 67 21 49 14 114 187 74 191 228 153 15 114 59 17 168 231 31 225 218 163 249 101 248 40 79 39 34 151 146 203 245 251 122 32 192 136 105 201 101 127 29 251 127 157 6 251 146 75 44 198 158 112 45 56 3 150 184 6 15 17 158 64 176 145 112 173 244 3 7 231 15 70 90 152 213 40 169 61 128 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:04'!move	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 153 73 68 65 84 120 218 237 155 73 110 195 48 12 69 227 162 183 211 9 180 11 130 220 77 39 208 249 210 77 181 8 81 69 19 39 169 255 109 12 35 137 197 255 105 81 244 144 219 13 0 0 0 0 0 116 16 66 8 33 188 94 214 113 120 99 214 151 111 238 1 115 206 57 231 235 178 54 68 10 238 19 112 58 1 189 1 238 158 16 233 25 255 37 117 224 221 141 215 210 193 158 128 83 140 215 210 181 156 0 26 216 169 139 180 155 210 218 50 184 124 126 74 34 122 245 204 234 101 207 224 41 221 145 150 14 49 67 118 77 132 118 220 98 93 208 168 64 107 172 226 18 63 19 91 194 172 103 132 117 124 106 194 117 132 210 227 215 143 103 109 124 65 173 4 181 4 173 149 128 254 223 121 49 190 160 190 6 212 4 126 22 94 12 163 91 173 241 229 112 219 141 188 51 106 184 223 46 139 162 62 3 164 137 49 198 24 253 117 89 219 241 183 145 181 82 180 94 154 192 47 212 248 247 253 209 45 152 102 205 120 36 130 137 182 193 159 19 5 22 233 53 158 126 31 48 209 54 190 181 15 8 189 247 215 71 141 174 25 127 218 243 137 105 168 17 53 99 164 140 247 154 8 183 119 67 139 177 41 165 148 210 117 209 125 233 241 181 16 187 18 158 21 254 124 62 30 247 251 186 241 173 113 122 227 148 70 237 145 100 175 33 210 120 139 207 205 237 232 255 22 71 129 45 16 60 3 158 163 123 6 140 214 74 239 198 207 198 201 189 102 12 151 32 26 128 155 23 150 22 105 189 96 38 181 88 31 211 206 113 163 165 151 109 17 182 110 231 118 213 193 222 5 237 154 8 171 184 217 254 31 176 123 9 114 255 146 177 187 128 224 3 0 0 0 0 192 198 252 0 102 116 72 96 211 171 62 8 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 3/22/2006 10:38'!moveObject	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 3 197 73 68 65 84 56 203 205 149 219 107 28 85 28 199 127 51 231 204 206 236 165 201 54 187 221 100 215 166 209 104 188 164 165 193 75 189 165 40 74 109 73 74 8 40 136 79 17 250 32 69 240 81 241 193 23 255 13 125 146 22 4 219 162 105 170 62 72 17 74 235 173 52 77 27 67 211 244 146 205 50 187 217 251 236 206 204 206 204 185 205 241 33 208 37 65 155 60 244 193 207 243 151 15 191 239 57 156 223 81 164 148 240 40 80 225 17 129 119 152 59 250 209 124 143 30 211 176 202 5 56 140 249 150 109 123 246 245 243 199 186 9 185 3 222 154 249 253 212 108 213 44 147 142 207 93 143 175 21 131 175 207 20 15 189 119 233 233 163 103 31 100 182 23 189 48 117 254 199 75 245 82 149 84 155 180 209 98 213 38 45 85 137 89 14 190 255 101 253 153 137 179 185 131 95 110 196 30 86 237 205 183 243 134 210 84 227 70 58 169 149 107 76 195 10 194 32 56 48 46 153 16 153 221 26 235 248 156 213 182 57 163 241 241 149 190 30 45 26 21 133 102 121 238 215 194 232 72 191 142 84 69 129 48 148 52 12 5 97 11 203 117 65 44 230 175 63 76 52 54 182 208 211 151 192 88 134 216 114 156 149 31 102 229 226 232 176 107 94 185 124 225 243 227 51 95 165 250 95 42 212 189 252 106 149 249 235 204 41 255 167 104 242 113 48 98 17 61 136 128 130 72 39 17 58 229 6 15 232 13 59 29 156 243 8 71 8 31 152 248 54 112 37 101 21 226 175 113 97 253 187 104 98 64 244 15 160 38 173 135 24 252 48 17 18 136 134 189 245 218 181 192 94 213 163 46 8 14 0 141 252 13 9 156 122 197 192 94 22 172 189 85 116 226 139 139 157 133 199 162 195 123 244 148 164 5 51 38 4 81 153 8 152 161 140 170 116 201 181 255 220 181 63 199 125 27 0 28 235 55 224 140 179 150 160 14 245 204 77 162 153 79 127 238 77 196 219 54 142 233 160 42 42 230 110 195 206 235 200 17 4 179 0 18 202 225 80 211 24 51 65 208 233 169 201 217 185 159 84 188 75 48 123 235 19 121 247 227 115 42 86 49 82 73 199 226 224 217 190 18 215 211 129 115 183 221 250 187 233 220 33 158 213 114 254 176 91 115 217 108 22 84 24 25 26 12 5 15 185 83 171 86 18 241 216 38 17 37 65 200 67 46 66 139 221 243 220 82 187 99 101 244 215 148 48 225 186 183 3 111 193 37 75 46 185 224 216 246 228 228 59 32 229 129 103 135 1 148 207 62 57 153 78 167 79 126 248 193 233 211 167 186 213 28 171 162 27 8 69 52 137 42 101 47 136 42 54 129 190 92 98 202 164 134 229 93 21 180 14 0 29 167 37 165 20 180 99 54 218 194 107 228 134 246 57 173 154 145 76 155 166 217 157 200 106 220 179 42 69 199 169 169 189 194 229 55 235 244 74 213 191 220 38 215 176 150 233 143 140 247 168 99 0 64 41 221 221 19 167 190 119 228 141 215 87 110 47 77 31 63 86 41 21 78 188 63 29 215 194 238 68 110 179 196 57 37 180 19 207 238 105 212 60 187 115 87 1 13 88 60 20 10 227 62 13 171 8 192 247 188 231 159 27 94 47 87 51 201 56 165 20 243 78 181 92 77 166 50 149 82 177 43 162 196 246 138 101 215 50 141 88 58 154 74 33 22 247 218 235 156 23 4 35 146 10 33 85 0 200 23 10 139 11 243 47 31 28 17 82 18 223 87 85 5 35 124 245 250 197 59 247 215 54 68 202 198 134 236 27 216 79 2 11 33 61 18 77 98 205 64 88 231 196 35 190 37 67 209 110 220 7 128 39 247 13 142 31 126 117 111 110 96 111 54 29 248 68 215 35 24 161 191 230 23 191 249 238 12 167 178 43 2 128 100 102 132 6 118 40 184 162 34 140 12 85 139 168 42 182 42 203 15 46 56 149 76 190 114 232 197 236 64 63 132 52 106 232 102 217 186 121 235 86 97 53 207 55 12 114 199 32 13 48 64 2 33 3 64 7 0 128 167 158 24 66 26 108 191 143 182 32 25 84 204 130 237 56 148 50 35 166 71 227 137 220 208 224 70 175 77 213 254 47 191 200 63 151 156 177 64 253 10 252 215 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:04'!parallel	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 160 73 68 65 84 120 218 237 217 33 142 194 64 20 198 241 233 250 17 40 116 69 19 36 2 138 168 196 115 3 154 106 18 210 27 204 45 240 156 1 13 178 130 130 64 146 112 2 20 2 129 124 136 221 102 67 147 102 187 48 125 125 109 191 191 33 164 1 166 239 151 161 98 148 66 8 49 182 94 39 201 102 67 84 247 58 164 244 197 245 67 243 185 49 203 37 81 154 158 78 199 35 32 178 216 0 14 135 36 217 239 149 186 223 175 215 219 77 41 64 124 231 112 255 224 96 48 157 250 62 209 120 28 4 147 137 82 90 247 251 189 158 82 190 63 28 142 70 74 69 81 16 204 102 14 251 186 234 138 109 7 24 99 140 49 68 231 243 110 151 166 142 131 29 193 84 54 248 162 247 217 142 200 158 17 139 197 106 101 12 17 32 44 7 8 33 189 14 62 255 10 136 138 43 26 60 17 118 4 107 197 131 7 196 79 143 71 28 199 177 237 27 204 127 95 241 224 59 11 177 221 186 174 235 18 93 46 158 231 121 68 118 32 202 127 190 243 16 81 164 181 214 68 118 32 222 31 8 32 62 130 176 55 128 206 65 132 97 24 134 225 239 194 255 7 81 221 13 183 30 34 63 248 207 32 170 11 16 128 224 9 16 66 2 132 144 0 33 36 64 8 9 16 66 2 132 144 0 33 36 64 8 9 16 66 2 132 144 154 9 209 194 51 107 217 16 29 58 179 110 10 4 254 154 88 33 236 159 89 215 61 223 210 213 11 97 255 204 186 232 186 248 120 33 170 59 179 110 220 224 243 85 11 193 119 102 221 248 236 66 240 157 89 183 46 89 15 235 14 7 8 33 1 66 72 128 16 18 32 132 244 46 68 221 235 110 93 101 33 138 174 35 75 253 5 129 193 51 133 193 11 9 131 71 47 61 1 49 101 139 124 116 26 58 40 0 0 0 0 73 69 78 68 174 66 96 130) ! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:05'!perpendicular	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 43 73 68 65 84 120 218 237 154 177 106 194 64 24 199 191 136 171 248 2 5 201 32 244 9 220 83 55 103 87 131 155 80 16 103 151 27 178 244 5 218 221 193 39 112 112 210 209 193 232 208 177 80 40 20 92 74 133 34 25 186 8 215 233 40 124 114 36 198 187 220 93 242 253 22 137 201 93 46 191 63 201 229 114 7 64 16 4 65 16 4 65 16 4 65 16 4 65 84 158 223 223 201 100 50 225 220 116 59 42 199 106 229 251 190 207 249 251 123 187 221 110 115 78 65 220 198 108 182 217 44 22 114 127 53 252 199 124 126 60 30 143 0 159 159 231 243 249 12 112 56 44 151 203 165 237 119 132 125 237 18 226 227 248 245 117 191 7 24 12 24 27 143 47 219 89 187 44 152 36 73 226 121 110 6 97 30 44 62 73 190 190 126 126 0 118 187 205 102 187 189 60 254 34 128 48 12 195 48 228 156 130 184 142 52 241 111 111 235 117 28 123 158 180 2 33 94 182 61 28 54 26 141 6 231 118 246 17 230 206 47 196 63 62 190 188 48 198 185 120 212 220 223 119 187 157 206 127 187 24 99 140 177 12 237 116 51 136 226 207 155 87 124 73 130 16 245 167 253 58 40 30 227 102 16 234 41 92 60 198 141 32 212 99 92 60 198 238 32 212 97 157 120 76 89 131 176 94 60 166 44 65 56 39 30 99 54 136 252 229 157 23 143 41 54 8 124 124 246 242 165 19 143 209 27 68 254 253 165 23 143 81 27 68 254 59 164 114 226 49 166 250 136 202 139 199 20 21 4 137 79 65 87 16 36 254 74 84 5 65 226 111 36 111 16 36 94 49 89 131 32 241 154 145 5 145 38 94 60 154 92 17 239 221 94 133 94 132 248 135 135 209 168 223 7 144 205 185 62 63 127 124 124 127 3 180 90 245 122 189 14 112 119 215 235 245 122 0 79 79 205 102 179 9 16 69 81 20 69 158 117 215 91 187 189 10 189 164 137 23 147 221 178 197 3 211 233 233 116 58 153 190 10 57 214 6 144 117 149 65 16 4 65 16 208 42 14 101 100 237 92 133 120 217 182 43 159 193 173 33 239 91 13 22 239 234 124 132 49 84 189 78 150 101 98 168 48 116 189 199 231 13 194 180 143 194 209 61 128 202 26 132 108 127 105 193 34 117 143 92 211 130 168 140 120 76 154 104 213 35 87 18 47 161 232 79 6 36 94 130 173 223 106 116 243 7 21 204 94 20 55 57 135 172 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:05'!pointDefinedByCoordinates	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 180 73 68 65 84 120 218 237 154 193 205 194 48 12 133 211 95 140 192 22 12 193 0 156 184 230 10 136 9 58 69 87 224 156 43 39 6 96 8 182 96 135 254 39 11 41 81 112 210 66 253 76 252 93 162 170 45 181 223 139 157 138 198 57 195 48 12 173 140 163 116 4 218 233 166 221 150 19 190 155 248 123 237 82 41 88 233 140 55 35 22 194 90 208 92 254 164 3 104 157 85 221 229 54 227 193 48 67 230 98 45 72 24 51 64 152 70 215 128 56 15 185 215 230 202 10 160 64 181 190 231 227 77 160 196 128 221 174 239 183 91 188 64 203 160 184 227 17 151 108 5 144 17 186 13 33 112 255 58 73 2 224 4 63 30 135 225 249 148 14 59 101 191 119 238 241 168 78 191 243 222 123 239 199 49 132 16 66 72 143 23 79 36 158 249 239 13 65 173 140 92 43 122 141 36 52 221 17 31 139 81 215 114 0 2 126 27 151 98 35 234 18 69 161 92 248 120 84 34 60 234 91 70 169 208 233 245 74 132 231 18 151 134 23 158 132 190 94 157 219 108 212 183 158 56 113 105 120 225 233 152 12 200 157 87 102 4 110 160 57 97 149 87 0 234 26 240 130 19 150 171 0 101 224 6 206 85 128 116 124 31 2 47 145 243 249 116 58 28 202 43 64 57 250 18 65 51 160 209 239 1 56 52 246 61 0 15 251 36 41 140 25 32 140 173 1 194 216 26 32 140 181 32 97 204 0 97 108 13 16 198 214 0 97 172 5 125 133 242 78 97 6 124 21 222 136 213 212 27 231 93 143 194 82 113 211 115 210 214 157 49 160 180 199 231 126 56 255 192 182 206 243 122 54 215 130 46 151 190 95 175 151 122 26 63 145 103 58 200 205 4 28 114 27 206 110 183 97 184 223 97 182 167 199 130 210 168 181 199 227 243 243 45 136 219 106 9 186 251 27 119 215 131 97 124 148 127 134 246 108 126 47 30 109 160 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:05'!polygon	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 9 92 73 68 65 84 120 218 237 91 107 76 155 101 27 190 74 129 210 195 91 218 66 143 208 150 114 42 39 41 200 32 50 220 208 56 141 75 22 77 22 157 51 51 131 4 231 70 68 102 166 176 17 127 204 68 127 105 162 46 152 37 102 25 78 101 33 217 146 109 49 100 51 134 140 48 53 49 147 127 75 212 132 31 99 39 206 231 210 183 156 74 253 113 231 249 234 247 242 189 225 208 246 165 240 113 253 121 211 62 240 230 121 238 235 62 223 79 129 29 236 64 74 212 214 114 28 199 5 131 236 185 217 251 137 219 236 13 72 5 161 192 11 11 149 74 165 18 184 126 61 43 43 43 43 24 28 25 57 122 244 232 81 233 9 137 223 108 193 68 11 98 26 158 153 153 152 152 152 8 228 230 38 37 37 37 1 46 151 94 175 215 3 193 224 236 236 236 172 244 251 220 182 4 8 161 84 202 229 114 57 224 241 168 213 106 53 224 114 89 44 22 11 160 209 208 103 133 66 165 82 169 164 223 215 182 33 64 76 227 51 50 116 58 157 14 40 40 144 201 100 50 192 225 32 193 3 28 199 113 192 159 127 62 120 240 224 1 80 90 74 150 33 53 182 124 12 88 45 152 122 60 9 9 9 9 64 81 17 9 62 35 163 172 172 172 12 248 226 139 187 119 239 222 5 30 62 244 251 253 126 192 231 27 24 24 24 0 252 254 198 198 198 70 233 98 193 150 37 64 76 240 121 121 228 82 94 125 53 53 53 53 21 40 46 166 207 147 147 46 151 203 5 124 248 225 139 47 126 245 85 232 239 103 102 22 23 23 23 1 158 39 34 252 254 225 225 225 97 233 206 177 229 8 16 19 60 203 106 158 121 134 124 121 81 145 195 225 112 0 28 71 130 111 107 123 227 141 239 191 7 2 129 154 154 212 84 96 121 121 255 254 253 251 129 191 255 38 193 243 60 123 83 48 40 101 46 180 101 8 16 19 188 209 72 46 166 164 132 8 72 75 75 75 75 75 3 244 122 147 201 100 2 90 90 106 107 175 94 253 31 7 143 187 117 235 214 173 208 231 193 193 249 249 249 121 128 231 39 39 39 39 165 59 87 204 19 32 38 120 143 135 130 104 117 53 165 145 78 167 213 106 181 2 41 41 54 155 205 6 156 62 253 230 155 237 237 33 141 103 79 185 252 187 239 198 198 66 79 134 161 33 114 69 126 255 227 199 143 31 3 62 95 125 125 125 125 244 109 33 102 9 16 19 124 101 165 70 163 209 0 79 61 165 213 106 181 64 65 1 9 222 110 175 168 168 168 0 154 154 200 213 172 23 127 252 225 243 249 124 128 207 183 188 188 188 12 44 44 76 77 77 77 69 255 156 49 151 134 138 251 120 242 237 89 89 164 249 110 183 193 96 48 0 106 53 249 250 134 134 231 158 251 252 243 144 166 51 8 53 93 108 157 125 207 243 129 64 32 0 0 148 182 70 27 49 67 128 152 224 159 126 154 178 152 138 10 18 124 90 90 118 118 118 54 160 84 146 207 111 106 122 237 181 111 191 141 220 62 88 44 112 58 165 201 134 54 157 0 49 193 187 221 212 42 200 207 39 65 155 205 233 233 233 233 128 86 75 193 245 212 169 87 94 249 230 155 141 107 188 216 250 232 232 210 210 210 18 192 243 79 158 60 121 2 120 189 199 142 29 59 22 12 114 220 133 11 23 46 68 222 38 54 141 0 49 193 239 221 155 156 156 156 12 216 237 164 241 6 3 249 124 151 171 187 187 187 91 38 171 171 187 118 109 126 62 122 193 241 247 223 169 39 84 89 73 193 61 16 160 52 53 90 144 156 0 161 224 19 19 201 197 60 251 44 245 106 152 111 183 90 73 211 83 83 11 11 11 11 129 186 186 150 150 95 127 13 6 35 173 241 98 235 60 79 174 40 24 140 110 93 32 89 22 36 20 124 106 106 74 74 74 10 224 118 211 1 115 114 40 171 97 189 26 135 163 171 171 171 75 38 123 239 189 234 234 207 62 147 106 151 33 12 12 44 44 44 44 0 60 79 45 138 104 33 234 22 32 222 50 160 188 187 172 140 136 176 90 243 242 242 242 128 143 62 122 235 173 142 14 160 174 238 196 9 64 58 141 23 98 98 130 178 33 191 127 124 124 124 60 122 242 137 154 5 8 5 111 52 82 26 201 242 248 146 18 210 120 163 49 35 35 35 3 224 56 42 160 98 5 191 253 230 245 122 189 192 232 40 41 202 240 112 116 6 54 17 183 128 149 174 38 62 62 62 30 40 47 167 118 175 203 69 77 50 139 133 130 236 217 179 111 191 125 253 122 232 255 165 214 248 213 214 167 167 89 16 102 245 65 140 18 176 82 227 89 254 78 189 26 183 155 124 187 217 76 149 235 233 211 221 221 221 221 128 92 30 249 67 69 18 172 48 91 90 162 22 69 164 17 54 1 66 193 179 1 136 221 78 27 207 205 165 180 210 106 37 23 115 230 76 77 205 149 43 128 92 94 91 11 196 158 198 11 43 227 153 25 106 77 248 253 228 146 34 141 13 199 0 161 224 61 30 242 241 121 121 113 113 113 113 64 101 165 217 108 54 3 54 91 65 65 65 1 208 212 116 251 246 237 219 145 63 64 180 49 60 204 230 5 244 156 157 61 126 252 248 241 200 197 130 117 91 128 80 240 102 51 185 24 155 141 158 133 133 228 227 245 122 106 11 159 57 115 248 240 15 63 0 114 249 225 195 64 236 106 188 216 250 95 127 81 12 216 189 155 10 180 197 197 200 90 194 154 45 64 40 120 135 131 130 106 85 21 5 83 54 0 97 249 125 75 11 249 248 237 130 241 113 114 169 62 95 100 99 193 170 22 32 20 124 102 38 5 87 54 196 206 201 161 30 141 201 68 4 52 53 189 254 250 165 75 128 92 126 226 4 16 123 26 189 209 117 175 151 98 193 220 220 220 220 220 92 228 8 16 181 0 161 224 139 138 40 111 207 207 87 40 20 10 32 39 135 122 37 38 147 221 110 183 3 167 78 117 118 118 118 70 110 99 177 134 135 15 217 196 140 231 121 62 114 195 251 21 22 32 20 124 121 57 107 134 81 87 210 237 166 30 141 78 231 116 58 157 255 214 248 67 135 128 216 209 216 72 173 51 244 245 145 230 79 79 211 224 134 231 7 7 7 7 195 21 255 191 44 64 204 199 103 101 177 155 100 148 199 127 242 201 189 123 247 238 1 31 124 176 189 53 158 225 210 37 175 215 235 13 181 161 167 166 40 22 204 205 141 140 140 140 132 255 126 153 80 240 121 121 164 233 101 101 76 243 73 211 63 253 180 183 183 183 119 243 53 114 179 215 247 237 163 186 166 178 146 92 175 197 82 90 90 90 10 168 213 231 207 159 63 191 254 121 193 138 24 80 89 73 233 99 97 97 113 113 113 49 96 50 101 102 102 102 134 203 243 246 65 87 215 244 244 244 52 192 243 51 51 51 51 64 92 28 165 223 27 197 138 24 48 62 78 21 107 110 46 5 155 184 56 114 61 194 10 145 97 179 53 82 170 245 139 23 15 30 84 40 100 255 241 24 83 83 36 31 159 239 209 163 71 143 194 32 128 249 56 246 226 31 127 188 115 231 206 29 64 161 160 193 136 197 210 223 223 223 15 52 55 247 246 86 85 1 106 117 73 73 73 9 160 82 145 165 40 149 61 61 205 205 128 82 121 238 220 185 115 50 89 172 220 187 143 52 132 231 154 157 141 204 237 137 21 62 75 76 128 123 246 80 193 101 50 81 119 211 96 160 167 94 79 62 145 227 232 169 80 80 157 192 110 43 188 251 110 123 123 123 123 232 61 98 26 37 92 103 136 53 139 96 120 225 5 58 239 238 221 116 78 155 173 188 188 188 60 164 136 107 37 96 133 11 18 70 125 38 160 95 126 17 43 193 71 71 71 71 129 67 135 168 2 214 104 232 58 135 193 208 215 215 215 7 156 61 203 130 20 213 17 9 9 87 175 214 214 2 95 127 125 242 228 201 147 193 96 125 125 91 91 91 91 232 109 140 152 104 207 126 195 197 253 251 148 150 150 148 208 77 186 96 112 99 237 234 176 167 252 171 185 156 151 94 34 77 97 105 173 90 77 4 105 181 228 226 52 26 106 79 199 199 83 129 167 80 80 129 215 208 208 209 209 209 177 249 26 47 182 110 177 80 240 61 112 128 206 231 118 123 60 30 15 96 52 222 184 113 227 70 24 22 176 94 8 45 70 72 204 207 63 83 214 32 68 85 21 5 177 204 204 177 177 177 49 64 167 163 3 113 28 205 136 155 155 119 237 218 181 11 48 24 174 93 171 171 3 146 146 136 184 247 223 15 119 199 145 193 226 34 237 211 239 167 231 70 111 79 72 112 247 235 191 177 214 32 253 242 203 52 87 112 56 168 46 209 235 201 66 212 106 170 79 216 173 103 185 156 214 27 27 175 92 161 57 131 52 49 128 225 249 231 201 181 238 217 67 163 85 171 149 20 103 173 177 64 242 107 41 98 22 195 192 8 250 233 39 202 46 172 86 42 253 157 78 34 192 96 32 159 107 181 14 13 13 13 1 58 29 37 7 31 127 76 67 125 165 242 226 197 131 7 1 173 150 110 208 5 2 71 142 28 57 2 52 52 92 190 124 249 114 248 251 23 166 227 161 30 17 197 194 64 96 125 205 58 201 45 96 189 88 205 98 138 139 105 16 148 158 78 49 70 175 167 251 69 70 35 89 6 199 145 37 41 149 244 119 42 21 197 28 133 130 146 6 161 166 174 55 43 99 120 231 29 163 209 104 4 114 114 168 128 93 107 44 136 121 2 196 32 70 140 78 71 4 104 52 244 100 87 27 141 70 150 54 211 247 201 201 44 9 160 160 159 144 64 4 169 213 212 98 80 169 90 91 91 91 67 2 100 89 153 24 1 53 53 68 64 126 62 89 162 197 114 243 230 205 155 219 152 0 49 172 102 49 108 130 231 116 146 197 184 221 68 16 203 206 146 147 201 213 105 52 212 17 72 74 34 31 239 247 83 125 51 49 65 159 91 91 247 237 251 242 203 144 69 84 87 211 247 213 213 235 139 5 219 142 0 49 172 53 248 23 21 17 33 46 23 17 97 179 209 147 227 104 93 163 161 118 60 35 136 253 182 248 254 253 137 137 137 9 32 59 155 234 1 187 189 167 167 167 231 255 208 2 54 138 213 8 98 191 79 48 155 201 149 49 130 180 90 102 49 116 25 65 163 161 236 204 108 238 236 236 236 220 33 32 108 172 213 114 246 238 101 173 26 114 109 7 14 244 247 247 247 75 241 19 143 29 236 96 43 227 31 155 227 168 4 251 87 97 42 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:06'!property	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 8 232 73 68 65 84 120 218 237 91 71 72 124 189 23 189 118 84 176 160 130 189 128 136 88 113 41 138 5 68 172 8 54 176 131 11 43 130 32 98 69 65 193 130 226 198 133 109 161 27 11 136 136 88 112 225 194 238 194 133 21 43 138 189 96 239 221 247 95 12 135 252 191 153 111 190 153 167 51 234 175 156 77 200 155 188 188 228 156 228 222 228 38 67 244 23 127 241 39 67 129 95 113 142 251 238 6 255 76 40 240 228 241 255 222 148 174 24 35 222 211 211 211 211 211 83 254 93 226 56 142 147 165 220 178 170 111 126 126 126 126 126 158 232 234 234 234 234 234 74 248 87 254 66 72 120 129 53 249 252 252 252 252 252 156 72 71 71 71 71 71 71 118 4 8 63 151 119 57 89 213 63 54 54 54 54 54 70 148 147 147 147 147 147 67 180 176 176 176 176 176 192 95 8 169 5 120 127 127 127 127 127 39 122 122 122 122 122 122 34 122 126 126 126 126 126 230 47 196 239 2 5 5 5 5 5 5 162 203 203 203 203 203 75 162 192 192 192 192 192 64 254 66 240 22 224 230 230 230 230 230 134 165 210 54 84 210 243 95 173 28 242 138 138 138 138 138 138 31 23 66 81 50 133 31 195 79 33 74 94 229 0 12 76 109 109 109 109 109 109 162 190 190 190 190 190 62 34 71 71 71 71 71 71 148 18 239 125 100 46 192 79 35 10 207 219 219 219 219 219 219 137 66 66 66 66 66 66 136 244 244 244 244 244 244 136 172 172 172 172 172 172 136 22 23 23 23 23 23 63 255 93 8 209 219 219 219 219 219 75 228 224 224 224 224 224 32 94 8 153 9 240 211 136 239 232 232 232 232 232 32 114 113 113 113 113 113 33 202 200 200 200 200 200 96 68 39 36 36 36 36 36 176 247 131 131 131 131 131 131 69 133 144 246 187 200 35 133 16 173 173 173 173 173 173 194 181 49 33 62 45 192 79 33 30 196 121 123 123 123 123 123 51 194 177 106 169 170 170 170 170 170 34 218 218 218 218 218 218 34 106 105 105 105 105 105 33 26 30 30 30 30 30 102 245 5 5 5 5 5 5 49 27 46 45 241 226 132 48 51 51 51 51 51 35 114 115 115 115 115 115 19 237 151 242 239 66 60 76 203 245 245 245 245 245 53 81 113 113 113 113 113 49 19 2 56 59 59 59 59 59 99 66 216 216 216 216 216 216 48 33 48 99 6 6 6 6 6 6 136 156 156 156 156 156 156 62 222 94 73 144 90 0 73 27 153 239 38 94 87 87 87 87 87 151 104 104 104 104 104 104 136 200 216 216 216 216 216 152 232 240 240 240 240 240 240 95 58 174 172 172 172 172 76 180 189 189 189 189 189 205 102 8 0 19 242 217 246 74 226 237 195 51 224 187 136 71 190 176 176 176 176 176 144 117 176 161 161 161 161 161 129 17 119 119 119 119 119 119 71 164 170 170 170 170 170 42 190 253 185 185 185 185 185 185 68 221 221 221 221 221 221 68 209 209 209 209 209 209 68 105 105 105 105 105 105 242 35 158 183 0 194 21 126 23 241 192 196 196 196 196 196 4 81 120 120 120 120 120 56 145 173 173 173 173 173 173 180 189 33 202 202 202 202 202 202 18 37 190 174 174 174 174 174 78 118 253 146 153 0 226 240 213 196 11 195 194 194 194 194 194 130 72 77 77 77 77 77 77 114 123 75 74 74 74 74 74 136 186 186 186 186 186 186 228 71 188 220 77 208 119 17 47 252 252 224 224 224 224 224 64 122 1 12 12 12 12 12 12 88 62 53 53 53 53 53 149 255 119 199 199 199 199 199 199 89 76 8 203 88 56 109 105 77 144 212 203 208 175 114 194 210 190 135 229 29 156 49 108 189 164 84 56 154 11 83 38 237 119 177 174 247 247 247 247 247 247 39 42 43 43 43 43 43 35 242 243 243 243 243 243 99 209 82 225 25 32 142 191 15 239 3 240 129 175 38 30 121 119 119 119 119 119 119 182 94 223 223 223 223 223 223 23 141 85 9 167 120 15 192 8 150 150 248 148 148 148 148 148 20 34 103 103 103 103 103 103 230 67 0 8 49 55 55 55 55 55 39 153 71 185 207 0 89 19 15 32 232 37 76 208 206 206 206 206 206 142 248 244 241 241 241 241 241 145 109 184 96 74 96 138 80 15 226 253 226 136 199 190 1 245 32 15 224 249 191 159 27 124 64 0 190 196 203 187 28 4 208 210 210 210 210 210 98 65 48 68 39 197 165 15 15 15 15 15 15 108 21 100 105 105 105 105 105 201 136 134 16 166 166 166 166 166 166 226 137 127 123 123 123 123 123 99 51 16 27 186 204 204 204 204 204 76 182 33 252 103 84 84 134 2 124 23 241 120 222 214 214 214 214 214 198 58 10 66 140 140 140 140 140 140 136 212 213 213 213 213 213 69 83 140 72 56 203 233 233 233 233 233 105 162 139 139 139 139 139 11 102 82 16 43 194 70 79 120 132 31 29 29 29 29 29 49 223 130 13 29 234 195 192 16 23 130 0 62 189 19 254 46 226 211 211 211 211 211 211 69 71 38 108 189 164 85 17 78 248 144 170 168 168 168 168 168 48 31 1 39 139 122 80 239 241 241 241 241 241 177 104 253 24 8 8 97 224 253 95 118 25 202 151 120 13 13 13 13 13 13 70 132 164 29 176 56 220 223 223 223 223 223 179 20 33 139 215 215 215 215 215 87 241 245 246 244 244 244 244 244 176 124 64 64 64 64 64 128 20 60 254 247 207 76 59 56 47 28 73 34 149 55 241 176 161 30 30 30 30 30 30 44 212 48 59 59 59 59 59 75 100 98 98 98 98 98 194 70 50 14 72 190 10 16 220 199 199 199 199 199 135 72 73 73 73 73 73 137 45 71 225 115 66 67 67 67 67 67 137 38 39 39 39 39 39 89 47 127 108 44 8 196 99 131 3 226 49 226 225 36 113 20 40 236 108 191 10 53 53 53 53 53 53 68 123 123 123 123 123 123 68 77 77 77 77 77 77 114 136 5 125 23 241 0 136 199 9 19 108 50 95 194 97 194 224 140 97 42 176 170 130 208 146 80 95 95 95 95 95 79 212 216 216 216 216 216 200 218 27 31 31 31 31 31 207 70 62 32 214 135 254 247 103 216 43 168 16 183 33 144 126 21 241 56 99 189 189 189 189 189 189 229 127 207 7 209 77 28 77 138 3 86 45 248 158 176 32 253 253 253 253 253 253 108 7 14 211 216 217 217 217 217 217 201 174 237 192 100 195 151 192 4 77 77 77 77 77 77 177 222 75 104 54 186 200 113 2 1 56 78 48 114 56 238 244 244 244 244 244 84 52 21 28 120 176 84 96 155 69 83 193 178 143 227 70 71 71 71 71 71 57 78 208 81 150 206 204 204 204 204 204 112 156 192 215 112 156 192 212 240 79 5 235 122 214 15 193 6 137 227 4 49 36 142 19 132 177 57 78 32 60 199 153 155 155 155 155 155 179 242 194 169 32 248 199 113 213 213 213 213 213 213 172 125 72 5 3 147 125 95 112 30 193 113 174 174 174 174 174 174 194 245 241 152 1 80 242 229 229 229 229 229 133 165 242 26 241 118 118 118 118 118 118 108 36 241 5 54 86 24 249 88 247 15 14 14 14 14 14 138 94 48 147 245 170 14 22 3 231 18 97 97 97 97 97 97 162 51 64 238 203 80 225 231 176 189 177 177 177 177 177 177 44 143 13 144 189 189 189 189 189 61 35 94 92 125 63 149 120 228 229 126 32 195 183 193 32 26 35 30 177 153 230 230 230 230 230 102 230 4 63 59 226 17 74 248 46 226 249 242 38 247 88 144 48 241 48 61 32 62 38 38 38 38 38 230 247 35 94 90 200 109 25 42 137 248 200 200 200 200 200 72 230 91 248 2 59 227 239 54 53 146 202 201 76 0 105 99 65 146 136 135 51 250 40 241 184 112 133 235 38 124 137 255 168 239 250 104 185 47 139 5 73 34 94 248 222 14 95 44 45 45 45 45 45 17 21 20 20 20 20 20 176 245 57 110 67 200 138 120 89 9 244 229 78 24 171 26 16 143 139 81 112 174 8 25 240 197 242 242 242 242 242 50 81 84 84 84 84 84 20 235 32 70 60 130 114 95 69 188 172 76 15 111 1 196 1 91 123 156 44 33 142 158 156 156 156 156 156 204 130 100 124 177 178 178 178 178 178 66 20 23 23 23 23 23 199 66 14 63 157 120 228 165 21 228 195 51 0 196 195 25 98 6 20 21 21 21 21 21 17 9 118 198 252 137 95 93 93 93 93 93 37 74 76 76 76 76 76 252 245 136 231 11 222 51 160 188 188 188 188 188 92 148 248 188 188 188 188 188 60 118 178 196 23 107 107 107 107 107 107 68 73 73 73 73 73 73 44 172 251 187 18 207 91 0 216 240 138 138 138 138 138 10 209 107 223 146 14 159 197 97 125 125 125 125 125 157 205 168 63 133 120 222 2 8 31 46 251 250 250 250 250 250 178 152 7 4 64 57 67 67 67 67 67 67 34 107 107 107 107 107 107 209 250 16 213 44 45 45 45 45 45 101 121 220 80 67 216 25 103 189 210 118 88 94 229 96 130 165 125 15 39 104 50 19 64 216 7 232 235 235 235 235 235 139 158 144 33 76 125 114 114 114 114 114 194 46 80 1 8 78 101 103 103 103 103 103 19 109 108 108 108 108 108 16 213 214 214 214 214 214 18 69 68 68 68 68 68 136 238 140 191 250 223 148 146 158 203 10 82 11 0 211 3 192 102 227 82 44 110 29 32 152 134 145 2 65 64 124 126 126 126 126 126 62 209 230 230 230 230 230 38 27 233 187 187 187 187 187 187 68 149 149 149 149 149 149 146 219 35 45 49 178 46 199 23 176 12 255 140 130 50 72 105 197 68 155 166 169 169 169 169 169 201 46 187 226 126 141 48 64 60 86 71 248 99 196 159 13 102 196 62 233 70 56 14 183 17 188 188 188 188 188 188 216 109 101 152 160 145 145 145 145 145 17 150 23 110 192 159 14 25 17 33 237 228 253 75 252 95 252 48 252 15 157 2 91 74 184 1 204 172 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:06'!ray	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 149 73 68 65 84 120 218 237 154 61 14 130 48 24 134 91 103 56 4 3 215 106 76 186 25 35 151 241 8 14 156 128 201 155 56 153 56 178 187 144 212 161 49 198 250 83 104 191 210 79 121 159 173 4 18 120 31 126 90 242 10 1 120 97 76 219 182 173 49 185 207 99 113 28 143 85 85 85 198 156 78 117 93 215 198 64 68 38 92 17 215 107 211 52 13 68 164 98 229 110 56 28 250 190 239 133 56 159 135 97 24 132 184 92 186 174 235 132 128 136 196 40 165 148 82 143 128 215 235 178 44 75 99 226 158 136 251 126 16 247 17 55 120 26 17 110 240 16 224 101 172 8 59 242 5 12 1 193 248 68 88 124 34 16 124 52 223 69 64 192 108 196 138 208 90 107 173 31 199 187 99 48 146 216 87 17 130 39 37 244 85 4 17 46 171 105 187 143 13 78 74 119 139 157 190 10 177 223 23 69 81 228 190 108 62 76 20 224 67 202 231 59 92 74 59 125 197 202 154 136 207 179 28 223 199 150 102 101 13 94 240 5 15 17 137 152 26 60 68 16 17 27 124 154 159 126 11 100 234 2 43 205 79 191 5 178 219 109 183 155 77 248 202 22 34 152 0 17 76 128 8 38 64 4 19 66 69 160 197 65 12 158 8 38 64 4 19 32 130 9 16 193 4 136 96 2 68 48 1 34 152 48 143 8 212 110 188 160 114 201 4 84 46 153 128 202 37 19 168 43 151 232 57 5 226 138 120 14 18 5 179 217 120 31 228 124 34 100 232 129 255 73 236 29 45 39 231 73 220 140 251 85 194 43 151 223 183 251 129 128 81 188 86 46 237 56 247 121 253 13 225 149 75 124 140 137 136 45 156 129 64 98 131 135 8 34 16 108 38 98 155 126 224 199 185 1 85 109 241 171 221 62 127 106 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 6/21/2007 16:23'!redo	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 8 6 0 0 0 87 2 249 135 0 0 0 6 98 75 71 68 0 255 0 255 0 255 160 189 167 147 0 0 0 9 112 72 89 115 0 0 13 215 0 0 13 215 1 66 40 155 120 0 0 0 7 116 73 77 69 7 215 6 21 14 22 55 133 211 233 232 0 0 8 11 73 68 65 84 104 222 237 152 105 108 84 215 21 199 255 247 222 247 222 204 120 188 225 193 216 198 27 182 176 195 82 108 140 77 73 104 33 64 0 177 101 32 141 147 170 129 46 106 196 180 85 219 168 31 218 170 21 72 84 173 104 20 169 85 104 139 42 58 137 105 17 137 66 128 54 241 184 132 134 134 128 144 193 16 92 28 83 4 49 16 179 120 101 48 227 241 50 51 111 222 123 247 222 126 176 227 96 48 48 4 236 98 201 231 203 147 238 242 206 255 119 238 126 128 49 27 179 49 27 213 70 70 194 137 219 171 217 1 220 0 80 238 243 24 251 31 230 191 233 8 6 203 225 74 200 248 251 234 215 180 239 141 74 0 66 32 126 182 124 187 35 119 252 180 87 87 191 110 123 101 52 142 0 226 181 113 248 241 226 173 142 226 156 121 47 173 169 176 237 113 123 53 117 84 1 0 64 179 254 49 190 61 247 215 246 5 83 203 159 166 140 28 113 123 181 164 81 5 208 99 94 71 99 168 6 79 23 255 208 246 236 151 95 42 165 140 212 185 189 90 246 168 1 0 0 93 244 224 211 208 81 60 145 191 90 93 191 232 229 92 198 104 157 219 171 21 143 26 0 2 10 75 70 113 41 92 131 130 9 37 244 167 43 95 79 177 107 113 71 221 94 109 233 255 253 28 112 123 181 100 0 83 1 20 16 130 41 148 145 153 18 120 204 78 227 39 189 242 220 251 244 116 247 62 80 66 65 41 235 251 18 5 89 142 34 24 134 137 223 191 231 137 116 133 59 126 84 185 62 186 125 196 1 220 94 45 143 50 178 137 17 237 249 130 244 34 115 162 107 178 154 154 152 97 79 113 78 36 201 142 116 36 219 38 160 203 106 131 223 184 0 70 24 8 165 160 132 13 192 164 170 147 97 147 137 216 114 224 7 225 214 96 227 150 119 95 212 55 140 8 128 219 171 77 165 140 252 38 78 75 90 177 168 168 92 157 149 189 88 225 136 66 23 189 48 68 24 166 136 192 148 58 76 17 5 37 12 26 181 131 246 139 39 148 130 17 6 144 62 25 201 44 19 201 44 7 21 213 191 208 207 54 31 127 135 115 241 45 159 199 176 134 5 192 237 213 236 148 145 55 156 90 210 138 167 102 62 103 43 206 92 68 3 230 21 52 71 62 70 84 132 192 136 6 133 104 3 95 149 218 160 82 7 52 102 7 163 234 64 244 9 29 188 12 227 233 120 164 105 83 176 247 212 239 244 234 134 202 90 110 137 21 62 143 209 243 80 1 220 94 45 137 50 114 112 118 225 226 233 75 166 173 179 183 69 207 161 41 124 10 166 212 7 4 43 68 3 163 159 65 216 160 49 59 52 234 128 74 237 80 153 189 127 234 208 33 37 216 105 34 50 181 34 28 186 240 166 89 121 114 219 21 206 197 147 62 143 209 250 80 0 220 94 45 141 50 90 61 111 250 170 156 199 11 86 105 39 3 111 33 204 3 159 71 155 106 183 71 191 95 188 66 85 72 34 0 0 140 41 125 211 8 4 0 1 1 1 35 42 52 18 7 66 24 84 98 71 182 109 22 78 183 30 22 127 61 252 171 0 231 124 161 207 99 156 121 32 0 183 87 203 167 148 84 47 42 121 54 181 56 103 158 114 44 176 3 6 15 221 20 105 21 10 177 129 17 21 92 154 136 138 94 68 69 8 32 22 4 225 0 17 96 84 133 194 84 48 170 220 209 143 74 28 208 168 19 241 108 60 30 79 252 14 142 54 190 35 125 199 43 186 42 215 71 199 221 218 86 185 15 241 132 50 242 207 37 165 207 167 21 100 20 211 15 253 127 130 5 3 10 209 64 37 135 0 135 41 34 136 138 16 162 34 4 33 251 214 30 163 74 159 96 162 66 33 202 192 246 121 55 51 101 4 66 112 76 115 46 195 249 27 199 177 191 118 103 68 74 249 245 161 218 42 247 49 0 223 204 116 229 229 20 101 205 163 251 219 95 134 37 251 196 11 112 68 101 8 134 184 14 46 205 193 167 36 97 253 130 25 24 237 219 46 25 97 32 247 0 80 137 3 101 137 47 160 173 227 170 220 117 228 143 61 220 178 150 250 60 198 137 47 12 224 246 106 113 148 145 87 151 150 172 117 158 233 218 143 168 8 129 128 130 195 132 33 34 144 16 67 44 46 50 32 248 51 8 74 89 255 194 189 179 217 105 34 102 39 174 195 249 150 58 81 89 83 209 201 57 159 231 243 24 231 238 212 62 38 0 74 201 198 226 252 39 156 14 123 28 62 189 86 3 0 144 16 176 164 113 151 62 236 166 19 247 115 136 187 45 59 39 115 97 118 194 90 212 54 30 180 62 56 181 187 141 115 241 85 159 199 184 122 55 109 74 76 91 38 85 126 50 127 106 185 173 54 248 214 144 209 30 28 193 4 100 56 166 97 162 99 26 226 85 23 52 234 132 141 57 192 136 134 70 253 40 174 232 31 13 217 47 81 201 64 89 252 55 112 232 236 94 179 230 220 254 139 156 139 249 62 143 209 113 47 125 177 140 64 201 196 148 92 110 145 8 252 209 11 119 108 148 162 229 160 36 249 25 36 178 12 52 7 63 193 217 198 122 253 70 208 111 232 70 136 134 245 16 181 41 14 237 251 203 55 43 67 1 184 212 73 40 118 150 99 223 169 138 104 253 165 234 58 110 137 37 62 143 209 27 203 236 136 5 160 116 98 106 158 189 211 104 30 178 146 17 21 51 146 86 34 219 86 130 195 231 246 68 78 55 158 32 18 188 150 91 98 23 128 51 0 130 0 34 132 144 179 10 177 221 214 63 77 155 130 233 142 149 216 83 179 69 191 208 90 255 33 183 196 51 62 143 97 196 186 179 220 19 128 41 100 126 250 184 28 165 211 108 26 178 126 78 202 90 24 33 41 183 29 218 160 235 102 168 66 8 249 203 91 163 215 159 149 184 205 178 108 37 152 108 91 128 157 71 126 27 105 234 184 184 155 91 226 187 62 143 33 238 231 108 186 39 128 148 40 77 75 152 132 250 208 127 110 171 43 140 127 18 54 158 140 55 171 55 135 44 203 92 232 243 24 181 177 58 206 179 207 69 150 58 11 21 31 108 138 248 187 91 182 190 251 162 254 243 97 121 208 72 33 211 18 108 41 232 177 252 131 201 137 134 233 9 203 177 187 122 107 196 178 204 23 238 71 252 99 113 139 145 70 191 132 191 188 191 81 247 119 53 111 252 162 226 99 26 1 194 72 83 80 111 207 115 178 20 24 34 60 80 62 78 203 129 191 247 50 186 245 27 23 125 30 163 42 86 135 51 156 110 168 86 18 182 29 216 16 9 71 123 60 149 235 163 111 12 235 163 158 0 117 254 158 171 72 84 211 110 217 117 178 209 28 56 47 36 151 255 142 213 153 148 2 66 87 241 218 191 54 133 67 122 119 249 131 138 143 9 128 91 242 152 63 216 98 58 21 215 160 114 75 68 251 47 145 68 139 213 89 195 245 19 114 251 129 205 61 186 17 89 226 243 24 239 141 84 98 171 206 223 217 162 59 217 96 128 160 217 2 87 98 58 161 20 11 98 139 190 100 187 14 253 161 211 178 204 185 62 143 113 108 36 51 115 117 77 254 70 213 134 4 196 177 228 155 0 90 145 236 76 133 77 137 203 119 123 181 57 49 60 94 27 45 206 75 135 186 211 15 43 128 207 99 116 114 105 236 252 239 229 26 115 82 220 236 129 114 33 45 180 68 79 227 169 210 53 14 202 200 219 110 175 102 187 219 13 25 18 115 125 30 227 242 195 206 130 196 148 23 18 92 110 170 191 240 145 229 144 46 184 180 73 3 151 181 43 145 147 72 117 165 147 130 172 25 19 24 163 59 220 94 77 185 67 16 184 207 99 92 27 142 28 19 139 105 241 85 241 222 194 85 232 108 15 52 47 44 203 91 162 118 154 77 144 68 128 81 138 176 8 160 52 103 153 218 29 238 204 15 134 58 86 20 174 164 123 27 170 120 116 164 146 100 44 230 29 164 138 159 204 93 166 151 70 140 80 254 204 172 133 74 143 184 6 9 14 139 24 8 73 63 74 115 151 170 140 210 180 246 64 211 218 194 149 116 87 67 21 15 61 82 0 0 80 184 138 237 11 246 118 44 13 71 122 93 51 179 23 170 186 236 2 135 1 65 44 116 89 45 40 76 155 205 156 90 82 124 75 199 165 57 159 84 90 127 123 228 0 26 170 184 89 184 138 237 236 10 5 202 110 4 175 103 23 101 63 169 218 85 7 116 217 3 14 19 65 171 25 147 199 151 209 214 246 150 212 204 197 189 167 26 170 248 197 225 6 184 239 228 174 207 99 24 130 203 53 109 29 77 127 254 199 193 29 145 80 64 200 124 199 92 36 43 89 80 136 29 166 140 64 85 84 14 160 115 100 18 197 15 150 86 44 99 10 125 59 115 66 110 122 65 206 244 56 87 82 58 218 59 154 69 77 253 193 144 105 153 89 62 143 209 253 72 3 244 67 168 0 214 41 42 91 14 137 175 72 160 141 91 252 107 247 122 203 142 217 152 141 217 195 177 255 1 144 175 73 88 169 71 12 171 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:06'!rotation	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 3 12 73 68 65 84 120 218 237 155 189 106 181 64 16 134 85 210 89 88 167 144 64 26 193 194 52 22 66 238 64 66 106 123 187 16 115 1 185 128 128 157 96 237 77 132 220 66 192 54 22 150 129 96 145 43 176 246 43 14 131 100 206 217 111 221 31 221 245 231 105 68 61 174 235 59 179 51 235 142 199 48 14 14 14 180 97 24 254 110 183 143 165 186 3 39 246 35 56 230 106 153 219 144 4 54 77 213 2 168 134 83 0 154 199 98 97 89 61 124 63 134 97 28 1 32 228 126 4 154 155 137 57 96 186 240 105 154 166 105 138 61 254 48 24 39 211 67 7 22 254 178 33 240 44 135 182 221 61 236 66 200 17 126 63 134 160 132 6 209 152 63 85 64 104 127 127 161 75 241 123 128 105 254 29 49 32 56 54 200 110 71 136 232 3 146 5 227 205 25 69 81 20 69 177 121 225 177 0 211 161 9 59 77 120 124 255 97 240 60 207 243 188 113 63 8 130 32 8 54 111 8 121 179 32 62 67 144 67 77 24 134 97 24 142 231 227 56 142 227 88 119 131 48 247 79 254 8 224 187 63 249 250 44 203 178 44 211 125 100 144 28 139 249 66 50 47 47 207 207 79 79 178 132 103 239 71 158 231 121 158 15 131 109 219 182 109 235 102 136 5 12 160 11 96 8 232 63 95 104 162 229 36 210 113 218 136 93 32 4 233 2 14 77 114 158 91 154 176 162 29 89 15 144 172 217 66 146 232 8 144 198 250 13 128 67 146 216 115 139 94 207 204 250 13 0 192 123 68 146 36 73 146 208 158 107 57 3 104 82 146 156 159 40 138 162 40 50 140 182 109 219 182 149 221 58 127 8 210 212 0 242 99 170 239 251 190 239 27 70 215 117 93 215 209 126 77 90 4 164 29 199 91 233 130 204 45 212 252 139 109 150 101 89 150 165 79 104 157 56 2 72 203 197 152 169 231 119 179 154 73 133 49 4 201 50 196 212 223 203 27 202 48 27 114 28 199 113 28 89 173 138 195 153 3 104 194 232 87 72 129 228 235 186 174 235 186 170 123 51 34 57 9 143 194 235 86 156 175 235 186 174 235 49 25 111 22 221 138 243 124 47 98 27 64 77 113 158 92 55 208 107 117 116 113 88 5 22 93 68 27 6 177 197 184 233 60 62 190 190 222 223 15 195 221 221 195 195 237 237 106 95 196 104 197 121 118 202 178 44 203 210 48 78 203 209 242 123 12 194 171 80 139 3 209 226 60 110 135 124 159 203 5 25 246 145 0 30 13 66 99 193 177 231 107 55 2 176 71 159 246 225 236 232 241 85 85 85 85 117 190 127 185 85 210 231 42 227 249 190 239 251 190 55 205 166 105 154 166 145 191 68 64 242 252 175 175 143 143 239 111 13 166 223 243 20 231 105 200 143 245 216 179 241 72 16 141 253 179 35 183 56 207 10 187 65 72 253 155 219 0 210 67 16 20 231 217 66 139 108 104 95 216 1 227 113 220 223 169 119 186 185 9 130 235 107 254 164 172 62 102 41 225 92 40 200 81 96 8 146 160 63 63 77 243 251 123 222 34 24 2 120 127 127 123 251 252 164 59 220 206 12 64 255 103 15 205 147 193 0 144 116 113 8 98 77 198 11 253 71 108 189 96 143 7 129 213 132 214 29 128 103 63 216 195 213 78 46 54 204 50 211 229 131 51 14 225 53 225 16 90 17 243 126 84 124 112 112 240 127 254 1 239 98 79 150 168 109 20 16 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:07'!scale	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 47 0 0 0 47 16 6 0 0 0 35 183 79 239 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 19 73 68 65 84 120 218 237 155 221 141 194 48 12 128 219 211 45 193 19 18 3 192 0 172 128 88 162 111 8 49 0 3 176 69 150 64 172 192 0 48 0 18 79 140 209 123 138 170 90 117 157 31 39 78 56 127 47 149 142 107 147 124 117 156 186 132 166 81 50 208 247 227 99 211 252 72 119 233 187 25 68 67 126 165 187 86 55 152 216 182 165 206 36 255 65 153 3 143 232 105 134 27 162 169 70 8 21 239 72 215 117 93 215 193 8 167 83 202 151 1 159 18 176 99 60 80 248 244 13 112 237 15 95 191 50 227 219 241 116 55 96 124 125 255 99 37 83 197 118 56 116 106 199 158 143 93 143 194 182 87 93 138 42 117 106 210 169 100 122 134 20 79 238 14 251 230 96 119 225 243 41 170 24 164 133 227 237 83 66 221 132 75 141 147 20 144 234 186 152 88 90 124 172 240 66 35 62 117 7 248 30 243 252 34 90 122 220 226 13 199 139 63 157 142 199 195 129 123 209 204 46 62 93 131 110 57 181 148 194 38 91 123 249 132 151 93 89 22 35 156 111 224 220 149 101 94 15 217 26 138 253 220 181 125 87 177 249 133 51 191 157 228 46 205 83 209 182 227 25 98 251 203 253 74 33 185 7 174 72 225 190 142 107 41 207 149 114 138 73 41 249 174 19 87 216 168 112 111 120 43 201 208 119 54 201 41 71 56 36 174 178 12 125 254 79 78 238 119 41 238 237 165 169 44 197 169 126 0 181 161 194 83 163 187 12 132 240 20 175 51 129 11 162 178 10 223 162 166 204 147 44 213 236 247 231 243 118 219 247 155 205 110 183 90 233 76 129 32 226 195 69 89 225 210 3 43 29 100 183 48 158 74 108 4 47 151 235 245 98 49 252 253 122 189 92 238 247 225 188 247 251 249 252 124 164 135 87 46 108 169 6 139 244 199 227 118 123 189 116 77 128 4 139 215 136 142 131 20 15 75 112 141 96 30 80 241 86 184 49 198 24 3 191 56 160 177 107 128 46 182 211 144 145 11 111 0 38 18 75 61 212 34 252 95 113 22 64 69 174 21 111 83 17 124 126 215 20 53 38 248 199 103 48 194 173 88 56 67 164 7 88 61 54 130 225 209 126 206 187 197 77 97 222 37 171 144 168 112 97 84 112 102 190 244 187 76 69 81 68 248 3 221 179 150 104 213 141 47 93 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:07'!script	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 15 228 73 68 65 84 120 218 237 92 87 76 85 89 23 94 32 72 17 112 20 145 50 2 14 14 32 29 212 40 168 1 6 46 96 67 29 49 106 98 124 48 177 36 250 98 124 149 7 19 95 124 241 197 18 77 196 68 52 64 148 166 210 171 151 38 69 229 114 17 27 88 232 92 122 239 229 252 15 123 214 172 195 185 231 220 123 65 248 199 127 242 175 151 29 206 89 187 173 181 87 251 246 185 232 193 60 226 56 248 63 1 0 192 166 77 155 54 109 218 4 48 51 51 51 51 51 3 208 212 212 212 212 212 164 167 183 76 211 113 92 125 125 125 125 125 61 247 127 250 139 198 198 198 198 198 198 56 78 161 80 40 20 10 142 187 116 233 210 165 75 151 240 128 46 249 65 85 95 64 81 81 81 81 81 209 63 45 6 105 154 155 155 155 155 155 91 190 118 122 122 122 122 122 154 20 209 219 219 219 219 219 203 113 114 185 92 46 151 47 157 34 244 151 201 164 150 156 152 216 169 93 110 154 239 122 0 214 174 93 187 118 237 90 0 63 63 63 63 63 63 128 172 172 172 172 172 44 90 221 98 231 145 84 64 96 96 96 96 96 160 250 243 246 246 246 246 246 118 128 236 236 236 236 236 108 245 231 72 159 63 127 254 252 249 179 122 255 210 210 210 210 210 82 128 218 218 218 218 218 90 128 252 252 252 252 252 124 117 190 79 159 62 125 250 244 137 4 142 124 194 121 150 155 152 37 208 223 22 22 22 22 22 22 0 219 183 111 223 190 125 59 64 74 74 74 74 74 10 128 145 145 145 145 145 209 194 21 33 169 128 226 226 226 226 226 98 245 231 111 222 188 121 243 230 13 128 167 167 167 167 167 39 192 236 236 236 236 236 44 128 74 165 82 169 84 0 213 213 213 213 213 213 0 29 29 29 29 29 29 0 111 223 190 125 251 246 45 245 111 109 109 109 109 109 5 240 246 246 246 246 246 166 254 56 95 121 121 121 121 121 57 192 200 200 200 200 200 8 245 243 245 245 245 245 245 5 248 246 237 219 183 111 223 150 94 208 66 11 195 86 168 112 230 162 200 34 112 31 15 30 60 120 16 19 131 10 210 93 17 11 118 65 219 182 109 219 182 109 27 64 93 93 93 93 93 29 192 138 21 43 86 172 88 1 96 96 96 96 96 96 0 176 101 203 150 45 91 182 0 184 184 184 184 184 184 0 108 221 186 117 235 214 173 0 25 25 25 25 25 25 0 198 198 198 198 198 198 180 193 240 240 240 240 240 112 82 132 191 191 191 191 191 63 192 202 149 43 87 174 92 169 174 120 39 39 39 39 39 167 165 19 176 148 75 99 113 134 214 133 132 174 9 159 99 182 228 234 234 234 186 121 51 192 221 187 119 239 222 189 75 163 104 91 151 30 127 121 203 233 91 255 91 190 123 33 243 160 2 196 222 77 76 76 76 76 76 144 171 13 14 14 14 14 14 6 248 248 241 227 199 143 31 233 32 177 224 12 96 106 106 106 106 106 202 92 209 202 149 0 223 191 127 255 222 216 8 112 226 196 137 19 39 78 252 45 110 181 52 214 64 106 113 232 18 164 98 129 144 208 84 209 183 71 68 68 68 68 68 144 239 150 201 100 50 153 140 248 31 61 122 244 232 209 35 128 130 130 130 130 130 2 128 216 216 216 216 216 88 114 97 104 73 56 174 157 157 157 157 157 29 128 82 169 84 42 149 0 61 61 61 61 61 61 0 247 239 223 191 127 255 62 157 60 180 20 119 119 119 119 119 119 214 207 214 86 90 208 82 138 225 43 136 227 0 206 158 61 123 246 236 89 0 150 21 145 133 8 197 106 109 109 109 189 126 61 192 129 3 7 14 68 70 106 159 203 64 59 139 110 244 250 245 235 215 175 95 147 224 208 68 199 199 199 199 199 199 137 239 242 229 203 151 47 95 6 72 72 72 72 72 72 0 184 122 245 234 213 171 87 41 104 99 44 193 141 99 48 70 193 14 15 15 15 15 15 3 236 222 189 123 247 238 221 20 107 34 35 35 35 35 35 1 238 221 187 119 239 222 61 128 175 95 191 126 253 250 21 192 214 214 214 214 214 86 90 208 66 197 224 188 44 25 5 216 179 103 207 158 61 123 0 172 172 172 172 172 172 0 186 186 186 186 186 186 152 34 70 71 217 223 221 221 0 205 205 205 205 205 205 52 78 76 76 76 76 76 204 15 40 64 219 201 23 154 58 198 6 180 128 209 209 209 209 209 81 106 47 94 188 120 241 226 69 128 184 184 184 184 184 56 128 227 199 143 31 63 126 28 96 195 134 13 27 54 108 160 152 129 2 71 114 117 117 117 117 117 5 120 245 234 213 171 87 175 0 214 172 89 179 102 205 26 0 123 123 123 123 123 123 128 243 231 207 159 63 127 30 224 230 205 155 55 111 222 36 147 79 76 76 76 124 250 84 187 75 226 191 231 243 177 172 6 64 95 95 95 95 95 31 96 199 142 29 59 118 236 160 247 3 3 3 3 3 3 204 213 124 251 198 98 97 96 32 192 224 224 224 224 224 32 128 92 46 151 91 88 0 228 229 229 229 229 229 105 213 131 122 161 35 44 196 22 90 200 48 11 224 184 156 156 156 156 156 28 142 99 39 136 227 88 144 229 56 230 99 137 111 118 118 118 118 102 134 227 88 144 91 88 59 61 205 113 44 189 229 56 75 75 75 75 75 75 142 99 10 166 130 10 219 169 169 169 169 201 73 142 155 156 156 156 212 212 50 203 101 235 28 31 103 127 143 141 177 194 108 116 148 227 216 193 162 22 247 137 244 228 201 147 39 79 158 104 47 216 244 53 171 68 187 9 33 95 91 91 91 91 91 27 21 40 125 125 125 125 125 125 0 103 206 156 57 115 230 12 165 111 231 206 157 59 119 238 28 101 77 73 73 73 73 73 73 228 10 196 242 125 77 217 11 246 195 19 138 193 18 199 121 252 248 241 227 199 143 105 126 177 93 161 203 153 157 165 86 56 62 186 36 126 127 190 120 113 124 36 12 210 218 72 77 1 56 113 80 80 80 80 80 208 252 133 107 74 223 248 245 129 135 7 192 245 235 215 175 95 191 78 166 138 5 12 22 54 24 108 249 133 14 199 1 248 248 248 248 248 248 144 15 215 116 12 196 214 115 242 228 201 147 39 79 18 15 174 99 116 116 116 20 235 10 142 163 24 53 59 59 59 203 87 12 191 157 155 35 133 72 205 39 140 21 35 35 35 35 195 195 116 192 22 173 0 134 121 144 15 148 226 195 22 243 253 210 210 210 210 178 50 128 248 248 248 248 248 120 234 31 20 20 20 20 24 8 96 102 102 102 102 102 70 37 189 163 163 163 163 163 35 109 28 11 55 39 39 39 167 223 126 211 108 1 194 117 204 205 1 4 4 4 4 248 251 3 232 233 233 233 233 233 81 154 248 240 225 195 135 177 177 36 112 49 69 162 192 165 20 194 231 19 198 142 236 236 236 236 172 44 182 63 115 115 237 130 151 84 128 112 97 82 2 23 18 166 137 195 195 195 195 67 67 0 83 83 83 83 83 83 116 18 100 50 153 44 44 12 224 216 177 99 199 142 29 163 241 253 253 253 253 119 236 80 47 204 108 109 109 109 237 236 196 179 20 20 128 208 50 1 88 144 94 187 22 192 193 193 193 193 193 129 250 197 199 199 199 199 197 137 11 92 147 107 145 154 71 76 49 139 169 115 36 45 32 56 56 56 248 143 63 212 43 65 77 39 146 227 0 74 74 74 74 74 75 137 23 79 20 198 4 228 83 42 149 202 218 90 218 200 187 119 239 222 189 123 71 227 87 86 86 86 86 84 144 0 16 194 64 254 218 218 218 90 228 7 96 245 68 126 62 241 57 59 59 59 59 59 211 123 44 140 26 27 27 27 155 154 196 179 31 49 215 34 20 52 219 147 186 98 246 238 221 187 119 223 62 202 130 126 200 2 56 14 224 229 203 151 47 11 11 9 106 16 158 0 33 63 182 88 41 34 97 233 30 16 16 16 16 16 64 10 197 231 152 182 10 55 222 215 215 215 215 223 79 130 86 42 149 202 154 26 6 129 188 123 71 233 31 142 231 233 233 233 233 229 197 158 127 255 206 44 200 198 70 125 111 216 95 40 88 97 172 19 238 11 91 12 181 194 254 8 181 172 94 189 122 245 234 213 63 104 1 252 86 74 208 82 38 137 133 10 18 186 160 150 150 150 150 230 102 138 9 88 186 35 168 215 217 217 217 217 217 73 227 123 121 121 121 121 122 82 54 132 227 187 185 185 185 97 133 251 235 175 196 143 65 125 227 198 141 27 29 29 1 86 173 90 181 202 204 76 125 195 124 75 18 10 92 76 176 66 87 197 223 63 63 102 240 229 179 16 18 141 211 28 7 16 18 18 18 18 18 162 14 199 74 241 35 177 60 154 167 225 191 4 190 111 223 190 125 251 247 211 194 93 92 92 92 156 157 105 163 56 31 10 192 198 198 198 198 214 150 149 246 214 214 234 243 33 58 138 253 249 80 7 199 1 24 26 26 26 26 26 206 23 24 0 171 204 39 38 116 59 96 252 119 124 5 136 241 239 223 191 127 255 129 3 204 114 123 123 117 87 128 164 5 20 22 22 22 22 22 138 111 68 147 5 72 229 191 24 148 145 175 173 173 173 173 189 29 32 55 55 55 55 39 135 20 83 84 84 84 36 151 207 63 161 0 0 10 133 66 81 83 67 127 99 191 202 202 202 202 202 74 114 153 72 13 13 13 13 13 13 196 143 174 10 45 15 247 83 87 87 87 199 119 129 133 133 133 133 114 57 213 53 98 39 92 44 40 167 165 165 165 165 165 49 152 218 210 242 7 20 32 20 180 80 49 154 78 12 199 73 99 47 194 60 28 211 77 116 41 211 211 211 211 51 51 12 83 105 105 1 72 78 78 78 78 73 97 165 124 110 46 19 8 223 117 76 78 78 78 78 77 1 152 152 152 152 152 154 18 56 151 152 152 152 152 148 196 92 154 74 69 2 196 182 189 189 189 189 173 141 129 141 37 37 132 229 224 123 172 99 240 38 76 234 224 137 201 105 201 178 32 0 128 208 208 208 208 208 80 118 114 209 165 136 157 124 126 182 48 55 7 224 225 225 225 225 225 161 62 81 71 71 71 7 10 132 227 168 14 120 255 254 253 123 188 87 208 215 167 152 129 10 11 13 13 13 149 201 152 101 153 152 208 252 22 22 22 22 230 230 76 96 238 238 0 235 215 175 95 191 126 61 139 29 94 94 44 29 30 25 33 23 136 45 98 79 88 103 244 247 247 247 15 12 204 183 52 133 130 210 88 49 129 243 229 132 239 35 35 35 35 15 30 100 7 161 187 91 119 5 168 221 7 160 15 47 41 41 41 41 41 33 223 138 207 81 208 82 138 75 76 76 76 76 76 36 212 19 41 38 38 38 230 254 125 128 176 176 176 176 176 48 113 203 146 202 199 197 44 79 44 89 224 243 35 36 129 22 101 99 99 99 99 99 67 48 59 43 211 164 199 215 101 125 124 66 176 240 224 193 131 7 15 29 2 200 204 204 204 204 204 100 177 97 255 254 191 197 173 54 231 130 92 144 84 133 200 127 31 17 17 17 17 30 78 190 22 77 59 53 53 53 245 217 51 226 71 65 8 179 145 244 244 244 244 180 52 230 42 58 58 212 179 145 234 234 234 106 140 5 28 199 124 125 125 61 193 210 232 138 80 240 152 68 32 180 34 38 120 109 88 147 54 216 90 44 155 210 149 212 20 128 46 2 79 42 226 249 98 166 200 47 72 176 31 166 127 167 78 157 58 117 234 20 229 251 136 151 35 255 208 208 208 208 240 48 249 226 188 188 188 188 252 124 134 179 143 143 3 84 84 84 84 148 151 3 60 125 250 244 41 194 202 0 52 14 22 124 13 13 13 13 95 190 16 102 131 176 52 6 93 19 19 19 19 19 19 128 157 59 119 238 220 185 83 51 166 165 201 178 132 177 68 216 239 208 161 67 135 14 31 102 49 69 165 250 1 5 224 128 24 252 112 3 124 141 11 99 128 48 75 224 56 134 255 95 184 64 23 25 24 116 177 80 51 51 51 51 91 181 138 46 54 100 50 153 44 36 132 158 187 187 187 187 123 120 48 75 90 181 138 92 162 141 141 141 141 181 53 192 174 93 187 118 5 4 48 126 83 83 74 91 43 42 42 42 42 43 105 47 161 161 161 161 33 33 148 182 10 215 41 244 229 98 2 215 197 21 62 123 246 236 89 106 42 139 69 98 5 160 20 25 168 15 58 63 184 242 159 107 187 196 230 47 12 65 183 27 55 110 220 184 113 131 96 105 252 27 175 18 133 138 197 171 76 36 103 103 103 231 223 127 23 119 129 28 199 78 246 174 93 12 6 207 206 6 248 242 229 203 151 47 95 8 28 188 112 225 194 133 139 23 73 113 82 49 67 74 208 186 184 150 197 184 30 36 209 44 8 125 121 68 4 193 171 82 216 8 182 152 222 229 230 230 230 242 111 128 48 171 193 160 156 159 159 159 95 80 192 210 204 228 100 245 27 163 170 170 170 170 215 175 233 4 226 85 165 148 171 72 79 79 79 79 79 7 184 118 237 218 181 107 215 0 214 173 91 183 110 221 58 128 59 119 238 220 185 125 155 146 7 149 74 165 234 232 160 254 105 105 105 105 25 25 116 39 205 31 151 227 88 61 82 84 68 87 164 66 129 11 99 195 225 195 135 15 255 249 39 139 69 109 109 63 160 0 20 180 24 188 42 5 69 32 20 160 80 176 188 126 243 102 122 142 10 196 202 23 99 203 149 43 87 174 68 71 147 107 42 44 44 44 124 249 146 197 156 177 49 154 167 185 185 185 185 169 137 185 160 178 50 128 154 154 154 26 165 146 4 123 235 214 173 91 183 111 83 1 120 250 244 233 211 167 79 51 69 88 90 178 32 60 57 201 4 90 92 76 138 69 87 135 152 211 135 15 31 62 32 134 197 113 44 157 118 119 103 224 93 99 163 230 96 140 73 70 114 50 171 131 16 34 89 148 2 164 76 74 42 234 99 235 231 231 231 231 235 75 62 30 159 227 70 177 174 136 138 138 138 138 138 2 136 142 142 142 142 142 102 233 91 121 57 75 27 3 3 213 191 27 178 183 183 183 119 112 96 223 223 56 57 209 115 252 46 9 249 19 18 18 18 226 227 73 112 245 245 245 245 13 13 116 17 196 175 128 1 212 225 114 60 56 72 53 53 53 53 181 181 116 95 193 63 120 154 238 13 22 74 106 117 192 208 208 208 208 208 16 45 124 112 112 112 112 96 64 122 0 49 31 169 41 109 211 214 143 255 94 236 96 72 109 84 232 162 196 198 209 36 34 41 62 177 117 139 173 203 206 206 206 110 195 6 230 138 91 91 73 129 11 174 3 80 195 153 153 153 153 8 175 254 242 139 246 244 13 81 203 188 188 188 188 130 2 58 33 85 85 85 85 85 85 234 253 248 31 183 242 5 139 24 14 62 199 155 57 172 164 133 130 225 7 103 77 89 141 148 194 196 98 139 20 214 37 5 83 3 176 111 68 147 146 72 17 186 146 228 133 140 38 147 210 20 3 54 111 222 188 217 213 149 120 123 122 122 122 248 232 32 150 250 221 221 221 221 221 221 84 64 213 212 212 212 40 20 12 154 248 240 129 230 71 108 6 113 126 49 23 40 60 185 218 224 101 77 217 157 148 98 180 209 98 93 144 228 149 36 154 78 127 127 127 63 255 38 75 24 11 48 104 99 158 45 140 1 198 198 198 198 70 70 244 183 161 161 161 161 129 193 252 139 30 190 162 144 31 199 71 20 20 125 49 255 50 93 216 226 183 156 252 86 184 78 97 43 230 195 209 81 44 164 141 138 138 138 58 122 148 92 144 174 164 22 3 80 224 136 109 32 206 221 219 219 219 219 211 35 110 9 218 79 135 250 137 19 146 38 188 157 47 32 225 231 31 63 11 97 229 126 228 200 145 35 71 143 254 0 22 36 140 242 66 193 105 114 81 98 190 20 93 12 230 255 72 88 47 224 60 101 101 101 101 101 101 212 31 211 70 161 239 255 183 145 100 12 208 4 175 234 114 49 131 124 152 183 187 186 186 186 186 184 144 192 17 126 198 207 88 90 90 90 90 90 91 73 224 8 107 11 113 249 159 149 240 228 47 212 5 73 42 224 197 139 23 47 158 63 103 5 141 149 149 238 193 25 91 20 180 183 183 183 183 151 23 251 230 147 255 139 25 115 115 115 115 115 115 202 239 49 120 227 149 30 126 5 45 134 203 255 140 180 216 44 72 18 11 210 36 96 49 62 169 172 1 113 120 188 219 69 62 196 106 132 124 248 222 205 205 205 205 205 77 60 43 89 182 31 139 254 3 36 89 9 227 197 66 87 87 87 87 103 39 9 92 46 151 203 209 55 35 94 63 55 199 96 229 162 34 114 33 98 249 179 248 92 218 211 192 255 5 90 82 23 4 0 240 252 249 243 231 207 158 49 120 21 79 238 220 28 131 137 221 220 230 99 36 0 4 31 75 249 108 97 140 208 85 224 98 177 229 103 164 37 43 196 80 112 98 112 52 0 125 209 230 232 232 232 136 159 254 113 156 184 207 22 10 78 172 114 149 18 180 182 202 243 223 66 106 117 0 194 182 120 193 161 82 169 84 252 95 9 46 54 239 215 53 182 104 93 176 158 158 158 190 190 238 252 186 208 82 196 22 252 80 236 135 177 32 92 80 106 106 106 106 74 10 83 132 240 35 89 169 147 41 85 105 106 226 215 93 72 203 231 132 22 42 120 93 176 32 95 95 95 95 31 31 29 230 198 161 216 255 138 160 43 62 196 181 241 130 97 185 130 163 152 98 23 59 142 46 193 126 185 200 193 193 193 97 227 70 118 127 209 216 8 144 147 147 147 147 151 71 63 72 97 164 225 87 146 120 243 131 63 130 83 40 20 10 165 114 249 22 252 111 163 186 186 186 186 15 31 232 139 58 132 245 181 145 64 35 255 198 48 247 51 145 186 5 252 7 6 48 156 116 123 179 113 22 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:07'!segment	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 123 73 68 65 84 120 218 237 218 61 174 130 64 20 134 225 195 141 37 44 130 130 109 77 76 166 51 70 54 227 90 168 220 137 149 137 123 176 33 153 91 80 220 128 23 231 15 228 104 222 167 33 152 104 228 251 6 144 120 68 0 0 192 55 114 110 188 197 212 207 58 31 75 224 161 118 105 111 155 11 184 40 182 62 160 79 147 24 88 236 10 167 152 57 43 93 130 16 42 177 128 240 21 109 173 181 214 254 157 49 211 125 100 153 254 202 153 223 18 252 162 194 131 159 110 41 98 44 242 18 20 26 220 243 37 234 122 109 154 166 17 57 159 203 178 44 183 62 108 61 22 190 9 23 197 120 133 23 197 126 95 85 85 37 114 187 245 125 223 139 220 239 93 215 117 34 143 71 219 182 45 103 66 164 185 75 139 255 102 59 20 225 220 229 82 215 117 237 220 112 70 56 71 17 153 124 193 83 196 74 98 131 167 136 133 228 6 111 140 49 198 80 68 182 216 7 172 105 240 20 145 232 116 58 30 15 135 244 39 91 138 80 130 34 148 160 8 37 40 66 9 138 80 130 34 148 160 8 37 40 66 9 138 80 130 34 148 160 8 37 40 66 137 247 20 193 200 165 215 58 69 204 255 35 136 25 161 69 12 123 190 128 41 32 153 175 136 65 236 152 13 162 189 46 34 190 0 230 156 18 77 139 24 7 201 128 217 219 252 31 228 251 138 96 108 124 36 119 69 199 143 225 51 158 46 34 57 35 151 175 95 247 163 128 32 207 35 151 195 254 214 223 235 107 164 143 92 114 51 94 72 238 192 25 18 229 6 79 17 11 33 216 141 228 78 250 225 195 253 2 130 11 51 156 184 61 65 99 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:08'!style	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 12 96 73 68 65 84 120 218 237 155 93 108 83 231 29 198 127 254 78 236 99 39 118 18 199 78 26 39 77 8 36 144 16 88 10 101 172 104 131 169 163 21 157 4 148 125 73 211 54 42 173 163 157 52 169 218 197 180 155 169 149 216 214 74 211 46 182 21 181 218 84 58 84 237 134 177 93 180 97 85 183 174 148 22 10 11 4 200 23 249 78 252 17 219 241 71 142 125 252 253 113 236 93 28 101 233 202 118 81 8 132 66 158 27 203 199 246 123 254 239 243 188 239 255 253 191 207 121 13 107 88 195 26 214 176 134 53 172 97 13 247 35 84 183 246 243 114 121 181 59 112 119 65 245 169 249 212 222 234 45 143 31 223 177 227 201 39 87 174 11 135 15 95 184 112 234 20 124 247 187 175 191 254 203 95 174 92 187 127 252 227 247 190 247 211 159 194 231 62 247 242 203 199 142 173 92 187 3 3 63 252 225 179 207 222 252 239 213 43 23 202 26 110 6 107 2 172 50 214 4 88 101 172 9 176 202 88 19 96 149 113 203 85 208 103 21 133 130 40 46 46 66 58 61 61 61 51 3 26 141 201 100 50 129 32 116 118 118 118 222 185 56 238 187 25 32 203 217 108 54 11 129 192 169 83 167 78 193 182 109 178 28 143 67 48 216 215 215 215 7 201 228 196 196 248 248 157 139 231 190 19 32 18 57 113 226 248 113 248 246 183 119 237 234 238 134 39 158 232 234 170 173 133 245 235 237 118 139 5 36 105 100 100 116 244 206 197 115 223 9 240 200 35 205 205 102 51 124 243 155 143 62 186 125 59 216 237 86 171 201 4 62 95 48 24 137 64 69 69 93 93 93 221 157 139 231 190 177 34 186 186 90 91 235 235 225 39 63 121 250 233 253 251 161 162 66 163 41 151 97 108 108 106 202 227 129 159 255 252 181 215 222 125 23 178 217 66 161 80 184 217 187 124 122 43 226 150 5 248 232 163 35 71 30 127 124 229 136 250 252 231 95 121 229 111 127 131 183 222 26 29 125 251 237 155 111 71 146 98 49 73 130 55 222 248 197 47 126 247 59 248 254 247 31 123 236 161 135 96 227 70 69 136 247 222 251 240 195 203 151 161 175 239 210 165 185 57 40 151 183 109 251 202 87 160 171 107 255 254 3 7 192 231 187 122 245 234 85 200 102 37 73 146 160 178 210 106 173 174 134 230 230 222 222 135 30 90 190 207 209 163 61 61 221 221 55 47 192 61 151 130 100 89 150 101 25 94 121 229 133 23 126 243 27 120 230 153 3 7 118 239 134 141 27 91 90 234 234 96 120 248 250 245 153 25 16 197 68 34 157 6 183 59 155 53 24 160 187 251 192 129 131 7 193 227 185 124 249 210 165 101 226 255 67 148 90 163 209 222 134 154 241 158 19 224 79 127 122 249 229 55 222 128 47 127 121 243 230 150 22 104 107 107 106 178 219 193 239 95 88 136 197 192 227 153 159 95 88 128 15 62 152 154 138 199 97 251 246 35 71 158 125 22 226 241 64 32 16 128 124 62 149 74 167 151 219 83 169 212 106 149 10 108 54 151 203 229 90 249 120 239 25 1 66 33 133 88 163 49 155 149 36 248 210 151 182 110 221 184 17 10 133 76 38 145 128 201 201 217 217 217 89 8 4 98 177 108 22 114 185 150 150 238 110 176 219 55 108 232 232 128 104 84 249 252 147 168 173 109 109 109 109 5 147 201 102 179 217 64 165 42 151 101 121 229 226 190 103 4 56 126 252 165 151 94 125 21 158 124 114 215 174 222 94 104 104 168 171 51 155 33 26 141 68 194 97 152 159 95 88 16 69 56 123 214 239 47 22 97 199 142 31 252 224 200 17 16 69 159 207 235 5 89 254 239 197 87 163 209 233 116 58 101 228 55 55 3 148 203 229 178 82 118 168 87 144 181 207 188 0 191 255 253 139 47 190 250 42 236 222 189 126 125 109 45 180 180 212 215 87 85 65 34 17 143 139 34 76 77 121 189 11 11 240 246 219 231 207 143 143 67 103 231 183 190 245 157 239 64 54 155 72 72 18 132 195 83 83 211 211 55 182 107 179 53 55 187 92 74 10 250 111 194 85 170 79 191 212 254 127 124 102 5 240 122 103 102 188 94 176 88 178 217 88 12 190 250 213 71 31 221 181 11 244 122 189 94 163 129 177 177 137 137 185 57 184 120 241 250 245 249 121 24 31 119 187 195 97 176 219 59 58 58 59 97 102 230 220 185 243 231 33 26 157 155 155 157 133 96 112 124 124 108 12 146 201 104 52 26 5 65 168 171 179 219 149 113 175 20 219 43 75 252 18 238 122 47 40 149 74 36 82 41 56 117 234 181 215 78 158 92 190 30 10 77 77 205 206 194 11 47 28 57 242 141 111 128 205 86 93 109 50 193 216 216 232 232 208 16 120 60 126 127 48 8 217 172 78 103 52 66 44 150 76 102 50 240 206 59 47 189 244 226 139 48 53 117 246 236 153 51 80 42 41 244 118 117 237 219 247 196 19 96 48 152 76 70 35 120 189 87 174 92 185 2 109 109 59 119 238 220 249 241 136 238 147 25 176 84 78 30 63 254 171 95 253 225 15 176 103 143 203 37 8 80 89 153 203 37 18 112 248 240 161 67 123 246 64 83 147 211 89 83 3 145 72 32 224 118 67 52 42 138 241 56 140 143 135 66 233 52 24 12 14 135 211 185 220 174 40 94 188 248 254 251 176 110 157 221 46 8 208 208 96 54 107 181 112 253 250 95 254 114 242 36 232 116 21 21 149 149 80 44 42 158 81 38 19 143 199 227 183 175 159 119 237 12 120 243 205 19 39 254 250 87 216 191 191 171 171 190 30 214 173 107 109 109 110 134 116 58 147 41 22 97 231 206 246 118 167 19 74 165 100 50 28 134 120 92 153 41 147 147 74 170 121 231 157 243 231 135 135 97 243 102 149 202 100 2 151 203 225 176 217 192 225 104 111 111 111 135 206 78 155 77 167 131 124 62 155 77 38 225 253 247 7 7 231 231 111 140 163 88 204 231 243 121 184 107 83 208 210 206 117 165 81 81 225 241 40 139 230 129 3 143 63 14 193 96 44 86 40 192 250 245 46 87 125 61 104 181 122 125 85 21 92 187 54 50 210 223 15 181 181 85 85 38 19 244 247 143 140 184 221 160 215 43 21 139 203 37 203 137 4 236 219 119 248 240 99 143 41 52 170 84 240 222 123 23 46 12 13 65 56 28 143 167 82 224 243 249 124 11 11 240 231 63 255 248 199 207 61 183 242 253 185 109 2 44 46 142 142 62 255 252 202 5 212 216 184 117 235 209 163 176 119 239 222 189 123 247 130 94 111 177 56 157 96 54 231 243 225 48 244 244 108 218 180 121 51 164 82 146 20 139 65 169 84 42 21 139 144 205 230 114 217 44 252 232 71 79 63 253 245 175 67 177 152 74 197 227 48 56 56 51 19 141 130 199 163 148 161 209 232 226 98 36 2 115 115 161 80 34 1 225 112 42 85 44 130 209 104 177 88 44 240 212 83 71 143 62 255 60 24 141 102 179 217 12 237 237 189 189 91 183 130 213 106 183 219 237 55 198 123 232 144 195 113 43 27 180 187 110 13 56 120 112 247 238 238 110 168 170 50 155 13 6 72 165 210 233 108 22 218 218 26 26 204 102 144 229 114 185 84 2 143 103 118 118 108 12 212 106 101 68 59 28 74 217 216 217 217 210 226 116 66 79 79 79 207 150 45 160 209 148 74 217 44 140 140 76 76 76 78 194 249 243 202 12 73 38 75 37 173 22 218 219 29 14 65 128 13 27 122 122 54 109 130 107 215 206 156 57 123 86 17 182 84 130 217 217 193 193 225 225 219 215 223 187 102 13 88 92 140 197 210 105 232 234 234 234 218 180 9 156 206 182 182 222 94 152 159 31 31 191 120 17 212 234 124 94 163 1 189 222 96 88 183 14 76 38 131 65 163 1 131 193 106 181 88 64 16 170 170 26 26 64 20 131 65 143 7 74 165 66 193 239 135 142 142 166 38 155 13 250 250 254 249 207 92 14 58 59 187 187 183 108 129 109 219 218 218 172 86 200 231 115 185 92 14 250 251 99 49 173 22 252 126 191 63 28 94 142 107 233 243 123 94 128 191 255 253 204 153 169 41 104 109 117 185 214 173 131 108 54 147 145 36 104 105 105 106 106 108 132 138 138 170 42 101 209 45 151 139 69 176 88 4 193 104 84 4 49 26 193 96 168 174 126 224 1 240 249 46 93 58 119 14 106 106 20 235 96 195 134 142 142 13 27 224 183 191 253 217 207 154 154 224 244 233 115 231 198 199 193 235 117 187 61 30 152 153 9 4 162 81 184 122 213 235 77 36 224 145 71 14 30 220 191 255 99 4 105 149 29 241 237 194 170 167 32 89 150 229 82 9 244 122 149 74 175 7 181 90 167 171 172 132 82 73 146 252 126 133 248 186 58 208 104 42 43 205 102 80 236 50 208 235 117 58 173 22 4 193 225 104 111 135 133 133 217 217 225 97 48 26 141 70 189 30 26 27 93 174 214 86 208 106 203 229 124 30 202 101 89 206 231 193 233 180 88 202 101 37 21 205 205 193 191 254 53 52 52 55 7 22 139 66 115 127 127 95 223 233 211 203 241 217 108 78 167 195 113 15 11 144 203 229 114 178 172 152 101 209 40 152 76 149 149 58 29 84 84 64 38 3 6 131 217 108 183 67 46 39 138 138 103 147 207 103 50 32 8 141 141 93 93 144 201 68 34 110 55 24 141 229 114 44 6 245 245 181 181 181 181 160 86 235 245 38 19 4 2 162 152 201 192 224 224 228 100 32 0 225 112 161 96 48 128 70 35 8 22 11 180 180 56 157 86 43 216 237 213 213 149 149 80 46 231 114 169 212 114 124 161 144 199 227 245 66 38 147 74 125 252 250 74 97 213 83 208 204 140 199 19 141 130 221 94 95 95 83 3 235 215 183 180 52 52 128 32 84 87 215 213 41 35 87 150 149 156 174 8 98 177 56 28 144 201 136 162 207 167 8 146 76 130 78 103 52 86 87 131 217 108 181 186 92 224 118 79 78 14 12 64 36 18 14 43 213 83 87 87 71 135 178 40 167 211 96 179 233 245 178 12 115 115 110 247 252 60 164 211 202 142 217 235 125 247 221 171 87 111 140 51 153 20 197 88 12 42 43 149 211 19 43 133 85 159 1 199 142 189 254 250 71 31 193 190 125 123 246 124 241 139 74 7 5 1 180 90 133 208 92 46 145 8 133 148 7 34 58 29 20 10 233 244 226 34 20 10 202 117 173 214 100 178 217 150 133 73 38 253 254 161 33 16 4 37 165 212 213 89 173 130 0 165 82 62 47 73 240 225 135 74 202 17 69 133 208 37 135 115 124 60 24 76 167 225 193 7 123 123 183 111 191 49 78 163 209 98 81 82 224 202 98 213 102 128 36 37 18 217 44 20 10 197 98 169 4 106 117 38 19 143 131 86 91 83 211 220 12 197 98 46 151 76 42 126 190 40 42 199 73 148 247 74 46 215 106 43 42 204 102 208 235 109 182 166 38 136 197 102 103 7 6 96 201 54 14 4 22 22 162 81 200 231 139 69 89 86 170 172 84 10 22 22 124 190 249 121 101 231 156 201 64 36 34 203 90 45 36 147 90 173 82 247 111 222 188 252 136 17 108 54 135 163 190 30 76 38 101 159 112 207 8 112 225 194 192 128 199 3 79 61 117 240 224 23 190 176 124 125 105 68 150 203 178 92 44 66 46 39 73 161 16 40 142 61 84 84 212 212 180 180 64 62 175 88 4 201 164 219 125 229 10 132 66 225 240 226 34 84 87 91 173 85 85 48 63 31 10 137 34 148 74 202 147 90 73 74 36 146 73 240 122 131 65 81 4 48 26 5 1 166 166 210 105 131 1 106 107 27 27 107 107 193 106 85 8 95 170 126 30 124 80 41 139 111 23 86 253 84 196 201 147 191 254 245 51 207 192 195 15 63 252 240 142 29 160 211 85 86 86 85 45 167 158 76 70 146 194 97 8 6 23 23 51 25 104 106 114 56 172 86 240 122 125 62 191 31 172 214 170 42 65 128 43 87 6 7 39 38 32 145 40 20 74 37 16 197 120 60 153 92 174 150 174 93 27 30 158 155 131 145 145 185 185 64 0 70 70 102 102 66 161 101 55 116 133 232 188 211 127 208 184 85 123 170 92 222 178 165 163 163 185 25 52 26 131 65 16 148 148 19 143 67 161 144 74 45 46 130 86 171 209 104 52 240 192 3 117 117 130 0 233 116 42 149 76 42 150 130 36 65 127 255 208 208 244 52 132 66 209 168 36 129 32 40 251 131 37 55 117 116 116 98 194 235 133 179 103 175 93 155 153 129 96 48 26 77 38 151 18 213 237 176 215 238 168 0 55 143 166 38 197 157 212 235 5 161 182 86 89 36 211 105 200 229 226 241 64 224 198 239 23 10 197 98 177 8 243 243 129 64 56 12 211 211 94 111 32 160 16 13 96 54 11 130 193 160 216 209 137 4 124 240 193 192 192 228 36 132 195 177 88 50 9 129 64 36 146 76 174 62 225 159 196 170 9 240 181 175 237 221 187 109 27 168 84 202 113 143 124 94 25 241 159 196 146 205 188 176 16 14 139 34 204 206 250 124 225 176 146 58 84 42 229 81 227 200 8 228 114 133 130 44 131 86 171 156 98 80 171 149 87 159 47 20 146 164 187 143 248 37 172 154 0 59 119 110 217 210 214 182 188 177 82 169 212 106 141 230 198 239 229 114 185 92 62 15 94 175 226 209 44 157 74 184 126 125 122 218 239 7 183 59 16 88 92 4 183 59 24 140 197 238 94 162 255 31 86 109 31 112 232 208 115 207 29 59 166 82 201 242 210 206 83 113 57 63 137 104 84 20 37 105 121 68 7 2 145 136 36 193 137 19 167 79 95 190 172 82 125 86 137 95 194 170 111 196 202 229 255 125 206 38 157 206 100 178 89 48 24 244 122 157 78 89 100 227 113 248 199 63 46 94 28 27 91 237 168 215 176 134 53 172 12 254 13 220 222 31 79 192 215 34 195 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:08'!translation	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 2 82 73 68 65 84 120 218 237 150 191 106 194 80 20 135 175 165 110 250 16 86 66 199 128 139 116 232 35 152 181 72 36 184 20 132 14 78 46 18 16 33 147 62 66 183 46 77 23 31 32 56 185 56 41 100 22 218 161 67 119 151 14 29 110 7 57 4 143 164 73 108 146 147 120 207 183 92 126 33 38 242 157 63 68 8 134 148 10 245 31 160 162 213 178 172 86 75 74 200 219 237 203 203 118 11 169 146 155 151 43 106 17 212 104 218 253 253 237 45 221 251 175 169 5 228 5 238 248 184 247 29 38 35 187 137 80 102 5 129 216 184 29 255 246 246 248 248 250 10 41 191 149 116 225 64 103 7 231 195 195 243 115 183 123 122 253 248 204 14 101 86 208 129 160 147 255 94 73 220 241 137 249 248 152 205 102 179 64 40 100 207 235 118 131 14 15 56 46 64 84 199 71 77 72 246 147 82 24 194 68 67 222 108 122 189 94 47 200 211 105 167 211 233 72 105 219 182 109 219 231 138 82 80 52 128 5 3 88 52 206 97 157 127 30 248 57 10 23 98 179 49 77 211 140 47 62 221 9 136 123 93 1 242 17 15 68 253 94 161 66 124 125 13 6 131 65 184 120 200 147 201 120 60 30 7 215 211 41 68 20 201 159 95 154 207 173 247 247 249 124 62 151 242 230 102 52 26 141 42 21 207 59 172 162 245 122 191 223 239 133 184 187 171 213 106 53 33 86 171 102 179 217 20 162 90 245 125 223 23 226 231 71 215 117 93 8 199 113 28 199 201 235 243 18 10 113 1 159 179 32 30 50 136 159 78 13 195 48 78 87 14 100 220 241 249 76 0 166 196 171 41 174 120 44 246 233 169 221 110 183 169 197 151 152 115 197 39 205 12 162 108 226 191 191 135 195 225 80 74 124 46 151 141 70 163 81 162 66 167 37 30 147 86 33 194 68 239 118 154 166 105 193 9 226 251 253 122 189 94 151 210 178 44 203 178 10 92 136 172 196 99 146 222 31 87 56 22 143 11 64 237 151 92 252 127 73 42 190 240 19 80 22 241 24 22 79 76 148 248 176 213 67 94 136 178 139 199 43 8 139 198 185 48 19 112 233 226 225 190 40 241 185 23 66 21 241 88 44 249 234 81 85 124 210 204 226 89 252 101 137 199 100 94 8 22 31 15 22 143 200 75 124 234 176 120 34 88 60 17 44 158 136 207 207 197 98 177 96 241 228 176 248 130 193 226 11 2 139 87 28 22 79 4 139 39 130 197 19 193 226 137 96 241 68 176 120 34 164 116 93 215 101 241 228 176 248 130 193 226 11 130 106 226 127 1 94 140 135 70 242 90 129 96 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 6/21/2007 16:24'!undo	^ self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 8 6 0 0 0 87 2 249 135 0 0 0 6 98 75 71 68 0 255 0 255 0 255 160 189 167 147 0 0 0 9 112 72 89 115 0 0 13 215 0 0 13 215 1 66 40 155 120 0 0 0 7 116 73 77 69 7 215 6 21 14 22 33 113 7 92 185 0 0 7 60 73 68 65 84 104 222 237 89 107 108 20 215 21 254 238 157 153 125 122 237 181 177 215 15 176 193 177 113 32 161 113 29 40 33 102 72 8 105 72 34 138 148 168 65 233 35 49 83 210 170 106 165 72 105 127 164 162 74 164 86 85 155 164 74 11 149 104 162 40 73 181 38 52 13 105 107 42 34 145 166 136 38 38 107 48 21 41 208 96 108 48 182 99 27 227 7 182 215 235 245 122 119 102 238 220 219 31 187 80 199 216 142 141 119 183 137 228 35 141 102 164 189 115 231 251 238 61 247 156 239 156 5 22 108 193 22 236 11 109 36 85 19 7 252 120 16 32 127 1 196 34 85 67 44 85 223 161 169 152 180 161 150 124 223 225 41 254 43 32 156 169 222 129 164 19 56 246 134 244 130 39 175 114 87 229 131 117 78 66 8 79 53 1 57 137 46 163 72 146 252 102 78 241 189 95 43 191 227 5 7 145 92 105 57 3 52 73 224 179 36 89 62 186 248 150 237 91 203 239 124 209 1 222 158 182 67 44 39 1 124 177 36 201 245 101 107 127 186 36 119 233 54 69 152 231 0 30 1 148 47 0 129 128 31 149 84 146 143 220 114 207 158 108 79 222 58 42 140 51 128 48 210 26 70 229 121 128 223 44 219 220 117 183 109 174 117 57 50 74 72 28 188 149 246 60 112 67 4 26 106 201 14 155 203 183 231 182 205 251 156 138 205 9 97 52 1 16 147 70 9 72 74 38 129 24 111 106 252 35 206 91 140 157 22 66 180 0 104 5 208 172 106 24 249 191 36 178 99 111 72 191 116 121 203 159 186 117 147 223 69 201 56 192 58 167 89 154 18 128 228 128 25 87 96 198 250 97 140 247 136 232 104 103 44 60 212 98 6 47 159 80 0 243 109 139 177 159 171 26 58 210 66 32 224 135 44 73 242 94 111 209 250 135 43 170 119 57 32 250 0 214 55 195 27 102 226 110 3 72 252 34 196 1 16 39 132 144 49 124 233 239 172 227 212 171 166 197 70 15 89 204 124 86 213 208 156 50 2 1 63 60 146 44 31 42 172 216 182 166 184 114 167 3 172 13 176 130 51 188 193 1 48 64 152 16 194 188 246 124 237 78 156 32 202 114 128 248 48 210 123 152 183 127 244 138 206 204 208 33 139 153 143 205 85 118 144 89 128 47 146 100 185 190 180 234 169 165 190 242 26 69 152 205 0 31 251 140 183 174 2 54 33 196 36 240 19 126 3 177 3 114 5 32 149 160 231 220 107 177 203 231 235 154 44 198 238 85 53 132 146 66 32 224 199 42 42 73 239 175 216 240 171 156 172 130 77 84 232 167 33 68 44 30 109 196 56 32 24 0 1 1 145 56 196 2 16 28 32 18 8 20 0 28 2 102 28 240 213 11 137 93 185 74 66 24 32 52 11 212 181 5 253 109 117 70 215 199 111 117 89 22 83 85 13 253 243 38 208 80 75 130 55 173 254 110 86 238 178 175 19 22 122 21 156 13 64 240 49 64 68 103 185 60 87 253 222 14 66 221 0 205 72 4 190 56 240 107 46 38 12 16 234 130 156 249 77 12 117 253 147 117 156 222 119 133 91 92 85 53 180 207 119 7 54 75 178 237 192 10 245 71 46 135 203 1 99 228 181 249 39 42 34 131 16 119 156 16 177 1 194 128 16 70 124 94 98 131 205 187 3 35 125 167 121 251 169 55 207 115 75 220 170 106 215 197 231 57 159 129 59 168 68 255 177 124 237 14 143 219 91 68 98 67 187 33 120 36 73 213 136 18 39 2 154 32 162 131 16 59 156 190 95 160 245 196 174 200 232 149 142 31 170 26 246 38 35 10 173 164 148 124 88 90 245 104 118 86 254 42 26 27 250 13 196 140 81 232 6 52 37 81 18 231 130 67 113 223 3 33 175 67 211 251 207 13 115 142 98 85 195 248 188 212 168 170 161 153 115 113 123 199 169 183 122 134 186 143 51 103 238 78 80 185 32 137 4 56 32 244 68 248 5 204 72 61 20 187 19 190 210 117 110 74 241 76 210 50 113 192 143 92 42 225 104 65 217 221 229 133 21 15 41 177 161 221 224 230 212 153 88 113 127 21 138 103 11 32 24 132 136 2 60 10 110 13 193 210 207 194 138 157 133 224 163 51 126 75 178 175 128 146 249 4 206 28 222 25 229 140 21 78 23 90 231 164 133 84 13 131 1 63 214 246 181 213 31 102 122 164 170 248 75 63 182 235 193 151 97 233 45 215 141 181 101 62 140 166 250 231 25 183 162 134 108 115 114 197 230 230 206 204 60 155 183 224 203 14 151 239 219 16 86 15 244 208 159 192 141 169 149 132 165 183 192 70 34 240 228 44 181 66 3 109 85 0 62 72 138 152 83 53 140 5 252 184 123 240 210 201 3 166 17 217 84 122 251 15 28 102 168 22 44 246 239 73 206 233 68 44 220 77 132 64 149 30 129 19 128 119 164 191 101 213 64 199 135 223 16 144 215 248 150 126 69 20 221 252 164 211 210 255 5 99 180 110 202 232 198 141 78 120 22 149 56 66 3 109 171 167 35 112 67 21 153 170 193 224 22 182 134 6 154 247 95 60 177 59 170 100 62 14 217 181 97 186 225 93 170 134 51 170 134 122 85 195 239 239 124 12 27 56 99 121 3 29 199 95 255 248 200 179 81 93 95 36 236 217 79 76 125 50 204 78 184 50 75 100 73 198 93 73 47 41 85 13 188 250 113 104 99 195 29 123 90 26 126 29 149 220 91 161 100 60 48 235 93 172 174 193 147 166 30 185 171 181 241 149 136 101 229 66 201 184 239 122 55 50 59 225 200 92 6 33 176 58 101 53 113 117 13 158 142 134 123 159 105 174 127 62 70 108 42 108 153 219 230 178 8 39 45 198 190 117 161 241 229 168 146 241 80 92 27 77 172 40 88 63 20 123 30 4 71 126 74 139 250 245 53 248 173 17 29 254 222 185 250 231 162 156 84 192 238 253 206 92 72 188 195 98 131 23 245 72 39 36 91 233 167 67 164 148 11 51 214 11 74 209 157 242 190 208 250 237 216 103 234 145 71 154 143 190 56 110 154 217 115 203 2 28 135 35 193 11 156 42 203 62 13 78 46 64 44 220 9 16 156 74 75 99 75 213 112 136 153 250 125 45 129 223 133 195 87 26 196 28 68 189 141 16 65 38 71 34 42 251 48 62 218 195 44 134 99 105 235 204 169 26 142 89 150 85 221 218 248 135 160 16 144 102 37 36 40 54 58 60 5 196 154 148 20 137 156 135 72 240 114 20 72 211 14 76 32 113 150 115 177 26 248 108 57 28 23 139 238 155 236 174 92 112 243 210 4 255 95 4 1 47 66 131 29 74 218 9 36 72 124 2 160 122 66 113 60 21 120 59 165 216 191 172 242 126 167 21 61 145 208 67 137 12 235 170 198 96 215 113 19 220 216 171 106 8 166 188 55 58 13 137 254 153 154 4 148 162 54 187 240 102 159 59 43 151 232 35 7 255 183 170 182 50 112 228 163 183 237 61 198 57 126 150 150 230 238 92 123 169 84 194 187 217 249 101 149 75 86 110 116 154 225 131 137 242 20 32 82 22 100 231 70 92 60 249 78 68 88 198 211 170 134 222 207 21 129 128 31 249 84 66 99 97 89 85 81 94 73 165 205 28 59 0 206 6 18 224 189 80 50 182 160 231 66 32 22 29 235 127 111 253 118 188 148 182 246 250 172 75 23 9 251 23 47 95 183 36 167 104 137 108 140 254 249 90 117 71 229 124 200 174 77 232 110 57 30 29 233 107 63 195 45 212 164 165 59 61 199 213 127 192 233 41 90 147 93 84 34 27 225 191 37 20 40 133 228 168 4 145 203 241 201 127 62 24 15 7 123 143 112 11 143 168 26 140 207 29 1 0 65 42 201 22 248 24 8 117 131 72 197 144 236 43 17 30 30 18 221 205 7 99 156 233 47 113 142 159 168 26 102 253 207 78 186 9 52 71 66 151 73 112 96 49 207 240 170 52 26 30 196 112 235 71 227 225 225 222 62 110 225 81 85 195 201 148 55 119 147 224 70 37 84 66 29 128 66 66 208 96 49 188 11 96 159 170 77 159 47 22 108 193 22 108 122 251 47 1 167 63 47 137 31 193 98 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 11/26/2005 19:08'!vector	^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255 255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72 0 70 201 107 62 0 0 1 73 73 68 65 84 120 218 237 213 49 142 130 64 20 128 225 113 59 11 14 65 193 77 188 0 23 152 120 3 206 194 13 204 196 130 154 130 202 214 83 88 16 19 75 58 10 27 34 86 47 36 99 8 236 46 227 51 248 127 141 25 108 204 255 230 161 49 0 0 0 0 0 0 111 179 209 254 1 159 226 126 207 178 44 235 123 255 249 249 92 150 101 105 204 110 87 215 117 189 89 188 215 215 13 96 44 244 237 86 85 85 53 156 175 215 174 235 58 99 142 199 166 105 26 99 30 143 52 77 83 99 156 115 206 185 229 6 177 250 1 204 13 46 36 188 144 1 28 14 109 219 182 203 111 192 143 118 160 208 182 219 60 207 243 33 220 220 240 62 107 173 181 246 117 144 255 181 250 13 240 93 46 73 146 36 67 200 177 240 161 95 61 98 245 27 48 102 234 198 11 9 31 106 3 190 102 0 99 255 5 114 211 199 206 18 62 212 6 172 158 132 151 87 207 233 20 199 113 220 247 251 125 20 69 209 48 16 57 203 167 127 227 67 109 192 106 205 13 239 135 157 250 30 19 254 26 254 183 103 120 8 175 100 169 240 62 6 49 33 84 120 31 225 61 239 10 15 15 225 149 16 94 9 225 149 16 94 9 225 149 16 94 9 225 149 16 94 9 225 149 16 94 9 225 149 16 94 9 225 149 244 125 81 20 5 225 213 17 254 195 16 254 67 16 30 0 0 0 175 158 187 58 229 157 66 156 78 5 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'accessing' stamp: 'HilaireFernandes 4/2/2006 10:53'!viewer^self formFromGraphic: #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 24 0 0 0 24 8 2 0 0 0 111 21 170 175 0 0 0 6 98 75 71 68 0 255 0 255 0 255 160 189 167 147 0 0 0 9 112 72 89 115 0 0 14 196 0 0 14 196 1 149 43 14 27 0 0 0 7 116 73 77 69 7 214 4 2 8 52 1 149 4 169 0 0 0 0 180 73 68 65 84 56 203 197 85 203 14 195 48 8 35 86 255 187 233 143 199 59 108 107 9 143 164 149 50 205 226 20 192 134 146 208 66 82 86 0 178 8 91 230 40 199 17 158 115 223 227 120 223 218 69 225 115 190 46 79 103 137 62 44 137 172 166 179 92 84 144 90 133 188 107 181 234 92 76 63 202 0 58 165 159 218 184 35 131 62 24 163 114 10 172 229 69 33 86 56 211 216 132 45 56 119 41 136 11 49 201 221 116 90 88 26 158 177 228 92 72 131 52 157 246 122 177 244 137 104 46 173 60 212 72 222 218 169 60 232 58 109 205 223 128 247 200 180 37 79 239 34 226 163 171 24 45 3 100 10 115 244 193 152 46 154 59 229 172 92 35 63 91 108 43 87 237 159 255 34 47 138 168 164 232 254 82 152 242 0 0 0 0 73 69 78 68 174 66 96 130)! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 11/27/2005 19:46'!formFromGraphic: anArray	^ self formFromPNG: anArray ! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 11/26/2005 18:52'!formFromPNG: anArray	^(PNGReadWriter createAFormFrom: anArray asByteArray ) at: 1! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 3/29/2010 22:39'!scaled16: symbol	^ (self perform: symbol) scaledToSize: 16@16! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 3/30/2010 13:29'!scaled24: symbol	^ (self perform: symbol) scaledToSize: 24@24! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 4/28/2010 17:41'!segmentMorph: thick color: color dash: dash	^ (LineMorph from: 0@0 to: 60@0 color: color width: thick) 		dashedBorder: dash! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 4/28/2010 17:58'!segment: thick color: color dash: dash	^ (self segmentMorph: thick color: color dash: dash)		imageForm! !!DrGIcons class methodsFor: 'form' stamp: 'HilaireFernandes 4/28/2010 18:00'!segment: thick color: color dash: dash arrow: symbol	| morph |	morph := self segmentMorph: thick color: color dash: dash.	morph perform: symbol.	^ morph imageForm! !!DrGIntersectionPointItem methodsFor: 'comparing' stamp: 'HilaireFernandes 1/12/2006 22:22'!hash	^super hash bitXor: k hash! !!DrGIntersectionPointItem methodsFor: 'comparing' stamp: 'HilaireFernandes 1/12/2006 22:22'!= aMathItem	^ super = aMathItem and: [k = aMathItem k]! !!DrGIntersectionPointItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/30/2010 22:17'!initialize: theParents"check for the right intersection point when one parent is a circle or an arc"|pointA pointB clicPoint|	super initialize: theParents.	(theParents first isCircleItem 		or: [theParents second isCircleItem	 		or: [theParents first isArcItem				or: [theParents second isArcItem]]])		ifFalse: [^self].	pointA := theParents first intersectionWith: theParents second flag: -1.	pointB := theParents first intersectionWith: theParents second flag: 1.	pointA ifNil: [k := 1. ^self].	pointB ifNil: [k := -1.	^self].	clicPoint := theParents third.	(pointA squaredDistanceTo: clicPoint) < (pointB squaredDistanceTo: clicPoint)		ifTrue: [k := -1] 		ifFalse: [k := 1]! !!DrGIntersectionPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:28'!isConstrainedPointItem	^true! !!DrGIntersectionPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:26'!isIntersectionPointItem	^true! !!DrGIntersectionPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/12/2006 22:21'!k	^k! !!DrGIntersectionPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2008 15:26'!k: integer 	k := integer.	self update! !!DrGIntersectionPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 19:06'!parents: aCollection 	"We only need the 1st and 2nd mathItem in the collection. The 3rd one is a Point instance (position the user clicked) only used at initialization time"	aCollection ifNil: 		[parents := nil.		^self].	parents := OrderedCollection new		add: aCollection first;		add: aCollection second;		yourself! !!DrGIntersectionPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:59'!nodeType	^#Intersection! !!DrGIntersectionPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 4/25/2010 22:38'!writeAsXmlTo: aNode 	| node |	node := super writeAsXmlTo: aNode.	node		attributeAt: #extra		put: (k = 1				ifTrue: ['1']				ifFalse: ['0']).	^node! !!DrGIntersectionPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update	|aPoint|	self doesParentExist ifTrue:		[aPoint := (parents first intersectionWith: parents second flag: k).		aPoint 			ifNil: [exist := false]			ifNotNil: 				[exist := true.				self point: aPoint]].! !!DrGIntersectionPointItem commentStamp: '<historical>' prior: 0!k 				- (-1) or 1 when they are 2 intersection points!!DrGLabelMorph methodsFor: 'editing' stamp: 'HilaireFernandes 3/12/2006 21:47'!acceptContents	costume mathItem name: contents asString.! !!DrGLabelMorph methodsFor: 'event handling' stamp: 'HilaireFernandes 2/22/2006 15:39'!mouseMove: evt	costume 		ifNotNil: 			[costume constraintTextPosition: evt cursorPoint.			self position: costume textPosition].! !!DrGLine2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:02'!nodeType	^#'2pts'! !!DrGLine2PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:36'!parentQty	^2! !!DrGLine2PointsItem methodsFor: 'comparing' stamp: 'HilaireFernandes 4/30/2010 22:15'!= aMathItem	^ aMathItem 		ifNil: [false]		ifNotNil: [self basicType = aMathItem basicType 			and: [ self nodeType = aMathItem nodeType ]			and: [(self parents includesAllOf: aMathItem parents)				and: [aMathItem parents includesAllOf: self parents]]]! !!DrGLineBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:55'!mathItemClass	^DrGLine2PointsItem! !!DrGLineCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#line! !!DrGLineCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:02'!instantiateMorph	morph := DrGLineMorph new! !!DrGLineCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/12/2006 22:40'!redraw	super redraw.	morph		from: (drawable worldToMorph: mathItem origin)		direction: (drawable vectorToMorph: mathItem direction)! !!DrGLineCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:02'!styleClass	^DrGCurveCostumeStyle! !!DrGLineItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/24/2006 22:55'!abscissaOf: aPoint 	^(aPoint - origin dotProduct: vector normalized) arcTan 		* DrGDirectionItem invPi + 0.5! !!DrGLineItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/31/2005 11:41'!closestPointTo: aPoint	|unitVector|	unitVector := vector normalized.	^origin + (((aPoint - origin) dotProduct: unitVector) * unitVector)! !!DrGLineItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/12/2006 17:31'!contains: aPoint	(vector crossProduct: (aPoint - origin)) closeTo: 0! !!DrGLineItem methodsFor: 'computing' stamp: 'HilaireFernandes 4/30/2010 22:18'!intersectionWith: aCurveItem flag: aFlag	aCurveItem isLineItem 		ifTrue: [^ self intersectionWithDirection: aCurveItem].	(aCurveItem isSegmentItem 		or: [aCurveItem isRayItem 			or: [aCurveItem isCircleItem				or: [aCurveItem isArcItem]]])			ifTrue: [^ aCurveItem intersectionWith: self flag: aFlag].! !!DrGLineItem methodsFor: 'computing' stamp: 'HilaireFernandes 5/13/2010 10:56'!pointAt:	anAbscissa	|point abscissa|	"In the interval [-0.5 ; 0.5]"	abscissa := anAbscissa - 0.5.	(abscissa = 0.5 or: [abscissa = -0.5]) 		ifTrue:			[point := abscissa * vector.			point x > 0 				ifTrue: [point := Float infinity @ point y] 				ifFalse: [point := 0 - Float infinity @ point y].			point y > 0				ifTrue: [point := point x @ Float infinity] 				ifFalse: [point := point x @ (0 - Float infinity)]]		ifFalse:			[abscissa := abscissa * Float pi.			point := origin + (abscissa tan * vector normalized)].	^point! !!DrGLineItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 14:22'!adaptiveDescriptiveName	^ 'This line %1' translated! !!DrGLineItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#line! !!DrGLineItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:36'!isCurveItem	^true! !!DrGLineItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:36'!isLineItem	^true! !!DrGLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:22'!nodeName	^ 'line'! !!DrGLineMorph methodsFor: 'layout' stamp: 'HilaireFernandes 4/21/2010 08:39'!extendFrom: aPoint direction: u| p1 p2 drawable r|	drawable := self costume drawable.	r := u x asFloat / u y.	p1 := Point x: ((drawable top - aPoint y) * r + aPoint x) asInteger y: drawable top.	p2 := Point x: ((drawable bottom - aPoint y) * r + aPoint x) asInteger 		y: drawable bottom.	super from: p1 to: p2.! !!DrGLineMorph methodsFor: 'layout' stamp: 'HilaireFernandes 12/31/2005 10:45'!extendHorizontally: aPoint| p1 p2 drawable|	drawable := self costume drawable.	p1 := Point x: drawable left y: aPoint y.	p2 := Point x: drawable right y: aPoint y.	super from: p1 to: p2! !!DrGLineMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 11:07'!from: aPoint direction: u	u y abs < 0.001 		ifTrue: [self extendHorizontally: aPoint]		ifFalse: [self extendFrom: aPoint direction: u]! !!DrGLineMorph commentStamp: '<historical>' prior: 0!A DGLineMorph is extented to the boundary of its parent morph, a drawable in Dr. Geo jargon.!!DrGLocusBuilder methodsFor: 'private' stamp: 'jlrr 11/13/2007 12:05'!addItem: aMathItemCollection at: aPoint 	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection first isPointItemOnCurve		ifTrue: [freePoint				ifNil: [freePoint := aMathItemCollection first.					^ self].			constrainedPoint				ifNil: [constrainedPoint := aMathItemCollection first]]		ifFalse: [constrainedPoint				ifNil: [constrainedPoint := aMathItemCollection first.					^ self].			freePoint				ifNil: [freePoint := aMathItemCollection first]]! !!DrGLocusBuilder methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:05'!arguments	^ {freePoint. constrainedPoint}! !!DrGLocusBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 11/13/2007 20:30'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty		and: [(aMathItemCollection first isPointItemOnCurve					and: [aMathItemCollection first ~= freePoint]					and: [aMathItemCollection first ~= constrainedPoint])				or: [aMathItemCollection first isConstrainedPointItem 						and: [aMathItemCollection first ~= freePoint]						and: [aMathItemCollection first ~= constrainedPoint]]]! !!DrGLocusBuilder methodsFor: 'testing' stamp: 'jlrr 11/13/2007 12:05'!readyToBuild	^ freePoint notNil		and: [constrainedPoint notNil]! !!DrGLocusBuilder methodsFor: 'constant' stamp: 'jlrr 11/13/2007 12:05'!mathItemClass	^ DrGLocusItem! !!DrGLocusBuilder methodsFor: 'updating' stamp: 'jlrr 11/13/2007 12:06'!reset	super reset.	freePoint := constrainedPoint := nil! !!DrGLocusCostume methodsFor: 'testing' stamp: 'jlrr 11/13/2007 12:15'!basicType	^ #locus! !!DrGLocusCostume methodsFor: 'initialize-release' stamp: 'jlrr 11/13/2007 12:16'!instantiateMorph	morph := DrGLocusMorph new.	morph color: Color red.	morph borderColor: Color orange.	morph width: 2! !!DrGLocusCostume methodsFor: 'updating' stamp: 'jlrr 11/13/2007 12:16'!redraw	morph free: mathItem freePoint constrained: mathItem constrainedPoint! !!DrGLocusCostume methodsFor: 'style' stamp: 'jlrr 11/13/2007 12:16'!styleClass	^ DrGFinitCurveCostumeStyle! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:08'!abscissaOf: aPoint 	| i distance |	distance := self squareNorm: aPoint					- (p at: 1).	i := 1.	2		to: sampleNumber		do: [:n | (self squareNorm: (p at: n)						- aPoint)					< distance				ifTrue: [distance := self squareNorm: aPoint									- (p at: n).					i := n]].	^ (i / sampleNumber) asFloat! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!basicType	^ #locus! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!closestPointTo: aPoint 	| distance d m |	m := p at: 1.	distance := self squareNorm: aPoint - m.	2		to: sampleNumber		do: [:n | 			d := self squareNorm: (p at: n)							- aPoint.			d < distance				ifTrue: [m := p at: n.					distance := d]].	^ m! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!constrainedPoint	^ parents second! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!freePoint	^ parents first! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!parentQty	^ 2! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!pointAt: anAbscissa 	| m |	anAbscissa = 1.0		ifTrue: [m := p at: sampleNumber]		ifFalse: [m := p at: (anAbscissa * sampleNumber) rounded].	^ m! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!points: aCollection 	p := aCollection! !!DrGLocusItem methodsFor: 'accessing' stamp: 'jlrr 11/13/2007 12:09'!samples: aNumber 	sampleNumber := aNumber! !!DrGLocusItem methodsFor: 'private' stamp: 'jlrr 11/13/2007 12:08'!adaptiveDescriptiveName	^ 'This locus %1' translated! !!DrGLocusItem methodsFor: 'private' stamp: 'jlrr 11/13/2007 12:08'!squareNorm: aPoint 	^ aPoint x * aPoint x + (aPoint y * aPoint y)! !!DrGLocusItem methodsFor: '*DrGeoII-Core-testing' stamp: 'jlrr 11/13/2007 12:10'!isCurveItem	^ true! !!DrGLocusItem methodsFor: '*DrGeoII-Core-testing' stamp: 'jlrr 11/13/2007 12:10'!isGeometricItem	^ true! !!DrGLocusItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2008 22:59'!isLocusItem	^ true! !!DrGLocusItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:22'!nodeName	^'locus'! !!DrGLocusItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:22'!nodeType	^#none! !!DrGLocusItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update! !!DrGLocusMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/26/2008 09:19'!free: free constrained: constrained 	| x0 step x drawable myDomain points samples |	drawable := costume drawable.	x0 := free abscissa.	x := 0.001.	samples := 200.	step := 1.0 / samples.	points := Array new: samples.	free abscissa: x.	myDomain := costume domain.	myDomain updateAllMathItemsButLocus.	points at: 1 put: constrained point copy.	vertices := OrderedCollection new				add: (drawable						worldToMorph: (points at: 1));				 yourself.	2		to: samples		do: [:n | 			x := x + step.			free abscissa: x.			myDomain updateAllMathItemsButLocus.			points at: n put: constrained point copy.			vertices				add: (drawable						worldToMorph: (points at: n))].	self costume mathItem points: points.	self costume mathItem samples: samples.	free abscissa: x0.	myDomain updateAllMathItemsButLocus.	self computeBounds! !!DrGMacro methodsFor: 'private' stamp: 'HilaireFernandes 7/31/2008 11:52'!cleanNodes	nodes do: [ :node | 		node itemTemplate: 			((node itemTemplate copy) 				parents: nil;				yourself).		node itemTemplate releaseActionMap.]! !!DrGMacro methodsFor: 'private' stamp: 'HilaireFernandes 7/27/2008 20:29'!extractItemsFrom: inputs to: outputs in: domain 	"extract the items to define the whole macro structure"	| items parents tmp |	items := (Set		withAll: inputs)		addAll: outputs;		yourself.	parents := outputs.	[ (inputs includesAllOf: parents) | parents isEmpty ] whileFalse: 		[ tmp := parents.		parents := Set new.		tmp do: [ :item | item parents ifNotNil: [ parents addAll: item parents ] ].		items addAll: parents ].	^ domain factory ordered: items! !!DrGMacro methodsFor: 'private' stamp: 'HilaireFernandes 7/26/2008 21:15'!itemToNode: item	^ nodes detect: [:node |node itemTemplate = item]! !!DrGMacro methodsFor: 'private' stamp: 'HilaireFernandes 7/31/2008 13:47'!updateParentNodes	nodes do: 		[ :node | 		node isInputNode | node itemTemplate parents isNil ifFalse: 			[ node parentNodes: (node itemTemplate parents collect: [ :item | self itemToNode: item ]) ] ]! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/31/2008 14:47'!constructedNodes	^ nodes select: [:node | node isInputNode not]! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 17:10'!description	^ description! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 17:10'!description: anObject	description := anObject! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/29/2008 09:32'!inputBasicType"The basic type of the input parameters"	^self inputNodes collect: [:n | n itemTemplate basicType]! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 15:42'!inputNodes	^ nodes select: [:node | node isInputNode]! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/27/2008 12:03'!nodes	^nodes! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 15:43'!outputNodes	^ nodes select: [:node | node isOutputNode]! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 17:10'!title	^ title! !!DrGMacro methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 17:10'!title: anObject	title := anObject! !!DrGMacro methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/31/2008 22:55'!execute: inputs 	self cleanNodes.	self inputNodes 		with: inputs		do: [ :node :item | node itemTemplate: item ].	nodes do: 		[ :node | (node isInputNode or: [ node parentNodes isNil ]) ifFalse: 			[node itemTemplate parents: (node parentNodes collect: 				[ :aNode | aNode itemTemplate]).			node itemTemplate update ] ].	^ self constructedNodes collect: [ :n | n itemTemplate ]! !!DrGMacro methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/31/2008 11:54'!from: inputs to: outputs in: domain 	"build the tree nodes"	| items |	items := self 		extractItemsFrom: inputs		to: outputs		in: domain.	nodes := items collect: 		[ :item | 		DrGMacroNode 			on: item			from: inputs			to: outputs ].	self updateParentNodes.	self cleanNodes! !!DrGMacro methodsFor: 'testing' stamp: 'HilaireFernandes 7/27/2008 12:18'!hash	^nodes hash! !!DrGMacro methodsFor: 'comparing' stamp: 'HilaireFernandes 7/27/2008 12:11'!= aMacro	^ nodes size = aMacro nodes size 		and: 			[nodes with: aMacro nodes do: [:n1 :n2 |				n1 = n2 ifFalse: [^false]].			true]! !!DrGMacro commentStamp: 'HilaireFernandes 7/18/2008 10:52' prior: 0!A DrGMacro is a macro-construction definitionInstance Variables	nodes:		<Object>nodes	- xxxxx!!DrGMacro class methodsFor: 'testing' stamp: 'HilaireFernandes 8/25/2008 10:50'!isValidWith: inputs and: outputs 	"check the validity of a macro defined with these input and output items"	| parents |	parents := Set new.	outputs do: [ :item | 		(inputs includes: item) 			ifTrue: 				["item is an input, we don't go to parents, we keep it"				parents add: item]			ifFalse: 				["item isn't an input, we go to its parents"				item parents ifNotNil: [ parents addAll: item parents]]].	parents isEmpty ifTrue: [ ^ false ].	(inputs includesAllOf: parents) ifTrue: [ ^ true ].	^ self 		isValidWith: inputs		and: parents! !!DrGMacroBuilder methodsFor: 'private' stamp: 'HilaireFernandes 7/24/2008 23:33'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	self isInputMode ifTrue: [self addToggleItem: aMathItemCollection in: input].	self isOutputMode ifTrue: [self addToggleItem: aMathItemCollection in: output]! !!DrGMacroBuilder methodsFor: 'callback' stamp: 'HilaireFernandes 7/27/2008 20:16'!apply	"the user clicked the apply button, do we have all the needed information	to instantiate a new macro construction?"	self isMacroValid ifTrue: 		[ "we can instantiate a macro"		self triggerEvent: #readyToBuild.		^self].	self isLogicValid ifFalse: 		[self inform: 'Input and output items don''t match' translated].	self isDescriptionValid ifFalse: 		[self inform: 'Please, enter a proper title and description' translated]! !!DrGMacroBuilder methodsFor: 'callback' stamp: 'HilaireFernandes 7/25/2008 19:34'!cancel	"the user withdrawn the macro-construction creation"	self triggerEvent: #cancel! !!DrGMacroBuilder methodsFor: 'callback' stamp: 'HilaireFernandes 7/28/2008 12:11'!page: integer 	"we receive notification from the wizard the user change the wizard	current page"	| newState |	(integer = 1 or: [ integer = 4 ]) ifTrue: [ newState := DrGMacroToolStateNeutral ].	integer = 2 ifTrue: [ newState := DrGMacroBuildToolStateInput ].	integer = 3 ifTrue: [ newState := DrGMacroBuildToolStateOutput ].	self 		triggerEvent: #changedState		with: newState! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/20/2008 18:11'!arguments	self shouldNotImplement! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:50'!description	^description ! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:50'!description: string	description := string! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:54'!input	^input! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:07'!inputName	^ self itemsName: input! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:00'!itemsName: aMathItemCollection	^aMathItemCollection collect: [:mathItem | mathItem descriptiveName]! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:54'!output	^output ! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:07'!outputName	^ self itemsName: output! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:49'!title	^title! !!DrGMacroBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 12:49'!title: string	title := string! !!DrGMacroBuilder methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 20:28'!buildItem	self shouldNotImplement! !!DrGMacroBuilder methodsFor: 'building' stamp: 'HilaireFernandes 7/31/2008 11:54'!buildItem: domain 	| macro |	macro := DrGMacro new		title: title; description: description.	macro 	from: input to: output 	in: domain.	^ macro! !!DrGMacroBuilder methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 20:27'!getItem	self shouldNotImplement! !!DrGMacroBuilder methodsFor: 'building' stamp: 'HilaireFernandes 7/27/2008 20:27'!getItem: domain	self isMacroValid ifTrue:		[^self buildItem: domain].	^nil! !!DrGMacroBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 7/22/2008 12:48'!defaultDescription	^'Write down your description there.' asText! !!DrGMacroBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 7/22/2008 12:48'!defaultTitle	^'Macro name' asText! !!DrGMacroBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 7/20/2008 18:09'!mathItemClass	self shouldNotImplement! !!DrGMacroBuilder methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 11:57'!initialize	self reset.	wizard := (DrGWizardMacroBuild builder: self) openInWorld.	self registerEvents ! !!DrGMacroBuilder methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/20/2008 10:28'!registerEvents	wizard when: #page send: #page: to: self.	wizard when: #apply send: #apply to: self.	wizard when: #cancel send: #cancel to: self.! !!DrGMacroBuilder methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 09:57'!release	self removeEvents.	wizard delete.	wizard := nil! !!DrGMacroBuilder methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/20/2008 10:30'!removeEvents	wizard removeActionsWithReceiver: self! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/22/2008 12:56'!isDescriptionValid	^ ((title = self defaultTitle) | (description = self defaultDescription)) not! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/24/2008 23:31'!isInputMode	^ wizard isInputPage! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/25/2008 10:46'!isLogicValid	"check wheter a macro can be deduced from the input/output item collections"	^ DrGMacro 		isValidWith: input		and: output! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/27/2008 20:17'!isMacroValid 	^self isLogicValid & self isDescriptionValid ! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/24/2008 23:31'!isOutputMode	^ wizard isOutputPage! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/25/2008 10:21'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty and: 		[ self isInputMode &  (output includes: aMathItemCollection first) not or: [ self isOutputMode & (input includes: aMathItemCollection first) not ] ]! !!DrGMacroBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 7/22/2008 15:09'!readyToBuild"Only when the user clicks on the wizard 'apply' button,the system checks wheter the macro can be instiated"	^false! !!DrGMacroBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 8/4/2008 09:44'!reset	super reset.	input := OrderedCollection new.	output := OrderedCollection new.	title := self defaultTitle.	description := self defaultDescription.	self changed: #inputName.	self changed: #ouputName.	self changed: #title.	self changed: #description! !!DrGMacroBuilder commentStamp: 'HilaireFernandes 7/18/2008 10:57' prior: 0!A DrGMacroBuilder is builder to construct a macro-construction.The builder needs an appropriate list of: - input & output mathItems selected in the drawing area - a macro-construction name & descriptionThe builder checks the validity of the macro-construction, ie it checks if the outputsitems are deductible from the input itemsInstance Variables!!DrGMacroBuildTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/27/2008 10:11'!cancel	"the builder informs us the user wants to cancel the macro building process"	presenter selectTool: DrGSelectTool! !!DrGMacroBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 21:27'!costumesAt: aPoint	^self pointCostumesFirstAt: aPoint ! !!DrGMacroBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:19'!selectCostumesFrom: aMathItemCollection 	presenter ifNil: [^self].	self stopBlinking.	selectedCostumes := self app costumesOf: aMathItemCollection.	self startBlinking! !!DrGMacroBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 8/18/2008 12:27'!selectInputCostume	self selectCostumesFrom: builder input! !!DrGMacroBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:18'!selectNoCostume	self selectCostumesFrom: OrderedCollection new! !!DrGMacroBuildTool methodsFor: 'accessing' stamp: 'HilaireFernandes 8/18/2008 12:27'!selectOutputCostume	self selectCostumesFrom: builder output! !!DrGMacroBuildTool methodsFor: 'initialization' stamp: 'HilaireFernandes 8/4/2008 10:18'!initialize	super initialize.	self switchState: DrGMacroToolStateNeutral ! !!DrGMacroBuildTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/27/2008 10:26'!registerDependant: anObject	builder when: #changedState send: #switchState: to: self.	builder when: #cancel send: #cancel to: self.	builder when: #readyToBuild send: #readyToBuildMacro to: anObject! !!DrGMacroBuildToolStateInput methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:16'!context: aContext	super context: aContext.	self context selectInputCostume ! !!DrGMacroBuildToolStateInput methodsFor: 'handling' stamp: 'HilaireFernandes 8/4/2008 10:46'!handleChoice: aCostumeCollection 	self context builder		add: (aCostumeCollection collect: [ :c | c mathItem ])				at: (self area gridWorldPoint: self context last);		changed: #inputName.	self context selectInputCostume! !!DrGMacroBuildToolStateInput commentStamp: 'HilaireFernandes 7/25/2008 09:05' prior: 0!When user selects input page, blink the cosumes related to this state. In this state the user can select items as input parameters for the macro. He can also unselect items.!!DrGMacroBuildToolStateOutput methodsFor: 'handling' stamp: 'HilaireFernandes 7/25/2008 13:36'!context: aContext	super context: aContext.	self context selectOutputCostume ! !!DrGMacroBuildToolStateOutput methodsFor: 'handling' stamp: 'HilaireFernandes 8/4/2008 10:47'!handleChoice: aCostumeCollection 	self context builder		add: (aCostumeCollection collect: [ :c | c mathItem ])			at: (self area gridWorldPoint: self context last);		changed: #outputName.	self context selectOutputCostume! !!DrGMacroBuildToolStateOutput commentStamp: 'HilaireFernandes 7/25/2008 09:06' prior: 0!When user selects  output page, blink the cosumes related to this state. In this state the user can select items as output parameters for the macro. He can also unselect items.!!DrGMacroFactories methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/22/2008 22:07'!initialize	super initialize.	pool := nil! !!DrGMacroFactories methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 22:15'!pool	^ pool ifNil: 		[ pool := OrderedCollection new.		DrGMacroFactory allInstancesDo: [ :factory |			factory pool ifNotNil: [pool addAll: factory pool] ].		pool ]! !!DrGMacroFactories commentStamp: 'HilaireFernandes 8/22/2008 21:43' prior: 0!A DrGMacroFactories is a facade to all DrGMacroFactory instances in the image, ie for the various open canvas.Instance Variables!!DrGMacroFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 21:55'!titles	^ self pool collect: [:m | m title]! !!DrGMacroHiddenNode methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/31/2008 11:46'!basicType	^#hiddenMacroNode! !!DrGMacroHiddenNode methodsFor: 'comparing' stamp: 'HilaireFernandes 7/31/2008 14:08'!hash	^(super hash) bitXor: parentNodes hash! !!DrGMacroHiddenNode methodsFor: 'comparing' stamp: 'HilaireFernandes 7/31/2008 14:08'!= aNode	^ super = aNode and:		[parentNodes = aNode parentNodes]! !!DrGMacroHiddenNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:42'!isHiddenNode	^true! !!DrGMacroHiddenNode methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 21:14'!parentNodes	^ parentNodes! !!DrGMacroHiddenNode methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 21:14'!parentNodes: anObject	parentNodes := anObject! !!DrGMacroInputNode methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/31/2008 11:47'!basicType	^#inputMacroNode! !!DrGMacroInputNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:42'!isInputNode	^true! !!DrGMacroInputNode commentStamp: 'HilaireFernandes 7/18/2008 10:53' prior: 0!A DrGMacroNode is a node in a macro-construction. It represents an abstracted math item in the macro-construction tree.Instance Variables!!DrGMacroNode methodsFor: 'accessing' stamp: 'HilaireFernandes 7/31/2008 11:49'!basicType	^#macroNode! !!DrGMacroNode methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 21:08'!itemTemplate	^itemTemplate! !!DrGMacroNode methodsFor: 'accessing' stamp: 'HilaireFernandes 7/26/2008 17:57'!itemTemplate: anItem	itemTemplate := anItem! !!DrGMacroNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/31/2008 14:05'!hash	^ itemTemplate basicType hash bitXor: 		(itemTemplate nodeType hash bitXor: self basicType hash)! !!DrGMacroNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:41'!isHiddenNode	^false! !!DrGMacroNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:41'!isInputNode	^false! !!DrGMacroNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:41'!isOutputNode	^false! !!DrGMacroNode methodsFor: 'comparing' stamp: 'HilaireFernandes 7/31/2008 14:02'!= aNode"this is what we expect for input item of the macro"	^ self basicType = aNode basicType 		and: [itemTemplate basicType = aNode itemTemplate basicType]		and: [itemTemplate  nodeType = aNode itemTemplate nodeType]		! !!DrGMacroNode class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/31/2008 14:09'!on: item from: inputs to: outputs"return the appropriate nodes depending on the item is an input, output or intermediate item"	| class |	class := DrGMacroHiddenNode.	(inputs includes: item) ifTrue: [class := DrGMacroInputNode].	(outputs includes: item) ifTrue: [class := DrGMacroOutputNode].	^ class new itemTemplate: item! !!DrGMacroOutputNode methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/31/2008 11:47'!basicType	^#outputMacroNode! !!DrGMacroOutputNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/31/2008 15:17'!isHiddenNode	^false! !!DrGMacroOutputNode methodsFor: 'testing' stamp: 'HilaireFernandes 7/26/2008 15:42'!isOutputNode	^true! !!DrGMacroPlayer methodsFor: 'private' stamp: 'HilaireFernandes 7/29/2008 09:50'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	self addToggleItem: aMathItemCollection in: input! !!DrGMacroPlayer methodsFor: 'building' stamp: 'HilaireFernandes 7/31/2008 13:14'!buildItem	^ selectedMacro execute: input! !!DrGMacroPlayer methodsFor: 'callback' stamp: 'HilaireFernandes 7/28/2008 12:37'!cancel	self triggerEvent: #cancel! !!DrGMacroPlayer methodsFor: 'callback' stamp: 'HilaireFernandes 7/29/2008 10:14'!page: integer 	"we receive notification from the wizard the user change the wizard	current page"	| newState |	integer = 1 		ifTrue: [ newState := DrGMacroToolStateNeutral ]		ifFalse: [ newState := DrGMacroPlayToolStateSelect].	self 		triggerEvent: #changedState		with: newState! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/31/2008 14:49'!constructedNodes	^ selectedMacro constructedNodes ! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:35'!description	^ selectedMacro ifNotNil: [selectedMacro description] ifNil: [^nil]! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:50'!description: text 	selectedMacro ifNotNil: [selectedMacro description: text]! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:13'!input	^input! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/29/2008 09:41'!inputBasicType	^input collect: [:i | i basicType]! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:34'!selectedMacro	^selectedMacro ! !!DrGMacroPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:06'!selectedMacro: aMacro	"Some cleaning are needed"	selectedMacro := aMacro.	input := OrderedCollection new.	self triggerEvent: #changedMacro.! !!DrGMacroPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/29/2008 09:43'!initialize	wizard := (DrGWizardMacroPlay builder: self) openInWorld.	input := OrderedCollection new.	self registerEvents! !!DrGMacroPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 10:45'!registerEvents	wizard when: #page send: #page: to: self.	wizard when: #cancel send: #cancel to: self.! !!DrGMacroPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 10:46'!release	self removeEvents.	wizard delete.	wizard := nil! !!DrGMacroPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 10:46'!removeEvents	wizard removeActionsWithReceiver: self! !!DrGMacroPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 7/29/2008 09:43'!isWanted: aMathItemCollection	selectedMacro isNil ifTrue: [^false].	^aMathItemCollection notEmpty and: 		[selectedMacro inputBasicType includesAllOf: (self inputBasicType 			add: aMathItemCollection first basicType; 			yourself)]! !!DrGMacroPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 7/29/2008 09:58'!readyToBuild	^ self inputBasicType = selectedMacro inputBasicType! !!DrGMacroPlayer methodsFor: 'updating' stamp: 'HilaireFernandes 8/4/2008 09:50'!reset	super reset.	input := OrderedCollection new.	selectedMacro := nil.	self changed: #description.	wizard changed: #selectedMacro! !!DrGMacroPlayer commentStamp: 'HilaireFernandes 7/18/2008 10:59' prior: 0!A DrGMacroPlayer is a builder used to play a macro-construction against a user provided list of input items.It chekcs the validity of the input items against the macro-construction definition.Instance Variables!!DrGMacroPlayTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/29/2008 09:24'!changedMacro" the builder inform us the user selected another macro-construction,do some cleaning"	self selectNoCostume! !!DrGMacroPlayTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/28/2008 22:06'!registerDependant: anObject	builder when: #changedState send: #switchState: to: self.	builder when: #cancel send: #cancel to: self.	builder when: #readyToBuild send: #readyToPlayMacro to: anObject.	builder when: #changedMacro send: #changedMacro to: self! !!DrGMacroPlayToolStateSelect methodsFor: 'handling' stamp: 'HilaireFernandes 8/4/2008 10:47'!handleChoice: aCostumeCollection 	self context builder 		add: (aCostumeCollection collect: [ :c | c mathItem ])		at: (self area gridWorldPoint: self context last).	self context selectInputCostume! !!DrGMacroToolStateNeutral methodsFor: 'accessing' stamp: 'HilaireFernandes 7/25/2008 13:18'!context: aContext	super context: aContext.	self context selectNoCostume! !!DrGMacroToolStateNeutral methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/4/2008 14:46'!handleMouseAt: aPoint	^false! !!DrGMacroToolStateNeutral commentStamp: 'HilaireFernandes 7/25/2008 09:05' prior: 0!When user switch to info pages (info and description pages), we unselect all selected costumes. In this state the user can't select any items.!!DrGMathItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/29/2005 09:27'!abscissaOf: aPoint	self subclassResponsibility! !!DrGMathItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/29/2005 09:26'!closestPointTo: aPoint	self subclassResponsibility ! !!DrGMathItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/12/2006 16:51'!intersectionWith: aCurveItem flag: aFlag	self subclassResponsibility ! !!DrGMathItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/29/2005 09:27'!pointAt: anAbscissa	self subclassResponsibility ! !!DrGMathItem methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 12:05'!actionMap	actionMap ifNil: [^self createActionMap].	^ actionMap ! !!DrGMathItem methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 16:54'!releaseActionMap	actionMap := nil! !!DrGMathItem methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 12:04'!updateableActionMap	actionMap ifNil:		[actionMap := self createActionMap].	^actionMap! !!DrGMathItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:16'!adaptiveDescriptiveName	^ 'This math item %1' translated! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 15:20'!basicType	^#mathItem! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 13:15'!descriptiveName	^ self adaptiveDescriptiveName 		copyReplaceAll: '%1'		with: self safeName! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/12/2006 17:12'!exist	^exist! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/14/2008 22:45'!id	^id! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/14/2008 22:46'!id: aSymbol	id := aSymbol! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/12/2006 10:25'!longDescription	^'A long description of this mathematic item'! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/12/2006 10:18'!name	^name! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/11/2006 10:42'!name: aString	name := aString ! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:31'!parentQty"how many parents do need this item to be fully defined"	self subclassResponsibility! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/6/2005 16:00'!parents	^ parents ! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/23/2008 11:42'!parents: aCollection	parents := aCollection.! !!DrGMathItem methodsFor: 'accessing' stamp: 'HilaireFernandes 9/26/2008 20:57'!safeName	^ (name isNil or: [name isEmpty]) 		ifTrue: [''] 		ifFalse: [ name ]! !!DrGMathItem methodsFor: 'testing' stamp: 'HilaireFernandes 1/12/2006 17:28'!contains: aPoint	self subclassResponsibility ! !!DrGMathItem methodsFor: 'testing' stamp: 'HilaireFernandes 3/1/2006 10:24'!doesParentExist	exist := true.	parents ifNotNil:		[parents do: [:parent |			parent exist ifFalse: [exist := false]]].	^exist				! !!DrGMathItem methodsFor: 'comparing' stamp: 'HilaireFernandes 1/28/2008 22:44'!hash	^ (self parents hash bitXor: self nodeType hash) bitXor: self basicType hash! !!DrGMathItem methodsFor: 'comparing' stamp: 'HilaireFernandes 4/10/2010 12:35'!= aMathItem 	^ aMathItem		ifNil: [false]		ifNotNil: [self basicType = aMathItem basicType			and: [self nodeType = aMathItem nodeType]			and: [self parents = aMathItem parents]]! !!DrGMathItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/18/2008 10:07'!initialize	parents := nil.	exist := true.! !!DrGMathItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 12/29/2005 10:20'!initialize: theParents! !!DrGMathItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/23/2008 11:44'!release	self triggerEvent: #deletedMathItem.	"Do it last otherwise our deletedMathItem will never be sent"	super release.! !!DrGMathItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:49'!moveAt: aPoint	self shouldNotImplement! !!DrGMathItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:04'!moveEvent: aPoint	"are we dirty?"	"self dirty ifFalse: [^self]."	(self moveParent: aPoint)		ifFalse:			["parents are not moving, we can upate ourself"			self move: aPoint].	"notify the dependant mathItems"	"self triggerEvent: #movedMathItem."! !!DrGMathItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:39'!moveParent: aPoint"By default we try reverse dragging (move parents).This behaviour should be overridden for some mathItem, for example a free point on a curve should not reverse dragging the curve it belongs to.Return true if we are doing reverse dragging, otherwise false"	parents ifNotNil:		[parents do: [:parent|			parent moveEvent: aPoint]].	^true.! !!DrGMathItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/2/2006 09:29'!move: aPoint	self update	! !!DrGMathItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update! !!DrGMathItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 22:57'!nodeName	self subclassResponsibility! !!DrGMathItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/23/2008 12:08'!nodeType	^ #mathItem! !!DrGMathItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 23:11'!writeAsXmlTo: aNode	"return the newly created element"	| node |	node :=  XMLElement named: self nodeName attributes: Dictionary new.	node attributeAt: #type put: self nodeType.	self writeParentsAsXmlTo: node.	aNode addElement: node.	^node! !!DrGMathItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:48'!writeParentsAsXmlTo: aNode	self writeParents: parents asXmlTo: aNode! !!DrGMathItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:48'!writeParents: collection asXmlTo: aNode"write parents reference in the natural order"|attr|	collection do: [:each | 		attr := Dictionary new.		attr at: #ref put: each hash asString.		aNode addElement: (XMLElement named: #parent attributes: attr)]! !!DrGMathItem commentStamp: 'HilaireFernandes 1/14/2008 22:46' prior: 0!This is the root class of the mathematic items hierarchy.The classes in this hierarchy are models of the mathematical items like point, line, circle.These models will have different type of view depending on the ApplicationModel/View/Presenter.id                            - unique id used when importing Dr. Geo 1.1 filesname 						- for example A, (AB), [AD], ddescriptiveName		- 'this point A', 'this line (AB)'longDescription		- the point A, the symmetric of the point B in respect to O'!!DrGMathItem class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 12/29/2005 09:49'!newWith: theParents	"Instantiate this mathItem with these parents	Parents contains other MathItem instance, sometime it contains other object as Point"	^self new 		parents: theParents; 		initialize: theParents;		update! !!DrGMathItemBuilder methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 12:02'!actionMap	actionMap ifNil: [^self createActionMap].	^ actionMap ! !!DrGMathItemBuilder methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 16:54'!releaseActionMap	actionMap := nil! !!DrGMathItemBuilder methodsFor: 'event' stamp: 'HilaireFernandes 3/22/2006 11:53'!updateableActionMap	actionMap ifNil:		[actionMap := self createActionMap].	^actionMap! !!DrGMathItemBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 09:46'!addItem: aMathItemCollection at: aPoint	point := aPoint.! !!DrGMathItemBuilder methodsFor: 'private' stamp: 'HilaireFernandes 7/29/2008 09:48'!addToggleItem: aMathItemCollection in: aCollection	(aCollection includes: aMathItemCollection first) 		ifTrue: [aCollection remove: aMathItemCollection first ]		ifFalse: [aCollection add: aMathItemCollection first]! !!DrGMathItemBuilder methodsFor: 'building' stamp: 'HilaireFernandes 8/23/2008 15:51'!add: aMathItemCollection at: aPoint"Add a math item in the selection list of the builder,aPoint is the position where the action took placeReturn true if mathItem accepted"	(self isWanted: aMathItemCollection at: aPoint) ifTrue:		[self addItem: aMathItemCollection at: aPoint.		"Are we done? If so notify our dependent"		self readyToBuild ifTrue: 			[self triggerEvent: #readyToBuild].		^true].	^false! !!DrGMathItemBuilder methodsFor: 'building' stamp: 'HilaireFernandes 3/5/2006 14:48'!buildItem	^ {self mathItemClass newWith: self arguments}! !!DrGMathItemBuilder methodsFor: 'building' stamp: 'HilaireFernandes 12/6/2005 15:10'!getItem	"return an instantiated mathItem or nil if not possible"	self readyToBuild ifTrue:		[^ self buildItem].	^ nil.! !!DrGMathItemBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 20:39'!arguments"an argument list to give to the MathItem new method"	self subclassResponsibility ! !!DrGMathItemBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 09:46'!isWanted: aMathItemCollection"Check if the builder is interested by aMathItem"	self subclassResponsibility ! !!DrGMathItemBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/23/2008 15:52'!isWanted: aMathItemCollection at: aPoint"By default we don't need the point position of the click event'"	^ self isWanted: aMathItemCollection ! !!DrGMathItemBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 12/6/2005 16:40'!readyToBuild	"Can the builder build the math item now?"	self subclassResponsibility ! !!DrGMathItemBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 12/6/2005 16:27'!mathItemClass"Answer the MathItem class for this builder (i.e. self FreePointItem,...)"	self subclassResponsibility! !!DrGMathItemBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:46'!reset	point := nil.! !!DrGMathItemBuilder commentStamp: '<historical>' prior: 0!This is the root class of the MathBuilder hierarchy responsible to create new mathematic items.A builder instance is specialized to build one type of object: free point, constrained point, line, segment, transformed mathItem...To effectively build a new mathItem, the builder need to be fed with mathItem with the add: message.At any time it is possible to check wheter the build process is terminated or not with the readyToBuild message.Related patterns: BUILD, TEMPLATE METHOD!!DrGMathItemCommand methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 14:49'!createMathItem: aBuilder	mathItems := aBuilder getItem.! !!DrGMathItemCommand methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 14:49'!fromMathItem: aMathItem	mathItems := {aMathItem}.! !!DrGMathItemCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/23/2008 11:43'!execute	"Remove any previous dependant"	mathItems do: [:aMathItem| 		"record the mathItem in the factory"		domain factory add: aMathItem.		domain triggerEvent: #newMathItem with: aMathItem].	^mathItems! !!DrGMathItemCommand methodsFor: 'command' stamp: 'HilaireFernandes 3/5/2006 14:50'!unexecute	"remove the mathItem in the factory"	domain factory remove: mathItems! !!DrGMathItemCommand methodsFor: 'dependents access' stamp: 'HilaireFernandes 8/18/2008 12:48'!release	super release.	mathItems do: [:m | m release]! !!DrGMathItemCommand commentStamp: '<historical>' prior: 0!A command to record a mathItem construction!!DrGMathItemCommand class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 2/2/2006 09:50'!for: aMathItem in: aDomain 	^self new		domain: aDomain;		fromMathItem: aMathItem .! !!DrGMathItemCommand class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 12/7/2005 15:57'!with: aBuilder in: aDomain 	^self new		domain: aDomain;		createMathItem: aBuilder.! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/30/2005 11:37'!basicType	super basicType ! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2006 11:20'!containsPoint: aPoint	^exist and: [morph containsPoint: aPoint]! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 2/4/2006 11:57'!isAngleCostume	^self basicType = #angle! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:52'!isArcCostume	^self basicType = #arc! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:42'!isCircleCostume	^self basicType = #circle! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/2/2006 22:47'!isCompositeCostume	^self basicType = #composite! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:50'!isCurveCostume	^false! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/5/2006 11:06'!isFinitCurveCostume	^self isArcCostume 		or: [self isCircleCostume]		or: [self isSegmentCostume]! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:45'!isLineCostume	^self basicType = #line! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:52'!isLocusCostume	^self basicType = #locus! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:43'!isPointCostume	^self basicType = #point! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:43'!isRayCostume	^self basicType = #ray! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:45'!isSegmentCostume	^self basicType = #segment! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 2/4/2006 11:57'!isValueCostume	^self basicType = #value or: [self basicType = #angle]! !!DrGMathItemCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/7/2006 09:43'!isVectorCostume	^self basicType = #vector! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 11:14'!changed	morph changed! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 14:45'!dash: aDashMotif	morph dashedBorder: aDashMotif! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 11:07'!forceVisible: aBoolean 	(exist not or: [style isNotHidden]) ifTrue: [^false].	aBoolean 		ifTrue: 			[drawable addMorph: morph.			self redraw.			morph color: DrGCostumeStyle hiddenColor.			textMorph ifNotNil:				[drawable addMorph: textMorph.				textMorph position: self textPosition]]		ifFalse: 			[drawable removeMorph: morph.			morph color: style color.			textMorph ifNotNil:				[drawable removeMorph: textMorph]].	^true! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:04'!makeBackArrow	morph makeBackArrow! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:04'!makeBothArrows	morph makeBothArrows! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:04'!makeForwardArrow	morph makeForwardArrow! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 15:09'!makeNoArrows	morph makeNoArrows! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 1/25/2006 18:53'!redraw	textMorph ifNotNil: [textMorph position: self textPosition]! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 18:05'!startBlinking	morph startBlinking! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/2/2006 18:05'!stopBlinking	morph stopBlinking! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 12:14'!update	mathItem exist		ifTrue: [exist				ifFalse: [self updateToVisible].			self redraw]		ifFalse: [exist				ifTrue: [self updateToInvisible]]! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 11:10'!updateToInvisible	drawable removeMorph: morph.	textMorph ifNotNil:		[drawable removeMorph: textMorph].	exist := false! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/12/2006 21:52'!updateToVisible	style isNotHidden 		ifTrue: [drawable addMorph: morph].	textMorph ifNotNil:		[drawable addMorph: textMorph.		textMorph position: self textPosition].	exist := true! !!DrGMathItemCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 14:43'!width: anInteger	morph borderWidth: anInteger! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 3/3/2006 12:00'!color: aColor	morph color: aColor ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 5/13/2010 10:47'!domain	^drawable drgeoPresenter domain! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 18:28'!drawable	^drawable! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 18:28'!drawable: aDrawable	drawable := aDrawable ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2006 01:26'!exist	^exist! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2006 01:26'!exist: aBoolean	exist := aBoolean ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/13/2005 17:09'!mathItem	^mathItem ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/14/2005 16:19'!mathItem: aMathItem	self removeEvents.	mathItem := aMathItem.	self registerEvents.! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 14:40'!morph	^morph ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 12/15/2005 14:40'!morph: aMorph	morph := aMorph ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/19/2008 21:53'!name	^textMorph ifNotNil: [textMorph contents asString]		ifNil: ['']! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/19/2006 16:19'!style	^style! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/19/2006 16:19'!style: aStyle	style := aStyle ! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/25/2006 10:32'!textMorph	^textMorph! !!DrGMathItemCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/24/2008 12:32'!textMorph: aString	aString size = 0		ifTrue: 			[textMorph ifNotNil: 				[drawable removeMorph: textMorph.				textMorph := nil]]		ifFalse:			[textMorph 				ifNil: 					[textMorph := DrGLabelMorph new contents: aString.					textMorph costume: self.					exist ifTrue: [drawable addMorph: textMorph.					textMorph position: self textPosition]]				ifNotNil: 					[textMorph contents: aString]]! !!DrGMathItemCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/13/2006 15:00'!computeTextPositionDelta: aVector|distance|	aVector = (0@0) 		ifFalse:			[distance := aVector r.			distance > 40 ifTrue: [distance := 40].			^(aVector / aVector r) * distance +				(textMorph  fullBounds origin - textMorph fullBounds center)]		ifTrue:			[^textMorph  fullBounds origin - textMorph fullBounds center].	! !!DrGMathItemCostume methodsFor: 'layout' stamp: 'HilaireFernandes 2/13/2006 12:20'!constraintTextPosition: aPoint"Force the text arround the mathItemCostume to a position"	self subclassResponsibility ! !!DrGMathItemCostume methodsFor: 'layout' stamp: 'HilaireFernandes 1/25/2006 14:40'!textPosition"get an up to date text position"	self subclassResponsibility! !!DrGMathItemCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2008 12:36'!initialize	"costume should update itself regarding its model (mathItem)"	self instantiateMorph.	textPositionDelta := 7 @ 7.	self morph costume: self.	exist := mathItem exist.	exist ifTrue: [drawable addMorph: self morph].	self redraw.	self		style: (self styleClass newWith: self)! !!DrGMathItemCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 12/15/2005 16:01'!instantiateMorph	self subclassResponsibility ! !!DrGMathItemCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 13:07'!registerEvents	mathItem		ifNotNil: [mathItem				when: #deletedMathItem				send: #deleteCostume:				to: drawable app				with: self]! !!DrGMathItemCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/18/2008 12:49'!release	super release.	self drawable removeMorph: self morph.	self textMorph: ''.	self removeEvents.! !!DrGMathItemCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 12/14/2005 15:35'!removeEvents	mathItem ifNotNil: 		[mathItem removeActionsWithReceiver: self]! !!DrGMathItemCostume methodsFor: 'scripting' stamp: 'HilaireFernandes 4/2/2006 11:13'!openViewer	morph ifNotNil: [morph beViewed]! !!DrGMathItemCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:02'!styleClass	^DrGCostumeStyle! !!DrGMathItemCostume methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 11:54'!writeAsXmlTo: aNode 	"We wrote from the costume because it knows both the model and the	view of the math item"	self writeAttributesTo: (mathItem writeAsXmlTo: aNode)! !!DrGMathItemCostume methodsFor: 'xml writing' stamp: 'HilaireFernandes 4/25/2010 22:32'!writeAttributesTo: aNode 	aNode attributeAt: #id put: mathItem hash asString;		 attributeAt: #color put: style baseColor name asString capitalized;		 attributeAt: #masked put: style isHidden asString capitalized;		 attributeAt: #name put: self name! !!DrGMathItemCostume commentStamp: 'HilaireFernandes 1/23/2008 12:15' prior: 0!This is the root of the costumue hierarchy, a simple Adapter to morph.A costume is a visual representation of a mathItem. The user interact with the mathItem through its costume. mathItem 		- a costume need to know its model dirty 			- boolean, true if it need udpate (repositionned) (deprecated) morph 			- this the adaptee, the graphic representation textMorph     - to display the object name, may be nil drawable 		- a costume need to know where it is printed exist 		   - does the costume exist (ie when its mathItem does or not exist)!!DrGMathItemCostume class methodsFor: 'instance creation' stamp: 'HilaireFernandes 1/24/2006 23:08'!for: aMathItem in: aDrawable	|className|	className := 'DrG', aMathItem basicType capitalized , 'Costume'.	^ (self environment classNamed: className) 		basicNew		drawable: aDrawable;		mathItem: aMathItem;		initialize.! !!DrGMathItemFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 16:36'!dependentMathItem: theMathItem 	"Return a collection of the dependents items of theMathItem, 	Caution: it is not following the creation order, further traitment is need for that"	| dependents |	dependents := Set with: theMathItem.	pool do: [:aMathItem |		(aMathItem parents notNil and: 			[aMathItem parents includes: theMathItem]) ifTrue: 				[dependents addAll: (self dependentMathItem: aMathItem)]].	^ dependents! !!DrGMathItemFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 1/14/2008 22:51'!findInPoolById: anID"Try to find an item given its unique ID, it used to load Dr. Geo 1.1 file"	^ pool detect: [:each | each id = anID ]	! !!DrGMathItemFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 16:40'!orderedDependentMathItem: aMathItem	^self ordered: (self dependentMathItem: aMathItem )! !!DrGMathItemFactory methodsFor: 'accessing' stamp: 'HilaireFernandes 7/18/2008 16:41'!ordered: aMathItemCollection"sort the the math item according to the pool order"	^ pool select: [:item | aMathItemCollection includes: item]! !!DrGMathItemFactory methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 10:55'!updateAllMathItems	"stupidly update all math item"	pool		do: [:aMathItem | aMathItem update]! !!DrGMathItemFactory methodsFor: 'updating' stamp: 'HilaireFernandes 7/18/2008 10:27'!updateAllMathItemsButLocus	"stupidly update all math item but the loci ones"	pool		do: [:aMathItem | aMathItem isLocusItem not ifTrue: [ aMathItem update]]! !!DrGMathItemFactory commentStamp: 'HilaireFernandes 7/18/2008 10:26' prior: 0!See superclass comments.This factory interface in extended to handle mathItem specific action!!DrGMiddleBuilder methodsFor: 'private' stamp: 'HilaireFernandes 2/4/2006 10:57'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection first isPointItem 		ifTrue:			[pointA ifNil: 				[pointA := aMathItemCollection first.				^self].			pointB ifNil:				[pointB := aMathItemCollection  first.				^self]]		ifFalse: [segment := aMathItemCollection  first]! !!DrGMiddleBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 22:29'!arguments	segment ifNotNil: [^{segment}].	^{pointA . pointB}! !!DrGMiddleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 4/30/2010 22:14'!isWanted: aMathItemCollection	^ aMathItemCollection  notEmpty		and:	[			(aMathItemCollection first isPointItem 				and: [pointA isNil or: [pointB isNil]]				and: [(aMathItemCollection first ~= pointA)					and: [aMathItemCollection first ~= pointB]])			or: [aMathItemCollection first isSegmentItem 				and: [segment isNil]]]! !!DrGMiddleBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/2/2006 22:52'!readyToBuild	^ segment notNil or: [pointA notNil and: [pointB notNil]]! !!DrGMiddleBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:56'!mathItemClass	segment ifNotNil: [^DrGMiddlePointSegmentItem].	^DrGMiddlePoint2PointsItem! !!DrGMiddleBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:49'!reset	super reset.	pointA := pointB := segment := nil! !!DrGMiddlePoint2PointsItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:28'!isConstrainedPointItem	^true! !!DrGMiddlePoint2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:59'!nodeType	^#'Middle_2pts'! !!DrGMiddlePoint2PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:33'!update	self doesParentExist ifTrue:		[self point: (parents first point + parents second point) / 2].! !!DrGMiddlePointSegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:23'!nodeType	^ #'Middle_segment'! !!DrGMiddlePointSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self point: (parents first origin + (parents first direction / 2))].! !!DrGMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 10:30'!costume	^costume! !!DrGMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 10:30'!costume: aCostume	costume := aCostume! !!DrGMorph methodsFor: 'event handling' stamp: 'HilaireFernandes 12/15/2005 15:43'!handlesMouseDown: evt	^ false! !!DrGMorph methodsFor: 'initialization' stamp: 'HilaireFernandes 1/11/2006 10:41'!initialize	super initialize.	blink := false.! !!DrGMorph methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/9/2006 17:08'!isMorphCostume	^true! !!DrGMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 12/30/2005 12:14'!startBlinking	blink := true.	self startStepping ! !!DrGMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/24/2006 23:02'!step	blink ifFalse: [^self].	super step.	self color = DrGCostumeStyle blinkingColor 		ifTrue: [self color: costume style color]		ifFalse: [self color: DrGCostumeStyle blinkingColor]! !!DrGMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/21/2006 11:45'!stepTime	^500! !!DrGMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/20/2006 16:01'!stopBlinking	blink := false.	self stopStepping.! !!DrGMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/21/2006 10:41'!stopStepping	super stopStepping.	self color: costume style color.! !!DrGMoveCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/23/2008 11:39'!execute	domain moveEvent: mathItem inDirection: vector! !!DrGMoveCommand methodsFor: 'command' stamp: 'HilaireFernandes 1/23/2008 11:39'!unexecute	domain moveEvent: mathItem inDirection: vector negated! !!DrGMoveCommand methodsFor: 'accessing' stamp: 'HilaireFernandes 1/31/2006 11:28'!mathItem: aMathItem	mathItem := aMathItem ! !!DrGMoveCommand methodsFor: 'accessing' stamp: 'HilaireFernandes 1/31/2006 11:27'!vector: aPoint	vector := aPoint	! !!DrGMoveCommand class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/31/2006 11:40'!for: aMathItem with: aPoint in: aDomain	^self new		domain: aDomain;		mathItem: aMathItem;		vector: aPoint! !!DrGParallelBuilder methodsFor: 'private' stamp: 'HilaireFernandes 4/10/2010 12:31'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint.	aMathItemCollection first isPointItem 		ifTrue: [pointA := aMathItemCollection first].	aMathItemCollection first isDirectionItem 		ifTrue:[direction := aMathItemCollection first].	! !!DrGParallelBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 19:36'!arguments	^{direction . pointA}! !!DrGParallelBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 6/15/2010 22:37'!isWanted: aMathItemCollection	aMathItemCollection ifEmpty: [^false].	^ (aMathItemCollection first isPointItem and: [pointA isNil])		or: [aMathItemCollection first isDirectionItem and: [direction isNil]] ! !!DrGParallelBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/2/2006 16:09'!readyToBuild	^pointA notNil and: [direction notNil]! !!DrGParallelBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:56'!mathItemClass	^DrGParallelLineItem! !!DrGParallelBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:48'!reset	super reset.	pointA := direction := nil! !!DrGParallelBuilder commentStamp: '<historical>' prior: 0!pointA can accept a PointItem instance or just a Point instance.!!DrGParallelLineItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:03'!adaptiveDescriptiveName	^ 'This parallel line %1' translated! !!DrGParallelLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/23/2008 11:39'!moveParent: aPoint"Only move the origin parent if it is a PointItem instance"	parents size = 2 		ifTrue:			[parents second moveEvent: aPoint.			^true].	^false! !!DrGParallelLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!move: aPoint	parents size = 1 ifTrue: [origin := origin + aPoint].! !!DrGParallelLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self direction: (parents at: 1) direction.		parents size = 2 	ifTrue: [self origin: (parents at: 2) point]].! !!DrGParallelLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:04'!nodeType	^#parallel! !!DrGParallelLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:49'!writeParentsAsXmlTo: aNode	self writeParents: parents reversed asXmlTo: aNode! !!DrGParallelLineItem methodsFor: 'accessing' stamp: 'HilaireFernandes 4/10/2010 12:38'!parentQty 	^ 2! !!DrGParallelLineItem methodsFor: 'accessing' stamp: 'HilaireFernandes 7/31/2008 10:08'!parents: aCollection"Check wheter the user selected a pointItem or a location in the background for the origin of the parallel line"	aCollection ifNil: 		[parents := nil.		^self].	aCollection second isPointItem 		ifTrue: [parents := aCollection]		ifFalse: 			[parents := OrderedCollection new add: aCollection first;yourself.			self origin: aCollection second].	! !!DrGPerpendicularBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:56'!mathItemClass	^DrGPerpendicularlLineItem! !!DrGPerpendicularlLineItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:03'!adaptiveDescriptiveName	^ 'This perpendicular line %1' translated! !!DrGPerpendicularlLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:05'!nodeType	^#perpendicular! !!DrGPerpendicularlLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self direction: (parents at: 1) normal.		parents size = 2 	ifTrue: [self origin: (parents at: 2) point]].! !!DrGPointByCoordinatesBuilder methodsFor: 'private' stamp: 'HilaireFernandes 8/6/2008 13:56'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection first isScriptItem 		ifTrue: 			[script := aMathItemCollection first]		ifFalse: 			[valueX 				ifNil: [valueX := aMathItemCollection first.]				ifNotNil: [valueY ifNil: [valueY := aMathItemCollection first]]]! !!DrGPointByCoordinatesBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 8/6/2008 13:52'!arguments	^script 		ifNotNil: [{script}]		ifNil: [{valueX . valueY}]! !!DrGPointByCoordinatesBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/6/2008 13:50'!isWanted: aMathItemCollection	^ aMathItemCollection notEmpty		and: 			[(aMathItemCollection first isScriptItem				and: [aMathItemCollection first ~= script])						or: [aMathItemCollection first isValueItem				and: [aMathItemCollection first ~= valueX]				and: [aMathItemCollection first ~= valueY]]]			! !!DrGPointByCoordinatesBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 8/6/2008 13:53'!readyToBuild	^ (valueX notNil and: [valueY notNil])		or: [script notNil]! !!DrGPointByCoordinatesBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 8/6/2008 13:53'!mathItemClass	^script 		ifNotNil: [DrGPointByScriptItem ]		ifNil: [DrGPointByCoordinatesItem]! !!DrGPointByCoordinatesBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 8/6/2008 13:53'!reset	super reset.	script := valueX := valueY := nil! !!DrGPointByCoordinatesItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:28'!isConstrainedPointItem	^true! !!DrGPointByCoordinatesItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Coordinate! !!DrGPointByCoordinatesItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self point: parents first valueItem @ parents second valueItem]. ! !!DrGPointByScriptItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 8/6/2008 13:43'!nodeType	^#Script! !!DrGPointByScriptItem methodsFor: 'updating' stamp: 'HilaireFernandes 8/6/2008 13:43'!update	self doesParentExist ifTrue:		[self point: parents first valueItem asPoint]. ! !!DrGPointByScriptItem commentStamp: 'HilaireFernandes 8/6/2008 13:40' prior: 0!A DrGPointByScriptItem is definied by the returned value of a script.The script valueItem should understand asPoint.Instance Variables!!DrGPointCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#point! !!DrGPointCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/12/2006 22:13'!constraintTextPosition: aPoint|center vector|	center := drawable worldToMorph: mathItem point.	vector := aPoint - center.	^textPositionDelta := self computeTextPositionDelta: vector	! !!DrGPointCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/8/2006 14:45'!distanceTo: aPoint	^morph center dist: aPoint  ! !!DrGPointCostume methodsFor: 'layout' stamp: 'HilaireFernandes 1/25/2006 22:55'!textPosition	^(drawable worldToMorph: mathItem point) + textPositionDelta! !!DrGPointCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:03'!instantiateMorph	morph := DrGPointMorph new! !!DrGPointCostume methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 12:25'!pointSize: anExtent	morph extent: anExtent.	exist ifTrue: [morph center: (drawable worldToMorph: mathItem point)].! !!DrGPointCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/21/2006 11:12'!redraw	exist ifFalse: [^self].	super redraw.	morph center: (drawable worldToMorph: mathItem point).! !!DrGPointCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/3/2006 14:57'!shape: aShape! !!DrGPointCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:04'!styleClass	^DrGPointCostumeStyle! !!DrGPointCostume methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 22:35'!writeAttributesTo: aNode 	| attr |	super writeAttributesTo: aNode.	style thickness = #small		ifTrue: [attr := 'Dashed'].	style thickness = #medium		ifTrue: [attr := 'Normal'].	style thickness = #large		ifTrue: [attr := 'Thick'].	aNode attributeAt: #thickness put: attr.	attr := style shape asString capitalized.	style shape = #square		ifTrue: [attr := 'Rectangular'].	style shape = #round		ifTrue: [attr := 'Round'].	aNode attributeAt: #style put: attr! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 1/26/2008 11:28'!getCurveAbscissa	(mathItem respondsTo: #abscissa)		ifTrue: [^ mathItem exist				ifTrue: [mathItem abscissa]				ifFalse: [nil]]		ifFalse: [^ nil]! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 11:01'!getWorldX	^mathItem point x! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 11:01'!getWorldY	^mathItem point y! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 5/13/2010 10:49'!setCurveAbscissa: aFloat 	(mathItem respondsTo: #abscissa:)		ifTrue: [mathItem setCurveAbscissa: aFloat.			self domain updateAllMathItems]! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 5/13/2010 10:48'!setWorldX: aFloat	self domain		moveEvent: mathItem		at: aFloat @ mathItem point y! !!DrGPointCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 5/13/2010 10:49'!setWorldY: aFloat	self domain		moveEvent: mathItem		at: mathItem point x @ aFloat! !!DrGPointCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 1/21/2006 12:34'!addMyMenus: theMenu	self addSizeMenu: theMenu.	self addShapeMenu: theMenu.! !!DrGPointCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 15:23'!addShapeMenu: theMenu 	| subMenu theShape|	theShape := self shape.	subMenu := MenuMorph new.	#(#cross #round #square ) do: [:aShape | 		subMenu			add: aShape asString translated			target: self			selector: #shape:			argument: aShape.		self shape: aShape.		subMenu lastItem			 icon: self costume morph imageForm].	theMenu add: 'shape' translated subMenu: subMenu.	self shape: theShape ! !!DrGPointCostumeStyle methodsFor: 'menu' stamp: 'HilaireFernandes 4/28/2010 17:11'!addSizeMenu: theMenu 	| subMenu theThickness|	theThickness := self thickness.	subMenu := MenuMorph new.	#(#small #medium #large) do: [:aThickness | 		subMenu			add: aThickness asString translated			target: self			selector: #thickness:			argument: aThickness.		self thickness: aThickness.		subMenu lastItem			icon: self costume morph imageForm].	theMenu add: 'size' translated subMenu: subMenu.	self thickness: theThickness.! !!DrGPointCostumeStyle methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/26/2008 21:17'!initialize	super initialize.	self color: Color red.	self thickness: #medium.	self shape: #cross! !!DrGPointCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/21/2006 11:57'!shape	"Answer the value of shape"	^ shape! !!DrGPointCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 3/3/2006 14:41'!shape: anObject	"Set the value of shape"	shape := anObject.	costume changed.! !!DrGPointCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/21/2006 11:59'!thickness	"Answer the value of thickness"	^ thickness! !!DrGPointCostumeStyle methodsFor: 'accessing' stamp: 'HilaireFernandes 1/16/2008 15:23'!thickness: anObject	"Set the value of thickness"	thickness := anObject.	thickness = #small ifTrue: [costume pointSize: 6@6].	thickness = #medium ifTrue: [costume pointSize: 8@8].	thickness = #large ifTrue: [costume pointSize: 10@10].! !!DrGPointItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:07'!adaptiveDescriptiveName	^ 'This point %1' translated! !!DrGPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 15:20'!basicType	^#point! !!DrGPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 15:33'!point	^point ! !!DrGPointItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/19/2005 15:33'!point: aPoint	point := aPoint ! !!DrGPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:38'!isGeometricItem	^true! !!DrGPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:38'!isPointItem	^true! !!DrGPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/27/2006 11:02'!moveAt: aPoint! !!DrGPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGPointItem methodsFor: 'scripting' stamp: 'HilaireFernandes 2/9/2006 14:19'!moveTo: aPoint	self moveAt: aPoint.	self triggerEvent: #movedMathItem! !!DrGPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 22:59'!nodeName	^#point! !!DrGPointItemOnCurve methodsFor: 'accessing' stamp: 'HilaireFernandes 12/29/2005 09:57'!abscissa	^abscissa! !!DrGPointItemOnCurve methodsFor: 'accessing' stamp: 'HilaireFernandes 2/9/2006 11:28'!abscissa: anAbscissa	abscissa := anAbscissa.	abscissa > 1 ifTrue: [abscissa := 1].	abscissa < 0 ifTrue: [abscissa := 0]! !!DrGPointItemOnCurve methodsFor: 'accessing' stamp: 'HilaireFernandes 7/31/2008 10:09'!parents: aCollection"We only need the first mathItem in the collection. The second one is a Point instance (position the user clicked) only used at initialization time"	aCollection ifNil: 		[parents := nil.		^self].	parents := OrderedCollection new add: aCollection first;yourself.! !!DrGPointItemOnCurve methodsFor: 'initialize-release' stamp: 'HilaireFernandes 12/29/2005 11:04'!initialize: theParents	super initialize: theParents.	self point: (theParents first closestPointTo: theParents second).	self abscissa: (theParents first abscissaOf: self point).! !!DrGPointItemOnCurve methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:25'!isPointItemOnCurve	^true! !!DrGPointItemOnCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!moveAt: aPoint	self point: (parents first closestPointTo: aPoint).	self abscissa: (parents first abscissaOf: self point).! !!DrGPointItemOnCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!move: aPoint	self point: (parents first closestPointTo: point + aPoint).	self abscissa: (parents first abscissaOf: self point).! !!DrGPointItemOnCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/26/2008 11:17'!update	self doesParentExist ifTrue:		[self point: (parents first pointAt: abscissa).		(point x isInfinite or: [point y isInfinite ]) ifTrue: [exist := false]].! !!DrGPointItemOnCurve methodsFor: 'scripting' stamp: 'HilaireFernandes 1/24/2008 10:34'!moveTo: aPoint	self point: (parents first closestPointTo: aPoint).	self abscissa: (parents first abscissaOf: self point).! !!DrGPointItemOnCurve methodsFor: 'scripting' stamp: 'HilaireFernandes 1/28/2008 16:20'!setCurveAbscissa: aFloat 	self abscissa: aFloat.	self update! !!DrGPointItemOnCurve methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:59'!nodeType	^#'On_curve'! !!DrGPointItemOnCurve methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:56'!writeAsXmlTo: aNode	"It is important to return the node"	| node|	node :=  XMLElement named: self nodeName attributes: Dictionary new.	aNode addElement: node.	node attributeAt: #type put: self nodeType.	node addElement:  ((XMLElement named: #value) addContent: (XMLStringNode string: abscissa  asString)).	self writeParentsAsXmlTo: node.	^node! !!DrGPointMorph methodsFor: 'geometry testing' stamp: 'HilaireFernandes 3/6/2006 10:04'!containsPoint: aPoint	^(self bounds expandBy: 6) containsPoint: aPoint! !!DrGPointMorph methodsFor: 'drawing' stamp: 'HilaireFernandes 1/21/2006 14:34'!drawOn: aCanvas|shape|	shape := costume style shape.	shape = #square ifTrue:		[aCanvas fillRectangle: self bounds color: self color].	shape = #round ifTrue:		[aCanvas fillOval: self bounds color: self color].	shape = #cross ifTrue:		[aCanvas 			line: self topLeft + (1@1) 			to: self bottomRight - (1@1) 			width: 2 			color: self color.		aCanvas 			line: self topRight + (-1@1) 			to: self bottomLeft - (-1@1) 			width: 2				color: self color]! !!DrGPointMorph methodsFor: 'initializing' stamp: 'HilaireFernandes 3/13/2006 15:32'!initialize	super initialize.	self extent: 3@3! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 2/13/2006 10:32'!getCurveAbscissa	^costume getCurveAbscissa! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 10:56'!getWorldX	^costume getWorldX! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 10:56'!getWorldY	^costume getWorldY! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 2/13/2006 10:33'!setCurveAbscissa: aFloat	costume setCurveAbscissa: aFloat! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 10:56'!setWorldX: aFloat	costume setWorldX: aFloat! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/27/2006 10:55'!setWorldY: aFloat	costume setWorldY: aFloat! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 3/25/2006 19:24'!x: aNumber| oldPosition newX |	newX := costume drawable morphAbscissaToWorld: 		(self referencePlayfield cartesianOrigin x + aNumber).	oldPosition := costume mathItem point.	costume drawable view domain 		moveEvent: costume mathItem 		at: newX@oldPosition y! !!DrGPointMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 4/19/2010 13:08'!y: aNumber| oldPosition newY|	newY := costume drawable morphOrdinateToWorld: 		(self referencePlayfield cartesianOrigin y - aNumber + 0).	oldPosition := costume mathItem point.	costume drawable app domain 		moveEvent: costume mathItem 		at: oldPosition x @ newY! !!DrGPointMorph class methodsFor: '*DrGeoII-Etoys-flexiblevocabularies-scripting' stamp: 'HilaireFernandes 11/1/2009 10:23'!additionsToViewerCategoryDrGeo^ # (drgeo ((slot curveAbscissa 'The abscissa of this point on the curve' Number readWrite Player getCurveAbscissa Player setCurveAbscissa:)(slot Xw 'The x coordinate in the DrGeoII world coordinate system' Number readWrite Player getWorldX Player setWorldX:) (slot Yw 'The y coordinate in the DrGeoII world coordinate system' Number readWrite Player getWorldY Player setWorldY:)))! !!DrGPolygonBuilder methodsFor: 'private' stamp: 'HilaireFernandes 2/6/2006 20:27'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	points add: aMathItemCollection first! !!DrGPolygonBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 2/6/2006 21:37'!arguments	^points allButLast! !!DrGPolygonBuilder methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/6/2006 20:40'!initialize	points := OrderedCollection new.! !!DrGPolygonBuilder methodsFor: 'testing' stamp: 'CedrickBeler 4/23/2010 17:15'!isWanted: aMathItemCollection	^aMathItemCollection notEmpty		and: [aMathItemCollection first isPointItem]		and: [points isEmpty				or: [points first = aMathItemCollection first				or: [(points allButFirst includes: aMathItemCollection first) not]]]			! !!DrGPolygonBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 2/6/2006 21:45'!readyToBuild	^ points size > 2 and: [points first = points last]! !!DrGPolygonBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 2/6/2006 20:41'!mathItemClass	^DrGPolygonItem! !!DrGPolygonBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 2/6/2006 20:42'!reset	super reset.	points := OrderedCollection new! !!DrGPolygonCostume methodsFor: 'testing' stamp: 'HilaireFernandes 2/6/2006 21:26'!basicType	^#polygon! !!DrGPolygonCostume methodsFor: 'testing' stamp: 'HilaireFernandes 3/21/2010 20:52'!isCurveCostume	^ false! !!DrGPolygonCostume methodsFor: 'layout' stamp: 'HilaireFernandes 3/13/2006 20:37'!constraintTextPosition: aPoint|center vector answer|	answer := mathItem closestPointTo: (drawable morphToWorld: aPoint).	center := answer first.	anchorAbscissa := answer second.	center := drawable worldToMorph: center.	vector := aPoint - center.	^textPositionDelta := self computeTextPositionDelta: vector.! !!DrGPolygonCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/6/2006 21:36'!instantiateMorph	morph := DrGPolygoneMorph new.! !!DrGPolygonCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/13/2006 20:42'!redraw|vertices|	super redraw.	vertices := OrderedCollection new.	mathItem points do: [:point |		vertices add: (drawable worldToMorph: point)].	morph setVertices: vertices ! !!DrGPolygonCostume methodsFor: 'style' stamp: 'HilaireFernandes 2/6/2006 21:27'!styleClass	^DrGCurveCostumeStyle! !!DrGPolygoneMorph methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 9/10/2009 18:49'!containsPoint: aPoint	(self bounds containsPoint: aPoint) ifFalse: [^ false].		^ (self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0! !!DrGPolygoneMorph methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 4/30/2010 22:23'!isCurvier	^ false! !!DrGPolygoneMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 2/6/2006 21:47'!color: aColor	self borderColor: aColor.	super color: (aColor alpha: 0.3)! !!DrGPolygoneMorph methodsFor: 'initialization' stamp: 'HilaireFernandes 2/6/2006 21:56'!initialize	super initialize.	self makeClosed.! !!DrGPolygonItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 17:07'!abscissaOf: aPoint in: side"To speed up calculs, we better know the side where is the point"|distanceToPoint|	distanceToPoint := 0.	1 to: side - 1 do: [:i |		distanceToPoint := distanceToPoint + (sidesLength at: i)].	distanceToPoint := distanceToPoint + (aPoint dist: (points at: side)).	^ distanceToPoint / length! !!DrGPolygonItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 20:39'!closestPointTo: aPoint|closestPoint smallestDistance side|	smallestDistance := 1e10.	points withIndexDo: [:p :i | | distance point |		point := self closestPointTo: aPoint 					from: p					to:  (points at: i + 1 ifAbsent: [points at: 1]).		distance := aPoint dist: point.		distance < smallestDistance			ifTrue:				[smallestDistance := distance.				closestPoint := point.				side := i]].	^{closestPoint . self abscissaOf: closestPoint in: side}! !!DrGPolygonItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 16:41'!closestPointTo: aPoint from: pointA to: pointB|abscissa vector squareNorm|	vector := pointB - pointA.	squareNorm := vector dotProduct: vector.	abscissa := (aPoint - pointA) dotProduct: vector.	abscissa < 0 ifTrue: [abscissa := 0].	abscissa > squareNorm ifTrue: 		[abscissa := squareNorm].	^ pointA + (abscissa * vector / squareNorm asFloat)! !!DrGPolygonItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 17:01'!computeLength	length := 0.	sidesLength := OrderedCollection new.	points  withIndexDo: [:p :i |		length := length + 			(sidesLength add: (p dist: (points at: i + 1 ifAbsent: [points at: 1])))].	^length! !!DrGPolygonItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 20:47'!pointAt: anAbscissa|distanceToPoint leftDistanceToPoint sum|	distanceToPoint := leftDistanceToPoint := anAbscissa * length.	sum := 0.	sidesLength withIndexDo: [:s :i |		sum := sum + s.		sum >= distanceToPoint 			ifTrue:				["point is on this side"				|pointA pointB vector|				pointA := points at: i.				pointB := points at: i + 1 ifAbsent: [points at: 1].				pointA = pointB 					ifTrue: [vector := 0@0]					ifFalse:	[vector := (pointB - pointA) / (pointA dist: pointB)].				^pointA + (vector * leftDistanceToPoint)].		leftDistanceToPoint := leftDistanceToPoint - s]! !!DrGPolygonItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:07'!adaptiveDescriptiveName	^ 'This polygon %1' translated! !!DrGPolygonItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/6/2006 21:18'!basicType	^#polygon! !!DrGPolygonItem methodsFor: 'accessing' stamp: 'HilaireFernandes 3/13/2006 16:47'!length	^length ! !!DrGPolygonItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/6/2006 22:48'!parentQty	^3! !!DrGPolygonItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/7/2006 16:32'!points	^points! !!DrGPolygonItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/6/2006 21:17'!isGeometricItem	^true! !!DrGPolygonItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/6/2006 21:17'!isPolygonItem	^true! !!DrGPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:26'!nodeName	^'polygon'! !!DrGPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 4/28/2010 22:20'!nodeType	^ #npts! !!DrGPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[points := OrderedCollection new.		parents do: [:pointItem |			points add: pointItem point].		self computeLength].! !!DrGPolylineMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2006 12:46'!color: aColor	self borderColor: aColor.	super color: aColor.! !!DrGPolylineMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 10:43'!costume	^costume! !!DrGPolylineMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 10:43'!costume: aCostume	costume := aCostume! !!DrGPolylineMorph methodsFor: 'geometry testing' stamp: 'HilaireFernandes 9/10/2009 18:43'!containsPoint: aPoint	self lineSegmentsDo:		[:p1 :p2 |		(aPoint onLineFrom: p1 to: p2 within: 10.0)				ifTrue: [^ true]].	^ false! !!DrGPolylineMorph methodsFor: 'event handling' stamp: 'HilaireFernandes 12/15/2005 15:44'!handlesMouseDown: evt	^ false! !!DrGPolylineMorph methodsFor: 'initialization' stamp: 'HilaireFernandes 2/5/2006 11:46'!initialize	super initialize.	self makeOpen.	blink := false.	self sticky: true.! !!DrGPolylineMorph methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/9/2006 17:09'!isMorphCostume	^true! !!DrGPolylineMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 12/30/2005 12:20'!startBlinking	blink := true.	self startStepping.! !!DrGPolylineMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/24/2006 23:02'!step	blink ifFalse: [^self].	super step.	self borderColor = DrGCostumeStyle blinkingColor 		ifTrue: [self borderColor: costume style color]		ifFalse: [self borderColor: DrGCostumeStyle blinkingColor]! !!DrGPolylineMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/21/2006 11:42'!stepTime	^500! !!DrGPolylineMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/20/2006 16:01'!stopBlinking	blink := false.	self stopStepping.! !!DrGPolylineMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 1/22/2006 16:47'!stopStepping	super stopStepping.	self color: costume style color.! !!DrGRay2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:08'!nodeType	^#'2pts'! !!DrGRay2PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:36'!parentQty	^2! !!DrGRayBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:57'!mathItemClass	^DrGRay2PointsItem! !!DrGRayCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#ray! !!DrGRayCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:03'!instantiateMorph	morph := DrGRayMorph new! !!DrGRayCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/12/2006 22:41'!redraw	super redraw.	morph		from: (drawable worldToMorph: mathItem origin)		direction: (drawable vectorToMorph: mathItem direction)! !!DrGRayCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:02'!styleClass	^DrGCurveCostumeStyle! !!DrGRayItem methodsFor: 'computing' stamp: 'HilaireFernandes 2/22/2006 15:16'!abscissaOf: aPoint 	^(aPoint - origin dotProduct: vector normalized) arcTan 		* DrGDirectionItem inv2Pi! !!DrGRayItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/31/2005 11:35'!closestPointTo: aPoint	|unitVector abscissa|	unitVector := vector normalized.	abscissa := aPoint - origin dotProduct: unitVector.	abscissa < 0 ifTrue: [abscissa := 0].	^origin + (abscissa * unitVector)! !!DrGRayItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/18/2008 11:25'!intersectionWith: aCurveItem flag: aFlag|aPoint|	aCurveItem isLineItem 		ifTrue: 			[aPoint := self intersectionWithDirection: aCurveItem.			(self contains: aPoint)				ifTrue: [^aPoint]				ifFalse: [^nil]].	(aCurveItem isSegmentItem or: [aCurveItem isRayItem])		ifTrue:			[aPoint := self intersectionWithDirection: aCurveItem.			((self contains: aPoint) and: [aCurveItem contains: aPoint])				ifTrue: [^aPoint]				ifFalse: [^nil]].	(aCurveItem isCircleItem		or: [aCurveItem isArcItem])		ifTrue:			[^aCurveItem intersectionWith: self flag: aFlag].! !!DrGRayItem methodsFor: 'computing' stamp: 'HilaireFernandes 2/22/2006 15:47'!pointAt: anAbscissa	|point|	anAbscissa = 1 		ifTrue:			[|infX infY|			point := vector.			point x > 0 				ifTrue: [infX := Float infinity] 				ifFalse: [infX := 0 - Float infinity].			point y > 0				ifTrue: [infY :=	Float infinity] 				ifFalse: [infY := 0 - Float infinity].			point := infX@infY]		ifFalse:			[anAbscissa = 0				ifTrue: [point := origin]				ifFalse:					[point := origin + ((anAbscissa * Float halfPi) tan * vector normalized)]].	^point! !!DrGRayItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:03'!adaptiveDescriptiveName	^ 'This half-line %1' translated! !!DrGRayItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 11:31'!basicType	^#ray! !!DrGRayItem methodsFor: 'testing' stamp: 'HilaireFernandes 1/12/2006 18:36'!contains: aPoint	^ ((vector crossProduct: (aPoint - origin)) closeTo: 0) 		and: [((aPoint - origin) dotProduct: vector) >= 0]! !!DrGRayItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/30/2006 16:16'!isCurveItem	^true! !!DrGRayItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/4/2006 16:10'!isGeometricItem	^true! !!DrGRayItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/30/2006 16:15'!isRayItem	^true! !!DrGRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:07'!nodeName	^'halfLine'! !!DrGRayMorph methodsFor: 'layout' stamp: 'HilaireFernandes 12/31/2005 11:56'!extendFrom: origin direction: u| border drawable r|	drawable := costume drawable.	r := u x asFloat / u y.	u y > 0		ifTrue: [border := Point x: ((drawable bottom - origin y) * r + origin x) asInteger 			y: drawable bottom]		ifFalse: [border := Point x: ((drawable top - origin y) * r + origin x) asInteger 			y: drawable top].	super from: origin to: border.! !!DrGRayMorph methodsFor: 'layout' stamp: 'HilaireFernandes 12/31/2005 11:56'!extendHorizontally: origin direction: u| border drawable|	drawable := costume drawable.	u x > 0		ifTrue: [border := Point x: drawable right y: origin y]		ifFalse: [border := Point x: drawable left y: origin y].	super from: origin to: border! !!DrGRayMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 12/31/2005 11:05'!from: aPoint direction: u	u y abs < 0.001 		ifTrue: [self extendHorizontally: aPoint direction: u]		ifFalse: [self extendFrom: aPoint direction: u]! !!DrGRayMorph commentStamp: '<historical>' prior: 0!A DGRayMorph is extended in one 'sens' to the boundary of its parents morph, a drawable in Dr. Geo   jargon.!!DrGReflectionBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:04'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint.	(aMathItemCollection first isLineItem and: [axe isNil])		ifTrue: [axe := aMathItemCollection first]		ifFalse: [mathItem := aMathItemCollection first]! !!DrGReflectionBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 16:58'!arguments: aMathItem	^{aMathItem . axe}! !!DrGReflectionBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 2/7/2006 17:30'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty 		and:			[(aMathItemCollection first isLineItem and: [axe isNil])				or: [aMathItemCollection first isGeometricItem and: [mathItem isNil]]]! !!DrGReflectionBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/3/2006 11:32'!readyToBuild	^axe notNil and: [mathItem notNil]! !!DrGReflectionBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:27'!mathItemClass: aMathItem	|className|	className := 'DrGReflexion', aMathItem basicType capitalized, 'Item'.	^(self class environment classNamed: className)! !!DrGReflectionBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:47'!reset	super reset.	axe := mathItem := nil! !!DrGReflexionArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGReflexionArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update|pointA|	self doesParentExist ifTrue:		[origin := parents first origin.		radius := parents first radius.		center := parents first center.		length := parents first length negated.		pointA := center + (radius * (origin cos @ origin sin)).		pointA := pointA reflexionBy: parents second origin 						direction: parents second direction.		center := center reflexionBy: parents second origin 						direction: parents second direction.		pointA := pointA - center.		origin := pointA y asFloat arcTan2: pointA x].! !!DrGReflexionArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:58'!nodeType	^#Reflexion! !!DrGReflexionCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGReflexionCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self radius: parents first radius.		self center: (parents first center							reflexionBy: parents second origin 							direction: parents second direction)].! !!DrGReflexionCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Reflexion! !!DrGReflexionLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:43'!moveParent: aPoint	^false! !!DrGReflexionLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 14:01'!update	self reflexionUpdate! !!DrGReflexionLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Reflexion! !!DrGReflexionPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:29'!isConstrainedPointItem	^true! !!DrGReflexionPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Reflexion! !!DrGReflexionPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist	ifTrue:		[self point: (parents first point					reflexionBy: parents second origin 					direction: parents second direction)].! !!DrGReflexionPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGReflexionPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update|axe|	self doesParentExist 	ifTrue:		[axe := parents second.		points := OrderedCollection new.		parents first points do: [:point |			points add: (point reflexionBy: axe origin direction: axe direction)].		self computeLength].! !!DrGReflexionPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Reflexion! !!DrGReflexionRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGReflexionRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 16:00'!update	self reflexionUpdate ! !!DrGReflexionRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:00'!nodeType	^#Reflexion! !!DrGReflexionSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGReflexionSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 16:02'!update	self reflexionUpdate ! !!DrGReflexionSegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Reflexion! !!DrGReflexionVectorItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/3/2006 16:26'!initialize: theParents	super initialize: theParents.	self origin: parents first origin.! !!DrGReflexionVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGReflexionVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:34'!update	self doesParentExist ifTrue:		[self direction: (parents first direction 								vectorReflexionBy: parents second direction)].! !!DrGReflexionVectorItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Reflexion! !!DrGRotationArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGRotationArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update|arcItem|	self doesParentExist ifTrue:		[arcItem := parents first.		center := arcItem center			rotateBy: parents third valueItem negated 			about: parents second point.		origin := arcItem origin + parents third valueItem.		length := arcItem length.		radius := arcItem radius].! !!DrGRotationArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:04'!nodeType	^#Reflexion! !!DrGRotationBuilder methodsFor: 'private' stamp: 'HilaireFernandes 2/7/2006 17:28'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	(aMathItemCollection first isPointItem and: [center isNil])		ifTrue: [center := aMathItemCollection first. ^self].	(aMathItemCollection first isValueItem and: [value isNil])		ifTrue: [value := aMathItemCollection first. ^self].	mathItem := aMathItemCollection first! !!DrGRotationBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 15:22'!arguments: aMathItem	^{aMathItem . center . value}! !!DrGRotationBuilder methodsFor: 'testing' stamp: 'CedrickBeler 4/23/2010 16:54'!isWanted: aMathItemCollection	^ aMathItemCollection notEmpty 		and: [(aMathItemCollection first isPointItem and: [center isNil])				or: [(aMathItemCollection first isValueItem and: [value isNil])				or: [aMathItemCollection first isGeometricItem and: [mathItem isNil]]]]! !!DrGRotationBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 2/7/2006 17:45'!readyToBuild	^center notNil and: [value notNil] and: [mathItem notNil]! !!DrGRotationBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:27'!mathItemClass: aMathItem	|className|	className := 'DrGRotation', aMathItem basicType capitalized, 'Item'.	^(self class environment classNamed: className)! !!DrGRotationBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 17:46'!reset	super reset.	center := value := mathItem := nil! !!DrGRotationCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGRotationCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[radius := parents first radius.		center := parents first center			rotateBy: parents third valueItem negated 			about: parents second point].! !!DrGRotationCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:43'!moveParent: aPoint	^false! !!DrGRotationLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 21:58'!update	self rotationUpdate ! !!DrGRotationLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:29'!isConstrainedPointItem	^true! !!DrGRotationPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist	ifTrue:		[self point: (parents first point			rotateBy: parents third valueItem negated 			about: parents second point)].! !!DrGRotationPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGRotationPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update|center angle|	self doesParentExist ifTrue:		[center := parents second point.		angle := parents third valueItem negated.		points := OrderedCollection new.		parents first points do: [:point |			points add: (point 				rotateBy: angle				about: center)].		self computeLength].! !!DrGRotationPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGRotationRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 22:01'!update	self rotationUpdate ! !!DrGRotationRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGRotationSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 2/7/2006 22:02'!update	self rotationUpdate ! !!DrGRotationSegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGRotationVectorItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/7/2006 22:03'!initialize: theParents	super initialize: theParents.	self origin: parents first origin.! !!DrGRotationVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGRotationVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[vector := parents first direction 			rotateVector: parents third valueItem].! !!DrGRotationVectorItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Rotation! !!DrGScriptItem methodsFor: 'private' stamp: 'HilaireFernandes 8/23/2008 22:50'!adaptiveDescriptiveName	| string |	parents size > 0 		ifFalse: [string := 'This script {1}>>{2}' translated]		ifTrue: 			[parents size = 1 				ifTrue: [string := 'This script {1}>>{2} on argument: %2']				ifFalse: [string := 'This script {1}>>{2} on arguments: %2'].			string := string copyReplaceAll: '%2' with: self argumentName].	^string format: {'DrGeoUserScripts'. script asString}.! !!DrGScriptItem methodsFor: 'private' stamp: 'HilaireFernandes 8/4/2008 13:15'!argumentName	"collect parents name in a string as A, B, C"	| stream |	parents size = 0 ifTrue: [ ^ '' ].	stream := ReadWriteStream on: String new.	parents allButLast do: 		[ :item | 		stream			nextPutAll: item safeName;			nextPutAll: ', ' ].	stream nextPutAll: parents last safeName.	^ stream contents! !!DrGScriptItem methodsFor: 'testing' stamp: 'HilaireFernandes 8/23/2008 22:34'!hash	^super hash bitXor: script hash! !!DrGScriptItem methodsFor: 'testing' stamp: 'HilaireFernandes 8/3/2008 18:29'!isScriptItem	^true! !!DrGScriptItem methodsFor: 'initialization' stamp: 'HilaireFernandes 8/4/2008 10:31'!initialize: theParents 	super initialize: theParents.	script := theParents at: theParents size - 1! !!DrGScriptItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 8/3/2008 18:30'!nodeName	^#script! !!DrGScriptItem methodsFor: 'accessing' stamp: 'HilaireFernandes 8/23/2008 22:41'!parents: aCollection 	"last is the initial screen position of the value, and previous last is the script symbol"	aCollection ifNil: 		[ parents := nil.		^ self ].	aCollection last isPoint 		ifTrue: [ parents := aCollection allButLast: 2 ]		ifFalse: 			[ "play nicely with macro"			parents := aCollection ]! !!DrGScriptItem methodsFor: 'accessing' stamp: 'HilaireFernandes 8/23/2008 22:55'!script	^script! !!DrGScriptItem methodsFor: 'updating' stamp: 'HilaireFernandes 8/23/2008 22:44'!update	self doesParentExist ifTrue: 		[ value := DrGeoUserScripts instance			perform: script			withArguments: parents asArray ]! !!DrGScriptItem methodsFor: 'comparing' stamp: 'HilaireFernandes 8/23/2008 22:45'!= aScriptItem	^super = aScriptItem and: [script = aScriptItem script]! !!DrGScriptPlayer methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/23/2008 22:38'!arguments	^ (OrderedCollection withAll: input)		add: selectedMethod selector;		add: point;		yourself! !!DrGScriptPlayer methodsFor: 'private' stamp: 'HilaireFernandes 8/4/2008 14:39'!addItem: aMathItemCollection at: aPoint"Take the point position only when the user clic somewhere in the background"	aMathItemCollection ifEmpty: 		[point := aPoint.		^self].	input size < selectedMethod numArgs 		ifTrue: [self addToggleItem: aMathItemCollection in: input]		ifFalse: [(input includes: aMathItemCollection first) 			ifTrue: [input remove: aMathItemCollection first]]! !!DrGScriptPlayer methodsFor: 'callback' stamp: 'HilaireFernandes 8/2/2008 21:43'!cancel	self triggerEvent: #cancel! !!DrGScriptPlayer methodsFor: 'callback' stamp: 'HilaireFernandes 8/2/2008 21:48'!page: integer 	"we receive notification from the wizard the user change the wizard	current page"	| newState |	integer = 1 		ifTrue: [ newState := DrGMacroToolStateNeutral ]		ifFalse: [ newState := DrGMacroPlayToolStateSelect].	self 		triggerEvent: #changedState		with: newState! !!DrGScriptPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/23/2008 22:24'!description	| comment |	^ selectedMethod 		ifNil: [nil]		ifNotNil: 			[comment := DrGeoUserScripts firstCommentAt: selectedMethod selector.			comment isEmpty 				ifTrue: ['no comment, write one at the beginning of the script source code' translated]				ifFalse: [comment]]! !!DrGScriptPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:08'!description: aText 	! !!DrGScriptPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/2/2008 21:45'!input	^input! !!DrGScriptPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:00'!selectedMethod	^selectedMethod ! !!DrGScriptPlayer methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:03'!selectedMethod: aMethod	selectedMethod := aMethod .	input := OrderedCollection new.	self triggerEvent: #changedScript.! !!DrGScriptPlayer methodsFor: 'initialization' stamp: 'HilaireFernandes 8/2/2008 21:44'!initialize	wizard := (DrGWizardScript builder: self) openInWorld.	input := OrderedCollection new.	self registerEvents! !!DrGScriptPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 8/4/2008 14:50'!isWanted: aMathItemCollection 	"We are not yet performing type checking for script, we are even interestedin empty aMathItemCollection, (ie: just get the clic position in the background)"	selectedMethod ifNil: [^false].	aMathItemCollection ifEmpty: [ ^ true ].	^ input size = selectedMethod numArgs 		ifTrue: 			[ (input includes: aMathItemCollection first) 				ifTrue: [ true ]				ifFalse: [ false ] ]		ifFalse: [ true ]! !!DrGScriptPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 8/4/2008 09:41'!mathItemClass	^DrGScriptItem ! !!DrGScriptPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 8/4/2008 10:29'!readyToBuild	selectedMethod  ifNil: [^false].	^ input size = selectedMethod numArgs and: [ point isNil not ]! !!DrGScriptPlayer methodsFor: 'testing' stamp: 'HilaireFernandes 8/4/2008 09:44'!reset	super reset.	input := OrderedCollection new.! !!DrGScriptPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/2/2008 21:50'!registerEvents	wizard when: #page send: #page: to: self.	wizard when: #cancel send: #cancel to: self.! !!DrGScriptPlayer methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/2/2008 21:51'!removeEvents	wizard removeActionsWithReceiver: self! !!DrGScriptPlayer methodsFor: 'dependents access' stamp: 'HilaireFernandes 8/2/2008 21:51'!release	self removeEvents.	wizard delete.	wizard := nil! !!DrGScriptPlayTool methodsFor: 'updating' stamp: 'HilaireFernandes 8/3/2008 11:54'!changedScript" the builder inform us the user selected another script,do some cleaning"	self selectNoCostume! !!DrGScriptPlayTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/3/2008 11:44'!registerDependant: anObject	builder when: #changedState send: #switchState: to: self.	builder when: #cancel send: #cancel to: self.	builder when: #readyToBuild send: #readyToBuild to: anObject.	builder when: #changedScript send: #changedScript to: self! !!DrGSegment2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#'2pts'! !!DrGSegment2PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:36'!parentQty	^2! !!DrGSegment2PointsItem methodsFor: 'comparing' stamp: 'HilaireFernandes 4/30/2010 17:40'!= aMathItem 	^ aMathItem 		ifNil: [false]		ifNotNil: [self basicType = aMathItem basicType 			and: [self nodeType = aMathItem nodeType]			and: [				(self parents includesAllOf: aMathItem parents)					and: [aMathItem parents includesAllOf: self parents]]]! !!DrGSegmentBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:04'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection  at: aPoint.	pointA ifNil: 		[pointA := aMathItemCollection first.		^ self].	pointB ifNil: [pointB := aMathItemCollection first]	! !!DrGSegmentBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 16:13'!arguments	^{pointA . pointB}! !!DrGSegmentBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 4/30/2010 17:39'!isWanted: aMathItemCollection	^aMathItemCollection notEmpty		and: [aMathItemCollection first isPointItem] 		and: [aMathItemCollection first ~= pointA 			and: [aMathItemCollection first ~= pointB]]! !!DrGSegmentBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 12/21/2005 16:21'!readyToBuild	^ pointA notNil and: [pointB notNil]! !!DrGSegmentBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 22:58'!mathItemClass	^DrGSegment2PointsItem! !!DrGSegmentBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:46'!reset	super reset.	pointA := pointB := nil! !!DrGSegmentCostume methodsFor: 'testing' stamp: 'HilaireFernandes 12/31/2005 10:04'!basicType	^#segment! !!DrGSegmentCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:03'!instantiateMorph	morph := DrGSegmentMorph new! !!DrGSegmentCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/12/2006 22:07'!redraw	super redraw.	morph 		from: (drawable worldToMorph: mathItem origin) 		to: (drawable worldToMorph: mathItem origin + mathItem direction).! !!DrGSegmentCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:03'!styleClass	^DrGFinitCurveCostumeStyle! !!DrGSegmentItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/31/2005 11:40'!abscissaOf: aPoint	^((aPoint - origin) dotProduct: vector) / (vector dotProduct: vector)! !!DrGSegmentItem methodsFor: 'computing' stamp: 'HilaireFernandes 3/13/2006 16:16'!closestPointTo: aPoint	|abscissa squareNorm|	abscissa := (aPoint - origin) dotProduct: vector.	squareNorm := vector dotProduct: vector.	abscissa < 0 ifTrue: [abscissa := 0].	abscissa > squareNorm ifTrue: 		[abscissa := squareNorm].	^ origin + (abscissa * vector / squareNorm asFloat)! !!DrGSegmentItem methodsFor: 'computing' stamp: 'HilaireFernandes 1/17/2006 17:53'!intersectionWith: aCurveItem flag: aFlag|aPoint|	aCurveItem isLineItem		ifTrue:			[aPoint := self intersectionWithDirection: aCurveItem.			(self contains: aPoint)				ifTrue: [^aPoint]				ifFalse: [^nil]].	aCurveItem isSegmentItem		ifTrue:			[aPoint := self intersectionWithDirection: aCurveItem.			((self contains: aPoint) and: [aCurveItem contains: aPoint])				ifTrue: [^aPoint]				ifFalse: [^nil]].	(aCurveItem isRayItem 		or: [aCurveItem isCircleItem]		or: [aCurveItem isArcItem])		ifTrue:			[^aCurveItem intersectionWith: self flag: aFlag].			! !!DrGSegmentItem methodsFor: 'computing' stamp: 'HilaireFernandes 12/31/2005 11:40'!pointAt: anAbscissa	^ origin + (anAbscissa * vector)! !!DrGSegmentItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:07'!adaptiveDescriptiveName	^ 'This segment %1' translated! !!DrGSegmentItem methodsFor: 'accessing' stamp: 'HilaireFernandes 12/21/2005 16:33'!basicType	^#segment! !!DrGSegmentItem methodsFor: 'testing' stamp: 'HilaireFernandes 1/12/2006 17:37'!contains: aPoint|anAbscissa|	^ ((vector crossProduct: (aPoint - origin)) closeTo: 0) 		and: 			[anAbscissa := self abscissaOf: aPoint.			anAbscissa >= 0]		and: [anAbscissa <= 1]! !!DrGSegmentItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/21/2010 20:37'!isCurveItem	^true! !!DrGSegmentItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/3/2006 16:31'!isGeometricItem	^true! !!DrGSegmentItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:51'!isSegmentItem	^true! !!DrGSegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/19/2008 23:03'!nodeName	^#segment! !!DrGSegmentMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 6/19/2010 17:46'!from: startPoint to: endPoint 	| clippedSeg |	clippedSeg := self costume drawable bounds				intersectionWith: (LineSegment from: startPoint to: endPoint).	clippedSeg		ifNotNil: [			self visible ifFalse: [ self show].			vertices at: 1 put: clippedSeg start asIntegerPoint.			vertices at: 2 put: clippedSeg end asIntegerPoint.			self computeBounds]		ifNil: [self visible ifTrue: [self hide]]! !!DrGSegmentMorph methodsFor: 'initializing' stamp: 'HilaireFernandes 6/21/2007 18:10'!initialize	super initialize.	vertices := Array with: 0@0 with: 0@0! !!DrGSelectTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 16:53'!costumesAt: aPoint	^ self pointCostumesFirstAt: aPoint! !!DrGSelectTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/27/2005 12:00'!start	^start! !!DrGSelectTool methodsFor: 'accessing' stamp: 'HilaireFernandes 12/27/2005 12:00'!start: aPoint	start := aPoint ! !!DrGSelectTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/20/2006 12:02'!initialize	self reset! !!DrGSelectTool methodsFor: 'updating' stamp: 'HilaireFernandes 8/18/2008 12:58'!reset	super reset.	start := nil.	self switchState: DrGSelectToolStateNeutral! !!DrGSelectTool commentStamp: '<historical>' prior: 0!start					- the position where start the dragging!!DrGSelectToolState methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 09:57'!handleChoice: aCostumeCollection 	aCostumeCollection ifNotEmpty: 			[self context costume: aCostumeCollection first.			self switchState: DrGSelectToolStateSelected.			^true]		ifEmpty: 			[self context reset.			^false]! !!DrGSelectToolStateDragged methodsFor: 'handling' stamp: 'HilaireFernandes 4/19/2010 13:26'!handleMouseAt: aPoint|griddedPoint|	griddedPoint := self context gridPoint: aPoint.	(self context isGridded and: [self context mathItem isFreePointItem])		ifFalse:			[self context domain 				moveEvent: self context mathItem				inDirection: (self area morphToVector: 									griddedPoint - self context last).]		ifTrue:			[self context domain 				moveEvent: self context mathItem				at: (self area gridWorldPoint: griddedPoint)].	self context last: griddedPoint.! !!DrGSelectToolStateDragged methodsFor: 'handling' stamp: 'HilaireFernandes 4/19/2010 13:26'!handleRelease: aPoint 	self switchState: DrGSelectToolStateNeutral.	"issue a moveCommand"	self context domain 		moveMathItem: self context mathItem 		with: (self area morphToVector: 			self context last - self context start).	self context reset! !!DrGSelectToolStateGrabbed methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 09:58'!handleMouseAt: aPoint 	"The user is moving, switch to dragging state"|griddedPoint|	griddedPoint := self context gridPoint: aPoint.	self switchState: DrGSelectToolStateDragged.	self context		start: griddedPoint;		last: griddedPoint! !!DrGSelectToolStateGrabbed methodsFor: 'handling' stamp: 'HilaireFernandes 1/24/2006 23:13'!handleRelease: aPoint 	self switchState: DrGSelectToolStateNeutral.	self context reset! !!DrGSelectToolStateNeutral methodsFor: 'handling' stamp: 'HilaireFernandes 8/18/2008 12:38'!handlePress: aPoint 	| costumes griddedPoint|	self area hideTip.	griddedPoint := self context gridPoint: aPoint.	costumes := self context costumesAt: aPoint.	costumes size = 1 		ifTrue: 			[self context last: griddedPoint.			self context costume: costumes first.			self switchState: DrGSelectToolStateGrabbed.			^true].	"More than one math item under mouse"	costumes size > 1 		ifTrue: 			[self context last: griddedPoint.			self context chooseCostume: costumes.			^true].	"The user clicked in the background, clear the selection"	self context reset.	^false! !!DrGSelectToolStateSelected methodsFor: 'handling' stamp: 'HilaireFernandes 1/12/2006 11:01'!handleMouseAt: aPoint	|costumes|	costumes := self context costumesAt: aPoint.	(costumes includes: self context costume)		ifTrue:			[self area 				tip: self context costume mathItem descriptiveName				at: aPoint]		ifFalse: [self area hideTip]! !!DrGSelectToolStateSelected methodsFor: 'handling' stamp: 'HilaireFernandes 7/20/2008 09:58'!handlePress: aPoint 	| costumes |	self area hideTip.	costumes := self context costumesAt: aPoint.	(costumes includes: self context costume) 		ifTrue: 			[self switchState: DrGSelectToolStateGrabbed.			^true]		ifFalse: 			[self context reset.			^false]! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 4/20/2010 07:54'!addCustomMenuItems: menu hand: aHandMorph 	"super addCustomMenuItems: menu hand: aHandMorph."	| submenu |	menu addLine.	submenu := MenuMorph new.	self addToolsMenuItems: submenu hand: aHandMorph.	menu add: 'Dr. Geo tools' translated subMenu: submenu.	submenu := MenuMorph new.	self addGetButtonsMenuItems: submenu hand: aHandMorph.	menu add: 'Give me Dr. Geo buttons' translated subMenu: submenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 4/20/2010 07:54'!addGetButtonsMenuItems: menu hand: aHandMorph 	"from this menu we can ask for buttons to plug arround"	self addPointBtnMenuItems: menu hand: aHandMorph.	self addLineBtnMenuItems: menu hand: aHandMorph.	self addTransformationBtnMenuItems: menu hand: aHandMorph.	self addNumericBtnMenuItems: menu hand: aHandMorph.	self addMacroBtnMenuItems: menu hand: aHandMorph.	self addOtherBtnMenuItems: menu hand: aHandMorph.! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:39'!addLineBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #lineBtn menuItemBtn: self drgeoPresenter lineButtonData to: subMenu.	self add: #parallelBtn menuItemBtn: self drgeoPresenter parallelButtonData to: subMenu.	self add: #perpendicularBtn menuItemBtn: self drgeoPresenter perpendicularButtonData to: subMenu.	self add: #rayBtn menuItemBtn: self drgeoPresenter rayButtonData to: subMenu.	self add: #segmentBtn menuItemBtn: self drgeoPresenter segmentButtonData to: subMenu.	self add: #vectorBtn menuItemBtn: self drgeoPresenter vectorButtonData to: subMenu.	self add: #circleBtn menuItemBtn: self drgeoPresenter circleButtonData to: subMenu.	self add: #arcBtn menuItemBtn: self drgeoPresenter arcButtonData to: subMenu.		self add: #polygonBtn menuItemBtn: self drgeoPresenter polygonButtonData to: subMenu.		self add: #locusBtn menuItemBtn: self drgeoPresenter locusButtonData to: subMenu.	menu add: ('Curves' translated) subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:39'!addLineMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter lineButtonData to: subMenu.	self addMenuItem: self drgeoPresenter parallelButtonData to: 	subMenu.	self addMenuItem: self drgeoPresenter perpendicularButtonData to: subMenu.	self addMenuItem: self drgeoPresenter rayButtonData to: subMenu.	self addMenuItem: self drgeoPresenter segmentButtonData to: subMenu.	self addMenuItem: self drgeoPresenter vectorButtonData to: subMenu.	self addMenuItem: self drgeoPresenter circleButtonData to: subMenu.	self addMenuItem: self drgeoPresenter arcButtonData to: subMenu.	self addMenuItem: self drgeoPresenter polygonButtonData to: subMenu.	self addMenuItem: self drgeoPresenter locusButtonData to: subMenu.	menu add: 'Curves' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:39'!addMacroBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #macroBuildBtn menuItemBtn: self drgeoPresenter macroBuildButtonData to: subMenu.	self add: #executeBtn menuItemBtn: self drgeoPresenter macroExecuteButtonData to: subMenu.	menu add: 'Macro-construction' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:40'!addMacroMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter macroBuildButtonData to: subMenu.	self addMenuItem: self drgeoPresenter macroExecuteButtonData to: subMenu.	self addMenuItem: self drgeoPresenter macroDeleteButtonData to: subMenu.	menu add: 'Macro-construction' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/14/2010 16:39'!addMenuItem: array to: menu	menu 		add: array first 		target: self drgeoPresenter		selector: array third.	menu lastItem		setBalloonText: array fourth  		! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:40'!addNumericBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #distanceBtn menuItemBtn: self drgeoPresenter distanceButtonData to: subMenu.	self add: #angleBtn menuItemBtn: self drgeoPresenter angleButtonData to: subMenu.	self add: #coordinatesBtn menuItemBtn: self drgeoPresenter coordinatesButtonData to: subMenu.	self add: #scriptBtn menuItemBtn: self drgeoPresenter scriptButtonData to: subMenu.	self add: #scriptEditBtn menuItemBtn: self drgeoPresenter scriptEditButtonData to: subMenu.	menu add: 'Numerics' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:40'!addNumericMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter distanceButtonData to: subMenu.	self addMenuItem: self drgeoPresenter angleButtonData to: subMenu.	self addMenuItem: self drgeoPresenter coordinatesButtonData to: subMenu.	self addMenuItem: self drgeoPresenter scriptEditButtonData to: subMenu.	self addMenuItem: self drgeoPresenter scriptButtonData to: subMenu.	menu add: 'Numerics' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:40'!addOtherBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #undoBtn menuItemBtn: self drgeoPresenter undoButtonData to: subMenu.	self add: #redoBtn menuItemBtn: self drgeoPresenter redoButtonData to: subMenu.	self add: #eraserBtn menuItemBtn: self drgeoPresenter eraserButtonData to: subMenu.	self add: #styleBtn menuItemBtn: self drgeoPresenter styleButtonData to: subMenu.	self add: #propertyBtn menuItemBtn: self drgeoPresenter propertyButtonData to: subMenu.	self add: #moveBtn menuItemBtn: self drgeoPresenter moveButtonData to: subMenu.			self add: #gridBtn menuItemBtn: self drgeoPresenter gridButtonData to: subMenu.	self add: #gridStuckBtn menuItemBtn: self drgeoPresenter gridStuckButtonData to: subMenu.	self add: #viewerBtn menuItemBtn: self drgeoPresenter viewerButtonData to: subMenu.	menu add: 'Other' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:41'!addOtherMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter undoButtonData to: subMenu.	self addMenuItem: self drgeoPresenter redoButtonData to: subMenu.	self addMenuItem: self drgeoPresenter eraserButtonData to: subMenu.	self addMenuItem: self drgeoPresenter styleButtonData to: subMenu.	self addMenuItem: self drgeoPresenter propertyButtonData to: subMenu.	self addMenuItem: self drgeoPresenter moveButtonData to: subMenu.	subMenu 		addUpdating: #gridString		target: self drgeoPresenter		selector: #gridOnOff		argumentList: #();				addUpdating: #griddedString		target: self drgeoPresenter		selector: #gridStuckOnOff		argumentList: #().	self addMenuItem: self drgeoPresenter viewerButtonData to: subMenu.	self addMenuItem: self drgeoPresenter multipleModeButtonData to: subMenu.	subMenu 				addUpdating: #createMultipleString		target: self drgeoPresenter		selector: #createMultipleOnOff		argumentList: #();				add: 'default position and scale' translated		target: self area		selector: #defaultScalePosition.	menu add: 'Other' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:41'!addPointBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #freePointBtn menuItemBtn: self drgeoPresenter freePointButtonData to: subMenu.	self add: #middlePointBtn menuItemBtn: self drgeoPresenter middleButtonData to: subMenu.		self add: #pointByCoordinatesBtn menuItemBtn: self drgeoPresenter pointByCoordinatesButtonData to: subMenu.	menu add: 'Points' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:41'!addPointMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter freePointButtonData to: subMenu.	self addMenuItem: self drgeoPresenter middleButtonData to: subMenu.	self addMenuItem: self drgeoPresenter pointByCoordinatesButtonData to: subMenu.	menu add: 'Points' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 4/20/2010 07:55'!addToolsMenuItems: menu hand: aHandMorph 	self addPointMenuItems: menu hand: aHandMorph.	self addLineMenuItems: menu hand: aHandMorph.	self addTransformationMenuItems: menu hand: aHandMorph.	self addNumericMenuItems: menu hand: aHandMorph.	self addMacroMenuItems: menu hand: aHandMorph.	self addOtherMenuItems: menu hand: aHandMorph! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:41'!addTransformationBtnMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self add: #symmetryBtn menuItemBtn: self drgeoPresenter symmetryButtonData to: subMenu.	self add: #reflectionBtn menuItemBtn: self drgeoPresenter reflectionButtonData to: subMenu.	self add: #translationBtn menuItemBtn: self drgeoPresenter translationButtonData to: subMenu.	self add: #rotationBtn menuItemBtn: self drgeoPresenter rotationButtonData to: subMenu.	self add: #homothetyBtn menuItemBtn: self drgeoPresenter homothetyButtonData to: subMenu.	menu add: 'Transformations' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/13/2010 10:41'!addTransformationMenuItems: menu hand: aHandMorph 	| subMenu |	subMenu := MenuMorph new.	self addMenuItem: self drgeoPresenter symmetryButtonData to: subMenu.	self addMenuItem: self drgeoPresenter reflectionButtonData to: subMenu.	self addMenuItem: self drgeoPresenter translationButtonData to: subMenu.	self addMenuItem: self drgeoPresenter rotationButtonData to: subMenu.	self addMenuItem: self drgeoPresenter homothetyButtonData to: subMenu.	menu add: 'Transformations' translated subMenu: subMenu! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 5/14/2010 16:39'!add: btnSelector menuItemBtn: array to: menu	menu 		add: array first 		target: self		selector: #giveMeButton:		argument: btnSelector.	menu lastItem 		icon: (DrGIcons scaled16: array second);		setBalloonText: array fourth  		! !!DrGService methodsFor: 'menu' stamp: 'HilaireFernandes 4/20/2010 07:55'!popupMenu	"super addCustomMenuItems: menu hand: aHandMorph."	| menu |	menu := MenuMorph new title: 'Dr. Geo tools' translated.	self addToolsMenuItems: menu hand: nil.	menu addStayUpItem.	menu popUpInWorld: World! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:41'!angleBtn	^ self buttonAtHand: self drgeoPresenter angleButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:41'!arcBtn	^ self buttonAtHand: self drgeoPresenter arcButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:41'!buttonAtHand: array"array first = button formarray second = symbol callbackarray third = help string"	^ IconicButton new		labelGraphic: (DrGIcons scaled24: array second);		color: self colorButton;		setBalloonText: array fourth translated;		target: self drgeoPresenter;		actionSelector: array third! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!circleBtn	^ self buttonAtHand: self drgeoPresenter circleButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 4/20/2010 07:56'!colorButton	^ Color green alpha: 0.2! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!coordinatesBtn	^ self buttonAtHand: self drgeoPresenter coordinatesButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!distanceBtn	^ self buttonAtHand: self drgeoPresenter distanceButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!editGroupBtn	^ self buttonAtHand: self drgeoPresenter editGroupButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!eraserBtn	^ self buttonAtHand: self drgeoPresenter eraserButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!freePointBtn	^ self buttonAtHand: self drgeoPresenter freePointButtonData! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 4/20/2010 07:56'!giveMeButton: aSymbol	self currentHand attachMorph: (self perform: aSymbol)! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!gridBtn	^ self buttonAtHand: self drgeoPresenter gridButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!gridStuckBtn	^ self buttonAtHand: self drgeoPresenter gridStuckButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!groupBtn	^ self buttonAtHand: self drgeoPresenter groupButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!homothetyBtn	^ self buttonAtHand: self drgeoPresenter homothetyButtonData  ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!lineBtn	^ self buttonAtHand: self drgeoPresenter lineButtonData  ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!locusBtn	^ self buttonAtHand: self drgeoPresenter locusButtonData  ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!macroBuildBtn	^ self buttonAtHand: self drgeoPresenter macroBuildButtonData   ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!macroDeleteBtn	^ self buttonAtHand: self drgeoPresenter macroDeleteButtonData    ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!macroExecuteBtn	^ self buttonAtHand: self drgeoPresenter macroExecuteButtonData    ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!middlePointBtn	^ self buttonAtHand: self drgeoPresenter middleButtonData    ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!moveBtn	^ self buttonAtHand: self drgeoPresenter moveButtonData     ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!multipleModeBtn          	^ self buttonAtHand: self drgeoPresenter multipleModeButtonData        ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!parallelBtn	^ self buttonAtHand: self drgeoPresenter parallelButtonData      ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!perpendicularBtn	^ self buttonAtHand: self drgeoPresenter parallelButtonData! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!pointByCoordinatesBtn 	^ self buttonAtHand: self drgeoPresenter pointByCoordinatesButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!polygonBtn 	^ self buttonAtHand: self drgeoPresenter polygonButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!propertyBtn  	^ self buttonAtHand: self drgeoPresenter propertyButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!rayBtn   	^ self buttonAtHand: self drgeoPresenter rayButtonData! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:42'!redoBtn    	^ self buttonAtHand: self drgeoPresenter redoButtonData ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!reflectionBtn     	^ self buttonAtHand: self drgeoPresenter reflectionButtonData  ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!rotationBtn      	^ self buttonAtHand: self drgeoPresenter rotationButtonData  ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!scriptBtn      	^ self buttonAtHand: self drgeoPresenter scriptButtonData   ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!scriptEditBtn      	^ self buttonAtHand: self drgeoPresenter scriptEditButtonData   ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!segmentBtn      	^ self buttonAtHand: self drgeoPresenter segmentButtonData    ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!styleBtn      	^ self buttonAtHand: self drgeoPresenter styleButtonData    ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!symmetryBtn       	^ self buttonAtHand: self drgeoPresenter symmetryButtonData     ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!translationBtn        	^ self buttonAtHand: self drgeoPresenter translationButtonData     ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!undoBtn         	^ self buttonAtHand: self drgeoPresenter undoButtonData      ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!vectorBtn         	^ self buttonAtHand: self drgeoPresenter vectorButtonData      ! !!DrGService methodsFor: 'button' stamp: 'HilaireFernandes 5/13/2010 10:43'!viewerBtn         	^ self buttonAtHand: self drgeoPresenter viewerButtonData       ! !!DrGService methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 21:33'!app	^ app! !!DrGService methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 21:33'!app: anObject	app := anObject! !!DrGService methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 21:33'!area	^ area! !!DrGService methodsFor: 'accessing' stamp: 'HilaireFernandes 5/13/2010 10:38'!drgeoPresenter	^ app presenter! !!DrGService methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/21/2010 07:51'!initialize	super initialize.	self color: Color veryLightGray muchLighter .	self borderWidth: 1.	self clipSubmorphs: true.	self layoutPolicy: ProportionalLayout new.	area := DrGDrawable newOn: app.	self installTools! !!DrGService methodsFor: 'initialize-release' stamp: 'HilaireFernandes 5/13/2010 10:42'!installTools 	self 		addMorph: area	 	fullFrame: (LayoutFrame 			fractions: (0@0 corner: 1@1) 			offsets: (0@0 corner: -25@ -25)).	self		addMorph: self drgeoPresenter verticalWheel		fullFrame: (LayoutFrame 			fractions: (1 @ 1 corner: 1 @ 1) 			offsets: (-25@ -120 corner: 0@ -20)).	self		addMorph: self drgeoPresenter horizontalWheel		fullFrame: (LayoutFrame 			fractions: (1 @ 1 corner: 1 @ 1) 			offsets: (-120@ -25 corner: -20@0)).	self	 	addMorph: self drgeoPresenter zoomWheel 		fullFrame: (LayoutFrame 			fractions: (1 @ 0 corner: 1 @ 0) 			offsets: (-25@0 corner: 0@100)).	area layoutChanged! !!DrGService methodsFor: 'testing' stamp: 'HilaireFernandes 4/19/2010 10:32'!isApplication	^false! !!DrGService methodsFor: 'testing' stamp: 'HilaireFernandes 6/21/2007 14:53'!isService	^true! !!DrGService class methodsFor: 'instance creation' stamp: 'HilaireFernandes 4/19/2010 21:55'!in: aDrgeo	^ self basicNew app: aDrgeo;		initialize! !!DrGService class methodsFor: 'instance creation' stamp: 'HilaireFernandes 6/18/2007 17:09'!with: aDrgeoModel 	^ self basicNew initialize: aDrgeoModel! !!DrGService class methodsFor: 'parts bin' stamp: 'HilaireFernandes 5/13/2010 20:38'!descriptionForPartsBin	^ (DescriptionForPartsBin		formalName: 'Dr. Geo'		categoryList: #('Graphics' 'Tools' )		documentation: 'An interactive geometry canvas to draw dynamic geometric sketch. Open the Morph menu to get access to the construction tools and more.' translated		globalReceiverSymbol: #DrGeo		nativitySelector: #sample)		sampleImageForm: DrGIcons angle! !!DrGStringMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/25/2006 17:53'!costume	"Answer the value of costume"	^ costume! !!DrGStringMorph methodsFor: 'accessing' stamp: 'CedrickBeler 4/23/2010 16:49'!costume: anObject	"Set the value of costume"	costume := anObject! !!DrGStringMorph methodsFor: 'event handling' stamp: 'HilaireFernandes 2/4/2006 12:17'!handlesMouseDown: evt	^true! !!DrGStringMorph methodsFor: 'initialization' stamp: 'HilaireFernandes 1/26/2008 14:38'!initialize	super initialize.	blink := false.	self font: DrGDefault font! !!DrGStringMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 2/4/2006 12:04'!startBlinking	blink := true.	self startStepping ! !!DrGStringMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 2/4/2006 12:04'!step	blink ifFalse: [^self].	super step.	self color = DrGCostumeStyle blinkingColor 		ifTrue: [self color: costume style color]		ifFalse: [self color: DrGCostumeStyle blinkingColor]! !!DrGStringMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 2/4/2006 12:04'!stopBlinking	blink := false.	self stopStepping.! !!DrGStringMorph methodsFor: 'stepping and presenter' stamp: 'HilaireFernandes 2/4/2006 12:04'!stopStepping	super stopStepping.	self color: costume style color.! !!DrGStringMorph methodsFor: 'testing' stamp: 'HilaireFernandes 2/4/2006 12:04'!stepTime	^500! !!DrGStyleTool methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 20:32'!costumesAt: aPoint	^self pointCostumesFirstAt: aPoint ! !!DrGStyleTool methodsFor: 'accessing' stamp: 'HilaireFernandes 4/19/2010 13:20'!presenter: aPresenter	super presenter: aPresenter.	self app forceVisible: true.! !!DrGStyleTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 7/18/2008 16:49'!initialize	super initialize.	self reset.! !!DrGStyleTool methodsFor: 'initialize-release' stamp: 'HilaireFernandes 4/19/2010 13:20'!release	self app forceVisible: false.	super release.! !!DrGStyleTool methodsFor: 'private' stamp: 'HilaireFernandes 4/19/2010 13:20'!myCostumesAt: aPoint"return the list of costume at position aPoint"	^self app costumes select: [:aCostume |		(self isWanted: {aCostume mathItem})		and: [aCostume containsPoint: aPoint]]! !!DrGStyleTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/20/2008 09:59'!reset	super reset.	self switchState: DrGStyleToolState! !!DrGStyleTool commentStamp: '<historical>' prior: 0!A tool to edit the style of the costume.!!DrGStyleToolState methodsFor: 'handling' stamp: 'HilaireFernandes 1/24/2006 14:30'!handleChoice: aCostumeCollection	aCostumeCollection 		ifNotEmpty: 			[self context costume: aCostumeCollection first.			self context costume style popupMenu].	self context reset! !!DrGStyleToolState methodsFor: 'handling' stamp: 'HilaireFernandes 8/18/2008 12:39'!handlePress: aPoint	|costumes|	self area hideTip.	costumes := self context costumesAt: aPoint.	costumes size = 1 ifTrue:		[self context last: aPoint.		self handleChoice: costumes.		^true].	"More than one math item under mouse"	costumes size > 1 ifTrue:		[self context last: aPoint.		self context chooseCostume: costumes.		^true].	"The user clicked in the background, clear the selection"	self context reset.	^false! !!DrGSymmetryArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGSymmetryArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist 		ifTrue: 			[origin := parents first origin + Float pi.			origin > Float pi ifTrue: [origin := origin - DrGDirectionItem twoPi].			radius := parents first radius.			center := 2 * parents second point - parents first center.			length := parents first length].! !!DrGSymmetryArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Symmetry! !!DrGSymmetryBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:06'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	(aMathItemCollection first isPointItem and: [center isNil])		ifTrue: [center := aMathItemCollection first]		ifFalse: [mathItem := aMathItemCollection first]! !!DrGSymmetryBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 15:23'!arguments: aMathItem	^{aMathItem . center}! !!DrGSymmetryBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:06'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty		and:			[(aMathItemCollection first isPointItem and: [center isNil])				or:				[aMathItemCollection first isGeometricItem and: [mathItem isNil]]]! !!DrGSymmetryBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/3/2006 16:53'!readyToBuild	^center notNil and: [mathItem notNil]! !!DrGSymmetryBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:26'!mathItemClass: aMathItem	|className|	className := 'DrGSymmetry', aMathItem basicType capitalized, 'Item'.	^(self class environment classNamed: className)! !!DrGSymmetryBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:47'!reset	super reset.	mathItem := center := nil! !!DrGSymmetryCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGSymmetryCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[self radius: parents first radius.		self center: (2 * parents second point) - parents first center].! !!DrGSymmetryCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Symmetry! !!DrGSymmetryLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:43'!moveParent: aPoint	^false! !!DrGSymmetryLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 17:20'!update	self symmetryUpdate ! !!DrGSymmetryLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:01'!nodeType	^#Symmetry! !!DrGSymmetryPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:29'!isConstrainedPointItem	^true! !!DrGSymmetryPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Symmetry! !!DrGSymmetryPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue: 		[self point: (2 * parents second point) - parents first point].! !!DrGSymmetryPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGSymmetryPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update|center|	self doesParentExist 	ifTrue:		[center := parents second point.		points := OrderedCollection new.		parents first points do: [:point |			points add: (2 * center - point)].		self computeLength].! !!DrGSymmetryPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Symmetry! !!DrGSymmetryRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGSymmetryRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 17:23'!update	self symmetryUpdate ! !!DrGSymmetryRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Symmetry! !!DrGSymmetrySegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGSymmetrySegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/3/2006 17:24'!update	self symmetryUpdate ! !!DrGSymmetrySegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Symmetry! !!DrGSymmetryVectorItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/3/2006 17:25'!initialize: theParents	super initialize: theParents.	self origin: (parents first origin)! !!DrGSymmetryVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGSymmetryVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[self direction: parents first direction negated].! !!DrGSymmetryVectorItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Symmetry! !!DrGTransformationBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 15:39'!arguments	^self arguments: mathItem! !!DrGTransformationBuilder methodsFor: 'building' stamp: 'HilaireFernandes 3/5/2006 15:37'!buildItem	mathItem class = DrGCompositeItem 		ifTrue:			[^ mathItem subItems collect: [:aMathItem|					(self mathItemClass: aMathItem) 						newWith: (self arguments: aMathItem)]]		ifFalse:			[^super buildItem]! !!DrGTransformationBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:39'!mathItemClass	^ self mathItemClass: mathItem! !!DrGTransformationBuilder commentStamp: '<historical>' prior: 0!Transformation builder can handle compositeItem, we need to specializeits behavior.!!DrGTranslationArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGTranslationArcItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[origin := parents first origin.		radius := parents first radius.		center := parents first center + parents second direction.		length := parents first length].! !!DrGTranslationArcItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGTranslationBuilder methodsFor: 'private' stamp: 'HilaireFernandes 1/6/2006 10:06'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	(aMathItemCollection first isVectorItem and: [vector isNil])		ifTrue: [vector := aMathItemCollection first]		ifFalse: [mathItem := aMathItemCollection first]! !!DrGTranslationBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 3/5/2006 15:23'!arguments: aMathItem	^{aMathItem . vector}! !!DrGTranslationBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/6/2006 10:07'!isWanted: aMathItemCollection 	^ aMathItemCollection notEmpty 		and:			[(aMathItemCollection first isVectorItem and: [vector isNil])				or:				[aMathItemCollection first isGeometricItem 					and: aMathItemCollection first isVectorItem not 					and: [mathItem isNil]]]! !!DrGTranslationBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 1/4/2006 06:40'!readyToBuild	^vector notNil and: [mathItem notNil]! !!DrGTranslationBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 3/5/2006 15:23'!mathItemClass: aMathItem	|className|	className := 'DrGTranslation', aMathItem basicType capitalized, 'Item'.	^(self class environment classNamed: className)! !!DrGTranslationBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 1/8/2006 19:47'!reset	super reset.	vector := mathItem := nil.! !!DrGTranslationBuilder commentStamp: '<historical>' prior: 0!curveItem : segment, vector, circle, arc!!DrGTranslationCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:42'!moveParent: aPoint	^false! !!DrGTranslationCircleItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[self center: parents first center + parents second direction.		self radius: parents first radius].! !!DrGTranslationCircleItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGTranslationLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:43'!moveParent: aPoint	^false! !!DrGTranslationLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/4/2006 06:56'!update	self translationUpdate! !!DrGTranslationLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGTranslationPointItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:29'!isConstrainedPointItem	^true! !!DrGTranslationPointItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:04'!nodeType	^#Translation! !!DrGTranslationPointItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[self point: parents first point + parents second direction].! !!DrGTranslationPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGTranslationPolygonItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update|translation|	self doesParentExist 	ifTrue:		[translation := parents second direction.		points := OrderedCollection new.		parents first points do: [:point |			points add: point + translation].		self computeLength].! !!DrGTranslationPolygonItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGTranslationRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGTranslationRayItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/4/2006 07:03'!update	self translationUpdate ! !!DrGTranslationRayItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGTranslationSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint	^false! !!DrGTranslationSegmentItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/4/2006 07:02'!update	self translationUpdate ! !!DrGTranslationSegmentItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 12:02'!nodeType	^#Translation! !!DrGValueArcLengthItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:14'!adaptiveDescriptiveName	^ 'This arc length %1' translated! !!DrGValueArcLengthItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:06'!nodeType	^#'arc_length'! !!DrGValueArcLengthItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue: 		[value := parents first length abs * parents first radius].! !!DrGValueBuilder methodsFor: 'private' stamp: 'HilaireFernandes 2/2/2006 14:04'!addItem: aMathItemCollection at: aPoint	super addItem: aMathItemCollection at: aPoint.	aMathItemCollection ifEmpty: [^self].	aMathItemCollection first isPointItem 		ifTrue: 			[pointA ifNil:				[pointA := aMathItemCollection first.				^self].			pointB ifNil:				[pointB := aMathItemCollection first.				^self]]		ifFalse: [curveItem := aMathItemCollection first]! !!DrGValueBuilder methodsFor: 'accessing' stamp: 'HilaireFernandes 8/3/2008 12:05'!arguments	(pointA notNil and: [curveItem notNil]) 		ifTrue: [^{pointA . curveItem. point}].	curveItem ifNotNil: [^{curveItem. point}].	pointB ifNotNil: [^{pointA . pointB. point}].	^{point}! !!DrGValueBuilder methodsFor: 'testing' stamp: 'CedrickBeler 4/23/2010 16:46'!isWanted: aMathItemCollection 	aMathItemCollection		ifEmpty: [^ true].	aMathItemCollection first isPointItem		ifTrue: [^ true].	((aMathItemCollection first isLineItem				or: [aMathItemCollection first isSegmentItem				or: [aMathItemCollection first isVectorItem				or: [aMathItemCollection first isCircleItem				or: [aMathItemCollection first isArcItem]]]])			and: [pointA isNil])		ifTrue: [^ true].	(pointA notNil			and: [aMathItemCollection first isLineItem					or: [aMathItemCollection first isCircleItem]])		ifTrue: [^ true].	^ false! !!DrGValueBuilder methodsFor: 'testing' stamp: 'HilaireFernandes 4/30/2010 22:24'!readyToBuild	^(point notNil 		and: [curveItem isNil] 		and: [pointA isNil				and: [pointB isNil]])		or: [pointB notNil			or: [curveItem notNil]]! !!DrGValueBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/16/2008 17:22'!mathItemClass	pointA		ifNotNil: [curveItem				ifNotNil: [curveItem isLineItem						ifTrue: [^ DrGValueDistancePointLineItem]]].	curveItem		ifNotNil: [curveItem isLineItem				ifTrue: [^ DrGValueLineSlopeItem].			curveItem isSegmentItem				ifTrue: [^ DrGValueSegmentLengthItem].			curveItem isCircleItem				ifTrue: [^ DrGValueCircleLengthItem].			curveItem isVectorItem				ifTrue: [^ DrGValueVectorNormItem].			curveItem isArcItem				ifTrue: [^ DrGValueArcLengthItem]].	pointB		ifNotNil: [^ DrGValueDistancePointsItem].	^ DrGFreeValueItem! !!DrGValueBuilder methodsFor: 'updating' stamp: 'HilaireFernandes 2/2/2006 14:00'!reset	super reset.	pointA := pointB := curveItem := nil! !!DrGValueCircleLengthItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 11:39'!adaptiveDescriptiveName	^ 'This circle perimeter %1' translated! !!DrGValueCircleLengthItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:16'!nodeType	^#'circle_perimeter'! !!DrGValueCircleLengthItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:35'!update	self doesParentExist ifTrue:		[value := parents first radius * DrGDirectionItem twoPi].! !!DrGValueCostume methodsFor: 'testing' stamp: 'HilaireFernandes 2/2/2006 11:38'!basicType	^#value! !!DrGValueCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 3/14/2006 15:25'!contents: aString	morph contents: aString! !!DrGValueCostume methodsFor: 'accessing' stamp: 'HilaireFernandes 1/28/2008 21:45'!textMorph: aString 	"We don't have label for ValueCostume"	^ mathItem name: aString! !!DrGValueCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 3/14/2006 15:29'!instantiateMorph	morph := DrGValueMorph new.	morph contents: self roundedValueString.	mathItem class = DrGFreeValueItem		ifTrue: [morph launchMiniEditor: ActiveHand lastEvent]! !!DrGValueCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/14/2006 15:26'!launchMiniEditor	morph launchMiniEditor: ActiveHand lastEvent! !!DrGValueCostume methodsFor: 'updating' stamp: 'HilaireFernandes 2/5/2006 12:36'!position	^(drawable worldToMorph: mathItem position)! !!DrGValueCostume methodsFor: 'updating' stamp: 'HilaireFernandes 1/31/2008 23:07'!redraw	(mathItem name isNil or: [mathItem name size = 0]) ifTrue:		 [self contents: self roundedValueString]		ifFalse: [self contents: (mathItem name, ' = ', self roundedValueString)].	morph  topLeft: self position.! !!DrGValueCostume methodsFor: 'updating' stamp: 'HilaireFernandes 8/24/2008 18:09'!roundedValueString	^ (mathItem valueItem isPoint			or: [mathItem valueItem isNumber])		ifTrue: [(mathItem valueItem roundTo: 0.01) asString]		ifFalse: [mathItem valueItem asString]! !!DrGValueCostume methodsFor: 'updating' stamp: 'HilaireFernandes 3/14/2006 15:30'!valueString	^mathItem valueItem asString! !!DrGValueCostume methodsFor: 'style' stamp: 'HilaireFernandes 3/14/2006 14:49'!styleClass	mathItem class = DrGFreeValueItem		ifTrue: [^DrGFreeValueCostumeStyle]		ifFalse: [^DrGValueCostumeStyle]! !!DrGValueCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 2/13/2006 10:39'!getMathItemValue	^mathItem valueItem! !!DrGValueCostume methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 1/26/2008 09:15'!setMathItemValue: aValue 	| freeValue |	freeValue := self mathItem.	freeValue class = DrGFreeValueItem		ifTrue: [freeValue valueItem: aValue.			self domain updateAllMathItems .			self redraw]! !!DrGValueCostumeStyle methodsFor: 'accessing' stamp: 'jlrr 9/29/2007 13:49'!rename|answer|	costume mathItem name 		ifNotNil:			[answer := FillInTheBlankMorph 				request: 'Rename this value' translated 				initialAnswer: costume mathItem name]		ifNil:			[answer := FillInTheBlankMorph 				request: 'Name this value' translated].	answer size = 0 ifTrue: [answer := nil].	costume mathItem name: answer.	costume redraw! !!DrGValueDistancePointLineItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 11:40'!adaptiveDescriptiveName	^ 'This point-line distance %1' translated! !!DrGValueDistancePointLineItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:17'!nodeType	^#'distance_pt_line'! !!DrGValueDistancePointLineItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!update	self doesParentExist ifTrue:		[value := ((parents first point - parents second origin) 					dotProduct: parents second direction normal) abs].! !!DrGValueDistancePointsItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 11:41'!adaptiveDescriptiveName	^ 'This distance between two points %1' translated! !!DrGValueDistancePointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:17'!nodeType	^# 'distance_2pts'! !!DrGValueDistancePointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!update	self doesParentExist ifTrue:		[value := parents first point dist: parents second point].! !!DrGValueItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:14'!adaptiveDescriptiveName	^ 'This value %1' translated! !!DrGValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/2/2006 11:18'!basicType	 ^#value! !!DrGValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 11:19'!parents: aCollection 	"last is the initial screen position of the value"	aCollection ifNil: 		[ parents := nil.		^ self ].	aCollection last isPoint 		ifTrue: [ parents := aCollection allButLast ]		ifFalse: [ parents := aCollection ]! !!DrGValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/2/2006 10:48'!position	^position! !!DrGValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/2/2006 10:47'!position: aPoint	position := aPoint! !!DrGValueItem methodsFor: 'accessing' stamp: 'HilaireFernandes 2/2/2006 10:49'!valueItem	^value! !!DrGValueItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 2/2/2006 11:59'!initialize	super initialize.	value := 0! !!DrGValueItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 8/3/2008 12:04'!initialize: theParents	super initialize: theParents.	self position: theParents last! !!DrGValueItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/2/2006 11:19'!isValueItem	^true! !!DrGValueItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint"Don't move my parent"	^false! !!DrGValueItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!move: aPoint	position := position + aPoint.! !!DrGValueItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 10:34'!nodeName	^'numeric'! !!DrGValueLineSlopeItem methodsFor: 'private' stamp: 'HilaireFernandes 1/16/2008 17:22'!adaptiveDescriptiveName	^ 'This line slope %1' translated! !!DrGValueLineSlopeItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:17'!nodeType	^#slope! !!DrGValueLineSlopeItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!update	|v|	self doesParentExist ifTrue:		[v := parents first direction.		v x= 0 ifTrue: [exist := false]		ifFalse: [value := v y / v x.]].! !!DrGValueMorph methodsFor: 'editing' stamp: 'HilaireFernandes 2/2/2006 15:04'!acceptContents	costume mathItem valueItem: contents asNumber! !!DrGValueMorph methodsFor: 'events-processing' stamp: 'HilaireFernandes 3/12/2006 18:54'!handleMouseDown: anEvent	^false! !!DrGValueMorph methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/9/2006 17:10'!isMorphCostume	^true! !!DrGValueMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'HilaireFernandes 2/13/2006 10:38'!getMathItemValue	^costume getMathItemValue! !!DrGValueMorph methodsFor: '*DrGeoII-Etoys-scripting' stamp: 'jlrr 11/25/2007 16:46'!setMathItemValue: aValue 	costume setMathItemValue: aValue! !!DrGValueMorph class methodsFor: '*DrGeoII-Etoys-flexiblevocabularies-scripting' stamp: 'HilaireFernandes 11/1/2009 10:21'!additionsToViewerCategoryDrGeo	^ #(drgeo ((slot value 'The math item value' Number readWrite Player getMathItemValue Player setMathItemValue:))) ! !!DrGValueSegmentLengthItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:14'!adaptiveDescriptiveName	^ 'This segment length %1' translated! !!DrGValueSegmentLengthItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:18'!nodeType	^#'segment_length'! !!DrGValueSegmentLengthItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!update	self doesParentExist ifTrue:		[value := parents first direction r].! !!DrGValueVectorNormItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:15'!adaptiveDescriptiveName	^ 'This Vector''s norm %1' translated! !!DrGValueVectorNormItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 11:18'!nodeType	^#'vector_norm'! !!DrGVector2PointsItem methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/2/2006 09:43'!initialize: theParents	super initialize: theParents.	self origin: (theParents first point).! !!DrGVector2PointsItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:22'!nodeType	^#'2pts'! !!DrGVector2PointsItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/17/2006 16:36'!parentQty	^2! !!DrGVector2PointsItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!update	self doesParentExist ifTrue:		[self direction: (parents at: 2) point - (parents at: 1) point].! !!DrGVectorBuilder methodsFor: 'constant' stamp: 'HilaireFernandes 1/24/2006 23:01'!mathItemClass	^DrGVector2PointsItem! !!DrGVectorCostume methodsFor: 'testing' stamp: 'HilaireFernandes 1/2/2006 09:12'!basicType	^#vector! !!DrGVectorCostume methodsFor: 'initialize-release' stamp: 'HilaireFernandes 1/24/2006 23:03'!instantiateMorph	morph := DrGVectorMorph new! !!DrGVectorCostume methodsFor: 'style' stamp: 'HilaireFernandes 1/24/2006 23:02'!styleClass	^DrGCurveCostumeStyle! !!DrGVectorItem methodsFor: 'private' stamp: 'jlrr 9/30/2007 15:07'!adaptiveDescriptiveName	^ 'This vector %1' translated! !!DrGVectorItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/2/2006 09:06'!basicType	^#vector! !!DrGVectorItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/13/2006 15:09'!isCurveItem	^false! !!DrGVectorItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/3/2006 16:31'!isGeometricItem	^true! !!DrGVectorItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/28/2008 16:36'!isSegmentItem	^false! !!DrGVectorItem methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2006 09:39'!isVectorItem	^true! !!DrGVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 3/25/2006 15:44'!moveParent: aPoint"We don't want to move the parents, as the whole vector representation can be move all arround"	^false! !!DrGVectorItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 10:36'!move: aPoint	origin := origin + aPoint.! !!DrGVectorItem methodsFor: 'xml writing' stamp: 'HilaireFernandes 1/20/2008 09:17'!nodeName	^'vector'! !!DrGVectorMorph methodsFor: 'accessing' stamp: 'HilaireFernandes 1/28/2008 22:40'!from: startPoint to: endPoint	"We don't calculate clipped vector, otherwise the arrow may be misplaced when part of the vector extremity is outisde the drawing area'"	vertices at: 1 put: startPoint asIntegerPoint .	vertices at: 2 put: endPoint  asIntegerPoint.	self computeBounds! !!DrGVectorMorph methodsFor: 'initializing' stamp: 'HilaireFernandes 1/2/2006 09:49'!initialize	super initialize.	arrows := #forward.! !!DrGViewerTool methodsFor: 'updating' stamp: 'HilaireFernandes 7/20/2008 09:59'!reset	super reset.	self switchState: DrGViewerToolState! !!DrGViewerTool commentStamp: '<historical>' prior: 0!A tool to select an item to open its viewer!!DrGViewerToolState methodsFor: 'handling' stamp: 'HilaireFernandes 4/2/2006 11:10'!handleChoice: aCostumeCollection	aCostumeCollection 		ifNotEmpty: 			[self context presenter 				openViewerForCostume: aCostumeCollection first].	self context reset! !!DrGWizard methodsFor: 'accessing' stamp: 'HilaireFernandes 7/17/2008 15:37'!addPage: aPage	pages add: aPage.	currentPage ifNil: 		[self addMorph: aPage.		currentPage := 1]! !!DrGWizard methodsFor: 'accessing' stamp: 'HilaireFernandes 8/26/2008 17:52'!goPage: integer	(self findA: DrGWizardPage) ifNotNilDo: 		[:page | self removeMorph: page].	self addMorph: (self pageAt: integer).	self triggerEvent: #page with: integer.! !!DrGWizard methodsFor: 'accessing' stamp: 'HilaireFernandes 7/20/2008 12:10'!pageAt: integer	^ pages at: integer ! !!DrGWizard methodsFor: 'callback' stamp: 'HilaireFernandes 7/20/2008 10:10'!apply	self triggerEvent: #apply! !!DrGWizard methodsFor: 'callback' stamp: 'HilaireFernandes 7/20/2008 10:10'!cancel	self triggerEvent: #cancel! !!DrGWizard methodsFor: 'callback' stamp: 'HilaireFernandes 7/20/2008 10:09'!next	currentPage < pages size ifFalse: [^ self].	self goPage: (currentPage := currentPage + 1)! !!DrGWizard methodsFor: 'callback' stamp: 'HilaireFernandes 7/20/2008 10:10'!previous	currentPage > 1 ifFalse: [^self].	self goPage: (currentPage := currentPage - 1)! !!DrGWizard methodsFor: 'meta-actions' stamp: 'HilaireFernandes 7/28/2008 10:07'!delete	super delete.	pages do: [:page | page delete].! !!DrGWizard methodsFor: 'initialization' stamp: 'HilaireFernandes 7/25/2008 13:41'!initialize	super initialize.	self color: Color white.	self borderColor: Color black.	self borderWidth: 1.	self extent: 200@150.	self layoutPolicy: TableLayout new.	self vResizing: #spaceFill.	self hResizing: #spaceFill.	pages := OrderedCollection new.! !!DrGWizard commentStamp: 'HilaireFernandes 7/20/2008 10:58' prior: 0!A DrGMacroMorph is an abstractact dialog to build and play macro.It emits event when  - the user changes the page with the next and previous buttons - the user press apply and cancelInstance Variables	pages:		dictionary of pages Morphpages	- xxxxx!!DrGWizard class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/20/2008 19:51'!example	"DrGWizard example openInWorld"	| wizard |	wizard := self new.	wizard		addPage: ((DrGWizardPage firstPage: 'Step 1/3') model: wizard);		addPage: ((DrGWizardPage standardPage: 'Step 2/3') model: wizard;			content: 'We can change content :	1. One	2. Two	3. Three' asTextMorph);		addPage: ((DrGWizardPage applyPage: 'Step 3/3') model: wizard).	^ wizard! !!DrGWizardMacroBuild methodsFor: 'accessing' stamp: 'HilaireFernandes 7/22/2008 13:19'!builder: aBuilder	builder := aBuilder ! !!DrGWizardMacroBuild methodsFor: 'meta-actions' stamp: 'HilaireFernandes 7/28/2008 10:07'!delete	super delete.	builder := nil.! !!DrGWizardMacroBuild methodsFor: 'initialization' stamp: 'HilaireFernandes 7/28/2008 11:03'!firstPage	^ (DrGWizardPage firstPage: 'Build a macro-construction' translated) 				model: self;				content: 'To build a macro-construction, 1. First select the input paramaters, 2. Next select the output parameters, 3. Next chose a name and a description, 4. Last apply the selection.' translated asTextMorph lock! !!DrGWizardMacroBuild methodsFor: 'initialization' stamp: 'HilaireFernandes 7/28/2008 11:02'!fourthPage	| page morph |	page := Morph new color: Color white.	page		layoutPolicy: TableLayout new;		listDirection: #bottomToTop;		cellPositioning: #topLeft;		layoutInset: 0@3.	page addMorph: 'Title:' translated asStringMorph.	morph := PluggableTextMorph 		on: builder text: #title accept: #title:.	morph acceptTextInModel.	morph		acceptOnCR: true;		hResizing: #spaceFill;		height: 16;		hideScrollBarsIndefinitely.	page addMorph: morph.	page addMorph: 'Description:' translated asStringMorph.	morph := PluggableTextMorph 		on: builder text: #description accept: #description:.	morph		hResizing: #spaceFill;		vResizing: #spaceFill.	page addMorph: morph.	morph acceptTextInModel.	^(DrGWizardPage applyPage: 'Give a name and a description' translated) 				model: self;				content: page! !!DrGWizardMacroBuild methodsFor: 'initialization' stamp: 'HilaireFernandes 9/5/2008 16:59'!initialize	super initialize.	self 		addPage: self firstPage;		addPage: self secondPage;		addPage: self thirdPage;		addPage: self fourthPage.	self extent: 400@250		! !!DrGWizardMacroBuild methodsFor: 'initialization' stamp: 'HilaireFernandes 7/28/2008 11:03'!secondPage	| list |	list := PluggableListMorph 		on: builder		list: #inputName 		selected: nil 		changeSelected: nil.	^ (DrGWizardPage new standardPage: 'Select input parameters' translated) 		model: self;		content: list! !!DrGWizardMacroBuild methodsFor: 'initialization' stamp: 'HilaireFernandes 7/28/2008 11:03'!thirdPage	| list |	list := PluggableListMorph 		on: builder 		list: #outputName		selected: nil 		changeSelected: nil.	^ (DrGWizardPage new standardPage: 'Select output parameters' translated) 		model: self;		content: list! !!DrGWizardMacroBuild methodsFor: 'testing' stamp: 'HilaireFernandes 7/20/2008 18:05'!isInputPage	^ currentPage  = 2! !!DrGWizardMacroBuild methodsFor: 'testing' stamp: 'HilaireFernandes 7/20/2008 18:05'!isOutputPage	^ currentPage  = 3! !!DrGWizardMacroBuild class methodsFor: 'instance creation' stamp: 'HilaireFernandes 7/25/2008 10:06'!builder: aBuilder 	^ self basicNew		builder: aBuilder;		initialize ! !!DrGWizardMacroPlay methodsFor: 'accessing' stamp: 'HilaireFernandes 7/28/2008 12:19'!builder: aBuilder	builder := aBuilder! !!DrGWizardMacroPlay methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 22:04'!macroList	^ macroFactories titles! !!DrGWizardMacroPlay methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 22:04'!selectedMacro	^ macroFactories indexOf: builder selectedMacro! !!DrGWizardMacroPlay methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 22:04'!selectedMacro: anIndex	builder selectedMacro: (macroFactories at: anIndex).	self changed: #selectedMacro.	builder changed: #description.! !!DrGWizardMacroPlay methodsFor: 'meta-actions' stamp: 'HilaireFernandes 7/28/2008 10:48'!delete	super delete.	builder := nil.! !!DrGWizardMacroPlay methodsFor: 'initialization' stamp: 'HilaireFernandes 8/4/2008 10:10'!firstPage	^ (DrGWizardPage firstPage: 'Execute a macro-construction' translated) 				model: self;				content: 'To execute a macro-construction, 1. First select a macro-construction from the list, 2. Select items on the figure. Only items relevant to the selected macro-construction are selectable. Once enought items are selected, the macro is automaticly executed. To start press the ''next'' button.' translated asTextMorph lock! !!DrGWizardMacroPlay methodsFor: 'initialization' stamp: 'HilaireFernandes 9/5/2008 16:59'!initialize	super initialize.	macroFactories := DrGMacroFactories new.	self		addPage: self firstPage;		addPage: self secondPage.	self extent: 400@250.! !!DrGWizardMacroPlay methodsFor: 'initialization' stamp: 'HilaireFernandes 7/29/2008 10:32'!secondPage	|list page morph |	page := Morph new color: Color white.	page		layoutPolicy: TableLayout new;		listDirection: #bottomToTop;		cellPositioning: #topLeft;		layoutInset: 0@3.	page addMorph: 'Title:' translated asStringMorph.	list := PluggableListMorph		on: self		list: #macroList		selected: #selectedMacro		changeSelected: #selectedMacro:.	list hResizing: #spaceFill;		height: 50.	page addMorph: list.	page addMorph: 'Description:' translated asStringMorph.	morph := PluggableTextMorph 		on: builder text: #description accept: #description:.	morph		hResizing: #spaceFill;		vResizing: #spaceFill.	page addMorph: morph.	morph acceptTextInModel.	^(DrGWizardPage lastPage: 'Select a macro-construction then the figure items' translated) 		model: self;		content: page! !!DrGWizardMacroPlay methodsFor: 'testing' stamp: 'HilaireFernandes 7/28/2008 11:10'!isSelectPage	^ currentPage = 2! !!DrGWizardMacroPlay class methodsFor: 'instance creation' stamp: 'HilaireFernandes 7/28/2008 11:59'!builder: aBuilder 	^ self basicNew		builder: aBuilder;		initialize ! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 7/17/2008 12:50'!addButton: btn	buttons addMorphBack: btn! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 8/22/2008 16:39'!applyBtn	nextOrApply := SimpleButtonMorph new 		target: self;		color: Color lightGreen;		borderWidth:  1;		borderColor: #raised;		label: 'apply' translated;		actionSelector: #apply.	^nextOrApply ! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 7/20/2008 18:59'!buttons	buttons := Morph new.	buttons color: Color white.	buttons layoutPolicy: TableLayout new;		listDirection: #leftToRight;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		cellInset: 5;		listCentering: #bottomRight.	^ buttons! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 8/22/2008 16:40'!cancelBtn	cancel := SimpleButtonMorph new		target: self;		color: Color lightRed;		borderWidth:  1;		borderColor: #raised;		label: 'cancel' translated;		actionSelector: #cancel.	^ cancel! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 7/17/2008 16:18'!locked: button	button color: button color muchLighter.	button lock.	^ button! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 8/22/2008 16:41'!nextBtn	nextOrApply := SimpleButtonMorph new		target: self;		color:  Color lightGreen;		borderWidth: 1;		borderColor: #raised;		label: 'next' translated;		actionSelector: #next.	^ nextOrApply! !!DrGWizardPage methodsFor: 'button' stamp: 'HilaireFernandes 8/22/2008 16:41'!previousBtn	previous := SimpleButtonMorph new		target: self;		color: Color lightGreen;		borderWidth: 1;		borderColor: #raised;		label: 'previous' translated;		actionSelector: #previous.	^ previous! !!DrGWizardPage methodsFor: 'callback' stamp: 'HilaireFernandes 7/17/2008 16:39'!apply	model apply! !!DrGWizardPage methodsFor: 'callback' stamp: 'HilaireFernandes 7/17/2008 16:39'!cancel	model cancel! !!DrGWizardPage methodsFor: 'callback' stamp: 'HilaireFernandes 7/17/2008 16:39'!next	model next! !!DrGWizardPage methodsFor: 'callback' stamp: 'HilaireFernandes 7/17/2008 16:39'!previous	model previous! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 7/17/2008 16:57'!applyPage: title	self title: title.	self 		addButton: self cancelBtn;		addButton:  self previousBtn;		addButton: self applyBtn.! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 7/17/2008 16:57'!firstPage: title	self title: title.	self 		addButton: self cancelBtn;		addButton: (self locked: self previousBtn);		addButton: self nextBtn! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 8/4/2008 10:24'!initialize	super initialize.	self color: Color white.	self clipSubmorphs: true.	self layoutPolicy: TableLayout new;		listDirection: #topToBottom;		hResizing: #spaceFill;		vResizing:  #spaceFill;		layoutInset: 3.	self addMorph: self buttons.	self defaultContent.! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 7/17/2008 16:58'!lastPage: title	self title: title.	self		addButton: self cancelBtn;		addButton: self previousBtn;		addButton: (self locked: self nextBtn)! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 7/17/2008 16:58'!standardPage: title	self title: title.	self 		addButton: self cancelBtn;		addButton: self previousBtn;		addButton: self nextBtn! !!DrGWizardPage methodsFor: 'initialization' stamp: 'HilaireFernandes 7/17/2008 16:57'!title: title	self addMorph: title asTextMorph lock.! !!DrGWizardPage methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:27'!content: aMorph	aMorph 		vResizing: #spaceFill;		hResizing: #spaceFill.	content 		ifNotNil: [self replaceSubmorph: content by: aMorph]		ifNil: [self addMorph: aMorph].	content := aMorph.	content isTextMorph ifTrue: 		[content wrapFlag: true.]! !!DrGWizardPage methodsFor: 'accessing' stamp: 'HilaireFernandes 8/22/2008 16:41'!defaultContent	self content: (Morph new		color:  (Color r: 0.85 g: 0.9 b: 1.0)).! !!DrGWizardPage methodsFor: 'accessing' stamp: 'HilaireFernandes 7/17/2008 16:39'!model: aMacroMorph 	model := aMacroMorph! !!DrGWizardPage methodsFor: 'submorphs-add/remove' stamp: 'HilaireFernandes 7/28/2008 10:01'!delete	super delete.	model := nil.	content release; delete! !!DrGWizardPage commentStamp: 'HilaireFernandes 7/20/2008 19:44' prior: 0!A DrGWizardPage is a page morph to add in a wizard dialog..Content can be added with the #content: messageAlternatively, it can be subclassed this class, to do sooverride intialiaze with super call and at the end of initialize use #content: messageInstance Variables	buttons:		<Object>	cancel:		<Object>	content:		<Object>	model:		<Object>	nextOrApply:		<Object>	previous:		<Object>buttons	- xxxxxcancel	- xxxxxcontent	- xxxxxmodel	- xxxxxnextOrApply	- xxxxxprevious	- xxxxx!!DrGWizardPage class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/17/2008 11:25'!applyPage	"page with cancel button, previous button, and apply button"! !!DrGWizardPage class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/17/2008 16:27'!applyPage: title	"page with cancel button, previous button, and apply button"		^ self new applyPage: title! !!DrGWizardPage class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/17/2008 16:24'!firstPage: title	"page with cancel button, gray and locked previous button, and next button"	^ self new firstPage: title! !!DrGWizardPage class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 7/17/2008 16:04'!lastPage: title	"page with cancel button, previous button, and gray and locked next button"	^self new lastPage: title! !!DrGWizardPage class methodsFor: 'instance creation' stamp: 'HilaireFernandes 7/17/2008 13:12'!standardPage: title	"page with cancel, previous, next buttons"	^ self new standardPage: title.! !!DrGWizardScript methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 8/4/2008 11:36'!goPage: integer	super goPage: integer.	self changed: #methodList! !!DrGWizardScript methodsFor: 'accessing' stamp: 'HilaireFernandes 8/2/2008 20:46'!builder: anObject	builder := anObject ! !!DrGWizardScript methodsFor: 'accessing' stamp: 'HilaireFernandes 9/27/2008 18:47'!instanceList	^ instanceList		ifNil: [instanceList := DrGeoScripts instance list]! !!DrGWizardScript methodsFor: 'accessing' stamp: 'HilaireFernandes 9/27/2008 18:47'!methodList	^ methodList ifNil: [methodList := DrGeoScripts instance selectors]! !!DrGWizardScript methodsFor: 'accessing' stamp: 'HilaireFernandes 8/4/2008 10:07'!selectedMethod	^ builder selectedMethod 		ifNil: [0]		ifNotNil: [self methodList indexOf: builder selectedMethod selector asString]! !!DrGWizardScript methodsFor: 'accessing' stamp: 'HilaireFernandes 9/27/2008 18:48'!selectedMethod: anIndex 	builder		selectedMethod: (self instanceList				at: anIndex				ifAbsent: []).	self changed: #selectedMethod.	builder changed: #description! !!DrGWizardScript methodsFor: 'meta-actions' stamp: 'HilaireFernandes 8/2/2008 21:38'!delete	super delete.	builder := nil! !!DrGWizardScript methodsFor: 'initialization' stamp: 'HilaireFernandes 8/4/2008 10:27'!firstPage	^ (DrGWizardPage firstPage: 'Use a script in the figure' translated) 				model: self;				content: 'To use a script, 1. First select a script from the list, 2. Select items on the figure. Once enought items are selected, the script is inserted in the figure close to the latest selected item. To start press the ''next'' button.' translated asTextMorph lock! !!DrGWizardScript methodsFor: 'initialization' stamp: 'HilaireFernandes 9/5/2008 16:58'!initialize	super initialize.	self 		addPage: self firstPage;		addPage: self secondPage.	self extent: 400@250! !!DrGWizardScript methodsFor: 'initialization' stamp: 'HilaireFernandes 9/27/2008 18:48'!secondPage	| list page morph |	page := Morph new color: Color white.	page layoutPolicy: TableLayout new;		 listDirection: #bottomToTop;		 cellPositioning: #topLeft;		 layoutInset: 0 @ 3.	page addMorph: 'Script name:' translated asStringMorph.	list := PluggableListMorph				on: self				list: #methodList				selected: #selectedMethod				changeSelected: #selectedMethod:.	list hResizing: #spaceFill;		 height: 80.	page addMorph: list.	page addMorph: 'Description:' translated asStringMorph.	morph := PluggableTextMorph				on: builder				text: #description				accept: #description:.	morph hResizing: #spaceFill;		 vResizing: #spaceFill.	page addMorph: morph.	morph acceptTextInModel.	^ (DrGWizardPage lastPage: 'Select a script then the figure items' translated) model: self;		 content: page! !!DrGWizardScript methodsFor: 'testing' stamp: 'HilaireFernandes 8/2/2008 21:40'!isSelectPage	^ currentPage = 2! !!DrGWizardScript class methodsFor: 'instance creation' stamp: 'HilaireFernandes 8/2/2008 21:40'!builder: aBuilder 	^ self basicNew		builder: aBuilder;		initialize ! !!DrGWrappedCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 14:14'!dashed	costume style dash: #dash! !!DrGWrappedCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 14:14'!dotted	costume style dash: #dot! !!DrGWrappedCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:46'!large	costume style thickness: #large! !!DrGWrappedCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 14:15'!plain	costume style dash: #plain! !!DrGWrappedCurve methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:46'!small	costume style thickness: #small! !!DrGWrappedItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 13:58'!color: aColor	costume style color: aColor! !!DrGWrappedItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:48'!hide	costume style isHidden: true.	costume forceVisible: false.! !!DrGWrappedItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 13:59'!name: aString	costume  textMorph: aString ! !!DrGWrappedItem methodsFor: 'updating' stamp: 'HilaireFernandes 1/24/2008 11:12'!show	costume forceVisible: true.	costume style isHidden: false! !!DrGWrappedItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2008 14:04'!costume: aCostume	costume := aCostume ! !!DrGWrappedItem methodsFor: 'accessing' stamp: 'HilaireFernandes 1/22/2008 14:20'!mathItem	^ costume mathItem ! !!DrGWrappedItem commentStamp: 'HilaireFernandes 1/22/2008 12:35' prior: 0!A class to encapsulate costume for user friendly use when doing Smalltalk figure!!DrGWrappedItem class methodsFor: 'as yet unclassified' stamp: 'HilaireFernandes 1/22/2008 14:03'!wrap: aCostume 	^ self new costume: aCostume! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 22:06'!cross	costume style shape: #cross! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:45'!large	costume style thickness: #large! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:46'!medium	costume style thickness: #medium! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 22:06'!round	costume style shape: #round! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 15:46'!small	costume style thickness: #small! !!DrGWrappedPoint methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 22:06'!square	costume style shape: #square! !!DrGWrappedValue methodsFor: 'updating' stamp: 'HilaireFernandes 1/22/2008 14:18'!name: aString 	costume mathItem name: aString.	costume redraw! !!Encoder methodsFor: 'initialize-release' stamp: 'eem 3/12/2009 16:13'!initScopeAndLiteralTables	scopeTable := StdVariables copy.	litSet := StdLiterals copy.	"comments can be left hanging on nodes from previous compilations.	 probably better than this hack fix is to create the nodes afresh on each compilation."	scopeTable do:		[:varNode| varNode comment: nil].	litSet do:		[:varNode| varNode comment: nil].	selectorSet := StdSelectors copy.	litIndSet := Dictionary new: 16.	literalStream := WriteStream on: (Array new: 32).	addedSelectorAndMethodClassLiterals := false! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/27/2009 09:25'!environment	"Answer the environment of the current compilation context,	 be it in a class or global (e.g. a workspace)"	^class == nil		ifTrue: [Smalltalk]		ifFalse: [class environment]! !!Encoder methodsFor: 'encoding' stamp: 'bf 4/12/2010 14:41'!undeclared: name	| sym |	(requestor notNil and: [requestor interactive]) ifTrue: [		^ self notify: 'Undeclared'].	Transcript show: ' (' , name , ' is Undeclared) '.	sym _ name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!Encoder methodsFor: 'temps' stamp: 'eem 12/1/2008 12:07'!fixTemp: name	| node |	node := scopeTable at: name ifAbsent: [].	node class ~~ TempVariableNode ifTrue:		[self error: 'can only fix a floating temp var'].	node index: nTemps.	nTemps := nTemps + 1.	^node! !!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:13'!floatTemp: node	(node ~~ (scopeTable at: node name ifAbsent: [])	or: [node class ~~ TempVariableNode	or: [node code ~= (node code: nTemps - 1 type: LdTempType)]]) ifTrue:		[self error: 'can only float the last allocated temp var'].	nTemps := nTemps - 1! !!Encoder methodsFor: 'results' stamp: 'bgf 3/12/2009 17:42'!allLiterals	((literalStream isKindOf: WriteStream)	 and: [ (addedSelectorAndMethodClassLiterals ifNil: [ false ]) not]) ifTrue:		[addedSelectorAndMethodClassLiterals := true.		 self litIndex: nil.		 self litIndex: self associationForClass].	^literalStream contents	"The funky ifNil: [false], even though the init method initializes addedSAMCL,	 is simply so that Monticello can load and compile this update without	 killing the encoder that is compiling that update itself..."! !!Encoder methodsFor: 'results' stamp: 'eem 5/27/2009 09:25'!associationForClass	| assoc |	assoc := self environment associationAt: class name ifAbsent: [nil].	^assoc value == class		ifTrue: [assoc]		ifFalse: [Association new value: class]! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'bf 9/14/2010 15:24'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	envelope updateSelector = #ratio: ifTrue:		[menu add: 'choose denominator...' translated action: #chooseDenominator:].	menu add: 'adjust scale...' translated action: #adjustScale:.	menu addLine.	menu add: 'get sound from lib' translated action: #chooseSound:.	menu add: 'put sound in lib' translated action: #saveSound:.	menu add: 'read sound from disk...' translated action: #readFromDisk:.	menu add: 'save sound on disk...' translated action: #saveToDisk:.	menu add: 'save library on disk...' translated action: #saveLibToDisk:.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'sw 8/12/2009 11:43'!rebuild	"Rebuild the receiver from scratch."	| bottomButtons header toAdd |	self removeAllMorphs.	header := self addARow: {		self lockedString: 'Please describe this project' translated.	}.	header color: ScriptingSystem baseColor.	self addARow: {		self lockedString: 'Project Name' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self expandedFormat ifTrue: [		self fieldToDetailsMappings do: [ :each |			toAdd := (each size < 5 or: [each fifth = #text])				ifTrue:					[self genericTextFieldNamed: each first]				ifFalse:					[self popUpEntryNamed: each first menuTitle: each third].			self addARow: {				self lockedString: each third translated.				self inAColumnForText: {toAdd height: each fourth}			}.		].	].	bottomButtons _ self expandedFormat ifTrue: [		{			self okButton.			self cancelButton.		}	] ifFalse: [		{			self okButton.			self expandButton.			self cancelButton.		}	].	self addARow: bottomButtons.	self fillInDetails.! !!EToyProjectDetailsMorph methodsFor: 'project details' stamp: 'yo 9/11/2009 19:53'!copyOutDetails	"Prepare a new Dictionary holding project-info details as noted in the dialog."	| newDetails elements item user |	newDetails := Dictionary new.	self fieldToDetailsMappings do: [ :each |		namedFields at: each first ifPresent: [ :field |				(#('age' 'subject' 'region') includes: each first)					ifFalse:							[newDetails at: each second put: field contents string]						ifTrue:							[elements := self choicesFor: each first.  "triplet"							item := elements detect: [:el | el third = field contents string translated] ifNone: [nil].							item ifNotNil:								[newDetails at: each second put: item first]]]].	namedFields at: 'projectname' ifPresent: [ :field |		newDetails at: 'projectname' put: field contents string withBlanksTrimmed].	namedFields		at: 'author'		ifPresent: [:field | 			user := field contents string withBlanksTrimmed.			newDetails at: 'projectauthor' put: user.			user isEmpty				ifTrue: [user := nil].			theProject				ifNotNil: [theProject forgetExistingURL]].	^ newDetails! !!EToyProjectDetailsMorph methodsFor: 'project details' stamp: 'sw 9/10/2009 11:00'!fieldToDetailsMappings	"Answer an array describing, top to bottom, the details of each element.		Each element is a tuple consisting of:			1.	field name (internal)			2.	key in the project-details dictionary			3.	text (english version) to be shown in the entry's label at left.			4. vertical space to allow			5. entry type: (if missing, text is implied)				#text --> editable text field				#popUp --> pop-up of choices"	^{		{#description. 'projectdescription'. 'Description' translatedNoop. 100}. 		{#author. 'projectauthor'. 'Author' translatedNoop. 20}.		{#keywords. 'projectkeywords'. 'Tags' translatedNoop. 20}.		{#subject.  'projectcategory'.  'Subject' translatedNoop.  20.  #popUp}.		{#age.		'projectage'.	'Target Age' translatedNoop.  20.  #popUp}.		{#region.		'projectregion'.	'Region' translatedNoop.  20.  #popUp}.		}! !!EToyProjectDetailsMorph methodsFor: 'project details' stamp: 'sw 8/8/2009 03:38'!fillInDetails	"Given that the receiver's namedFields is already set up, give each such field its appropriate initial value."	| elements item |	theProject ifNotNil:		[namedFields at: 'projectname' ifPresent:			[:field | field contentsWrapped: theProject name]].	projectDetails ifNotNil:		[self fieldToDetailsMappings do: [ :tuple |			namedFields at: tuple first ifPresent: [ :field |				projectDetails at: tuple second ifPresent: [ :data |					elements := self choicesFor: tuple first.					elements						ifNil:							[field contentsWrapped: data]						ifNotNil:							[item := elements detect: [:el | el first = data] ifNone: [nil].							item ifNotNil:								[field contentsWrapped: item third translated]							ifNil:								[field contentsWrapped: '(none)' translated]]]]]]! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'bf 9/16/2009 19:01'!choicesFor: aSymbol	"Answer the list of choices to offer for the given symbol, which will be subject, age, or region.  Answer nil if the symbol provided is one without enumerated choices."		aSymbol = #subject ifTrue:		[^ self class subjectTriplets].	aSymbol = #age ifTrue:		[^ self class ageTriplets].	aSymbol = #region ifTrue:		[^ self class regionTriplets].	^ nil! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'sw 9/28/2009 15:13'!doOK	"User hit the ok button in the project-info dialog.  Store the updated project-info back in the project. Call the message-send residing in the receiver's actionBlock to carry out any subsequent desired task.  Note that this method sets the 'arguments' of the message-send in the actionBlock"	| args actionSelector  |	self validateTheProjectName ifFalse: [^false].	projectDetails := self copyOutDetails.	theProject acceptProjectDetails: projectDetails.  "Make sure project & world feel the changes"			actionBlock isMessageSend "new way -- hopefully all cases"		ifTrue:  "please excuse this ugly, non-modular code..."			[actionSelector := actionBlock selector.			args := (actionSelector = #handUserSorterMorphForProjectNamed:) 				ifTrue:					[{theProject name}]				ifFalse:					[actionSelector numArgs = 0						ifTrue:							[nil]						ifFalse:							[Array with: projectDetails]].			actionBlock arguments: args.			actionBlock value]		ifFalse:  "Old way, with actionBlock actually a block of one argument.  This should no longer occur."			[actionBlock value: projectDetails].	self delete! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'sw 9/10/2009 10:59'!doPopUp: aSymbol event: anEvent for: aTextMorph	"The user clicked on a pop-up field in the project-info dialog.  Put up the pop-up of choices."	| aMenu aTitle |	aMenu := MenuMorph new defaultTarget: self.	aTitle := aTextMorph valueOfProperty: #menuTitle.	aTitle ifNotNil:		[aMenu addTitle: aTitle translated].	aMenu add: '(none)' translated target: self selector: #setInfoField:to: argumentList: {aSymbol asString. '(none)'}.	aMenu addLine.	(self choicesFor: aSymbol) do:		[:aChoice |			aMenu add: aChoice third translated target: self selector: #setInfoField:to: argumentList: {aSymbol. aChoice first}].	aMenu popUpInWorld! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'sw 9/10/2009 10:59'!popUpEntryNamed: aString	"Answer a text morph that will serve as a pop-up"	| newField |	newField := StaticTextMorph new beAllFont: self myFont;				 extent: 400 @ 20;				 contentsWrapped: '(none)' translated.	namedFields at: aString put: newField.	newField on: #click send: #doPopUp:event:for: to: self withValue: aString.	^ newField! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'sw 9/10/2009 11:00'!popUpEntryNamed: aString menuTitle: titleInEnglish	"Answer a text morph that will serve as a pop-up.  The first parameter is the key in the named-fields dictionary, the second is the title (in english) to give to the menu."	| newField |	newField := StaticTextMorph new beAllFont: self myFont;				 extent: 400 @ 20;				 contentsWrapped: '(none)' translated.	newField setProperty: #menuTitle toValue: titleInEnglish.	namedFields at: aString put: newField.	newField on: #click send: #doPopUp:event:for: to: self withValue: aString.	^ newField! !!EToyProjectDetailsMorph methodsFor: 'utilities' stamp: 'sw 8/8/2009 03:40'!setInfoField: aFieldName to: aValue	"Install a value into an info field of the dialog.  Textual fields are filled literally, but enumerated fields (subject, region, etc.) are represented by codes which get mapped into (translated) text to display."	| newValue choices |	newValue := aValue.	choices := self choicesFor: aFieldName.	choices ifNotNil:  "i.e. one of the fields with enumerated values"		[(choices detect: [:c | c first = aValue] ifNone: [nil]) ifNotNilDo:			[:item | newValue := item third translated]].	(namedFields at: aFieldName) contentsWrapped: newValue	! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 19:57'!cachedTripletsFor: aCategory	"Load triplets from file, e.g. '.ageCatList-de.csv' for the 'age' category"	| file  |	[		file := FileStream readOnlyFileNamed: (self tripletsFileNameFor: aCategory).		[^self tripletsFrom: file contentsOfEntireFile] ensure: [file close].	] ifError: [].	^nil! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 19:43'!tripletsFileNameFor: aCategory	"self tripletsFileNameFor: #age"	^ '.', aCategory, 'CatList-', Locale current localeID printString, '.csv'! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 19:54'!tripletsFrom: csvString	| result |	[result := (self linesIn: (csvString copyReplaceAll: String lf with: String cr))		collect: [:l | self csvLineQuotedDecodedFor: l]	] on: Error do: [:ex | ^ nil].	(self validateCategoryTriplets: result) ifFalse:  [^ nil].	^result.! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 19:43'!tripletsUrlFor: aCategory	"self tripletsUrlFor: #age"	^'http://squeakland.org/', aCategory, 'CatList?lang=', Locale current localeID printString! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/17/2009 21:57'!updateTripletsFor: aCategory	"Fetch the age-range, subject, or region triplet files from the web site and cache them locally."	| contents triplets file filename |	contents := (HTTPSocket httpGet: (self tripletsUrlFor: aCategory) args: #() user: '' passwd: '') contents.	triplets := self tripletsFrom: contents.	triplets ifNotNil: [		self useTriplets: triplets for: aCategory.		filename := self tripletsFileNameFor: aCategory.		file := FileStream fileNamed: filename.		[file truncate; nextPutAll: contents] ensure: [file close].	].	! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 22:49'!updateTripletsFromWebSite	"Attempt to update the age-range, subject, and region triplets cache on file by looking for the latest versions on the web site."	#(age subject region) do: [:cat |		self updateTripletsFor: cat]! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'bf 9/16/2009 23:24'!updateTripletsFromWebSiteInBackground	[		[self updateTripletsFromWebSite] ifError: []	] forkAt: Processor userBackgroundPriority named: 'Etoys category updater'! !!EToyProjectDetailsMorph class methodsFor: 'classification information' stamp: 'sw 9/14/2009 12:59'!validateCategoryTriplets: aList	"The input is a tuple obtained by extracting lines from a string obtained from the squeakland web site.  Answer true if the tuple passes the smoke-test for category triplets."		(aList isNil or: [aList size < 2]) ifTrue: [^ false].	aList do:		[:element |			(element isCollection not or:  [element size < 3]) ifTrue: [^ false]].	^ true"self validateCategoryTriplets:  RegionTriplets"! !!EToyProjectDetailsMorph class methodsFor: 'utilities' stamp: 'sw 8/7/2009 14:53'!csvLineQuotedDecodedFor: aString	"Given that the string provided consists of items delimited by double-quotes and separated by commas, answer an array containing the individual items with quotes removed."	| openQuoteHanging readStream elementStream char |	openQuoteHanging := false.	^ Array streamContents: [:writeStream |		readStream := aString readStream.		elementStream := WriteStream on: ''.		[readStream atEnd] whileFalse:			[char := readStream next.			char = $"				ifTrue:					[openQuoteHanging						ifTrue:							[writeStream nextPut: elementStream contents.							elementStream := WriteStream on: ''.							openQuoteHanging := false]						ifFalse:							[openQuoteHanging := true]]				ifFalse:					[openQuoteHanging ifTrue:						[elementStream nextPut: char]]]]				"(((HTTPSocket httpGet: 'http://squeakland.org/subjectCatList' args: #() user: '' passwd: '')) contents copyReplaceAll: String lf with: String cr) lines collect: [:l | EToyProjectDetailsMorph csvLineQuotedDecodedFor: l]"! !!EToyProjectDetailsMorph class methodsFor: 'utilities' stamp: 'sw 8/7/2009 21:34'!linesIn: aString	"Answer an array whose elements are strings constituting the lines in the input string."	^ Array streamContents: [:aStream |		aString linesDo:			[: aLine | aStream nextPut: aLine]]"EToyProjectDetailsMorph linesIn: 'Fredthe	Bear'"! !!EToyProjectDetailsMorph class methodsFor: 'classification defaults' stamp: 'sw 8/7/2009 22:12'!defaultAgeTriplets	"Answer a default set of triplets characterizing the Age classifications"	^  #(	('556' 'showcase : by age : 6 to 8' 'Ages 6 to 8')	('558' 'showcase : by age : 9 to 11' 'Ages 9 to 11')	('559' 'showcase : by age : 12 to 14' 'Ages 12 to 14')	('560' 'showcase : by age : 15 to 18' 'Ages 15 to 18') )! !!EToyProjectDetailsMorph class methodsFor: 'classification defaults' stamp: 'sw 9/17/2009 12:30'!defaultRegionTriplets	"Answer default triplets for the region codes"	^  #(	('619' 'showcase : by region : Africa' 'Africa')	('620' 'showcase : by region : Antarctica' 'Antarctica')	('621' 'showcase : by region : Asia' 'Asia') 	('622' 'showcase : by region : Australia' 'Australia') 	('623' 'showcase : by region : Caribbean' 'Caribbean')	('624' 'showcase : by region : Central America' 'Central America')	('625' 'showcase : by region : Europe' 'Europe') 	('626' 'showcase : by region : North America' 'North America')	('627' 'showcase : by region : Oceania' 'Oceania') 	('628' 'showcase : by region : South America' 'South America') )"EToyProjectDetailsMorph defaultRegionTriplets"! !!EToyProjectDetailsMorph class methodsFor: 'classification defaults' stamp: 'sw 8/7/2009 22:12'!defaultSubjectTriplets	"Answer a default set of triplets characterizing the Subject classifications"	^  #(	('554' 'showcase : by subject : language arts' 'Language Arts')	('553' 'showcase : by subject : mathemetics' 'Mathematics')	('555' 'showcase : by subject : science' 'Science')	('860' 'showcase : by subject : social studies' 'Social Studies') 	('861' 'showcase : by subject : music' 'Music')	('862' 'showcase : by subject : visual arts' 'Visual Arts')	('863' 'showcase : by subject : health' 'Health'))! !!EToyProjectDetailsMorph class methodsFor: 'classification defaults' stamp: 'sw 8/7/2009 21:44'!restoreDefaultTriplets	"Restore the defaults obtained from cold hard code."	RegionTriplets := self defaultRegionTriplets.	AgeTriplets := self defaultAgeTriplets.	SubjectTriplets := self defaultSubjectTriplets"EToyProjectDetailsMorph restoreDefaultTriplets"! !!EToyProjectDetailsMorph class methodsFor: 'class initialization' stamp: 'bf 9/16/2009 19:45'!initialize	self startUp: true.	Smalltalk addToStartUpList: self.! !!EToyProjectDetailsMorph class methodsFor: 'class initialization' stamp: 'bf 9/16/2009 19:25'!unload	Smalltalk removeFromStartUpList: self! !!EToyProjectDetailsMorph class methodsFor: 'classification accessing' stamp: 'bf 9/16/2009 19:48'!ageTriplets	"Answer a list of the triplets characterizing the 'age' categories; each triplet is of the form		(<numeric code> <string code> <english version>)"	^ AgeTriplets ifNil: [		AgeTriplets := (self cachedTripletsFor: #age)			ifNil: [self defaultAgeTriplets]]! !!EToyProjectDetailsMorph class methodsFor: 'classification accessing' stamp: 'bf 9/16/2009 19:48'!regionTriplets	"Answer a list of triplets of the form (numberCode stringCode englishName) for the regions."	^ RegionTriplets ifNil: [		RegionTriplets := (self cachedTripletsFor: #region)			ifNil: [self defaultRegionTriplets]]! !!EToyProjectDetailsMorph class methodsFor: 'classification accessing' stamp: 'bf 9/16/2009 19:49'!subjectTriplets	"Answer a list of triplets characterizing the subjects in the current taxonomy."	^ SubjectTriplets ifNil: [		SubjectTriplets := (self cachedTripletsFor: #subject)			ifNil: [self defaultSubjectTriplets]]! !!EToyProjectDetailsMorph class methodsFor: 'classification accessing' stamp: 'bf 9/16/2009 22:54'!useTriplets: triplets for: aCategory	aCategory = #age ifTrue: [AgeTriplets := triplets].	aCategory = #subject ifTrue: [SubjectTriplets := triplets].	aCategory = #region ifTrue: [RegionTriplets := triplets].! !!EToyProjectDetailsMorph class methodsFor: 'system startup' stamp: 'bf 9/16/2009 19:50'!startUp: resuming	resuming ifTrue: [		"Make sure we try cached versions"		SubjectTriplets := AgeTriplets := RegionTriplets := nil.	]! !!EToyProjectDetailsMorph class methodsFor: 'instance creation' stamp: 'sw 9/28/2009 15:42'!getFullInfoFor: aProject ifValid: aMessageSend expandedFormat: expandedFormat	"Obtain project info for the project by putting up a dialog-box showing current values for the various project-info variables and allowing the user to change the data."	| detailsMorph  |	detailsMorph := self basicNew.	detailsMorph expandedFormat: expandedFormat;		project: aProject actionBlock: aMessageSend;		initialize;		becomeModal;		beSticky;		openCenteredInWorld! !!EToyProjectQueryMorph methodsFor: 'utilities' stamp: 'sw 8/12/2009 11:47'!rebuild	"Rebuild the receiver from scratch."	| toAdd isText |	self removeAllMorphs.	self addARow: {		self lockedString: 'Enter things to search for' translated.	}.	self addARow: {		self lockedString: 'Project Name' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self fieldToDetailsMappings do: [ :each |		isText := each size < 5 or: [each fifth = #text].		self addARow: {			self lockedString: each third translated.				toAdd := isText					ifTrue:						[self genericTextFieldNamed: each first]					ifFalse:						[self popUpEntryNamed: each first menuTitle: each third].				self inAColumnForText: {toAdd height: each fourth}		}.	].	self addARow: {		self okButton.		self cancelButton.	}.	self fillInDetails.! !!EToyProjectQueryMorph methodsFor: 'ok button hit' stamp: 'sw 9/25/2009 15:38'!doOK	"User hit the ok button in the project-query dialog."	| details |	details := self copyOutDetails.	actionBlock isMessageSend "new way -- hopefully all cases"		ifTrue:			[actionBlock arguments: {details. actionBlock arguments second}.			actionBlock value]		ifFalse:  "Old way, with actionBlock actually a block of one argument.  This should no longer occur."			[actionBlock value: details].	self delete! !!EToyProjectQueryMorph methodsFor: 'query' stamp: 'sw 9/25/2009 15:36'!carryOutQuery: details onProjectServer: aProjectServer	"The user submitted a query; the parameter holds the details dictionary.  Carry out the query."	| criteria clean |	criteria := OrderedCollection new.	details keysAndValuesDo:		[ :k :v |			(clean _ v withBlanksTrimmed convertToEncoding: SuperSwikiServer defaultEncodingName) isEmpty						ifFalse: [criteria add: k,': *',clean,'*']].	aProjectServer queryProjectsAndShow: criteria! !!EToyProjectQueryMorph class methodsFor: 'instance creation' stamp: 'sw 9/25/2009 15:36'!onServer: aProjectServer	"EToyProjectQueryMorph onServer: SuperSwikiServer testOnlySuperSwiki"	| detailsMorph messageToSendIfValid |	detailsMorph := self basicNew.	messageToSendIfValid := MessageSend receiver: detailsMorph selector: #carryOutQuery:onProjectServer: arguments: {nil. aProjectServer}.	detailsMorph		project: nil		actionBlock: messageToSendIfValid;"***		actionBlock: [ :x | 			criteria _ OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean _ v withBlanksTrimmed convertToEncoding: SuperSwikiServer defaultEncodingName) isEmpty					ifFalse: [criteria add: k,': *',clean,'*']].			aProjectServer queryProjectsAndShow: criteria];  ****"		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectRenamerMorph methodsFor: 'ok button pressed' stamp: 'sw 9/25/2009 16:11'!doOK	"The user hit the ok button in the renamer dialog box; carry out the rename."	| aName |	self validateTheProjectName ifFalse: [^self].	aName := (namedFields at: 'projectname') contents string withBlanksTrimmed.	self delete.	actionBlock isMessageSend		ifTrue:			[actionBlock arguments: (Array with: aName).			actionBlock value]		ifFalse:			[actionBlock value: aName]! !!EToyProjectRenamerMorph commentStamp: 'sw 9/25/2009 15:21' prior: 0!Nowadays, anyway, EToyProjectRenamerMorph only occurs as an abstract superclass for EToyProjectQueryMorph and EToyProjectDetailsMorph.!!EToyVocabulary class methodsFor: 'as yet unclassified' stamp: 'Richo 5/13/2010 00:40'!allPhrasesWithContextToTranslate	| etoyVocab results literals additions |	results := OrderedCollection new.	etoyVocab := Vocabulary eToyVocabulary.	etoyVocab initialize.		"just to make sure that it's unfiltered."	self morphClassesDeclaringViewerAdditions do: [:cl |		(cl class includesSelector: #additionsToViewerCategories)			ifTrue: [				literals := OrderedCollection new.				cl additionsToViewerCategories do: [:group | 					literals add: group first.					group second do: [:tuple |						literals add: (ScriptingSystem wordingForOperator: (tuple at: 2)).  "wording"						literals add: (tuple at: 3).  "help string"]].				literals ifNotEmpty: [					results add: {cl category. cl class. #additionsToViewerCategories. literals}]].		cl class selectors do: [:aSelector | ((aSelector beginsWith: 'additionsToViewerCategory')								and: [(aSelector at: 26 ifAbsent: []) ~= $:])			ifTrue: [				literals := OrderedCollection new.				additions := (cl perform: aSelector).				literals add: additions first.				additions second do: [:tuple |					literals add: (ScriptingSystem wordingForOperator: (tuple at: 2)).  "wording"					literals add: (tuple at: 3).  "help string"].				literals ifNotEmpty: [					results add: {cl category. cl class. aSelector. literals}]]]].		literals :=( self allStandardVocabularies			select: 				[:aVocab | aVocab representsAType]			thenCollect: 				[:aVocab | aVocab vocabularyName asString ]).		results add: {Vocabulary class category. Vocabulary class. #typeChoices. literals}.	^results.! !!EToyVocabulary class methodsFor: 'accessing' stamp: 'sw 5/16/2009 05:45'!masterOrderingOfCategorySymbols	"Answer a dictatorially-imposed presentation list of category symbols.	This governs the order in which available vocabulary categories are presented in etoy viewers using the etoy vocabulary.	The default implementation is that any items that are in this list will occur first, in the order specified here; after that, all other items will come, in alphabetic order by their translated wording."	EToyVocabulary class decompile:  #masterOrderingOfCategorySymbols.	self flag: #(('scripts' translatedNoop) ('variables' translatedNoop) ('as object' translatedNoop)).	^ {'basic' translatedNoop. 'color' translatedNoop. 'geometry' translatedNoop. 		'more geometry' translatedNoop.		'pen use' translatedNoop. 'tests' translatedNoop. 'motion' translatedNoop. 'fill & border' translatedNoop. 'scripting' translatedNoop. 'sound' translatedNoop. 'observation' translatedNoop. 'button' translatedNoop. 'layout' translatedNoop. 'drag & drop' translatedNoop. 'search' translatedNoop. 'miscellaneous' translatedNoop}		collect: [:each | each asSymbol]! !!EtoyDAVLoginMorph methodsFor: 'actions' stamp: 'yo 9/9/2009 01:54'!doCancel	self delete.	cancelBlock ifNotNil:[cancelBlock value].! !!EtoyDAVLoginMorph methodsFor: 'actions' stamp: 'yo 9/9/2009 02:35'!doOK	| proposed proposedPass |	proposed _ theNameMorph contents string.	proposed isEmpty ifTrue: [^self inform: 'Please enter your login name' translated].	proposed size > 24 ifTrue: [^self inform: 'Please make the name 24 characters or less' translated].	(Project isBadNameForStoring: proposed) ifTrue: [		^self inform: 'Please remove any funny characters' translated	].	proposedPass := thePasswordMorph contents string.	(actionBlock value: proposed value: proposedPass) ifTrue:[self delete].! !!EtoyDAVLoginMorph methodsFor: 'actions' stamp: 'yo 9/11/2009 16:25'!launchBrowser	ActiveWorld addMorph: self buildPanel centeredNear: Sensor cursorPoint.	ScratchPlugin primOpenURL: self url.! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/10/2009 13:30'!buttonColor	^ self defaultColor! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/9/2009 01:54'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f _ SimpleButtonMorph new		target: self;		label: aString font: self myFont;		color: aColor;		actionSelector: aSymbol;		setBalloonText: helpString.	col _ (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/11/2009 16:37'!cancelButton	^self		buttonNamed: 'Cancel' translated		action: #doCancel 		color: self buttonColor 		help: 'Cancel this login operation.' translated! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/9/2009 01:54'!myFont	^ Preferences standardEToysFont! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/11/2009 16:37'!okButton	^self		buttonNamed: 'OK' translated		action: #doOK 		color: self buttonColor 		help: 'Login to Squeakland' translated! !!EtoyDAVLoginMorph methodsFor: 'building' stamp: 'yo 9/11/2009 16:36'!okButton2	^self		buttonNamed: 'OK'  translated		action: #deletePanel 		color: self buttonColor 		help: 'Close this dialog' translated! !!EtoyDAVLoginMorph methodsFor: 'initialization' stamp: 'yo 9/10/2009 13:31'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color fromString: '#ECE8CC'! !!EtoyDAVLoginMorph methodsFor: 'initialization' stamp: 'yo 9/9/2009 01:54'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!EtoyDAVLoginMorph methodsFor: 'initialization' stamp: 'yo 9/10/2009 13:29'!defaultColor	^ (Color fromString: '#ECE8CC') muchLighter! !!EtoyDAVLoginMorph methodsFor: 'initialization' stamp: 'yo 9/10/2009 11:29'!initialize	"initialize the state of the receiver"		super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 beSticky;		 rebuild.	self setProperty: #morphicLayerNumber toValue: 10.! !!EtoyDAVLoginMorph methodsFor: 'initialization' stamp: 'yo 9/9/2009 01:54'!openInWorld: aWorld	super openInWorld: aWorld.	aWorld primaryHand newKeyboardFocus: theNameMorph.! !!EtoyDAVLoginMorph methodsFor: 'initialize' stamp: 'yo 9/11/2009 16:14'!delete	self deletePanel.	super delete.! !!EtoyDAVLoginMorph methodsFor: 'initialize' stamp: 'yo 9/9/2009 01:54'!name: aString actionBlock: aBlock cancelBlock: altBlock	theName _ aString.	actionBlock _ aBlock.	cancelBlock _ altBlock.	theNameMorph contentsWrapped: theName.	theNameMorph editor selectAll.! !!EtoyDAVLoginMorph methodsFor: 'initialize' stamp: 'yo 9/11/2009 16:24'!rebuild	| title link |	self removeAllMorphs.	title := StringMorph contents: 'Login to Squeakland' translated font: self myFont.	title lock.	link :=  StringMorph contents: '(create account)' translated font: Preferences standardListFont emphasis: 4.	link color: Color blue.	link beSticky.	link on: #click send: #launchBrowser to: self.	self addARow: { title. self newSpacer: Color transparent. link}.	self addARow: { (StringMorph contents:'') lock }.	(self addARow: {		(StringMorph contents: 'Username:' translated font: self myFont) lock.		Morph new extent: 15@0; color: Color transparent.		self newSpacer: Color transparent.		(theNameMorph _ TextMorph new			beAllFont: self myFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 250@20;			borderStyle: (InsetBorder new color: Color black; width: 2);			contentsWrapped: 'the old name'			).	}) color: self defaultColor; borderWidth: 0.	self addARow: { (StringMorph contents:'') lock }.	(self addARow: {		(StringMorph contents: 'Password:' translated font: self myFont) lock.		Morph new extent: 15@0; color: Color transparent.		self newSpacer: Color transparent.		(thePasswordMorph _ TextMorph new			beAllFont: (FixedFaceFont new passwordFont baseFont: self myFont copy);			crAction: (MessageSend receiver: self selector: #doOK);			extent: 250@20;			borderStyle: (InsetBorder new color: Color black; width: 2);			contentsWrapped: ''			).	}) color: self defaultColor.	self addARow: { (StringMorph contents:'') lock }.	self addARow: {		self newSpacer: Color transparent.		self okButton hResizing: #rigid.		Morph new extent: 30@0; color: Color transparent.		self cancelButton hResizing: #rigid.	}.! !!EtoyDAVLoginMorph methodsFor: 'private' stamp: 'bf 9/15/2009 19:26'!buildPanel	| title |	self deletePanel.	panel := AlignmentMorphBob1 new.	panel vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		color: self defaultColor;		 beSticky;		borderWidth: self defaultBorderWidth;		borderColor:  self defaultBorderColor.	title := TextMorph new contents: 'Etoys is trying to open your web browser.\If it does not work, you can sign up at:\\' translated withCRs, self url; beAllFont: self myFont.	title beSticky.	title centered.	panel addARow: {title}.	panel addARow: { (StringMorph contents:'') lock }.	panel addARow: {		self newSpacer: Color transparent.		self okButton2 hResizing: #rigid.		self newSpacer: Color transparent.	}.	panel setProperty: #morphicLayerNumber toValue: 9.	^ panel.! !!EtoyDAVLoginMorph methodsFor: 'private' stamp: 'yo 9/11/2009 15:39'!deletePanel	panel ifNotNil: [panel delete. panel := nil].! !!EtoyDAVLoginMorph methodsFor: 'private' stamp: 'yo 9/11/2009 19:17'!loginAndDo: aBlock ifCanceled: cb	"EtoyDAVLoginMorph loginAndDo:[:n :p | true] ifCanceled:[]"	self name: '' actionBlock: aBlock cancelBlock: cb;		fullBounds;		position: Display extent - self extent // 2.	self position: self position + (0@40).	ActiveWorld addMorphInLayer: self! !!EtoyDAVLoginMorph methodsFor: 'private' stamp: 'yo 9/11/2009 15:38'!newSpacer: aColor	"Answer a space-filling instance of me of the given color."	^ AlignmentMorph newSpacer: aColor! !!EtoyDAVLoginMorph methodsFor: 'private' stamp: 'yo 9/11/2009 15:21'!url	^ 'http://squeakland.org/action/signup'.! !!EtoyDAVLoginMorph class methodsFor: 'instance creation' stamp: 'yo 9/11/2009 19:18'!loginAndDo: aBlock ifCanceled: cancelBlock	"EtoyDAVLoginMorph loginAndDo:[:n :p | true] ifCanceled:[]"	| |	self new loginAndDo: aBlock ifCanceled: cancelBlock.! !!EventRecordingSpace methodsFor: 'halo' stamp: 'sw 3/24/2009 13:18'!defersHaloToInteriorMorph: aMorph	"Answer whether  when a halo-click goes down over some subobject within me, I should defer to it rather than seize the halo myself."	^ true! !!EventSensor methodsFor: 'private-I/O' stamp: 'bf 9/8/2009 04:52'!swapControlAndAltKeys: evt	| char |	char := evt at: 3.	"Cursor keys and mouse wheel are not switched."	(#(28 29 30 31) includes: char) ifTrue: [^ self].	(evt at: 5) == CtrlKeyBit		ifTrue: ["Ctrl -> Alt (^A -> a)"			char < 32 ifTrue: [#(3 6) do: [:ind | evt at: ind put: (char bitOr: 16r60)]].			evt at: 5 put: 8]		ifFalse: [(evt at: 5) == CommandKeyBit			ifTrue: ["Alt -> Ctrl (a -> ^A)"				(char >= 16r60 and:  [char < 16r80]) ifTrue: [#(3 6) do: [:ind | evt at: ind put: (char bitAnd: 16r1F)]].				evt at: 5 put: 2]].! !!ExtendedClipboardInterface methodsFor: 'general-api-read' stamp: 'bf 9/30/2009 13:24'!readClipboardData: format	^clipboard = 0 ifFalse: 		[self primReadClipboardData: clipboard format: format].! !!ExtendedClipboardMacInterface methodsFor: 'general-api-read' stamp: 'bf 7/17/2009 15:45'!readByteStringClipboardData	^(self readClipboardData: 'com.apple.traditional-mac-plain-text')		ifNotNilDo: [: bytes | bytes asString macToSqueak]! !!ExtendedClipboardMacInterface methodsFor: 'general-api-read' stamp: 'bf 8/28/2010 19:20'!readFormClipboardData	| bytes formats |	formats := self readAvailableFormats.	(formats includes: 'image/png' asMIMEType)		ifTrue: [bytes := self readPNGClipboardData.			^ (PNGReadWriter on: bytes readStream) nextImage].	(formats includes: 'image/jpeg' asMIMEType)		ifTrue: [bytes := self readJPEGClipboardData.			^ (JPEGReadWriter2 on: bytes readStream) nextImage].	^ nil! !!ExtendedClipboardMacInterface methodsFor: 'general-api-read' stamp: 'bf 7/17/2009 15:49'!readStringClipboardData	| string |	string := self readUTF8StringClipboardData.	string ifNil: [string := self readWideStringClipboardData].	string ifNil: [string := self readByteStringClipboardData].	^string! !!ExtendedClipboardMacInterface methodsFor: 'general-api-read' stamp: 'bf 7/17/2009 16:09'!readTextClipboardData	^self readStringClipboardData		ifNotNilDo: [:string | (string replaceAll: Character lf with: Character cr) asText]! !!ExtendedClipboardMacInterface methodsFor: 'general-api-read' stamp: 'bf 8/10/2010 22:05'!readUTF8StringClipboardData	^(self readClipboardData: 'public.utf8-plain-text')		ifNotNilDo: [:bytes |			[bytes asString utf8ToSqueak] ifError: [bytes asString] ]! !!ExtendedClipboardUnixInterface methodsFor: 'general-api-read' stamp: 'bf 9/30/2009 13:14'!readStringClipboardData	^self readWideStringClipboardData! !!ExtendedClipboardUnixInterface methodsFor: 'general-api-read' stamp: 'bf 9/30/2009 13:16'!readTextClipboardData	| formats |	formats := self readAvailableFormats.	(formats includes: 'text/html')		ifTrue: [^ self readHTMLClipboardData formattedText].	(formats includes: 'UTF8_STRING')		ifTrue: [^self readWideStringClipboardData asText].	(formats includes: 'STRING')		ifTrue: ["handled by old clipboard code, fall through"].	^ nil! !!ExtendedClipboardUnixInterface methodsFor: 'general-api-read' stamp: 'bf 9/30/2009 13:15'!readWideStringClipboardData	^(self readClipboardData: 'UTF8_STRING') asString utf8ToSqueak! !!ExtendedClipboardWinInterface methodsFor: 'general-api-read' stamp: 'bf 8/28/2010 19:24'!readFormClipboardData	| bytes formats |	formats := self readAvailableFormats.	(formats includes: 'image/bmp' asMIMEType)		ifTrue: [bytes := self readBMPClipboardData.			^ (BMPReadWriter on: bytes readStream) nextImage].	^ nil! !!ExternalDropHandler class methodsFor: 'class initialization' stamp: 'Richo 7/16/2010 18:27'!initialize	"ExternalDropHandler initialize"	self resetRegisteredHandlers.	self		registerHandler: self defaultImageHandler;		registerHandler: self defaultGZipHandler;		registerHandler: self defaultProjectHandler;		registerHandler: self defaultMidiHandler;		registerHandler: self defaultMorphHandler.! !!ExternalDropHandler class methodsFor: 'private' stamp: 'Richo 7/20/2010 09:43'!defaultMorphHandler	^ ExternalDropHandler		type: nil		extension: 'morph'		action: [:stream | (Morph fromStreamedRepresentation: stream contents) openInWorld]! !!ExternalSettings class methodsFor: 'accessing' stamp: 'bf 8/8/2010 18:08'!assuredPreferenceDirectory	"Answer the preference directory, creating it if necessary"	|  prefDir topDir |	prefDir := self preferenceDirectory.	prefDir		ifNil:			[topDir := Preferences startInUntrustedDirectory				ifTrue: [FileDirectory on: SecurityManager default secureUserDirectory]				ifFalse: [FileDirectory default].			prefDir := topDir directoryNamed: self preferenceDirectoryName.			prefDir assureExistence].	^ prefDir! !!ExternalSettings class methodsFor: 'accessing' stamp: 'bf 8/8/2010 18:11'!preferenceDirectory	| prefDirName imgPath vmPath secDir |	prefDirName := self preferenceDirectoryName.	Preferences startInUntrustedDirectory 		ifTrue: [			secDir := (FileDirectory on: SecurityManager default secureUserDirectory)				directoryNamed: prefDirName.			^secDir exists ifTrue: [secDir]].	imgPath := SmalltalkImage current imagePath. "might be different from default!!"	vmPath := SmalltalkImage current vmPath.	^((FileDirectory on: imgPath) directoryExists: prefDirName)		ifTrue: [(FileDirectory on: imgPath) directoryNamed: prefDirName]		ifFalse: [			((FileDirectory on: vmPath) directoryExists: prefDirName)				ifTrue: [(FileDirectory on: vmPath) directoryNamed: prefDirName]				ifFalse: [nil]]! !!FileList2 methodsFor: 'initialization' stamp: 'yo 9/9/2009 14:58'!initialDirectoryList	| dir nameToShow dirList |	dirList _ (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList _ Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList do: [:e | e balloonText: e withoutListWrapper pathName].	dirList _ dirList,(		ServerDirectory serverNames collect: [ :n | 			dir _ ServerDirectory serverNamed: n.			nameToShow _ n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!FileList2 methodsFor: 'initialization' stamp: 'yo 9/9/2009 14:58'!initialDirectoryListForProjects	| dir nameToShow dirList |	dirList _ (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList _ Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList do: [:e | e balloonText: e withoutListWrapper pathName].	dirList _ dirList,((		ServerDirectory serverNames select: [ :n | 			(ServerDirectory serverNamed: n) isProjectSwiki.		]) collect: [:n |			dir _ ServerDirectory serverNamed: n.			nameToShow _ n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!FileList2 methodsFor: 'initialization' stamp: 'bf 8/25/2010 02:18'!limitedSuperSwikiDirectoryList	| dir nameToShow dirList localDirName localDir localList |	dirList _ OrderedCollection new.	localList _ OrderedCollection new.	ServerDirectory serverNames do: [ :n | 		dir _ ServerDirectory serverNamed: n.		dir isProjectSwiki ifTrue: [			nameToShow _ n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	ServerDirectory localProjectDirectories do: [ :each |		localList add: (dirList add: (FileDirectoryWrapper with: each name: each localName model: self))	].	(dirList anySatisfy: [:e | e withoutListWrapper pathName beginsWith: 'sugar://']) ifFalse: [		"Make sure the following are always shown, but not twice"		localDirName := SecurityManager default untrustedUserDirectory.		localDir := FileDirectory on: localDirName.		((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)				ifFalse: [localList add: (dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self))].		FileDirectory default pathName = localDirName				ifFalse: [localList add: (dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self))].		(dirList anySatisfy: [:each | each withoutListWrapper acceptsUploads])			ifFalse: [localList add: (dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self))].	].	localList do: [:e | e balloonText: e withoutListWrapper pathName].	^dirList! !!FileList2 methodsFor: 'initialization' stamp: 'bf 8/25/2010 02:20'!limitedSuperSwikiPublishDirectoryList	| dirList localDirName localDir localList |	dirList _ self publishingServers.	localList _ OrderedCollection new.	ServerDirectory localProjectDirectories do: [ :each |		localList add: (dirList add: (FileDirectoryWrapper with: each name: each localName model: self))].	(dirList anySatisfy: [:e | e withoutListWrapper pathName beginsWith: 'sugar://']) ifFalse: [		"Make sure the following are always shown, but not twice"		localDirName := SecurityManager default untrustedUserDirectory.		localDir := FileDirectory on: localDirName.		((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)				ifFalse: [localList add: (dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self))].		FileDirectory default pathName = localDirName				ifFalse: [localList add: (dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self))]].	localList do: [:e | e balloonText: e withoutListWrapper pathName].	^dirList! !!FileList2 methodsFor: 'initialize-release' stamp: 'yo 9/9/2009 11:54'!initialize	showDirsInFileList _ false.	fileSelectionBlock _ [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	] fixTemps.	dirSelectionBlock _ [ :dirName | true].! !!FileList2 methodsFor: 'user interface' stamp: 'yo 9/11/2009 10:28'!morphicDirectoryTreePaneFiltered: aSymbol	^(SimpleHierarchicalListMorph 		on: self		list: aSymbol		selected: #currentDirectorySelected		changeSelected: #setSelectedDirectoryTo:		menu: #volumeMenu:		keystroke: nil		autoExpand: true)			autoDeselect: false;			enableDrag: false;			enableDrop: true;			yourself		! !!FileList2 methodsFor: 'private' stamp: 'yo 9/17/2009 18:16'!directoryNamesFor: item	"item may be file directory or server directory"	| entries |	entries _ [item directoryNames] on: Error do: [:ex |		(ex isKindOf: NetworkError)			ifTrue: [self inform: 'Network Error' translated]			ifFalse: [(ex isKindOf: ProtocolClientError)				ifTrue: [self loginHit]				ifFalse: [(ex isMemberOf: InvalidDirectoryError) ifTrue: [ex outer] ifFalse: [self inform: 'Unknown Error' translated]]].		^ #()].	dirSelectionBlock ifNotNil:[entries _ entries select: dirSelectionBlock].	^entries! !!FileList2 methodsFor: 'private' stamp: 'yo 9/9/2009 02:37'!loginButton	^ loginButton! !!FileList2 methodsFor: 'private' stamp: 'yo 9/9/2009 02:37'!loginButton: aButton	loginButton := aButton.! !!FileList2 methodsFor: 'private' stamp: 'yo 9/9/2009 03:13'!loginField	^ loginField! !!FileList2 methodsFor: 'private' stamp: 'yo 9/16/2009 16:58'!loginHit	| s failed ret |	loginDialog ifNotNil: [^ false].	s := ServerDirectory servers at: 'My Squeakland' ifAbsent: [^ false].	failed := [Utilities loggedIn: false. loginDialog := nil. s user: nil].	ret := true.	loginDialog := EtoyDAVLoginMorph new.	loginDialog loginAndDo: [:n :p |		s ifNotNil: [			s user: n.			s password: p.			[s copy createPersonalDirectory: n] on: Error do: [:ex |				"either directory already exists or could not create.				Here, it is just eaten as the following test will tell us whether it can be read."].			[s entries] on: ProtocolClientError,  NetworkError do: [:ex |				failed value. self inform: 'Login failed.'. ret := false].			ret ifTrue: [Utilities authorName: n. Utilities loggedIn: true]].		self updateLoginButtonAppearance.		Utilities loggedIn ifTrue: [			self directory: directory.			brevityState := #FileList.			"self addPath: path."			self changed: #fileList.			self changed: #contents.			self changed: #currentDirectorySelected.			EToyProjectDetailsMorph updateTripletsFromWebSiteInBackground.		].		loginDialog := nil. 		true.	] ifCanceled: failed.! !!FileList2 methodsFor: 'private' stamp: 'yo 9/9/2009 03:03'!logoutHit	| s |	s := ServerDirectory servers at: 'My Squeakland' ifAbsent: [^ false].	Utilities loggedIn: false. s user: nil.	self updateLoginButtonAppearance! !!FileList2 methodsFor: 'private' stamp: 'yo 9/17/2009 18:16'!setSelectedDirectoryTo: aFileDirectoryWrapper	currentDirectorySelected _ aFileDirectoryWrapper.	[self directory: aFileDirectoryWrapper withoutListWrapper] on: Error do: [:ex |		(ex isKindOf: NetworkError)			ifTrue: [self inform: 'Network Error' translated]			ifFalse: [(ex isKindOf: ProtocolClientError)				ifTrue: [self loginHit]				ifFalse: [(ex isMemberOf: InvalidDirectoryError) ifTrue: [ex outer] ifFalse: [self inform: 'Unknown Error' translated]]].		^ self].	brevityState := #FileList.	"self addPath: path."	self changed: #fileList.	self changed: #contents.	self changed: #currentDirectorySelected.! !!FileList2 methodsFor: 'private' stamp: 'yo 9/15/2009 22:09'!updateLoginButtonAppearance	| old oldField notLoggedInMessage |	notLoggedInMessage := '(not logged in)' translated.	old := loginButton.	oldField := loginField.	loginField := Morph new color: Color white.	loginField borderWidth: 2.	loginField borderColor: ScriptingSystem baseColor.	loginField beSticky.	loginField width: 150.	loginField height: 30.	loginField clipSubmorphs: true.	Utilities loggedIn ifTrue: [		loginButton := self class					buildButtonText: 'Logout' translated					balloonText: nil					receiver: self					selector: #logoutHit.		loginButton color: ScriptingSystem baseColor.		loginField addMorphCentered: (StringMorph contents: (Utilities authorNamePerSe ifNil: [notLoggedInMessage]) font: Preferences standardEToysButtonFont).		loginButton setBalloonText: 'Log out from the Squeakland server' translated.		loginField setBalloonText: 'Your Squeakland user name' translated.	]	ifFalse: [		loginButton := self class					buildButtonText: 'Login' translated					balloonText: nil					receiver: self					selector: #loginHit.		loginButton color: ScriptingSystem baseColor.		loginField addMorphCentered: (StringMorph contents: notLoggedInMessage font: Preferences standardEToysButtonFont).		loginButton setBalloonText: 'Log in to share projects on the Squeakland server' translated.		loginField setBalloonText: 'Your Squeakland user name' translated	].	loginButton setNamePropertyTo: 'login'.	loginButton width: 150.	old ifNotNil: [		old owner addMorph: loginButton inFrontOf: old.		old delete].	oldField ifNotNil: [		oldField owner addMorph: loginField inFrontOf: oldField.		oldField delete].! !!FileList2 class methodsFor: 'blue ui' stamp: 'yo 9/11/2009 17:12'!buildLoadButtons: window fileList: aFileList reallyLoad: aBoolean 	| aRow  okButton cancelButton |	okButton := self				buildButtonText: 'OK' translated				balloonText: nil				receiver: aFileList				selector: (aBoolean						ifTrue: [#okHitForProjectLoader]						ifFalse: [#okHit]).	okButton width: 150.	cancelButton := self				buildButtonText: 'Cancel' translated				balloonText: nil				receiver: aFileList				selector: #cancelHit.	cancelButton width: 150.	aFileList updateLoginButtonAppearance.	aRow := window addARow: {aFileList loginButton. aFileList loginField. okButton. cancelButton}.	aRow color: ScriptingSystem paneColor.	aRow listCentering: #bottomRight.	aRow layoutInset: 3 @ 3.	aRow cellInset: 6 @ 3.	^ aRow! !!FileList2 class methodsFor: 'blue ui' stamp: 'yo 9/9/2009 14:18'!buildPane: aWorld fileList: aFileList window: window dirFilterType: aSymbol 	| treeExtent filesExtent treePane fileListPane pane2a pane2b aRow |	aWorld width < 800		ifTrue: [treeExtent := 150 @ 300.			filesExtent := 350 @ 300]		ifFalse: [treeExtent := 250 @ 300.			filesExtent := 350 @ 300].	(treePane := aFileList morphicDirectoryTreePaneFiltered: aSymbol) extent: treeExtent;		 retractable: false;		 borderWidth: 0.	fileListPane := aFileList morphicFileListPane extent: filesExtent;				 retractable: false;				 borderWidth: 0.	aRow := window addARow: {(window inAColumn: {(pane2a := window inARow: {window inAColumn: {treePane}}) useRoundedCornersInEtoys; layoutInset: 3})					layoutInset: 3. (window inAColumn: {(pane2b := window inARow: {window inAColumn: {fileListPane}}) useRoundedCornersInEtoys; layoutInset: 3})					layoutInset: 3}.	aRow color: ScriptingSystem paneColor.	window fullBounds.	{pane2a. pane2b}		do: [:each | 			each borderWidth: 1.			each borderColor: ScriptingSystem borderColor].	^ treePane.! !!FileList2 class methodsFor: 'blue ui' stamp: 'yo 9/11/2009 17:12'!buildSaveButtons: window fileList: aFileList	| buttonData buttons aRow |	buttonData := Preferences enableLocalSave				ifTrue: [#(#('Save' #okHit 'Save in the place specified above')							#('Save on local disk only' #saveLocalOnlyHit 'saves in the Squeaklets folder')							#('Cancel' #cancelHit 'return without saving') ) translatedNoop]				ifFalse: [#(#('Save' #okHit 'Save in the place specified above')							#('Cancel' #cancelHit 'return without saving') ) translatedNoop].	buttons := buttonData				collect: [:each | self						buildButtonText: each first translated						balloonText: each third translated						receiver: aFileList						selector: each second].	aFileList updateLoginButtonAppearance.	buttons := {aFileList loginButton. aFileList loginField. Morph new color: Color transparent; width: 50}, buttons.	aRow := window addARow: buttons.	aRow color: ScriptingSystem paneColor.	aRow listCentering: #bottomRight.	aRow layoutInset: 3 @ 3.	aRow cellInset: 6 @ 3.	^ aRow! !!FileList2 class methodsFor: 'blue ui' stamp: 'bf 8/25/2010 02:33'!morphicViewProjectLoader2InWorld: aWorld title: title reallyLoad: aBoolean dirFilterType: aSymbol isGeneral: isGeneral	"Put up a blue file-list for loading etoy projects.""FileList2 morphicViewProjectLoader2InWorld: self currentWorld reallyLoad: true dirFilterType: #limitedSuperSwikiDirectoryList"	| window aFileList actionRow treePane p |	aFileList _ self buildFileListDirFilterType: aSymbol.	window := self buildMorphicWindow: aFileList title: title. 	actionRow _ self buildLoadButtons: window fileList: aFileList reallyLoad: aBoolean.	isGeneral		ifTrue: [self buildFileTypeButtons: window actionRow: actionRow fileList: aFileList].	treePane := self buildPane: aWorld fileList: aFileList window: window dirFilterType: aSymbol.	window addMorphBack: actionRow.	window fullBounds.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	window beSticky.	aFileList sortByName.	"This crazy stuff I really cannot figure out how to get the directory selected by default other than this."	(treePane scroller submorphs detect: [:e |		p := e complexContents withoutListWrapper pathName.		(p beginsWith: 'sugar://') or: [p = SecurityManager default untrustedUserDirectory]] ifNone: [nil])			ifNotNilDo: [:item | WorldState addDeferredUIMessage: [aFileList setSelectedDirectoryTo: item complexContents]].	aFileList postOpen.	^ window! !!FileList2 class methodsFor: 'blue ui' stamp: 'bf 8/25/2010 02:33'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window aFileList treePane pane2 option treeExtent row p |	aFileList _ self new directory: ServerDirectory projectDefaultDirectory.	aFileList dirSelectionBlock: self hideSqueakletDirectoryBlock.	window := self buildMorphicWindow: aFileList title: 'Publish This Project' translated. 	window setProperty: #morphicLayerNumber toValue: 11.	option _ aProject world 		valueOfProperty: #SuperSwikiPublishOptions 		ifAbsent: [#initialDirectoryListForProjects].	aProject world removeProperty: #SuperSwikiPublishOptions.	World height < 500 ifTrue: [		treeExtent _ 350@150.	] ifFalse: [		treeExtent _ 350@300.	].	(treePane _ aFileList morphicDirectoryTreePaneFiltered: option) 		extent: treeExtent; 		retractable: false;		borderWidth: 0.treePane color: Color transparent.	row := window addARow: {			window inAColumn: {(ProjectViewMorph on: aProject) lock}.			(				window inAColumn: {					(pane2 _ window inARow: {window inAColumn: {treePane}}) 						useRoundedCornersInEtoys; layoutInset: 3				}			) layoutInset: 3		}.	row color: ScriptingSystem paneColor.	pane2 borderColor: ScriptingSystem borderColor.	pane2 borderWidth: 1.	window addMorphBack: (self buildSaveButtons: window fileList: aFileList).	window fullBounds.	window beSticky.	"This crazy stuff I really cannot figure out how to get the directory selected by default other than this."	(treePane scroller submorphs detect: [:e |		p := e complexContents withoutListWrapper pathName.		(p beginsWith: 'sugar://') or: [p = SecurityManager default untrustedUserDirectory]] ifNone: [nil])			ifNotNilDo: [:item | WorldState addDeferredUIMessage: [aFileList setSelectedDirectoryTo: item complexContents]].	aFileList postOpen.	^ window ! !!FilePackage methodsFor: '*monticello' stamp: 'al 12/2/2005 13:58'!classDefinition: string with: chgRec	| tokens theClass |		self flag: #traits.			tokens := Scanner new scanTokens: string.	"tokens size = 11 ifFalse:[^doIts add: chgRec]."	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: '*monticello' stamp: 'avi 1/19/2004 23:47'!doIts	^ doIts! !!FileStream class methodsFor: 'instance creation' stamp: 'CdG 10/19/2005 23:21'!detectFile: aBlock do: anotherBlock		| file |	file := aBlock value.	^ file 		ifNil: [ nil ]         ifNotNil: [ [anotherBlock value: file] ensure: [file close]]! !!FileStream class methodsFor: 'instance creation' stamp: 'bkv 1/22/2004 17:29'!readOnlyFileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^ self detectFile: [ self readOnlyFileNamed: fileName ] do: aBlock! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'bf 5/8/2010 12:30'!setPasswordQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	| pane |	self setQuery: queryString 		initialAnswer: initialAnswer 		answerHeight: answerHeight 		acceptOnCR: acceptBoolean.	pane _ self submorphNamed: 'textPane'.	pane font: FixedFaceFont new passwordFont.! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'yo 8/3/2009 19:57'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerExtent: answerExtent	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!' centerAt: Display center inWorld: ActiveWorld		onCancelReturn: '*** Cancelled ***' acceptOnCR: true answerExtent: self defaultAnswerExtent"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setQuery: queryString		initialAnswer: defaultAnswer		answerExtent: answerExtent		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorphInLayer: aFillInTheBlankMorph centeredNear: aPoint.	aFillInTheBlankMorph layoutChanged.	^ aFillInTheBlankMorph getUserResponse! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'yo 8/3/2009 19:58'!requestPassword: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setPasswordQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.		aWorld addMorphInLayer: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'yo 8/3/2009 20:13'!request: queryString initialAnswer: defaultAnswer onCancelReturn: cancelResponse	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: ActiveHand cursorPoint		inWorld: ActiveWorld		onCancelReturn: cancelResponse! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'bf 5/8/2010 12:30'!requestPassword: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView myPar pwdFont myArray myStyle |	aFillInTheBlank acceptOnCR: true.	messageView _ DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView _ self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	" now answerView to use the password font"	myPar _ answerView displayContents.	pwdFont _ FixedFaceFont new passwordFont.	myArray _ Array new: 1.	myArray at: 1 put: pwdFont.	myStyle _ TextStyle fontArray: myArray.	myPar setWithText: (myPar text) style: myStyle.	topView _ View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!Flaps class methodsFor: 'flaps registry' stamp: 'bf 5/10/2010 23:36'!defaultsQuadsDefiningToolsFlap	"Answer a structure defining the default Tools flap.	previously in quadsDefiningToolsFlap"	^ OrderedCollection new	addAll: {	{#Browser. 		#prototypicalToolWindow.	'Browser'  translatedNoop.	'A Browser is a tool that allows you to view all the code of all the classes in the system' translatedNoop}.	{#TranscriptStream.		#openMorphicTranscript.		'Transcript'  translatedNoop.		'A Transcript is a window usable for logging and debugging; browse references to #Transcript for examples of how to write to it.' translatedNoop}.	{#Workspace.	#prototypicalToolWindow	.	'Workspace'  translatedNoop.		'A Workspace is a simple window for editing text.  You can later save the contents to a file if you desire.' translatedNoop}};		add: { Preferences useFileList2 ifTrue: [ #FileList2 ] ifFalse: [ #FileList ].				#prototypicalToolWindow.				'File List' translatedNoop.				'A File List is a tool for browsing folders and files on disks and FTP servers.' translatedNoop };	addAll: {	{#DualChangeSorter.		#prototypicalToolWindow.	'Change Sorter' translatedNoop.	'Shows two change sets side by side' translatedNoop}.	{#SelectorBrowser.		#prototypicalToolWindow.	'Method Finder' translatedNoop.	'A tool for discovering methods by providing sample values for arguments and results' translatedNoop}.	{#MessageNames	.	#prototypicalToolWindow	.	'Message Names' translatedNoop.		'A tool for finding, viewing, and editing all methods whose names contain a given character sequence.' translatedNoop}.	{#Preferences.		#preferencesControlPanel.	'Preferences' translatedNoop.		'Allows you to control numerous options' translatedNoop}.	{#Utilities.			#recentSubmissionsWindow.	'Recent' translatedNoop.				'A message browser that tracks the most recently-submitted methods' translatedNoop}.	{#ProcessBrowser.	#prototypicalToolWindow.	'Processes' translatedNoop.		'A Process Browser shows you all the running processes' translatedNoop}.	{#Preferences.		#annotationEditingWindow.	'Annotations' translatedNoop.	'Allows you to specify the annotations to be shown in the annotation panes of browsers, etc.' translatedNoop}.	{#PackagePaneBrowser.	#prototypicalToolWindow	.	'Packages' translatedNoop.	'Package Browser:  like a System Browser, except that if has extra level of categorization in the top-left pane, such that class-categories are further organized into groups called "packages"' translatedNoop}.	{#ChangeSorter.		#prototypicalToolWindow.	'Change Set' translatedNoop.		'A tool that allows you to view and manipulate all the code changes in a single change set' translatedNoop}};		yourself! !!Flaps class methodsFor: 'flaps registry' stamp: 'Richo 5/23/2010 17:25'!unregisterQuadsWithReceiver: aReceiver 	"delete all quads with receiver aReceiver."	self registeredFlapsQuads		do: [:assoc | assoc value				removeAllSuchThat: [:q | (self environment at: (q first) ifAbsent: [nil]) = aReceiver ]]! !!Flaps class methodsFor: 'predefined flaps' stamp: 'bf 8/29/2010 16:51'!defaultsQuadsDefiningPlugInSuppliesFlap	"Answer a list of quads which define the objects to appear in the default Supplies flap used in the Plug-in image"	^  {	{#ObjectsTool. #newStandAlone. 'Object Catalog' translatedNoop. 'A tool that lets you browse the catalog of available objects' translatedNoop}.	{#AllScriptsTool. #allScriptsToolForActiveWorld. 'All Scripts' translatedNoop. 'Stop, Step, and Go buttons for controlling all your scripts at once.  The tool can also be "opened up" to control each script in your project individually.' translatedNoop}.	{#AllPlayersTool. #allPlayersToolForActiveWorld. 'Players' translatedNoop. 'A tool listing all the scripted objects in the project.' translatedNoop}.	{#TrashCanMorph. #new	. 'Trash' translatedNoop. 'A tool for discarding objects' translatedNoop}.	{#TextMorph	. #authoringPrototype. 'Text' translatedNoop.	'Text that you can edit into anything you desire.' translatedNoop}.	{#RecordingControls. #authoringPrototype. 'Sound Recorder' translatedNoop. 'A device for making sound recordings.' translatedNoop}.	{#RectangleMorph. #authoringPrototype. 'Rectangle' translatedNoop. 'A rectangle' translatedNoop}.	{#EllipseMorph. #authoringPrototype. 'Ellipse' translatedNoop.  'An ellipse or circle' translatedNoop}.	{#StarMorph. #authoringPrototype. 'Star' translatedNoop. 'A star' translatedNoop}.	{#BookMorph. #authoringPrototype. 'Book' translatedNoop. 'A multi-paged structure' translatedNoop}.	{#ScriptingSystem. #prototypicalHolder. 'Holder' translatedNoop. 'A place for storing alternative pictures in an animation, etc.' translatedNoop}.	{#JoystickMorph	. #authoringPrototype. 'Joystick' translatedNoop. 'A joystick-like control' translatedNoop}.	{#PasteUpMorph. #authoringPrototype. 'Playfield' translatedNoop. 'A place for assembling parts or for staging animations' translatedNoop}.	{#FlapTab. #authoringPrototype. 'Flap' translatedNoop. FlapTab helpMessage}.	{#ScriptableButton. #authoringPrototype. 'Button' translatedNoop. 'A button to use with tile scripting; its script will be a method of its containing playfield' translatedNoop}.	{#SimpleSliderMorph.	#authoringPrototype.	'Slider' translatedNoop.	'A slider for showing and setting numeric values.' translatedNoop}.	{#GrabPatchMorph.	#authoringPrototype.	'Grab patch' translatedNoop.	'Make a new "Sketch" by designating a rectangular area of the screen' translatedNoop}.	{#LassoPatchMorph.	#authoringPrototype.	'Lasso' translatedNoop.	'Make a new "Sketch" by "lassoing" an area of the screen' translatedNoop}.} asOrderedCollection! !!Flaps class methodsFor: 'predefined flaps' stamp: 'kks 9/24/2009 21:04'!newSugarNavigatorFlap	| nav aFlapTab |	nav _ (SugarNavigatorBar newWith: SugarLibrary default) addButtons.	aFlapTab _ SugarNavTab new.	aFlapTab setNameTo: 'Sugar Navigator Flap' translated.	aFlapTab referent: nav.	aFlapTab addMorph: nav.	aFlapTab inboard: false.	aFlapTab edgeToAdhereTo: #top.	Preferences useArtificialSweetenerBar ifTrue: [nav configureForSqueakland].	aFlapTab resistsRemoval: true.	^ aFlapTab"Flaps replaceGlobalFlapwithID: 'SugarNavigator' translated "! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'KR 5/1/2008 10:11'!newClassDiagramConnectorsFlap	"Answer a newly-created flap which adheres to the left edge of the screen and which holds prototypes of Connectors parts relevant to UML class diagrams."		"	Flaps newClassDiagramConnectorsFlap openInWorld; setToPopOutOnDragOver: false.	"	|  aFlapTab aStrip |	aStrip _ self preferredConnectorsFlapBinClass		newPartsBinWithOrientation: #leftToRight andColor: (Color blue muchLighter alpha: 0.3) from: self quadsDefiningClassDiagramConnectorsFlap buttonClass: self preferredConnectorsButtonClass. 	aFlapTab _ FlapTab new referent: aStrip beSticky.	aFlapTab setName: 'Class Diagrams' translated edge: #bottom color: Color blue muchLighter.	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip beFlap: true.	aStrip extent: (self currentWorld width @ 78).	aStrip submorphsDo: [ :ea | ea updateImage ].	^aFlapTab! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'T2 3/6/2005 00:12'!newConnectorsFlap	"Answer a newly-created flap which adheres to the left edge of the screen and which holds prototypes of Connectors parts."	"Flaps newConnectorsFlap openInWorld; setToPopOutOnDragOver: false."	|  aFlapTab aStrip |	aStrip _ self preferredConnectorsFlapBinClass		newPartsBinWithOrientation: #leftToRight andColor: (Color blue muchLighter alpha: 0.8) from: self quadsDefiningConnectorsFlap buttonClass: self preferredConnectorsButtonClass. 	aFlapTab _ FlapTab new referent: aStrip beSticky.	aFlapTab setName: 'Connectors' translated edge: #bottom color: Color blue muchLighter.	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip beFlap: true.	aStrip extent: (self currentWorld width @ 78).	aStrip submorphsDo: [ :ea | ea updateImage ].	^ aFlapTab! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'nk 9/1/2004 20:30'!newFSMConnectorsFlap	"Answer a newly-created flap which adheres to the left edge of the screen and which holds prototypes of Connectors parts relevant to FSM diagrams."	"Flaps newFSMConnectorsFlap openInWorld; setToPopOutOnDragOver: false."	|  aFlapTab aStrip  |	aStrip _ self preferredConnectorsFlapBinClass newPartsBinWithOrientation: #leftToRight  andColor: (Color blue muchLighter alpha: 0.8) from: self quadsDefiningFSMConnectorsFlap buttonClass: self preferredConnectorsButtonClass.	aStrip submorphs third		actionSelector: #startWiringLabeled: ;		arguments: { 'event' }.	aFlapTab _ FlapTab new referent: aStrip beSticky.	aFlapTab setName: 'FSM' edge: #bottom color: (Color blue muchLighter).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip beFlap: true.	aStrip extent: (self currentWorld width @ 78).	aStrip color: (Color blue muchLighter alpha: 0.8).	aStrip submorphsDo: [ :ea | ea updateImage ].	^ aFlapTab! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'KR 5/1/2008 10:10'!newNCPartsBinFlap	"Answer a newly-created flap which adheres to the left edge of the screen."	"Flaps newNCPartsBinFlap openInWorld; setToPopOutOnDragOver: false."	|  aFlapTab aStrip |	aStrip _ self preferredConnectorsFlapBinClass		newPartsBinWithOrientation: #topToBottom andColor: (Color orange muchLighter alpha: 0.8) from: #() buttonClass: self preferredConnectorsButtonClass. 	aFlapTab _ FlapTab new referent: aStrip beSticky.	aFlapTab setName: 'My Flap' translated edge: #left color: Color orange lighter.	aFlapTab position: (self currentWorld width - aFlapTab width) @ ((Display height - aFlapTab height) * 2 // 3).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip extent: (120 @ self currentWorld height).	aStrip beFlap: true.	aStrip color: (Color orange muchLighter alpha: 0.8).		^ aFlapTab! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'nk 6/12/2004 18:39'!preferredConnectorsButtonClass	^Smalltalk at: #NCMakerButton ifAbsent: [ IconicButton ]! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'nk 6/12/2004 18:38'!preferredConnectorsFlapBinClass	^Smalltalk at: #NCPartsBin ifAbsent: [ PartsBin ]! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'nk 4/30/2004 17:08'!quadsDefiningClassDiagramConnectorsFlap	"Answer a structure defining the items on the default Class Diagram flap"	"Flaps newClassDiagramConnectorsFlap openInWorld; setToPopOutOnDragOver: false."	^ #(	(NCLabelMorph newStandAlone 'Label' 'A label')	(NCSmartLabelMorph newStandAlone 'Smart Label' 'A label that positions itself')	(NCAAConnectorMorph	newDirectionalAssociation	'Association'	'A class association for UML Class Diagrams')	(NCAAConnectorMorph	newAssociation	'Association'	'A class association for UML Class Diagrams')	(NCAAConnectorMorph newGeneralizationRelationship	'Generalization' 'An inheritance (generalization) connection for UML Class Diagrams')	(NCAAConnectorMorph newImplementationRelationship 'Implementation' 'An implementation relationship for UML Class Diagrams')	(NCTextRectangleMorph newUMLClassSymbol 'Class' 'A UML class symbol')	(NCTextRectangleMorph newUMLClassSymbolWithTwoBlocks 'Class2' 'A UML class symbol')	(NCTextRectangleMorph newUMLClassSymbolWithThreeBlocks 'Class3' 'A UML class symbol')	(NCCompositeStateMorph newUMLPackage 'UML Package' 'A UML package shape')	(NCNoteMorph  newStandAlone 'Note' 'An annotation')	)! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'KR 5/11/2008 02:49'!quadsDefiningConnectorsFlap	"Answer a structure defining the items on the default Connectors flap"	^ #(	(NCLabelMorph newStandAlone 'Label' 'A label')	(NCSmartLabelMorph newStandAlone 'Smart Label' 'A label that positions itself')	(NCAAConnectorMorph	newStandAlone		'Connector'	'A basic connector')	(NCAAConnectorMorph	newWithArrow 'ConnectorArrow'	'A basic connector with an arrowhead')	(NCAAConnectorMorph	newCurvyConnector 'Curvy Connector'	'A basic curved connector')	(NCAAConnectorMorph	newCurvyArrow 'Curvy ConnectorArrow'	'A basic curved connector with an arrowhead')	(NCGrabbableDisplayTextMorph authoringPrototype 'Title' 'Display text that you can move')	(NCTextRectangleMorph new 'Text Rectangle' 'A rectangle with text, or a button')	(NCButtonBar newStandAlone 'ButtonBar' 'A buttonBar for customizing')	(NCMakerButton newStandAlone 'Maker Button' 'A handy Morph-generating button')	(NCBasicShapeMorph newStandAlone 'Basic Shape' 'A simple shape with a context menu')	(Flaps newNCPartsBinFlap 'New Button Flap' 'A new button flap')	(NCAttachmentPointAdjusterWindow newStandAlone 'AP Adjuster' 'This lets you adjust the attachment points on a dropped Morph')	) translatedNoop! !!Flaps class methodsFor: '*connectors-shapes-flaps' stamp: 'KR 5/11/2008 02:50'!quadsDefiningFSMConnectorsFlap	"Answer a structure defining the items on the default FSM flap"	"Flaps newFSMConnectorsFlap openInWorld; setToPopOutOnDragOver: false."	^ #(	(NCLabelMorph newStandAlone 'Label' 'A label')	(NCSmartLabelMorph newStandAlone 'Smart Label' 'A label that positions itself')	(NCAAConnectorMorph newStateTransition 'State Transition' 'A state transition for UML State Diagrams')	(NCTextRectangleMorph newStateSymbol 'State' 'A UML State shape')	(NCCompositeStateMorph newCompositeState 'Composite State' 'A UML composite state shape')	(NCScrolledCompositeStateMorph newStandAlone 'Scrolled State' 'A UML State shape with scrollbars')	(NCEllipseMorph newStartState 'Start State' 'A UML start state shape')	(NCEllipseMorph newEndState 'End State' 'A UML end state shape')	"(NCButtonBar newFSMToolbar 'FSM ButtonBar' 'A buttonBar for State Machine drawings')"	) translatedNoop! !!FlapTab methodsFor: 'positioning' stamp: 'sw 5/29/2009 18:47'!adjustPositionVisAVisFlap	"If appropriate, adjust the receiver's position vis-a-vis the flap."	| sideToAlignTo opposite |	(#(left right top bottom) includes: edgeToAdhereTo) ifTrue:		[opposite _ Utilities oppositeSideTo: edgeToAdhereTo.		sideToAlignTo _ inboard			ifTrue:	[opposite]			ifFalse:	[edgeToAdhereTo].		self perform: (Utilities simpleSetterFor: sideToAlignTo) with: (referent perform: opposite)]! !!FlapTab class methodsFor: 'scripting' stamp: 'bf 8/29/2010 16:21'!authoringPrototype	^self newStandAlone markAsPartsDonor! !!FlapTab class methodsFor: 'scripting' stamp: 'bf 8/29/2010 16:24'!descriptionForPartsBin	^ self partName: 	'Flap' translatedNoop		categories:		{'Scripting' translatedNoop}		documentation: self helpMessage! !!FlapTab class methodsFor: 'scripting' stamp: 'bf 8/29/2010 16:24'!helpMessage	^'A flap to hold objects. For example, you can add a description of your project, or keep versions of sketches for later use. Use the flap tab''s halo menu to adjust its properties.' translatedNoop! !!FlapTab class methodsFor: 'scripting' stamp: 'bf 8/29/2010 16:46'!newStandAlone	"Answer a suitable instance for use in a parts bin"	^(Flaps newFlapTitled: 'My Flap' translated onEdge: #bottom)		setBalloonText: self helpMessage translated! !!FlapTab class methodsFor: 'class initialization' stamp: 'bf 8/29/2010 16:17'!initialize	self registerInFlapsRegistry.! !!FlapTab class methodsFor: 'class initialization' stamp: 'bf 8/29/2010 16:49'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	Flaps registerQuad: {#FlapTab. #authoringPrototype. 'Flap' translatedNoop. self helpMessage}		forFlapNamed: 'Supplies'.! !!Float methodsFor: '*DrGeoII-Core-fixing' stamp: 'HilaireFernandes 1/16/2006 22:00'!arcTan2: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| result |	(self = 0.0) ifTrue: [ (denominator > 0.0) ifTrue: [ result := 0 ]										    ifFalse: [ result := Pi ]						]			    ifFalse: [(denominator = 0.0)					ifTrue: [ (self > 0.0) ifTrue: [ result := Halfpi ]												ifFalse: [ result := Halfpi negated ]							]					ifFalse: [ (denominator > 0) ifTrue: [ result := (self / denominator) arcTan ]								 ifFalse: [ (self > 0) ifTrue: [result := ((self / denominator) arcTan) + Pi ]															ifFalse: [result := ((self / denominator) arcTan) - Pi]											]							].						].		^ result.! !!Form methodsFor: 'other' stamp: 'bf 8/17/2009 13:08'!preMultiplyAlpha	"Pre-multiply each pixel by its alpha, for proper alpha compositing (BitBlt rule 34).	E.g., half-transparent green 16r7F00FF00 becomes 16r7F007F00"	depth = 32 ifFalse: [^self].	1 to: bits size do: [:i |		| v a r g b |		v := bits at: i.		a := v bitShift: -24.		r := ((v bitShift: -16) bitAnd: 255) * a // 255.		g := ((v bitShift: -8) bitAnd: 255) * a // 255.		b := (v bitAnd: 255) * a // 255.		bits at: i put: (a bitShift: 24) + (r bitShift: 16) + (g bitShift: 8) + b].! !!FTPClient methodsFor: 'private protocol' stamp: 'kzy 10/17/2009 23:05'!openPassiveDataConnection	| portInfo list dataPort remoteHostAddress |	self sendCommand: 'PASV'.	self lookForCode: 227 ifDifferent: [:response | (TelnetProtocolError protocolInstance: self) signal: 'Could not enter passive mode: ' , response].	portInfo := (self lastResponse findTokens: '()') at: 2.	list := portInfo findTokens: ','.	remoteHostAddress := NetNameResolver addressForName: (list at: 1)					, '.'					, (list at: 2) , '.'					, (list at: 3) , '.'					, (list at: 4) timeout: 30.	dataPort := (list at: 5) asNumber * 256 + (list at: 6) asNumber.	self openDataSocket: remoteHostAddress port: dataPort! !!FunctionNameTile methodsFor: 'choice of function' stamp: 'sw 6/25/2007 17:19'!options	"Answer the options of the tile for an arrow"	| aTable |	aTable := ScriptingSystem tableOfNumericFunctions reversed.	^ Array with:				(aTable collect: [:pr | pr first] ), #(grouped)			with:				(aTable collect: [:pr | pr second]), #(grouped)! !!FunctionNameTile methodsFor: 'choice of function' stamp: 'sw 6/10/2007 03:43'!setOperator: anOperatorSymbol	"The user chose an entry with the given inherent operator symbol (this may differ from what the user sees in the pop-up or on the tile."	| aTable |	operatorOrExpression := anOperatorSymbol.	operatorOrExpression = #grouped		ifTrue:			[self line1: ' '.			self setBalloonText: 'parenthesized' translated]		ifFalse:			[aTable := ScriptingSystem tableOfNumericFunctions.			(aTable detect: [:m | m second = anOperatorSymbol] ifNone: [nil]) ifNotNilDo:				[:aTriplet |					self line1: aTriplet first translated.					self setBalloonText: aTriplet third translated]].	self addArrows.	self scriptEdited.	self layoutChanged! !!FunctionNameTile methodsFor: 'choice of function' stamp: 'KR 10/30/2009 12:28'!showOptions	"Put up a pop-up menu of options for the operator tile within me."	| aMenu aTable |	aMenu := MenuMorph new defaultTarget: self.	aTable := ScriptingSystem tableOfNumericFunctions.	aTable do:		[:triplet |			aMenu add: triplet first translated target: self  selector:  #setOperator: argument: triplet second.			triplet second = operatorOrExpression ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: triplet third translated].	aMenu addTranslatedList:		#(-		('parentheses'  grouped 'enclose within parentheses')) translatedNoop.	operatorOrExpression = #grouped ifTrue:		[aMenu lastItem color: Color red].	(owner owner isKindOf: TilePadMorph) ifTrue:		[aMenu addLine.		operatorOrExpression = #grouped			ifFalse:							[aMenu addTranslatedList:					#(('remove function' removeFunction  'strip away the function call, leaving just its former argument in its place')) translatedNoop.]			ifTrue:				[aMenu addTranslatedList:					#(('remove parentheses' removeFunction  'strip away the parenthesises')) translatedNoop]].	aMenu position: self position.	aMenu invokeModal! !!FunctionNameTile methodsFor: 'code generation' stamp: 'sw 6/11/2007 02:37'!storeCodeOn: aStream indent: tabCount 	"Store the receiver's code on the stream, honoring indentation."	operatorOrExpression = #grouped		ifTrue:			[aStream nextPutAll: ' yourself']		ifFalse:			[super storeCodeOn: aStream indent: tabCount]! !!FunctionNameTile methodsFor: 'initialization' stamp: 'sw 6/20/2007 02:39'!operator: anOperator wording: aWording helpString: aHelpString	"Set the operator as per aString, and add up/down arrows"	type _ #operator.	operatorOrExpression _ anOperator asSymbol.	operatorOrExpression = #grouped		ifTrue:			[self line1: ' ']		ifFalse:			[self line1: aWording].	self addArrows..	aHelpString ifNotNil: [submorphs last setBalloonText: aHelpString]! !!FunctionNameTile methodsFor: 'menu commands' stamp: 'sw 6/10/2007 03:20'!grouped	"The user chose grouped from the menu.  Establish the special-case null function call."	self setOperator: #grouped! !!FunctionNameTile methodsFor: 'menu commands' stamp: 'sw 6/10/2007 01:40'!removeFunction	"Remove the function-call... this is forwarded to owner."	^ owner removeFunction! !!FunctionNameTile methodsFor: 'arrows' stamp: 'sw 6/25/2007 17:42'!arrowAction: delta 	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| index operatorList |	operatorList := self options second.	index _ (operatorList indexOf: self value) + delta.	self setOperator: (operatorList atWrap: index).	self scriptEdited.	self layoutChanged! !!FunctionNameTile commentStamp: 'sw 6/9/2007 22:25' prior: 0!An operator tile holding the name of a function; used in conjunction with a FunctionTile which is always its owner.!!FunctionTile methodsFor: 'code generation' stamp: 'yo 6/22/2007 01:05'!basicParseNodeWith: encoder	"Answer a message node for the receiver."	| sel rec ret |	sel _ submorphs first operatorOrExpression.	rec _ submorphs third parseNodeWith: encoder.	ret _ MessageNode new				receiver: rec				selector: sel				arguments: #()				precedence: (sel precedence)				from: encoder				sourceRange: nil.	^ self convertPrecedenceInParseNode: ret with: encoder.! !!FunctionTile methodsFor: 'code generation' stamp: 'yo 6/13/2007 13:49'!convertPrecedenceInParseNode: message with: encoder	| e r w list |	w _ WriteStream on: (Array new: 3).	message receiver eToysExpFlattenOn: w.	list _ w contents.	e _ EToyExpressionTransformer2 new newNodeFromList: list encoder: encoder.	r _ e transform.	message receiver: r.	^ message.! !!FunctionTile methodsFor: 'code generation' stamp: 'yo 6/22/2007 01:23'!convertPrecedenceOfArgsInParseNode: message with: encoder	| e r w list |	message arguments size > 0 ifTrue: [		w _ WriteStream on: (Array new: 3).		message arguments first  eToysExpFlattenOn: w.		list _ w contents.		e _ EToyExpressionTransformer2 new newNodeFromList: list encoder: encoder.		r _ e transform.		message arguments at: 1 put: r.		^ message.	] ifFalse: [		^ message.	].! !!FunctionTile methodsFor: 'code generation' stamp: 'yo 6/22/2007 01:23'!kedamaParseNodeWith: encoder actualObject: obj	| ret arg |	arg _ submorphs third parseNodeWith: encoder.	ret _ MessageNode new				receiver: (encoder encodePlayer: obj)				selector: #random:				arguments: (Array with: arg)				precedence: (#random: precedence)				from: encoder				sourceRange: nil.	^  self convertPrecedenceOfArgsInParseNode: ret with: encoder.! !!FunctionTile methodsFor: 'code generation' stamp: 'yo 6/22/2007 01:16'!parseNodeWith: encoder	| phrase player costume sel |	sel _ submorphs first operatorOrExpression.	sel == #random ifFalse: [^ self basicParseNodeWith: encoder].	phrase _ self outermostMorphThat: [:m| m isKindOf: PhraseTileMorph].	phrase ifNil: [^ self basicParseNodeWith: encoder].	player _ phrase associatedPlayer.	player ifNil: [^ self basicParseNodeWith: encoder].	costume _ player costume.	costume ifNil: [^ self basicParseNodeWith: encoder].	(player isKindOf: KedamaExamplerPlayer) ifTrue: [		^ self kedamaParseNodeWith: encoder actualObject: player costume renderedMorph kedamaWorld player].	(costume renderedMorph isMemberOf: KedamaMorph) ifTrue: [		^ self kedamaParseNodeWith: encoder actualObject: self].	^ self basicParseNodeWith: encoder.! !!FunctionTile methodsFor: 'code generation' stamp: 'yo 9/7/2007 13:51'!sexpWith: dictionary	| n elements sel |	sel _ submorphs first operatorOrExpression.	n _ SExpElement keyword: #send.	n attributeAt: #type put: ((owner isMemberOf: TilePadMorph) ifTrue: [owner type] ifFalse: ['Number']).	elements _ Array with: ((SExpElement keyword: #selector)					attributeAt: #selector put: sel; yourself)				with: (argumentPad sexpWith: dictionary).	n elements: elements.	^ n.! !!FunctionTile methodsFor: 'code generation' stamp: 'sw 6/10/2007 01:59'!storeCodeOn: aStream indent: tabCount 	"Store the receiver's code on the stream, honoring indentation."	aStream nextPut: $(.	aStream space.	argumentPad storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	aStream space.	functionNameTile storeCodeOn: aStream indent: tabCount! !!FunctionTile methodsFor: 'initialization' stamp: 'sw 6/8/2007 01:41'!initialize	"initialize the state of the receiver"	super initialize.	type := #function.	self minHeight: 30; vResizing: #spaceFill; borderWidth: 0! !!FunctionTile methodsFor: 'initialization' stamp: 'KR 9/21/2009 23:50'!operator: opSymbol pad: aTilePadMorph	"Set the operator and pad.  Builds and adds the four submorphs of the receiver		function-name, left-paren, argument-pad, right-paren."	| functionTriplet |	functionTriplet := ScriptingSystem tableOfNumericFunctions  detect: [:triplet | triplet second = opSymbol].  "If none, error..."	self operator: opSymbol wording: functionTriplet first  translated helpString: functionTriplet third translated pad: aTilePadMorph! !!FunctionTile methodsFor: 'initialization' stamp: 'sw 6/10/2007 01:56'!operator: opSymbol wording: aWording  helpString: aHelpString pad: aTilePadMorph	"Set the operator and pad.  Builds and adds the four submorphs of the receiver -- function-name, left-paren, argument-pad, right-paren."	argumentPad := aTilePadMorph.	self removeAllMorphs.	self vResizing: #shrinkWrap.	functionNameTile _ FunctionNameTile new.	functionNameTile operator: opSymbol wording: aWording helpString: aHelpString.	self addMorphFront: functionNameTile.	self addMorphBack: (ImageMorph new image: (ScriptingSystem formAtKey: #LeftParenthesis)).	self addMorphBack: aTilePadMorph.	self addMorphBack: (ImageMorph new image: (ScriptingSystem formAtKey: #RightParenthesis))! !!FunctionTile methodsFor: 'initialization' stamp: 'sw 6/12/2007 15:28'!replaceSubmorph: existingMorph by: newMorph	"Replace a submorph by a different morph.  If it's my pad, fix up my argumentPad inst var."	super replaceSubmorph: existingMorph by: newMorph.	(newMorph isKindOf: TilePadMorph) ifTrue: [argumentPad := newMorph].! !!FunctionTile methodsFor: 'menu' stamp: 'sw 6/23/2007 03:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add custom menu items to the menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self topEditor ifNotNil:		[aCustomMenu add: 'remove function' translated action: #removeFunctionWrapper]! !!FunctionTile methodsFor: 'menu' stamp: 'sw 6/5/2007 23:23  <  sw 6/2/2007 05:19'!removeFunction	"Unwrap the receiver from its contents."	self removeFunctionWrapper	! !!FunctionTile methodsFor: 'menu' stamp: 'sw 6/22/2007 14:19'!removeFunctionWrapper	"Remove the function wrapper"		| myPad |	(owner isNil or: [owner owner isNil]) ifTrue: [^ Beeper beep].  "Not in a line of script"	myPad _ submorphs third.	owner owner replaceSubmorph: owner by: myPad.	myPad scriptEdited! !!FunctionTile methodsFor: 'dropping/grabbing' stamp: 'sw 6/20/2008 23:44'!booleanComparatorPhrase	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase rel  |	rel := Vocabulary numberVocabulary comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: #Number argType: #Number.	outerPhrase firstSubmorph addMorph: self.	outerPhrase submorphs last addMorph: (ScriptingSystem tileForArgType: #Number).	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!FunctionTile methodsFor: 'dropping/grabbing' stamp: 'sw 6/20/2008 23:40'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	"Answer a phrase of the right type for the putative container"	| aTemporaryViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[aTemporaryViewer _ CategoryViewer new invisiblySetPlayer: aPlayer.		aPhrase _ aTemporaryViewer booleanPhraseFromPhrase: self.		aPhrase justGrabbedFromViewer: false.		^ aPhrase].	^ self! !!FunctionTile methodsFor: 'dropping/grabbing' stamp: 'sw 6/20/2008 23:53'!tileRows	"Answer a list of tile rows -- in this case exactly one row -- representing the receiver."	^ Array with: (Array with: self)! !!FunctionTile commentStamp: 'sw 6/10/2007 03:41' prior: 0!A scripting tile consisting of a function-name and an argument pad, and representing a call to a numeric function of a single argument.!!FunctionTile class methodsFor: 'scripting' stamp: 'KR 5/23/2008 01:28'!defaultNameStemForInstances	"Answer a good default name stem to use for names of instances"	^ 'Function' translatedNoop! !!FunctionTile class methodsFor: 'scripting' stamp: 'sw 6/22/2007 14:53'!randomNumberTile	"Answer a newly conjured-up random-number tile, suitable for handing to the user."	| functionPhrase argTile aPad |	functionPhrase _ FunctionTile new.	argTile := (Vocabulary vocabularyNamed: 'Number') defaultArgumentTile.	aPad := TilePadMorph new setType: #Number.	aPad addMorphBack: argTile.	functionPhrase operator: #random pad: aPad.	^ functionPhrase"FunctionTile randomNumberTile openInHand"! !!GetTextExporter methodsFor: 'private' stamp: 'Richo 5/25/2010 22:05'!appendStringReceivers: aSymbol into: domains	| literals references domainName methodReference keywords found |		found := TranslatedReceiverFinder new stringReceiversWithContext: aSymbol.	found do: [ :assoc |		methodReference := assoc key.		keywords := assoc value.		domainName := (PackageOrganizer default packageOfMethod: methodReference ifNone: [nil]).		domainName := domainName isNil ifTrue: [TextDomainManager defaultDomain] ifFalse: [domainName name].		literals _ domains at: domainName ifAbsentPut: [Dictionary new].		keywords do: [ :literal |			references _ literals at: literal ifAbsentPut: [OrderedCollection new].			references add: methodReference.		].	]. ! !!GetTextExporter methodsFor: 'private' stamp: 'Richo 5/17/2010 21:54'!appendVocabularies: domains	| literalsForDomain references domainName methodReference |		EToyVocabulary allPhrasesWithContextToTranslate do: [ :r |		methodReference :=  (MethodReference new setStandardClass: (r second) methodSymbol: (r third)).		"domainName _ self getTextDomainForPackage: (PackageOrganizer default packageOfMethod: methodReference)".		domainName := 'Etoys-Tiles'.		literalsForDomain _ domains at: domainName ifAbsentPut: [Dictionary new].		r fourth do: [ :literal |			references _ literalsForDomain at: literal ifAbsentPut: [OrderedCollection new].			references add: methodReference.		].	]. 	! !!GetTextExporter methodsFor: 'private' stamp: 'Richo 5/25/2010 22:05'!createExtraInformation	| extras |	extras := OrderedCollection new.	#(		'Language name as you''d like it to appear in the Languages menu' 'Language-Name'		'Directionality of language' 'Language-Direction'		) pairsDo: [:first :second |			extras add: (Array with: '' with: first with: second).	].	^ extras! !!GetTextExporter methodsFor: 'private' stamp: 'KR 12/7/2007 12:52'!createHeaders	| headers |	headers := OrderedCollection new.	headers add: 'Project-Id-Version' -> 'eToys'.	headers add: 'POT-Creation-Date' -> self currentDateAndTime.	headers add: 'PO-Revision-Date' -> self currentDateAndTime.	headers add: 'Last-Translator' -> ''.	headers add: 'Language-Team' -> ''.	headers add: 'MIME-Version' -> '1.0'.	headers add: 'Content-Type' -> ('text/plain; charset=', stream converter class encodingNames first).	headers add: 'Content-Transfer-Encoding' -> '8bit'.	headers add: 'X-Etoys-SystemVersion' -> (SystemVersion current asString).	^ headers! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:03'!currentDateAndTime	^ String		streamContents: [:aStream | 			aStream nextPutAll: Date today yyyymmdd;				space.			Time now				print24: true				showSeconds: false				on: aStream.			aStream nextPutAll: '-0000']! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:02'!exportHeaderLineKey: keyString value: valueString 	stream nextPut: $";		 nextPutAll: keyString;		 nextPut: $:;		 space;		 nextPutAll: valueString;		 nextPutAll: '\n';		 nextPut: $";		 cr.! !!GetTextExporter methodsFor: 'private' stamp: 'KR 9/28/2007 13:15'!exportHeader: domainName	| headers |	self exportTag: 'msgid' msg: ''.	self exportTag: 'msgstr' msg: ''.	headers := self createHeaders.	headers add: 'X-Etoys-Domain' -> domainName.	headers do: [:each | self exportHeaderLineKey: each key value: each value].	stream cr; cr! !!GetTextExporter methodsFor: 'private' stamp: 'yo 8/27/2008 14:25'!exportInformation: anOrderedCollection	anOrderedCollection do: [:each |		self exportRecordHeader: each second.		self exportPhrase: each third translation: ''].	stream cr.! !!GetTextExporter methodsFor: 'private' stamp: 'tak 10/2/2007 21:25'!exportPhrase: phraseString translation: translationString 	| normalizedTrans tmp transStartsWithCR transEndsWithCR|	phraseString isEmpty		ifTrue: [^ self].	self exportTag: 'msgid' msg: phraseString.	translationString size = 0 ifTrue: [		normalizedTrans _ ''	] ifFalse: [		transEndsWithCR _ translationString last = (Character cr).		phraseString last = (Character cr) ifTrue: [			transEndsWithCR ifTrue: [				normalizedTrans _ translationString			] ifFalse: [				normalizedTrans _  translationString , String cr			]		] ifFalse: [			transEndsWithCR ifTrue: [				normalizedTrans _ translationString allButLast			] ifFalse: [				normalizedTrans _ translationString			]		].		transStartsWithCR _ normalizedTrans first = (Character cr).		phraseString first = (Character cr) ifTrue: [			transStartsWithCR ifFalse: [				tmp _ (Character cr asString) , normalizedTrans.				normalizedTrans _ tmp.			]		] ifFalse: [			transStartsWithCR ifTrue: [				normalizedTrans _ normalizedTrans allButFirst			]		]	].	self exportTag: 'msgstr' msg: normalizedTrans.	stream cr! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/13/2007 13:19'!exportRecordHeader: context	stream 		nextPutAll: '#: ';		nextPutAll: context;		cr.! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:07'!exportTag: tag msg: aString 	| pos end line |	(aString indexOf: Character cr)			= 0		ifTrue: [self exportTag: tag singleLine: aString]		ifFalse: [self exportTag: tag singleLine: ''.			pos := 1.			end := 0.			[end < aString size]				whileTrue: [end := aString indexOf: Character cr startingAt: pos.					end = 0						ifTrue: [end := aString size].					line := aString copyFrom: pos to: end.					stream nextPut: $";												nextPutAll: (self formatString: line);						 nextPut: $";						 cr.					pos := end + 1]]! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:07'!exportTag: tag singleLine: aString 	stream nextPutAll: tag.	stream space.	stream nextPut: $".	stream		nextPutAll: (self formatString: aString).	stream nextPut: $".	stream cr! !!GetTextExporter methodsFor: 'private' stamp: 'Richo 5/25/2010 22:06'!export: literals translator: translator domain: domainName 	| fileName |	"Export a gettext file in a category. literals is a dictionary of keyword -> #(MethodReference...) in the textDomain."	fileName := self dirNameDomain: domainName translator: translator.	[stream := FileStream forceNewFileNamed: fileName.	stream lineEndConvention: #lf.	stream converter: UTF8TextConverter new.	self exportHeader: domainName.	domainName = TextDomainManager defaultDomain	ifTrue: [self exportInformation: self createExtraInformation].	self exportBody: literals translator: translator]		ensure: [stream close]! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:07'!formatReplacements	| replacements |	replacements := OrderedCollection new.	replacements add: '\' -> '\\'.	replacements add: String cr -> '\n'.	replacements add: String tab -> '\t'.	replacements add: '"' -> '\"'.	^ replacements! !!GetTextExporter methodsFor: 'private' stamp: 'KR 7/11/2007 13:08'!formatString: aString 	| result |	result := aString.	self formatReplacements		do: [:each | result := result copyReplaceAll: each key with: each value].	^ result! !!GetTextExporter methodsFor: 'private' stamp: 'bf 10/8/2007 14:25'!translationFor: aKey in: translator	translator ifNil: [^''].	translator translations at: aKey ifPresent: [:s | ^s].	"If we have old camelCase translations, make space-separated words"	translator translations at: aKey toCamelCase ifPresent: [:s | 		(s includes: Character space) ifTrue: [^s].		^s fromCamelCase].	^''! !!GetTextExporter methodsFor: 'exporting' stamp: 'KR 9/28/2007 13:16'!appendTranslations: domains 	self appendStringReceivers: #translated into: domains.	self appendStringReceivers: #translatedNoop into: domains.	self appendVocabularies: domains.! !!GetTextExporter methodsFor: 'exporting' stamp: 'bf 9/14/2007 19:30'!dirNameCategory: category translator: translator 	"Answer a file name for the category. Make one if it is not exist yet.	Make template file name if translator is nil"	"self new dirNameCategory: 'Morphic-Scripting Support' translator:	NaturalLanguageTranslator current"	"self new dirNameCategory: 'Morphic-Scripting Support' translator: nil"	| safeCategory fileName dirName pathName |	safeCategory := category copyReplaceAll: ' ' with: '_'.	fileName := translator				ifNil: [safeCategory , '.pot']				ifNotNil: [translator localeID posixName , '.po'].	dirName := (safeCategory findTokens: '-')				inject: 'po'				into: [:aString :next | aString , FileDirectory slash , next].	pathName := dirName , FileDirectory slash , fileName.	(FileDirectory default directoryNamed: dirName) assureExistence.	^ pathName! !!GetTextExporter methodsFor: 'exporting' stamp: 'KR 5/28/2010 01:16'!dirNameDomain: domain translator: translator 	"Answer a file name for the domain. Make one if it is not exist yet.	Make template file name if translator is nil"	"self new dirNameDomain: 'etoys' translator:	NaturalLanguageTranslator current"	"self new dirNameDomain: 'etoys' translator: nil"	| fileName dirName pathName |	"safeCategory := category copyReplaceAll: ' ' with: '_'."	fileName := domain, 						(translator							ifNil: ['.pot']							ifNotNil: ['.po']).	dirName := 'po', FileDirectory slash, 								(translator 										ifNil: ['templates'] 										ifNotNil: [translator localeID posixName]). 	pathName := dirName , FileDirectory slash , fileName.	(FileDirectory default directoryNamed: dirName) assureExistence.	^ pathName! !!GetTextExporter methodsFor: 'exporting' stamp: 'tak 7/23/2007 00:39'!exportTemplate	"GetTextExporter2 new exportTemplate"	self exportTranslator: nil! !!GetTextExporter methodsFor: 'exporting' stamp: 'KR 9/28/2007 13:14'!exportTranslator: translator 	"Export translation files. the file extention is 'po', or 'pot' if translator is nil "	"GetTextExporter2 new exportTranslator: NaturalLanguageTranslator current "	| domains |	domains := Dictionary new.	self appendTranslations: domains.	domains		keysAndValuesDo: [:domainName :value |			self				export: value				translator: translator				domain: domainName]! !!GetTextExporter methodsFor: 'file out' stamp: 'bf 10/8/2007 13:26'!exportBody: literals translator: translator 	"Export a gettext file body. literals is a dictionary of keyword ->	#(MethodReference...) in the textDomain."	"Build {sortKey. comment. msgid } to optimize sorting (getting category is	too slow).	If there are two or more methods for a mgsid, only first method	(alphabetical) is used for sorting."	| sorted msgid sortedMethods category sortKey comment triplets commentUnderLined |	triplets := literals associations				collect: [:assoc | 					msgid := assoc key.					sortedMethods := assoc value asArray sort.					category := (Smalltalk at: sortedMethods first classSymbol) category asString.					sortKey := category , ',' , sortedMethods first printString , ',' , msgid.					comment := (sortedMethods								collect: [:each | each actualClass asString , '>>' , each methodSymbol asString])								inject: category								into: [:result :methodName | result , ',' , methodName].					"Replace white spaces to _ because gettext tool might					replace a space to a new line some times, and it makes					difficult to take a diff."					commentUnderLined := comment copyReplaceAll: ' ' with: '_'.					Array						with: sortKey						with: commentUnderLined						with: msgid].	"Sort and output the words"	sorted := triplets				sort: [:a :b | a first <= b first].	sorted		do: [:triplet | 			comment := triplet second.			msgid := triplet third.			self exportRecordHeader: comment.			self				exportPhrase: msgid				translation: (self translationFor: msgid in: translator)]! !!GetTextExporter methodsFor: 'as yet unclassified' stamp: 'Richo 5/6/2010 17:55'!getTextDomainForPackage: aPackageInfo 	^TextDomainManager domainForPackage: aPackageInfo! !!GetTextExporter methodsFor: 'accessing' stamp: 'tak 10/2/2007 15:53'!stream	^ stream! !!GetTextExporter methodsFor: 'accessing' stamp: 'tak 10/2/2007 15:53'!stream: aStream	stream := aStream! !!GetTextExporter commentStamp: '<historical>' prior: 0!Export translations to gettext format divided into categories."Export gettext template files"GetTextExporter new exportTemplate."Export translation files for current locale"GetTextExporter new exportTranslator: (InternalTranslator newLocaleID: LocaleID current)."Export all gettext template and po files."GetTextExporter exportAll.!!GetTextExporter class methodsFor: 'utilities' stamp: 'tak 10/18/2007 21:14'!coverageStatus	"self coverageStatus"	| keys diff |	keys := self keys.	diff := InternalTranslator allKnownPhrases keys difference: keys.	Transcript cr; show: 'Detected keywords by GetTextExporter2: ' , keys size printString.	Transcript cr; show: 'All known phrases in InternalTranslator: ' , InternalTranslator allKnownPhrases size printString.	Transcript cr; show: 'Coverage: ' , (keys size / InternalTranslator allKnownPhrases size * 100.0) printString , '%'.	diff inspect! !!GetTextExporter class methodsFor: 'utilities' stamp: 'tak 10/18/2007 21:14'!exportAll	"GetTextExporter2 exportAll"	self new exportTemplate.	InternalTranslator availableLanguageLocaleIDs		do: [:each | self new exportTranslator: each translator]! !!GetTextExporter class methodsFor: 'utilities' stamp: 'tak 9/16/2007 14:04'!exportTemplate	"GetTextExporter2 exportTemplate"	self new exportTemplate.! !!GetTextExporter class methodsFor: 'utilities' stamp: 'Richo 5/25/2010 21:56'!keys	| categories |	categories := Dictionary new.	self new appendTranslations: categories.	^ categories values		inject: Set new		into: [:set :next | set addAll: next keys;				 yourself]! !!GetTextExporter class methodsFor: 'utilities' stamp: 'tak 7/25/2007 13:57'!listAllHelp	"self listAllHelp"	| spec specs oCatalog flap flapSelectors allKeys oCatalogHelp flapHelp |	oCatalog := Dictionary new.	Morph withAllSubclasses		do: [:aClass | (aClass class includesSelector: #descriptionForPartsBin)				ifTrue: [spec := aClass descriptionForPartsBin.					oCatalog at: spec formalName put: spec documentation]].	Morph withAllSubclasses		do: [:aClass | (aClass class includesSelector: #supplementaryPartsDescriptions)				ifTrue: [specs := aClass supplementaryPartsDescriptions.					specs						do: [:each | oCatalog at: each formalName put: each documentation]]].	flap := Dictionary new.	flapSelectors := #(#defaultsQuadsDefiningPlugInSuppliesFlap #defaultsQuadsDefiningStackToolsFlap #defaultsQuadsDefiningSuppliesFlap #defaultsQuadsDefiningToolsFlap #defaultsQuadsDefiningWidgetsFlap #defaultsQuadsDefiningScriptingFlap ).	flapSelectors		do: [:selector | 			specs := Flaps perform: selector.			specs				do: [:each | flap at: each third put: each fourth]].	allKeys := oCatalog keys intersection: flap keys.	allKeys asArray sort		do: [:each | 			oCatalogHelp := oCatalog						at: each						ifAbsent: [''].			flapHelp := flap						at: each						ifAbsent: [''].			oCatalogHelp = flapHelp				ifFalse: [Transcript cr; show: 'Name: ' , each.					Transcript cr; show: 'O: ' , oCatalogHelp.					Transcript cr; show: 'F: ' , flapHelp.					Transcript cr.]]! !!GetTextExporter class methodsFor: 'utilities' stamp: 'Richo 5/25/2010 21:56'!verifyExport	"Same as #verifyMsgID: but it writes / reads .po files actually"	"GetTextExporter2 verifyExport"	"InternalTranslator removeLocaleID: (LocaleID isoString: 'test-US')"	| src dst localeID |	localeID := LocaleID isoString: 'test-US'.	self verifyMsgID: localeID.	src := localeID translator.	self new exportTranslator: src.	InternalTranslator removeLocaleID: localeID.	dst := localeID translator.	GetTextImporter import: dst allDirectory: FileDirectory default! !!GetTextExporter class methodsFor: 'utilities' stamp: 'tak 10/18/2007 21:14'!verifyMsgID: localeID 	"GetTextExporter2 verifyMsgID: (LocaleID isoString: 'test-US')"	"InternalTranslator removeLocaleID: (LocaleID isoString: 'test-US')"	"Test gettext keyword extract function without file I/O.	A language named <langName> will be made. And	all possible translated words are shown with extra X charactor like	'XwordX' in the language."	| src |	InternalTranslator removeLocaleID: localeID.	src := localeID translator.	self keys		do: [:key | src generics at: key put: 'X' , key , 'X']! !!GetTextImporter methodsFor: 'initialize-release' stamp: 'tak 11/7/2006 00:32'!initialize	msgId := ''.	msgStr := ''.	state := nil! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 11/7/2006 00:28'!appendId: aString 	msgId := msgId , aString! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 11/7/2006 00:28'!appendStr: aString 	msgStr := msgStr , aString! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 8/6/2007 12:23'!parse	| size |	size := (stream isKindOf: FileStream)				ifTrue: [stream size]				ifFalse: [1].	ProgressInitiationException		display: 'Importing phrases from a gettext file.'		during: [:bar | [stream atEnd]				whileFalse: [| line | 					line := stream upTo: Character linefeed.					self						parseLine: ((line endsWith: String cr)								ifTrue: [line allButLast]								ifFalse: [line]).					bar value: stream position / size]].	self storeTranslation! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 7/22/2007 23:08'!parseLine: lineString 	(lineString beginsWith: '"Content-Type:')		ifTrue: [self setContentType: lineString.			^ self].	(lineString beginsWith: '#')		ifTrue: ["do nothing"			^ self].	lineString = ''		ifTrue: [^ self storeTranslation].	(lineString beginsWith: 'msgid')		ifTrue: [state := #appendId:.			self parseMsg: lineString.			^ self].	(lineString beginsWith: 'msgstr')		ifTrue: [state := #appendStr:.			self parseMsg: lineString.			^ self].	self parseMsg: lineString! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 11/8/2006 14:42'!parseMsg: lineString 	| begin end msg |	begin := lineString indexOf: $".	end := lineString lastIndexOf: $".	msg := begin + 1 <= (end - 1)				ifTrue: [lineString copyFrom: begin + 1 to: end - 1]				ifFalse: [''].	state		ifNotNil: [self perform: state with: msg].	^ msg! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 3/22/2006 15:10'!setContentType: lineString 	"self new setContentType: 'Content-Type: text/plain; charset=utf-8'"	| reader charSet |	reader := lineString readStream.	reader upTo: $=.	charSet := reader upTo: $\.	stream		converter: (TextConverter newForEncoding: charSet)! !!GetTextImporter methodsFor: 'parsing' stamp: 'tak 10/18/2007 21:15'!storeTranslation	| key |	key := self formatString: msgId.	msgId isEmpty		ifFalse: [InternalTranslator registerPhrase: key.			msgStr isEmpty				ifFalse: [language						rawPhrase: key						translation: (self formatString: msgStr)]].	self initialize! !!GetTextImporter methodsFor: 'private' stamp: 'tak 11/8/2006 14:33'!formatString: aString "	self assert: (GetTextImporter new formatString: 'test') = 'test'.	self assert: (GetTextImporter new formatString: 'te\nst') = ('te', String cr, 'st').	self assert: (GetTextImporter new formatString: 'te\\nst') = ('te\nst').	self assert: (GetTextImporter new formatString: 'te\\st') = ('te\st').	self assert: (GetTextImporter new formatString: 'te\st') = ('te\st')."	| reader writer char |	reader := aString readStream.	writer := '' writeStream.	[reader atEnd]		whileFalse: [char := reader next.			(char = $\					and: [reader atEnd not])				ifTrue: [char := reader next.					char caseOf: {						[$n] -> [writer nextPut: Character cr].						[$t] -> [writer nextPut: Character tab].						[$"] -> [writer nextPut: $"].						[$\] -> [writer nextPut: $\]}						 otherwise: [writer nextPutAll: {$\. char}]]				ifFalse: [writer nextPut: char]].	^ writer contents! !!GetTextImporter methodsFor: 'importing' stamp: 'tak 10/24/2007 12:46'!importID: localeID fileNamed: fileName	| currentPlatform |	language := InternalTranslator newLocaleID: localeID.	currentPlatform := Locale currentPlatform.	[Locale		currentPlatform: (Locale localeID: localeID).	[stream := FileStream readOnlyFileNamed: fileName.	stream text.	self parse]		ensure: [stream notNil				ifTrue: [stream close]]]		ensure: [Locale currentPlatform: currentPlatform].	NaturalLanguageTranslator privateStartUp "Actually it is not private no more...".! !!GetTextImporter methodsFor: 'importing' stamp: 'tak 9/27/2007 12:09'!import: aLanguage 	^ self import: aLanguage fileNamed:  aLanguage localeID posixName , '.po'! !!GetTextImporter methodsFor: 'importing' stamp: 'tak 10/24/2007 11:03'!import: aLanguage fileNamed: fileName	self importID: aLanguage localeID fileNamed: fileName! !!GetTextImporter commentStamp: 'tak 10/24/2007 11:23' prior: 0!GetTextImporter load gettext po file into a InternalTranslator.GetTextImporter new importID: (LocaleID isoString: 'lang-name') fileNamed: 'lang.po'!!GetTextImporter class methodsFor: 'utilities' stamp: 'tak 10/18/2007 21:14'!cleanUpUnnecessaryPhrases	| keys refuse replaceBlock reader writer char result |	"GetTextImporter cleanUpUnnecessaryPhrases"	""	"Collect wrong phrases"	keys := InternalTranslator allKnownPhrases copy keys.	refuse := Set new.	"replaceBlock value: 'te\\nst'."	replaceBlock := [:aString | 			reader := aString readStream.			writer := '' writeStream.			[reader atEnd]				whileFalse: [char := reader next.					(char = $\							and: [reader peek = $\])						ifFalse: [writer nextPut: char]].			writer contents].	keys		do: [:each | 			result := replaceBlock value: each.			(result ~= each					and: [keys includes: result])				ifTrue: [refuse add: each].			result := GetTextImporter new formatString: each.			(result ~= each					and: [keys includes: result])				ifTrue: [refuse add: each]].	""	"Remove from translated"	InternalTranslator cachedTranslations		do: [:each | refuse				do: [:key | each translations						removeKey: key						ifAbsent: []]].	""	"Remove from untranslated"	refuse		do: [:key | InternalTranslator allKnownPhrases				removeKey: key				ifAbsent: []]! !!GetTextImporter class methodsFor: 'utilities' stamp: 'tak 10/18/2007 21:14'!importAll	"GetTextImporter importAll"	"Import all gettext files on po/. Only registered language is imported"	InternalTranslator cachedTranslations		do: [:translator | self import: translator allDirectory: FileDirectory default]! !!GetTextImporter class methodsFor: 'utilities' stamp: 'tak 8/6/2007 12:12'!import: translator allDirectory: aFileDirectory 	"self import: NaturalLanguageTranslator current allDirectory:	FileDirectory default"	| fileName targetFile |	fileName := translator localeID posixName , '.po'.	(FileDirectory default directoryNamed: 'po')		withAllSubdirectoriesCollect: [:each | (each fileExists: fileName)				ifTrue: [targetFile := each fullNameFor: fileName.					self new import: translator fileNamed: targetFile]]! !!GetTextInterchange methodsFor: 'private' stamp: 'tak 8/6/2007 12:12'!defaultFileName	^ language localeID posixName , '.po'! !!GetTextInterchange methodsFor: 'accessing' stamp: 'tak 3/23/2006 13:52'!language: translator	language _ translator! !!GetTextInterchange methodsFor: 'accessing' stamp: 'tak 3/23/2006 13:53'!stream	^ stream! !!GetTextInterchange methodsFor: 'accessing' stamp: 'tak 3/23/2006 13:52'!stream: aStream	stream _ aStream! !!GetTextTranslator methodsFor: 'accessing' stamp: 'yo 8/28/2008 13:16'!atRandom	| v |	moFiles ifEmpty: [^ ''].	(v := moFiles atRandom value) ifNil: [^ ''].	^ v atRandom.! !!GetTextTranslator methodsFor: 'accessing' stamp: 'KR 10/23/2007 19:16'!domainRegistered: aDomainName	"only current translator actually load the MO, to minimize loading time.	 other translator will load anyway when it goes current"	(self class current == self) 		ifTrue: [self moFileForDomain: aDomainName].	! !!GetTextTranslator methodsFor: 'accessing' stamp: 'KR 10/23/2007 18:44'!domainUnregistered: aDomainName	moFiles removeKey: aDomainName ifAbsent: [^self]	! !!GetTextTranslator methodsFor: 'accessing' stamp: 'KR 10/30/2007 18:38'!isDomainLoaded: aDomainName	| mo |	mo _ moFiles at: aDomainName ifAbsent: [nil].	^mo isNil not.! !!GetTextTranslator methodsFor: 'accessing' stamp: 'KR 10/16/2007 20:58'!loadMOFiles	TextDomainManager allKnownDomains 		do: [:domainName |			self moFileForDomain: domainName		].! !!GetTextTranslator methodsFor: 'accessing' stamp: 'KR 10/5/2007 00:39'!reloadMOFiles	moFiles _ Dictionary new.	self loadMOFiles.! !!GetTextTranslator methodsFor: 'initialize-release' stamp: 'KR 10/3/2007 19:43'!initialize	moFiles _ Dictionary new.! !!GetTextTranslator methodsFor: 'language switching' stamp: 'KR 10/17/2007 02:00'!setCurrent	"ensure actual contents of MOs is loaded on switching language"	self loadMOFiles! !!GetTextTranslator methodsFor: 'translation' stamp: 'tak 10/19/2007 13:38'!translate: aString inDomain: aDomainName	| mo |	mo _ self moFileForDomain: aDomainName.	^mo isNil 		ifTrue: [aString] 		ifFalse: [mo translationFor: aString]! !!GetTextTranslator methodsFor: 'private' stamp: 'KR 10/17/2007 03:20'!loadMOFileForDomain: aDomainName	| moName |	moName _ self class findMOForLocaleID: self localeID 								domain: aDomainName.	moName notNil			 ifTrue: [^MOFile new load: moName								localeID: self localeID]			ifFalse: [^nil]! !!GetTextTranslator methodsFor: 'private' stamp: 'KR 10/3/2007 19:46'!moFileForDomain: domainName	^moFiles at: domainName ifAbsentPut: [self loadMOFileForDomain: domainName]! !!GetTextTranslator commentStamp: '<historical>' prior: 0!emulation of gettext runtimeKnown limitation:       currently doesn't support plural forms.!!GetTextTranslator class methodsFor: 'accessing' stamp: 'tak 10/24/2007 12:35'!availableLanguageLocaleIDs	"GetTextTranslator availableLanguageLocaleIDs"	| ids dirs localeDirForLang directoryNames |	ids := Set new.	dirs := Set new.	dirs addAll: LocaleDirsForDomain values.	dirs addAll: self defaultLocaleDirs.	dirs do: [:dir |		| localesDir |		localesDir := FileDirectory on: dir. 		directoryNames := [localesDir directoryNames] on: InvalidDirectoryError do: [:e | #()].		directoryNames				do: [:langDirName | 					| localeID  |					localeID := LocaleID posixName: langDirName.					localeDirForLang := localesDir directoryNamed: (self langDirNameForLocaleID: localeID).					localeDirForLang ifNotNil: [						(localeDirForLang fileNamesMatching: '*.mo') ifNotEmpty: [ids add: localeID]					]				].	].	^ids! !!GetTextTranslator class methodsFor: 'class initialization' stamp: 'KR 12/19/2007 12:29'!initialize	SystemDefaultLocaleDirs _ OrderedCollection new.	UserDefaultLocaleDirs _ OrderedCollection new.	LocaleDirsForDomain _ Dictionary new.! !!GetTextTranslator class methodsFor: 'class initialization' stamp: 'KR 12/19/2007 12:32'!privateStartUp	self setupLocaleDirs.	self availableLanguageLocaleIDs do: [ :localeID |		NaturalLanguageTranslator translators 				at: localeID 				put: (self newForLocaleID: localeID).	]! !!GetTextTranslator class methodsFor: 'instance creation' stamp: 'KR 10/16/2007 20:56'!newForLocaleID: id	^self new localeID: id! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 12/19/2007 11:46'!addSystemDefaultLocaleDir: dir	"new dir will be put as first" 	self systemDefaultLocaleDirs addFirst: dir! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 10/16/2007 20:38'!defaultLocaleDirs	| dirs |	dirs _ OrderedCollection new.	UserDefaultLocaleDirs ifNotNil: [dirs addAll: UserDefaultLocaleDirs].	dirs addAll: self systemDefaultLocaleDirs.	^dirs! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 10/16/2007 20:29'!localeDirForDomain: aDomainName	"returns registered localeDirectory for the textdomain. returns nil if not registered"	^LocaleDirsForDomain at: aDomainName ifAbsent: [nil]! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 10/16/2007 20:30'!localeDirsForDomain: aDomainName	"returns collection of locale directories for text domain.  	This includes user defined one for the domain, user defaults and system defaults" 	| dirs dir |	dirs _ OrderedCollection new.	dir _ self localeDirForDomain: aDomainName.	dir ifNotNil: [dirs add: dir].	dirs addAll:  self defaultLocaleDirs.	^dirs! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 10/16/2007 20:50'!setLocaleDir: path forDoamin: aDomainName	self LocaleDirsForDomain		at: aDomainName		put: path.! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'tak 2/12/2008 10:48'!setupLocaleDirs	| dirs sepa localesDirName |	sepa := FileDirectory slash.	SystemDefaultLocaleDirs := nil.	dirs := self systemDefaultLocaleDirs.	localesDirName := 'locale'.	dirs add:  (SmalltalkImage current imagePath) , sepa , localesDirName.	dirs add:  (SmalltalkImage current vmPath) , sepa , localesDirName.	^dirs! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 12/19/2007 12:31'!systemDefaultLocaleDirs	^SystemDefaultLocaleDirs ifNil: [SystemDefaultLocaleDirs := OrderedCollection new]! !!GetTextTranslator class methodsFor: 'translation data layout' stamp: 'KR 10/16/2007 20:40'!userDefaultLocaleDirs	^UserDefaultLocaleDirs ifNil: [UserDefaultLocaleDirs := OrderedCollection new]! !!GetTextTranslator class methodsFor: 'private' stamp: 'tak 10/25/2007 15:56'!findMOForLocaleID: id domain: aDomainName	| sepa langSubDir path |	sepa _ FileDirectory slash.	langSubDir _ self langDirNameForLocaleID: id.	(self localeDirsForDomain: aDomainName)		do: [:each |			path _ each , sepa , langSubDir, sepa , (self moNameForDomain: aDomainName).			[(FileDirectory default fileExists: path)				 ifTrue: [^path]] on: InvalidDirectoryError do: [:e | ^nil]].	^nil.! !!GetTextTranslator class methodsFor: 'private' stamp: 'KR 10/16/2007 20:32'!langDirNameForLocaleID: id	"returns relative path from locale directory to actual directory containing MOs"	^(id posixName) , (FileDirectory slash)  , 'LC_MESSAGES'! !!GetTextTranslator class methodsFor: 'private' stamp: 'KR 10/16/2007 20:36'!localeDirsForDomain	^LocaleDirsForDomain ifNil: [LocaleDirsForDomain _ Dictionary new]! !!GetTextTranslator class methodsFor: 'private' stamp: 'KR 10/16/2007 19:40'!moNameForDomain: domainName	^domainName , '.mo'! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'wiz 11/13/2008 21:36'!readBitData	"using modified Lempel-Ziv Welch algorithm."	| outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar i bytes f c packedBits hasLocalColor localColorSize maxOutCodes |	maxOutCodes _ 4096.	offset := self readWord@self readWord. "Image Left@Image Top"	width _ self readWord.	height _ self readWord.	"---	Local Color Table Flag        1 Bit	Interlace Flag                1 Bit	Sort Flag                     1 Bit	Reserved                      2 Bits	Size of Local Color Table     3 Bits	----"	packedBits _ self next.	interlace _ (packedBits bitAnd: 16r40) ~= 0.	hasLocalColor _ (packedBits bitAnd: 16r80) ~= 0.	localColorSize _ 1 bitShift: ((packedBits bitAnd: 16r7) + 1).	hasLocalColor ifTrue: [localColorTable _ self readColorTable: localColorSize].	pass _ 0.	xpos _ 0.	ypos _ 0.	rowByteSize _ ((width + 3) // 4) * 4.	remainBitCount _ 0.	bufByte _ 0.	bufStream _ ReadStream on: ByteArray new.	outCodes _ ByteArray new: maxOutCodes + 1.	outCount _ 0.		prefixTable _ Array new: 4096.	suffixTable _ Array new: 4096.	initCodeSize _ self next.	bitMask _ (1 bitShift: initCodeSize ) - 1.	self setParameters: initCodeSize.	bitsPerPixel > 8 ifTrue: [^self error: 'never heard of a GIF that deep'].	bytes _ ByteArray new: rowByteSize * height.	[(code _ self readCode) = eoiCode] whileFalse:		[code = clearCode			ifTrue:				[self setParameters: initCodeSize.				curCode _ oldCode _ code _ self readCode.				finChar _ curCode bitAnd: bitMask.				"Horrible hack to avoid running off the end of the bitmap.  Seems to cure problem reading some gifs!!? tk 6/24/97 20:16"				xpos = 0 ifTrue: [						ypos < height ifTrue: [							bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar]]					ifFalse: [bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar].				self updatePixelPosition]			ifFalse:				[curCode _ inCode _ code.				curCode >= freeCode ifTrue:					[curCode _ oldCode.					outCodes at: (outCount _ outCount + 1) put: finChar].				[curCode > bitMask] whileTrue:					[outCount > maxOutCodes						ifTrue: [^self error: 'corrupt GIF file (OutCount)'].					outCodes at: (outCount _ outCount + 1)						put: (suffixTable at: curCode + 1).					curCode _ prefixTable at: curCode + 1].				finChar _ curCode bitAnd: bitMask.				outCodes at: (outCount _ outCount + 1) put: finChar.				i _ outCount.				[i > 0] whileTrue:					["self writePixel: (outCodes at: i) to: bits"					bytes at: (ypos * rowByteSize) + xpos + 1 put: (outCodes at: i).					self updatePixelPosition.					i _ i - 1].				outCount _ 0.				prefixTable at: freeCode + 1 put: oldCode.				suffixTable at: freeCode + 1 put: finChar.				oldCode _ inCode.				freeCode _ freeCode + 1.				self checkCodeSize]].	prefixTable _ suffixTable _ nil.	f _ ColorForm extent: width@height depth: 8.	f bits copyFromByteArray: bytes.	"Squeak can handle depths 1, 2, 4, and 8"	bitsPerPixel > 4 ifTrue: [^ f].	"reduce depth to save space"	c _ ColorForm extent: width@height		depth: (bitsPerPixel = 3 ifTrue: [4] ifFalse: [bitsPerPixel]).	f displayOn: c.	^ c! !!GoldBoxMenu methodsFor: 'initialization' stamp: 'KR 10/3/2009 09:27'!initializeFor: aScriptor	"Answer a graphical menu to be put up in conjunction with the Gold Box"	| aButton goldBox aReceiver boxBounds example toScale |	scriptor _ aScriptor.	lastItemMousedOver _ nil.	self removeAllMorphs.	self setProperty: #goldBox toValue: true.	self listDirection: #topToBottom;		hResizing: #spaceFill; extent: 1@1; vResizing: #spaceFill. "standard #newColumn stuff"	self setNameTo: 'Gold Box' translated.	self useRoundedCorners.	self color: Color white.	self borderColor:  (Color r: 1.0 g: 0.839 b: 0.065).	self hResizing: #shrinkWrap; vResizing: #shrinkWrap; borderWidth: 4.	{	{ScriptingSystem. #yesNoComplexOfTiles.  'test' translated. 'Test/Yes/No panes for testing a condition.'  translated}.	{ScriptingSystem. #timesRepeatComplexOfTiles. 'repeat'  translated.  'TimesRepeat panes for running a section of code repeatedly.'  translated}.	{ ScriptingSystem.	#randomNumberTile.	 'random'  translated.		'A tile that will produce a random number in a given range.'  translated}.	{ ScriptingSystem.	#seminalFunctionTile.	 'function'  translated.		'A tile representing a function call.  Click on the function name or the arrows to change functions.'  translated}.	{ScriptingSystem.	#buttonUpTile.	 'button up?'  translated.		'Reports whether the mouse button is up'  translated}.	{ScriptingSystem.	#buttonDownTile.	 'button down?'  translated.		'Reports whether the mouse button is down'  translated}.	{scriptor playerScripted. #tileToRefer.  'tile for me'  translated. 'A tile representing the object being scripted'  translated}.	{self.  #numericConstantTile.  'number'  translated.   'A tile holding a plain number'  translated}.} do:		[:tuple |			aReceiver _ tuple first.			example := aReceiver perform: tuple second.						aButton := IconicButton new target: aReceiver.			aButton borderWidth: 0;				color: Color transparent.			toScale := tuple size >= 5				ifTrue:					[tuple first perform: tuple fifth]  "bail-out for intractable images."				ifFalse:					[example imageForm].			aButton labelGraphic: (toScale copy scaledToHeight: 40).			aButton actionSelector: #launchPartOffsetVia:label:.			aButton arguments: {tuple second.  tuple third}.			(tuple size > 3 and: [tuple fourth isEmptyOrNil not]) ifTrue:				[aButton setBalloonText: tuple fourth].			aButton actWhen: #buttonDown.			aButton on: #mouseEnter send: #mousedOverEvent:button:  to: self.			aButton on: #click send: #delete to: self. 			self addMorphBack: aButton].	goldBox _ aScriptor submorphs first submorphThat: [:m | (m isKindOf: SimpleButtonMorph) and: [m actionSelector == #offerGoldBoxMenu]] ifNone: [nil].	goldBox		ifNil:			[self position: ActiveHand position]		ifNotNil:			[boxBounds _ goldBox boundsInWorld.			self center: boxBounds center.			self left: (boxBounds center x - (self width // 2)).			self top: boxBounds bottom].	lastItemMousedOver _ nil.	self on: #mouseLeave send: #mouseLeftMenuWithEvent: to: self.	self on: #mouseLeaveDragging send: #delete to: self.! !!GrabPatchMorph methodsFor: 'initialization' stamp: 'sw 8/3/2009 22:34'!initialize	"Initialize the receiver.  Emblazon the GrabPatch icon on its face"	super initialize.	self image: (ScriptingSystem formAtKey: 'GrabPatch').	self setProperty: #ignorePartsBinDrop toValue: true! !!GrabPatchMorph methodsFor: 'initialization'!justTornOffFromPartsBin	super justTornOffFromPartsBin.	self image: (Form extent: 0 @ 0).	"hide the icon"	ActiveHand showTemporaryCursor: Cursor crossHair! !!GrabPatchMorph methodsFor: 'dropping'!justDroppedInto: aPasteUpMorph event: anEvent 	"The user clicked, to indicate one corner of the patch to be grabbed..."	self delete.	ActiveHand showTemporaryCursor: nil.	ActiveWorld displayWorldSafely; runStepMethods.	^ ActiveWorld grabDrawingFromScreen: anEvent! !!GStreamer methodsFor: 'pads' stamp: 'JMM 11/27/2008 22:27'!callbackSignalSeenForIndex: aIndex	^self primcallbacksignalseenfor: aIndex! !!GStreamer methodsFor: 'pads' stamp: 'JMM 3/19/2008 20:26'!linkElementSrc: srcElement toDest: destElement filtered: caps	"Links src to dest using the given caps as filtercaps. The link must be from source to destination; the other direction will not be tried. The function looks for existing pads that aren't linked yet. It will request new pads if necessary. If multiple links are possible, only one is established.Make sure you have added your elements to a bin or pipeline with gst_bin_add() before trying to link them."	^self primgstelementlinkfiltered: srcElement handle dest: destElement handle filtered: caps handle"Returns:TRUE if the pads could be linked, FALSE otherwise."! !!GStreamer methodsFor: 'system primitives' stamp: 'JMM 11/27/2008 22:26'!primcallbacksignalseenfor: aIndex	<primitive: 'primitivecallbacksignalseenfor' module: 'GStreamerPlugin'>	self primitiveFailed! !!GStreamer commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.phpThe MIT LicensePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.!!GStreamerBin commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerBus methodsFor: 'accessing' stamp: 'JMM 3/18/2008 21:42'!havePending"Check if there are pending messages on the bus that should be handled.bus:a GstBus to checkReturns:TRUE if there are messages on the bus to be handled, FALSE otherwise. MT safe."	^self primgstbushavepending: self handle.! !!GStreamerBus methodsFor: 'accessing' stamp: 'JMM 3/18/2008 21:42'!peek"Peek the message on the top of the bus' queue. The message will remain on the bus' message queue. A reference is returned, and needs to be unreffed by the caller.bus:a GstBusReturns:The GstMessage that is on the bus, or NULL if the bus is empty. MT safe."	| data |	data := self primgstbuspeek: self handle.	data = 0 ifTrue: [^nil].	^GStreamerMessage handle: data! !!GStreamerBus methodsFor: 'accessing' stamp: 'JMM 3/18/2008 21:43'!pop"Get a message from the bus.bus:a GstBus to popReturns:The GstMessage that is on the bus, or NULL if the bus is empty. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage. MT safe."	| data |	data := self primgstbuspop: self handle.	data = 0 ifTrue: [^nil].	^GStreamerMessage handle: data! !!GStreamerBus methodsFor: 'accessing' stamp: 'JMM 3/18/2008 21:44'!popFilter: aMessageType	| data |	data := self primgstbuspop: self handle filter: aMessageType.	data = 0 ifTrue: [^nil].	^GStreamerMessage handle: data"typedef enum{  GST_MESSAGE_UNKNOWN           = 0,  GST_MESSAGE_EOS               = (1 << 0),  GST_MESSAGE_ERROR             = (1 << 1),  GST_MESSAGE_WARNING           = (1 << 2),  GST_MESSAGE_INFO              = (1 << 3),  GST_MESSAGE_TAG               = (1 << 4),  GST_MESSAGE_BUFFERING         = (1 << 5),  GST_MESSAGE_STATE_CHANGED     = (1 << 6),  GST_MESSAGE_STATE_DIRTY       = (1 << 7),  GST_MESSAGE_STEP_DONE         = (1 << 8),  GST_MESSAGE_CLOCK_PROVIDE     = (1 << 9),  GST_MESSAGE_CLOCK_LOST        = (1 << 10),  GST_MESSAGE_NEW_CLOCK         = (1 << 11),  GST_MESSAGE_STRUCTURE_CHANGE  = (1 << 12),  GST_MESSAGE_STREAM_STATUS     = (1 << 13),  GST_MESSAGE_APPLICATION       = (1 << 14),  GST_MESSAGE_ELEMENT           = (1 << 15),  GST_MESSAGE_SEGMENT_START     = (1 << 16),  GST_MESSAGE_SEGMENT_DONE      = (1 << 17),  GST_MESSAGE_DURATION          = (1 << 18),  GST_MESSAGE_LATENCY           = (1 << 19),  GST_MESSAGE_ASYNC_START       = (1 << 20),  GST_MESSAGE_ASYNC_DONE        = (1 << 21),  GST_MESSAGE_ANY               = ~0} GstMessageType;The different message types that are available.GST_MESSAGE_UNKNOWNan undefined messageGST_MESSAGE_EOSend-of-stream reached in a pipeline. The application will only receive this message in the PLAYING state and every time it sets a pipeline to PLAYING that is in the EOS state. The application can perform a flushing seek in the pipeline, which will undo the EOS state again.GST_MESSAGE_ERRORan error occured. Whe the application receives an error message it should stop playback of the pipeline and not assume that more data will be played.GST_MESSAGE_WARNINGa warning occured.GST_MESSAGE_INFOan info message occuredGST_MESSAGE_TAGa tag was found.GST_MESSAGE_BUFFERINGthe pipeline is buffering. When the application receives a buffering message in the PLAYING state for a non-live pipeline it must PAUSE the pipeline until the buffering completes, when the percentage field in the message is 100%. For live pipelines, no action must be performed and the buffering percentage can be used to inform the user about the progress.GST_MESSAGE_STATE_CHANGEDa state change happenedGST_MESSAGE_STATE_DIRTYan element changed state in a streaming thread. This message is deprecated.GST_MESSAGE_STEP_DONEa framestep finished. This message is not yet implemented.GST_MESSAGE_CLOCK_PROVIDEan element notifies its capability of providing a clock. This message is used internally and never forwarded to the application.GST_MESSAGE_CLOCK_LOSTThe current clock as selected by the pipeline became unusable. The pipeline will select a new clock on the next PLAYING state change.GST_MESSAGE_NEW_CLOCKa new clock was selected in the pipeline.GST_MESSAGE_STRUCTURE_CHANGEthe structure of the pipeline changed. Not implemented yet.GST_MESSAGE_STREAM_STATUSstatus about a stream, emitted when it starts, stops, errors, etc.. Not implemented yet.GST_MESSAGE_APPLICATIONmessage posted by the application, possibly via an application-specific element.GST_MESSAGE_ELEMENTelement-specific message, see the specific element's documentationGST_MESSAGE_SEGMENT_STARTpipeline started playback of a segment. This message is used internally and never forwarded to the application.GST_MESSAGE_SEGMENT_DONEpipeline completed playback of a segment. This message is forwarded to the application after all elements that posted GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.GST_MESSAGE_DURATIONThe duration of a pipeline changed. The application can get the new duration with a duration query.GST_MESSAGE_LATENCYPosted by elements when their latency changes. The pipeline will calculate and distribute a new latency. Since: 0.10.12GST_MESSAGE_ASYNC_STARTPosted by elements when they start an ASYNC state change. This message is not forwarded to the application but is used internally. Since: 0.10.13.GST_MESSAGE_ASYNC_DONEPosted by elements when they complete an ASYNC state change. The application will only receive this message from the toplevel pipeline. Since: 0.10.13GST_MESSAGE_ANYmask for all of the above messages.Get a message matching type from the bus. Will discard all messages on the bus that do not match type and that have been posted before the first message that does match type. If there is no message matching type on the bus, all messages will be discarded.bus:a GstBus to poptypes:message types to take into accountReturns:The next GstMessage matching type that is on the bus, or NULL if the bus is empty or there is no message matching type. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage. MT safe."! !!GStreamerBus commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerCaps commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerClock commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerElement methodsFor: 'pads' stamp: 'jcg 4/21/2008 15:23'!requestPadByName: aName	| pad padHandle |	padHandle := self primgstelementgetrequestpad: self handle name: aName nullTerminated.	padHandle = 0 ifTrue: [^nil].	pad := GStreamerRequestPad handle: padHandle.	self requestPads add: pad.	^pad"Retrieves a pad from the element by name. This version only retrieves request pads. The pad should be released with gst_element_release_request_pad().element:a GstElement to find a request pad of.name:the name of the request GstPad to retrieve.Returns:requested GstPad if found, otherwise NULL. Release after usage."! !!GStreamerElement methodsFor: 'pads' stamp: 'JMM 3/17/2008 12:59'!requestPadThatIsCompatibleTo: aPad capsFilter: caps	| pad padhandle |	caps 		ifNil: 			[padhandle := self primgstelementgetcompatiblepad: self handle pad: aPad handle capsFilter: 0.]		ifNotNil: 			[padhandle := self primgstelementgetcompatiblepad: self handle pad: aPad handle capsFilter: caps handle.].		padhandle = 0 ifTrue: [^nil].	pad := GStreamerPad handle: padhandle.	self requestPads add: pad.	^pad"GstPad*             gst_element_get_compatible_pad      (GstElement *element,                                                         GstPad *pad,                                                         const GstCaps *caps);Looks for an unlinked pad to which the given pad can link. It is not guaranteed that linking the pads will work, though it should work in most cases.element:a GstElement in which the pad should be found.pad:the GstPad to find a compatible one for.caps:the GstCaps to use as a filter.Returns:the GstPad to which a link can be made, or NULL if one cannot be found. gst_object_unref() after usage."! !!GStreamerElement methodsFor: 'pads' stamp: 'jcg 4/21/2008 15:23'!requestStaticPadByName: aName	| pad padHandle |	padHandle := self primgstelementgetstaticpad: self handle name: aName nullTerminated.	padHandle ifNil: [^nil].	pad := GStreamerStaticPad handle: padHandle.	self requestPads add: pad.	^pad"Retrieves a pad from element by name. This version only retrieves already-existing (i.e. 'static') pads.element:a GstElement to find a static pad of.name:the name of the static GstPad to retrieve.Returns:the requested GstPad if found, otherwise NULL. unref after usage. MT safe."! !!GStreamerElement commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerElementFactory commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerElementForSqueakSinkAudio commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerElementForSqueakSinkVideo methodsFor: 'get value' stamp: 'JMM 11/26/2008 16:12'!frameRate	^ [(self getFrameRateNumerator) / 		(self getFrameRateNumerator )] ifError: [1]! !!GStreamerElementForSqueakSinkVideo methodsFor: 'get value' stamp: 'JMM 11/26/2008 16:12'!height	^self getHeight! !!GStreamerElementForSqueakSinkVideo methodsFor: 'get value' stamp: 'JMM 11/26/2008 15:10'!width	^self getWidth! !!GStreamerMessage commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerMoviePlayerMorph class methodsFor: 'class initialization' stamp: 'JMM 3/27/2008 14:14'!initialize     "GStreamerMoviePlayerMorph initialize."    FileList registerFileReader: self.	self registerInFlapsRegistry.	! !!GStreamerObject methodsFor: 'state' stamp: 'JMM 3/13/2008 01:03'!getState: aTimeOutValue"Gets the state of the element""Returns an array which is the GstStateChangeReturn value, the state, the pending state"	| results |	results := self primstelementgetstate: self handle timeOut: aTimeOutValue.	^results"Gets the state of the element.For elements that performed an ASYNC state change, as reported by gst_element_set_state(), this function will block up to the specified timeout value for the state change to complete. If the element completes the state change or goes into an error, this function returns immediately with a return value of GST_STATE_CHANGE_SUCCESS or GST_STATE_CHANGE_FAILURE respectively.For elements that did not return GST_STATE_CHANGE_ASYNC, this function returns the current and pending state immediately.This function returns GST_STATE_CHANGE_NO_PREROLL if the element successfully changed its state but is not able to provide data yet. This mostly happens for live sources that only produce data in the PLAYING state. While the state change return is equivalent to GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that some sink elements might not be able to complete their state change because an element is not producing data to complete the preroll. When setting the element to playing, the preroll will complete and playback will start.element:a GstElement to get the state of.state:a pointer to GstState to hold the state. Can be NULL.pending:a pointer to GstState to hold the pending state. Can be NULL.timeout:a GstClockTime to specify the timeout for an async state change or GST_CLOCK_TIME_NONE for infinite timeout.Returns:GST_STATE_CHANGE_SUCCESS if the element has no more pending state and the last state change succeeded, GST_STATE_CHANGE_ASYNC if the element is still performing a state change or GST_STATE_CHANGE_FAILURE if the last state change failed. MT safe.The possible return values from a state change function. Only GST_STATE_CHANGE_FAILURE is a real failure.GST_STATE_CHANGE_FAILUREthe state change failedGST_STATE_CHANGE_SUCCESSthe state change succeededGST_STATE_CHANGE_ASYNCthe state change will happen asynchronouslyGST_STATE_CHANGE_NO_PREROLLthe state change succeeded but the element cannot produce data in PAUSED. This typically happens with live sources.typedef enum {  GST_STATE_CHANGE_FAILURE             = 0,  GST_STATE_CHANGE_SUCCESS             = 1,  GST_STATE_CHANGE_ASYNC               = 2,  GST_STATE_CHANGE_NO_PREROLL          = 3} GstStateChangeReturn;"! !!GStreamerObject methodsFor: 'state' stamp: 'JMM 3/12/2008 11:12'!setStateTo: symbol"Sets the state of the element. This function will try to set the requested state by going through all the intermediary states and calling the class's state change function for each.This function can return GST_STATE_CHANGE_ASYNC, in which case the element will perform the remainder of the state change asynchronously in another thread. An application can use gst_element_get_state() to wait for the completion of the state change or it can wait for a state change message on the bus."	| anInteger |	anInteger := 1.	symbol = #pending ifTrue: [anInteger := 0].	symbol = #null ifTrue: [anInteger := 1].	symbol = #ready ifTrue: [anInteger := 2].	symbol = #paused ifTrue: [anInteger := 3].	symbol = #playing ifTrue: [anInteger := 4].	^self primgstelementsetstate: self handle to: anInteger"typedef enum {  GST_STATE_VOID_PENDING        = 0,  GST_STATE_NULL                = 1,  GST_STATE_READY               = 2,  GST_STATE_PAUSED              = 3,  GST_STATE_PLAYING             = 4} GstState;GST_STATE_VOID_PENDINGno pending state.GST_STATE_NULLthe NULL state or initial state of an elementGST_STATE_READYthe element is ready to go to PAUSEDGST_STATE_PAUSEDthe element is PAUSEDGST_STATE_PLAYINGthe element is PLAYING		GST_STATE_NULL: this is the default state. This state will deallocate all resources held by the element. 		GST_STATE_READY: in the ready state, an element has allocated all of its global resources, that is, resources that can be kept within streams. You can think about opening devices, allocating buffers and so on. However, the stream is not opened in this state, so the stream positions is automatically zero. If a stream was previously opened, it should be closed in this state, and position, properties and such should be reset. 		GST_STATE_PAUSED: in this state, an element has opened the stream, but is not actively processing it. An element is allowed to modify a stream's position, read and process data and such to prepare for playback as soon as state is changed to PLAYING, but it is not allowed to play the data which would make the clock run. In summary, PAUSED is the same as PLAYING but without a running clock. Elements going into the PAUSED state should prepare themselves for moving over to the PLAYING state as soon as possible. Video or audio outputs would, for example, wait for data to arrive and queue it so they can play it right after the state change. Also, video sinks can already play the first frame (since this does not affect the clock yet). Autopluggers could use this same state transition to already plug together a pipeline. Most other elements, such as codecs or filters, do not need to explicitely do anything in this state, however. 		GST_STATE_PLAYING: in the PLAYING state, an element does exactly the same as in the PAUSED state, except that the clock now runs."! !!GStreamerObject commentStamp: '<historical>' prior: 0!handle is a memory address for a GStreamer ObjectRegister is the Weak Registery to enable our ability to deal with GCed Objects*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPad methodsFor: 'caps' stamp: 'JMM 11/27/2008 15:54'!getParentPad	"Gets the parent of pad, cast to a GstElement. If a pad has no parent or its parent is not an element, return NULL. The caller has a reference on the parent, so unref when you're finished with it. MT safe."	^GStreamerPad handle: (self primgstpadgetparentelement: self handle)! !!GStreamerPad methodsFor: 'pads' stamp: 'jcg 4/21/2008 15:28'!ghostPadNew: aName	^GStreamerPad handle: (self primgstghostpadnew: self handle 			name: aName nullTerminated)"Create a new ghostpad with target as the target. The direction will be taken from the target pad. target must be unlinked.Will ref the target.name:the name of the new pad, or NULL to assign a default name.target:the pad to ghost.Returns:a new GstPad, or NULL in case of an error."! !!GStreamerPad methodsFor: 'system primitives' stamp: 'JMM 11/27/2008 18:33'!primgstpadgetparentelement: gstPadOop	<primitive: 'primitivegstpadgetparentelement' module: 'GStreamerPlugin'>	self primitiveFailed! !!GStreamerPad commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPipeline methodsFor: 'utility' stamp: 'JMM 11/27/2008 23:01'!setStateToThisValue: newState	| currentState bus message |	currentState := self getSimplifiedState.	currentState = newState ifTrue: [^self].	self setStateTo: newState.	bus := self getBus.	message := bus waitUntilErrorOrMessage: {'state-changed'. 2. newState. self}  uptoMilliseconds: 5000.	^message! !!GStreamerPipeline methodsFor: 'bus' stamp: 'JMM 3/13/2008 11:51'!getAutoFlushBus"Check if pipeline will automatically flush messages when going to the NULL state.Returns: whether the pipeline will automatically flush its bus when going from READY to NULL state or not. MT safe."	^self primgstpipelinegetautoflushbus: self handle! !!GStreamerPipeline methodsFor: 'clock' stamp: 'JMM 3/13/2008 11:39'!getClock"Gets the gstClock of pipeline. Returns: a GstClock, unref after usage."	| clockHandle |	clockHandle := self primgstpipelinegetclock: self handle.	^GStreamerClock handle: clockHandle.! !!GStreamerPipeline methodsFor: 'clock' stamp: 'JMM 3/13/2008 12:21'!setClock: aGStreamerClock"Set the clock for pipeline. The clock will be distributed to all the elements managed by the pipeline. Returns:TRUE if the clock could be set on the pipeline. FALSE if some element did not accept the clock. MT safe."	^self primgstpipelinesetclock: self handle value: aGStreamerClock handle! !!GStreamerPipeline commentStamp: '<historical>' prior: 0!elementsInPipe  elements in the pipe*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPipelineSqueakAudioSink commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPipelineSqueakSink commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPipelineSqueakVideoSink commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerPlayer methodsFor: 'accessing' stamp: 'jcg 8/13/2008 15:51'!videoFrameHeight	self pipeLineIsSane ifFalse:[^1].	^self pipeLine height! !!GStreamerPlayer methodsFor: 'accessing' stamp: 'jcg 8/13/2008 15:51'!videoFrameRate	self pipeLineIsSane ifFalse:[^1].	^self pipeLine fps.! !!GStreamerPlayer methodsFor: 'accessing' stamp: 'jcg 8/13/2008 15:51'!videoFrameWidth	self pipeLineIsSane ifFalse:[^1].	^self pipeLine width! !!GStreamerPlayer methodsFor: 'actions' stamp: 'JMM 11/27/2008 23:02'!pause	self tryReopen ifFalse: [^ self].	self pipeLineIsSane ifFalse:[^self].	^self setStateToThisValue: #paused! !!GStreamerPlayer methodsFor: 'actions' stamp: 'JMM 11/27/2008 23:02'!play	| result |	self tryReopen ifFalse: [^ self].	self pipeLineIsSane ifFalse:[^self].	result := self setStateToThisValue: #playing.	self soundTrack play.	^result	! !!GStreamerPlayer methodsFor: 'actions' stamp: 'yo 8/13/2008 11:20'!rewind 	self tryReopen ifFalse: [^ self].	self pipeLineIsSane ifFalse:[^self].	self pipeLine seekToTimeInSeconds: 0.	self processAudioGiveTo: nil. " clean out pending data"	self pause.! !!GStreamerPlayer methodsFor: 'actions' stamp: 'yo 8/13/2008 11:20'!seekToTimeInSecondsEnsurePlaying: seconds	self tryReopen ifFalse: [^ self].	self pipeLineIsSane ifFalse:[^nil].	self hasVideo 		ifFalse: [self pipeLine seekToTimeInSecondsEnsurePlaying: seconds]		ifTrue: [self pause.			self halt. 			self pipeLine seekToTimeInSecondsEnsurePlaying: seconds.			self play]! !!GStreamerPlayer methodsFor: 'actions' stamp: 'JMM 11/27/2008 23:01'!setStateToThisValue: newState	self tryReopen ifFalse: [^ nil].	self pipeLineIsSane ifFalse:[^nil].	^self pipeLine setStateToThisValue: newState! !!GStreamerPlayer methodsFor: 'initialize-release' stamp: 'JMM 11/29/2008 21:51'!oggHookupToSqueakAudioAndVideo	| oggdemux vorbisdec vorbisdecSinkPad result audiosink audioconvert theoradec ffmpegcolorspace ximagesink theoradecSinkPad queueVideo oggdemuxSinkPad fileSrcPad audioresample caps capsfilterVideo capsfilter file bus message |	"Play both audio and video using a mux, this uses two dynamically created pads just to show how they are done"	"gst-launch filesrc location=test1.ogg !! oggdemux name=demux demux. !! vorbisdec !! audioconvert !! SqueakAudioSink demux. !! queue !! theoradec !! ffmpegcolorspace !! SqueakVideoSink"	"Note QUEUES are needed, otherwise the video/sound will not play"	file := GStreamerElement elementFactoryMake: 'filesrc' name: 'filesrc'.	file setKey: 'location' toStringValue: self filesrc.	oggdemux := GStreamerElement elementFactoryMake: 'oggdemux' name: 'oggdemux'. 	vorbisdec := GStreamerElement elementFactoryMake: 'vorbisdec' name: 'vorbisdec'. 	capsfilter := GStreamerElement elementFactoryMake: 'capsfilter' name: 'capsfilter'. 	caps := GStreamerPipelineSqueakSink audioCapsLittle.	capsfilter setKey: 'caps' toPointerValue: caps handle.	audiosink := GstElemSqueakAudioSink elementFactoryMake: 'fakesink' name: 'fakesinkAudio'.	audiosink setKey: 'sync' toBooleanValue: true.	audioconvert := GStreamerElement elementFactoryMake: 'audioconvert' name: 'audioconvert'.	audioresample := GStreamerElement elementFactoryMake: 'audioresample' name: 'audioresample'.	theoradec := GStreamerElement elementFactoryMake: 'theoradec' name: 'theoradec'.	ffmpegcolorspace := GStreamerElement elementFactoryMake: 'ffmpegcolorspace' name: 'ffmpegcolorspace'.	caps :=  Display depth = 32 		ifTrue: [GStreamerPipelineSqueakSink videoCapsBig32]		ifFalse: [GStreamerPipelineSqueakSink videoCapsBig16].	capsfilterVideo := GStreamerElement elementFactoryMake: 'capsfilter' name: 'capsfilterVideo'. 	capsfilterVideo setKey: 'caps' toPointerValue: caps handle.	ximagesink := GstElemSqueakVideoSink elementFactoryMake: 'fakesink' name: 'fakesinkVideo'.	ximagesink setKey: 'sync' toBooleanValue: true.	queueVideo := GStreamerElement elementFactoryMake: 'queue' name: 'queueVideo'.	volumePlayer := GStreamerElement elementFactoryMake: 'volume' name: 'volume'.	"Setup the pipeline" 	pipeLine := GStreamerPipelineSqueakVideoSink name: 'my-pipeline'.	result := pipeLine addElement: oggdemux.	result := pipeLine addElement: vorbisdec.	result := pipeLine addElement: file.	result := pipeLine addElement: capsfilter.	result := pipeLine addElement: capsfilterVideo.	result := pipeLine addElement: audiosink.	result := pipeLine addElement: audioconvert.	result := pipeLine addElement: audioresample.	result := pipeLine addElement: theoradec.	result := pipeLine addElement: ffmpegcolorspace.	result := pipeLine addElement: ximagesink.	"result := pipeLine addElement: capsfilterVideo."	result := pipeLine addElement: queueVideo.	result := pipeLine addElement: volumePlayer.		" NOTE SETUP OF SEMAPHORE AND REGISTER STEP"	pipeLine setupSemaphore.	pipeLine register.	result := GStreamer default linkElementSrc: vorbisdec toDest: audioconvert.	result := GStreamer default linkElementSrc: audioconvert toDest: audioresample.	result := GStreamer default linkElementSrc: audioresample toDest: capsfilter.	result := GStreamer default linkElementSrc: capsfilter toDest: volumePlayer.	result := GStreamer default linkElementSrc: volumePlayer toDest: audiosink.	result := GStreamer default linkElementSrc: queueVideo toDest: theoradec.	result := GStreamer default linkElementSrc: theoradec toDest: ffmpegcolorspace.	result := GStreamer default linkElementSrc: ffmpegcolorspace toDest: capsfilterVideo.	result := GStreamer default linkElementSrc: capsfilterVideo toDest: ximagesink.	"Ok here we get the demux sink pad and hook to the filesrc we could just hook the elements together but let's	explore hooking pad to pad" 	vorbisdecSinkPad := vorbisdec requestStaticPadByName: 'sink'.	theoradecSinkPad := queueVideo requestStaticPadByName: 'sink'.		oggdemuxSinkPad := oggdemux requestStaticPadByName: 'sink'.	fileSrcPad := file requestPadThatIsCompatibleTo: oggdemuxSinkPad capsFilter: oggdemuxSinkPad getCaps.	GStreamer default linkPadSrc: fileSrcPad toDest: oggdemuxSinkPad.	"Now lets setup the dynamic pad" 	oggdemux requestCallBackForSignal: 'pad-added' useArray: (Array with: vorbisdecSinkPad with: theoradecSinkPad).	pipeLine setStateTo: #paused.	bus := pipeLine getBus.	message := bus waitUntilErrorOrMessage: 'tag' uptoMilliseconds: 5000.	hasAudio := GStreamer default callbackSignalSeenForIndex: 1.	hasVideo := GStreamer default callbackSignalSeenForIndex: 2.	(hasVideo not or: [hasAudio not]) 		ifTrue: [pipeLine release.			pipeLine := nil.			^self].	message := bus waitUntilErrorOrMessage: {'state-changed'. 2. #pending. pipeLine}  uptoMilliseconds: 2000.! !!GStreamerPlayer methodsFor: 'initialize-release' stamp: 'yo 8/12/2008 22:39'!oggHookupToSqueakVideo	| oggdemux result theoradec ffmpegcolorspace ximagesink theoradecSinkPad queueVideo oggdemuxSinkPad fileSrcPad caps capsfilterVideo file |	"Play video using a mux, this uses two dynamically created pads just to show how they are done"	"gst-launch filesrc location=test1.ogg !! oggdemux name=demux demux. !! vorbisdec !! audioconvert !! SqueakAudioSink demux. !! queue !! theoradec !! ffmpegcolorspace !! SqueakVideoSink"	"Note QUEUES are needed, otherwise the video/sound will not play"	file := GStreamerElement elementFactoryMake: 'filesrc' name: 'filesrc'.	file setKey: 'location' toStringValue: self filesrc.	oggdemux := GStreamerElement elementFactoryMake: 'oggdemux' name: 'oggdemux'. 	theoradec := GStreamerElement elementFactoryMake: 'theoradec' name: 'theoradec'.	ffmpegcolorspace := GStreamerElement elementFactoryMake: 'ffmpegcolorspace' name: 'ffmpegcolorspace'.	caps :=  Display depth = 32 		ifTrue: [GStreamerPipelineSqueakSink videoCapsBig32]		ifFalse: [GStreamerPipelineSqueakSink videoCapsBig16].	capsfilterVideo := GStreamerElement elementFactoryMake: 'capsfilter' name: 'capsfilterVideo'. 	capsfilterVideo setKey: 'caps' toPointerValue: caps handle.	ximagesink := GstElemSqueakVideoSink elementFactoryMake: 'fakesink' name: 'fakesinkVideo'.	ximagesink setKey: 'sync' toBooleanValue: true.	queueVideo := GStreamerElement elementFactoryMake: 'queue' name: 'queueVideo'.	volumePlayer := GStreamerElement elementFactoryMake: 'volume' name: 'volume'.	"Setup the pipeline" 	pipeLine := GStreamerPipelineSqueakVideoSink name: 'my-pipeline'.	result := pipeLine addElement: oggdemux.	result := pipeLine addElement: file.	result := pipeLine addElement: capsfilterVideo.	result := pipeLine addElement: theoradec.	result := pipeLine addElement: ffmpegcolorspace.	result := pipeLine addElement: ximagesink.	result := pipeLine addElement: queueVideo.	result := pipeLine addElement: volumePlayer.		" NOTE SETUP OF SEMAPHORE AND REGISTER STEP"	pipeLine setupSemaphore.	pipeLine register.	result := GStreamer default linkElementSrc: queueVideo toDest: theoradec.	result := GStreamer default linkElementSrc: theoradec toDest: ffmpegcolorspace.	result := GStreamer default linkElementSrc: ffmpegcolorspace toDest: capsfilterVideo.	result := GStreamer default linkElementSrc: capsfilterVideo toDest: ximagesink.	"Ok here we get the demux sink pad and hook to the filesrc we could just hook the elements together but let's	explore hooking pad to pad" 	theoradecSinkPad := queueVideo requestStaticPadByName: 'sink'.		oggdemuxSinkPad := oggdemux requestStaticPadByName: 'sink'.	fileSrcPad := file requestPadThatIsCompatibleTo: oggdemuxSinkPad capsFilter: oggdemuxSinkPad getCaps.	GStreamer default linkPadSrc: fileSrcPad toDest: oggdemuxSinkPad.	"Now lets setup the dynamic pad" 	oggdemux requestCallBackForSignal: 'pad-added' useArray: (Array with: theoradecSinkPad).	hasVideo := true.	hasAudio := false.! !!GStreamerPlayer methodsFor: 'initialize-release' stamp: 'JMM 8/5/2008 16:08'!oggHookupToTypeFind	| file  result typeFind |	file := GStreamerElement elementFactoryMake: 'filesrc' name: 'filesrc'.	file setKey: 'location' toStringValue: self filesrc.	typeFind := GStreamerElement elementFactoryMake: 'typefind' name: 'typefind'. 	"Setup the pipeline" 	pipeLine := GStreamerPipeline name: 'my-pipeline'.	pipeLine addElement: file.	pipeLine addElement: typeFind.	result := GStreamerSystem default linkElementSrc: file toDest: typeFind.! !!GStreamerPlayer methodsFor: 'initialize-release' stamp: 'JMM 11/29/2008 21:47'!tryReopen	| |	self pipeLineIsSane		ifTrue: [^ true].	(filesrc isString			and: [FileDirectory default fileExists: filesrc])		ifTrue: [self oggHookupToSqueakAudioAndVideo.			self pipeLine				ifNil: [self closeFile.					hasAudio ifTrue: [self oggHookupToSqueakAudio].					hasVideo ifTrue: [self oggHookupToSqueakVideo].					self setStateToThisValue: #paused].			^ true].	^ false! !!GStreamerPlayer methodsFor: 'stepping' stamp: 'yo 8/13/2008 10:59'!processVideoGiveTo: player	self pipeLineIsSane ifFalse:[^ false].	^self pipeLine getVideodataIfFoundGiveTo: player! !!GStreamerPlayer class methodsFor: 'file list services' stamp: 'JMM 11/29/2008 21:50'!openFile: aFileName	| player |	player := self new.	player filesrc: aFileName.	player tryReopen.	^player! !!GStreamerRequestPad commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GStreamerStaticPad commentStamp: '<historical>' prior: 0!*  Created by John M McIntosh on 3/10/08. *  Copyright 2008 Corporate Smalltalk Consulting Ltd. http://www.smalltalkconsulting.com All rights reserved. *  Written for Viewpoints Research Institute  http://www.vpri.org/ * http://www.opensource.org/licenses/mit-license.php!!GstElemFakeSink commentStamp: '<historical>' prior: 0!Has subclasses for audio/video.  Has basically the same role as GStreamerElementForSqueakSinkAudio/Video, except:	- puts semaphore management in the element instead of the pipeline	- shorter name... easier to type when manually composing pipelines!!HaloMorph methodsFor: 'event handling' stamp: 'bf 6/24/2010 15:39'!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: newExtent.					newPosition := target position - (target extent - oldExtent // 2).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 15:16'!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	innerTarget aboutToBeBrownDragged.	self setProperty: #conclusionSelector toValue: #brownDragConcluded.	thePoint _ target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HandMorph methodsFor: 'accessing' stamp: 'wiz 12/4/2006 00:16'!targetPoint	"Return the new position of the target.	I.E. return the position of the hand less 	the original distance between hand and target position"	^ self position - targetOffset! !!HandMorph methodsFor: 'initialization' stamp: 'bf 6/26/2010 15:35'!initialize	"this is also called in releaseCachedState, so set everything to nil explicitely"	super initialize.	keyboardFocus _ nil.	mouseFocus _ nil.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cacheCanvas _ nil.	cachedCanvasHasHoles _ false.	temporaryCursor _ temporaryCursorOffset _ nil.	keyboardInterpreter _ nil.	self initForEvents.! !!HandMorph methodsFor: 'paste buffer' stamp: 'bf 9/29/2009 13:55'!pasteMorph	"The user requested 'paste';  depending on the type of data on the clipboard, launch an appropropriate morph that embodies the clipboard content, and open it on the screen."	| aPastee form text |	aPastee := nil.	form := ExtendedClipboardInterface current readFormClipboardData.	form		ifNotNil: [aPastee := SketchMorph withForm: form].	aPastee		ifNil: [text := Clipboard clipboardText.				text isEmpty ifFalse:					[aPastee := TextMorph nonwrappingPrototype.					aPastee contents: text.					text embeddedMorphs ifNotNilDo: [:morphs | 						morphs do: [:m |							m forkDownloadWhenFinished: [aPastee composeToBounds]].						aPastee composeToBounds].					aPastee width > ActiveWorld width ifTrue:						[aPastee wrapFlag: true.						aPastee width: ((2 * ActiveWorld width) // 3).						aPastee refreshParagraph]]].	aPastee		ifNil: [aPastee := self objectToPaste].	aPastee		ifNil: [^ self].	self attachMorph: aPastee.	aPastee align: aPastee center with: self position.	aPastee player		ifNotNil: [aPastee player startRunning]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'avi 2/10/2004 14:02'!httpGet: url args: args user: user passwd: passwd	| authorization |	authorization _ (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	^self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , CrLf! !!ImmWin32 methodsFor: 'keyboard' stamp: 'ka 4/7/2009 19:12'!keyboardFocusForAMorph: aMorph 	| left top pos |	aMorph		ifNil: [^ self].	[pos := aMorph prefereredKeyboardPosition.	Display isVirtualScreen		ifTrue: [pos := (pos / Display displayScale + Display displayOffset) truncated].	left := (pos x min: Display width max: 0) asInteger.	top := (pos y min: Display height max: 0) asInteger.	self setCompositionWindowPositionX: left y: top]		on: Error		do: [:ex | ex]! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'yo 9/11/2009 10:24'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	container _ hostList.	complexContents _ anObject.	self initWithContents: anObject asString font: Preferences standardListFont emphasis: nil.	indentLevel _ 0.	isExpanded _ false. 	nextSibling _ firstChild _ nil.	priorMorph ifNotNil: [		priorMorph nextSibling: self.	].	indentLevel _ newLevel.	self setProperty: #autoExpand toValue: true.! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'yo 9/11/2009 10:24'!initialize"initialize the state of the receiver"	super initialize.""	indentLevel _ 0.	isExpanded _ false.	self setProperty: #autoExpand toValue: true.! !!IndentingListItemMorph methodsFor: 'mouse events' stamp: 'yo 9/11/2009 10:24'!inToggleArea: aPoint	^ (self valueOfProperty: #autoExpand ifAbsent: [false]) ifFalse: [		self toggleRectangle containsPoint: aPoint	] ifTrue: [		self bounds containsPoint: aPoint	].! !!InteriorSugarNavBar methodsFor: 'buttons' stamp: 'bf 9/12/2009 20:04'!keepProject	"But don't..."! !!InteriorSugarNavBar methodsFor: 'morphic interaction' stamp: 'bf 9/15/2009 14:45'!resizeButtonsAndTabTo: newDim	"The user has chosen a new height for the nav bar; make the buttons follow suit."	| frame wantsSupplies |	wantsSupplies := supplies notNil and: [supplies flapShowing].	wantsSupplies ifTrue: [supplies hideFlap].	frame _ paintButton owner.	frame submorphs do: [:e |		e naviHeight: newDim].	frame height: newDim.	self height: newDim.	wantsSupplies ifTrue: [supplies showFlap]! !!InteriorSugarNavBar methodsFor: 'initialization' stamp: 'sw 9/13/2009 20:40'!makeTheSimpleButtons	"Add the buttons for use in normal kids' mode."	^{		self buttonPaint.		self buttonSupplies.		"self buttonUndo."		#spacer.			}! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'sw 9/25/2009 16:19'!insertNewProject	"Insert a new project in the thread."	| newProj messageToSendIfValid |	[newProj _ Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		messageToSendIfValid := MessageSend receiver: self selector: #insertNewProjectActionFor: arguments: {newProj}.	EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: messageToSendIfValid		expandedFormat: false! !!InternalTranslator class methodsFor: 'accessing' stamp: 'bf 5/2/2010 20:01'!availableLanguageLocaleIDs	"Return locale ids for the internal translation dictionary."	"InternalTranslator availableLanguageLocaleIDs"	^ self cachedTranslations values collect:[:each | each localeID]! !!InternalTranslator class methodsFor: 'class initialization' stamp: 'bf 5/4/2010 16:38'!discardAllTranslations	AllKnownPhrases := nil.	self resetCaches.! !!ISOLanguageDefinition class methodsFor: 'private' stamp: 'yo 9/28/2009 19:55'!isoLanguages	"ISO 639: 3-letter codes"	^'aar	aa	Afarabk	ab	Abkhazianace		Achineseach		Acoliada		Adangmeady		Adyghe; Adygeiafa		Afro-Asiatic languagesafh		Afrihiliafr	af	Afrikaansain		Ainuaka	ak	Akanakk		Akkadianalb/sqi	sq	Albanianale		Aleutalg		Algonquian languagesalt		Southern Altaiamh	am	Amharicang		English, Old (ca.450-1100)anp		Angikaapa		Apache languagesara	ar	Arabicarc		Official Aramaic (700-300 BCE); Imperial Aramaic (700-300 BCE)arg	an	Aragonesearm/hye	hy	Armenianarn		Mapudungun; Mapuchearp		Arapahoart		Artificial languagesarw		Arawakasm	as	Assameseast		Asturian; Bable; Leonese; Asturleoneseath		Athapascan languagesaus		Australian languagesava	av	Avaricave	ae	Avestanawa		Awadhiaym	ay	Aymaraaze	az	Azerbaijanibad		Banda languagesbai		Bamileke languagesbak	ba	Bashkirbal		Baluchibam	bm	Bambaraban		Balinesebaq/eus	eu	Basquebas		Basabat		Baltic languagesbej		Beja; Bedawiyetbel	be	Belarusianbem		Bembaben	bn	Bengaliber		Berber languages)bho		Bhojpuribih	bh	Biharibik		Bikolbin		Bini; Edobis	bi	Bislamabla		Siksikabnt		Bantu languagesbos	bs	Bosnianbra		Brajbre	br	Bretonbtk		Batak languagesbua		Buriatbug		Buginesebul	bg	Bulgarianbur/mya	my	Burmesebyn		Blin; Bilincad		Caddocai		Central American Indian languagescar		Galibi Caribcat	ca	Catalan; Valenciancau		Caucasian languagesceb		Cebuanocel		Celtic languagescha	ch	Chamorrochb		Chibchache	ce	Chechenchg		Chagataichi/zho	zh	Chinesechk		Chuukesechm		Marichn		Chinook jargoncho		Choctawchp		Chipewyan; Dene Sulinechr		Cherokeechu	cu	Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonicchv	cv	Chuvashchy		Cheyennecmc		Chamic languagescop		Copticcor	kw	Cornishcos	co	Corsicancpe		Creoles and pidgins, English basedcpf		Creoles and pidgins, French-basedcpp		Creoles and pidgins, Portuguese-basedcre	cr	Creecrh		Crimean Tatar; Crimean Turkishcrp		Creoles and pidginscsb		Kashubiancus		Cushitic languagescze/ces	cs	Czechdak		Dakotadan	da	Danishdar		Dargwaday		Land Dayak languagesdel		Delawareden		Slave (Athapascan)dgr		Dogribdin		Dinkadiv	dv	Divehi; Dhivehi; Maldiviandoi		Dogridra		Dravidian languagesdsb		Lower Sorbiandua		Dualadum		Dutch, Middle (ca.1050-1350)dut/nld	nl	Dutch; Flemishdyu		Dyuladzo	dz	Dzongkhaefi		Efikegy		Egyptian (Ancient)eka		Ekajukelx		Elamiteeng	en	Englishenm		English, Middle (1100-1500)epo	eo	Esperantoest	et	Estonianewe	ee	Eweewo		Ewondofan		Fangfao	fo	Faroesefat		Fantifij	fj	Fijianfil		Filipino; Pilipinofin	fi	Finnishfiu		Finno-Ugrian languages)fon		Fonfre/fra	fr	Frenchfrm		French, Middle (ca.1400-1600)fro		French, Old (842-ca.1400)frr		Northern Frisianfrs		Eastern Frisianfry	fy	Western Frisianful	ff	Fulahfur		Friuliangaa		Gagay		Gayogba		Gbayagem		Germanic languagesgeo/kat	ka	Georgianger/deu	de	Germangez		Geezgil		Gilbertesegla	gd	Gaelic; Scottish Gaelicgle	ga	Irishglg	gl	Galicianglv	gv	Manxgmh		German, Middle High (ca.1050-1500)goh		German, Old High (ca.750-1050)gon		Gondigor		Gorontalogot		Gothicgrb		Grebogrc		Greek, Ancient (to 1453)gre/ell	el	Greek, Modern (1453-)grn	gn	Guaranigsw		Swiss German; Alemannic; Alsatianguj	gu	Gujaratigwi		Gwich''inhai		Haidahat	ht	Haitian; Haitian Creolehau	ha	Hausahaw		Hawaiianheb	he	Hebrewher	hz	Hererohil		Hiligaynonhim		Himachalihin	hi	Hindihit		Hittitehmn		Hmonghmo	ho	Hiri Motuhrv	hr	Croatianhsb		Upper Sorbianhun	hu	Hungarianhup		Hupaiba		Ibanibo	ig	Igboice/isl	is	Icelandicido	io	Idoiii	ii	Sichuan Yi; Nuosuijo		Ijo languagesiku	iu	Inuktitutile	ie	Interlingue; Occidentalilo		Ilokoina	ia	Interlingua (International Auxiliary Language Association)inc		Indic languagesind	id	Indonesianine		Indo-European languagesinh		Ingushipk	ik	Inupiaqira		Iranian languagesiro		Iroquoian languagesita	it	Italianjav	jv	Javanesejbo		Lojbanjpn	ja	Japanesejpr		Judeo-Persianjrb		Judeo-Arabickaa		Kara-Kalpakkab		Kabylekac		Kachin; Jingphokal	kl	Kalaallisut; Greenlandickam		Kambakan	kn	Kannadakar		Karen languageskas	ks	Kashmirikau	kr	Kanurikaw		Kawikaz	kk	Kazakhkbd		Kabardiankha		Khasikhi		Khoisan languageskhm	km	Central Khmerkho		Khotanese; Sakankik	ki	Kikuyu; Gikuyukin	rw	Kinyarwandakir	ky	Kirghiz; Kyrgyzkmb		Kimbundukok		Konkanikom	kv	Komikon	kg	Kongokor	ko	Koreankos		Kosraeankpe		Kpellekrc		Karachay-Balkarkrl		Kareliankro		Kru languageskru		Kurukhkua	kj	Kuanyama; Kwanyamakum		Kumykkur	ku	Kurdishkut		Kutenailad		Ladinolah		Lahndalam		Lambalao	lo	Laolat	la	Latinlav	lv	Latvianlez		Lezghianlim	li	Limburgan; Limburger; Limburgishlin	ln	Lingalalit	lt	Lithuanianlol		Mongoloz		Loziltz	lb	Luxembourgish; Letzeburgeschlua		Luba-Lulualub	lu	Luba-Katangalug	lg	Gandalui		Luisenolun		Lundaluo		Luo (Kenya and Tanzania)lus		Lushaimac/mkd	mk	Macedonianmad		Maduresemag		Magahimah	mh	Marshallesemai		Maithilimak		Makasarmal	ml	Malayalamman		Mandingomao/mri	mi	Maorimap		Austronesian languagesmar	mr	Marathimas		Masaimay/msa	ms	Malaymdf		Mokshamdr		Mandarmen		Mendemga		Irish, Middle (900-1200)mic		Mi''kmaq; Micmacmin		Minangkabaumis		Uncoded languagesmkh		Mon-Khmer languagesmlg	mg	Malagasymlt	mt	Maltesemnc		Manchumni		Manipurimno		Manobo languagesmoh		Mohawkmon	mn	Mongolianmos		Mossimul		Multiple languagesmun		Munda languagesmus		Creekmwl		Mirandesemwr		Marwarimyn		Mayan languagesmyv		Erzyanah		Nahuatl languagesnai		North American Indian languagesnap		Neapolitannau	na	Naurunav	nv	Navajo; Navahonbl	nr	Ndebele, South; South Ndebelende	nd	Ndebele, North; North Ndebelendo	ng	Ndongands		Low German; Low Saxon; German, Low; Saxon, Lownep	ne	Nepalinew		Nepal Bhasa; Newarinia		Niasnic		Niger-Kordofanian languagesniu		Niueannno	nn	Norwegian Nynorsk; Nynorsk, Norwegiannob	nb	Bokmal, Norwegian; Norwegian Bokmalnog		Nogainon		Norse, Oldnor	no	Norwegiannqo		N''Konso		Pedi; Sepedi; Northern Sothonub		Nubian languagesnwc		Classical Newari; Old Newari; Classical Nepal Bhasanya	ny	Chichewa; Chewa; Nyanjanym		Nyamwezinyn		Nyankolenyo		Nyoronzi		Nzimaoci	oc	Occitan (post 1500)oji	oj	Ojibwaori	or	Oriyaorm	om	Oromoosa		Osageoss	os	Ossetian; Osseticota		Turkish, Ottoman (1500-1928)oto		Otomian languagespaa		Papuan languagespag		Pangasinanpal		Pahlavipam		Pampanga; Kapampanganpan	pa	Panjabi; Punjabipap		Papiamentopau		Palauanpeo		Persian, Old (ca.600-400 B.C.)per/fas	fa	Persianphi		Philippine languages)phn		Phoenicianpli	pi	Palipol	pl	Polishpon		Pohnpeianpor	pt	Portuguesepra		Prakrit languagespro		Provencal, Old (to 1500);Occitan, Old (to 1500)pus	ps	Pushto; Pashtoqaa-qtz		Reserved for local useque	qu	Quechuaraj		Rajasthanirap		Rapanuirar		Rarotongan; Cook Islands Maoriroa		Romance languagesroh	rm	Romanshrom		Romanyrum/ron	ro	Romanian; Moldavian; Moldovanrun	rn	Rundirup		Aromanian; Arumanian; Macedo-Romanianrus	ru	Russiansad		Sandawesag	sg	Sangosah		Yakutsai		South American Indian languagessal		Salishan languagessam		Samaritan Aramaicsan	sa	Sanskritsas		Sasaksat		Santaliscn		Siciliansco		Scotssel		Selkupsem		Semitic languagessga		Irish, Old (to 900)sgn		Sign Languagesshn		Shansid		Sidamosin	si	Sinhala; Sinhalesesio		Siouan languagessit		Sino-Tibetan languagessla		Slavic languagesslo/slk	sk	Slovakslv	sl	Sloveniansma		Southern Samisme	se	Northern Samismi		Sami languagessmj		Lule Samismn		Inari Samismo	sm	Samoansms		Skolt Samisna	sn	Shonasnd	sd	Sindhisnk		Soninkesog		Sogdiansom	so	Somalison		Songhai languagessot	st	Sotho, Southernspa	es	Spanish; Castiliansrd	sc	Sardiniansrn		Sranan Tongosrp	sr	Serbiansrr		Sererssa		Nilo-Saharan languagesssw	ss	Swatisuk		Sukumasun	su	Sundanesesus		Sususux		Sumerianswa	sw	Swahiliswe	sv	Swedishsyc		Classical Syriacsyr		Syriactah	ty	Tahitiantai		Tai languagestam	ta	Tamiltat	tt	Tatartel	te	Telugutem		Timneter		Terenotet		Tetumtgk	tg	Tajiktgl	tl	Tagalogtha	th	Thaitib/bod	bo	Tibetantig		Tigretir	ti	Tigrinyativ		Tivtkl		Tokelautlh		Klingon; tlhIngan-Holtli		Tlingittmh		Tamashektog		Tonga (Nyasa)ton	to	Tonga (Tonga Islands)tpi		Tok Pisintsi		Tsimshiantsn	tn	Tswanatso	ts	Tsongatuk	tk	Turkmentum		Tumbukatup		Tupi languagestur	tr	Turkishtut		Altaic languagestvl		Tuvalutwi	tw	Twityv		Tuvinianudm		Udmurtuga		Ugariticuig	ug	Uighur; Uyghurukr	uk	Ukrainianumb		Umbunduund		Undeterminedurd	ur	Urduuzb	uz	Uzbekvai		Vaiven	ve	Vendavie	vi	Vietnamesevol	vo	Volapukvot		Voticwak		Wakashan languageswal		Wolaitta; Wolayttawar		Waraywas		Washowel/cym	cy	Welshwen		Sorbian languageswln	wa	Walloonwol	wo	Wolofxal		Kalmyk; Oiratxho	xh	Xhosayao		Yaoyap		Yapeseyid	yi	Yiddishyor	yo	Yorubaypk		Yupik languageszap		Zapoteczbl		Blissymbols; Blissymbolics; Blisszen		Zenagazha	za	Zhuang; Chuangznd		Zande languageszul	zu	Zuluzun		Zunizxx		No linguistic content; Not applicablezza		Zaza; Dimili; Dimli; Kirdki; Kirmanjki; Zazaki'! !!JapaneseEnvironment class methodsFor: 'subclass responsibilities' stamp: 'KR 5/28/2010 16:12'!clipboardInterpreterClass	| platformName osVersion |	platformName := SmalltalkImage current  platformName.	osVersion := SmalltalkImage current  getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) 		ifTrue: [^NoConversionClipboardInterpreter].	platformName = 'Win32' 		ifTrue: [^self win32VMUsesUnicode 								ifTrue: [UTF8JPClipboardInterpreter] 								ifFalse: [WinShiftJISClipboardInterpreter]].	platformName = 'Mac OS' 		ifTrue: [			^('4.*' match: (SmalltalkImage current macVmMajorMinorBuildVersionString)) ifTrue: [MacUTF8ClipboardInterpreter] ifFalse: [MacShiftJISClipboardInterpreter]].	^platformName = 'unix' 		ifTrue: 			[(ShiftJISTextConverter encodingNames includes: X11Encoding getEncoding) 				ifTrue: [MacShiftJISClipboardInterpreter]				ifFalse: [UnixJPClipboardInterpreter]]		ifFalse: [ NoConversionClipboardInterpreter ]! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'bf 8/28/2010 15:16'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	| aTile displayer actualSetter |	actualSetter _ setter ifNotNil:		[(#(none nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile _ self newReadoutTile.	displayer _ UpdatingStringMorph new		getSelector: #externalName;		target: aTarget costume renderedMorph;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs == 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	displayer useStringFormat.	^ aTile! !!KedamaTurtleVectorPlayer2 methodsFor: 'player protocol' stamp: 'yo 8/24/2009 14:54'!getTurtleCount	^ exampler getTurtleCount.! !!KeyboardEvent methodsFor: 'printing' stamp: 'tk 10/13/2004 15:19'!printKeyStringOn: aStream	"Print a readable string representing the receiver on a given stream"	| kc inBrackets firstBracket keyString |	kc := self keyCharacter.	inBrackets := false.	firstBracket := [ inBrackets ifFalse: [ aStream nextPut: $<. inBrackets := true ]].	self controlKeyPressed ifTrue: [ 	firstBracket value. aStream nextPutAll: 'Ctrl-' ].	self commandKeyPressed ifTrue: [ firstBracket value. aStream nextPutAll: 'Cmd-' ].	(buttons anyMask: 32) ifTrue: [ firstBracket value. aStream nextPutAll: 'Opt-' ].	(self shiftPressed and: [ keyValue between: 1 and: 31 ])		ifTrue: [ firstBracket value. aStream nextPutAll: 'Shift-' ].	(self controlKeyPressed and: [ keyValue <= 26 ])			ifTrue:				[aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter]			ifFalse: 				[keyString := (kc caseOf: {					[ Character space ] -> [ ' ' ].					[ Character tab ] -> [ 'tab' ].					[ Character cr ] -> [ 'cr' ].					[ Character lf ] -> [ 'lf' ].					[ Character enter ] -> [ 'enter' ].					[ Character backspace ] -> [ 'backspace' ].					[ Character delete ] -> [ 'delete' ].					[ Character escape ] -> [ 'escape' ].					[ Character arrowDown ] -> [ 'down' ].					[ Character arrowUp ] -> [ 'up' ].					[ Character arrowLeft ] -> [ 'left' ].					[ Character arrowRight ] -> [ 'right' ].					[ Character end ] -> [ 'end' ].					[ Character home ] -> [ 'home' ].					[ Character pageDown ] -> [ 'pageDown' ].					[ Character pageUp ] -> [ 'pageUp' ].					[ Character euro ] -> [ 'euro' ].					[ Character insert ] -> [ 'insert' ].				} otherwise: [ String with: kc ]).				keyString size > 1 ifTrue: [ firstBracket value ].				aStream nextPutAll: keyString].	inBrackets ifTrue: [aStream nextPut: $> ]! !!KeyboardEvent methodsFor: 'private' stamp: 'sw 5/7/2009 22:52'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp	type _ aSymbol.	buttons _ anInteger.	position _ pos.	keyValue _ aValue.	source _ aHand.	wasHandled _ false.	timeStamp _ stamp.	type = #keystroke ifTrue: [ActiveWorld ifNotNil: [ActiveWorld lastKeystroke: self keyString]]! !!KeyedSet methodsFor: 'accessing' stamp: 'ul 2/19/2010 15:35'!like: anObject ifAbsent: aBlock	"Answer an object in the receiver that is equal to anObject,	or evaluate the block if not found. Relies heavily on hash properties"	^(array at: (self scanFor: (keyBlock value: anObject)))		ifNil: [ aBlock value ]		ifNotNil: [ :element | element enclosedSetElement ]! !!KoreanEnvironment methodsFor: 'as yet unclassified' stamp: 'janggoon 11/6/2008 23:57'!fontDownloadUrls	^ #('http://squeak.kr/data/' )! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:08'!clipboardInterpreterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) 		ifTrue: [^NoConversionClipboardInterpreter].	platformName = 'Win32' ifTrue: [^WinKSX1001ClipboardInterpreter].	platformName = 'Mac OS' 		ifTrue: 			[('10*' match: SmalltalkImage current osVersion) 				ifTrue: [^NoConversionClipboardInterpreter]				ifFalse: [^WinKSX1001ClipboardInterpreter]].	platformName = 'unix' 		ifTrue: 			[(EUCKRTextConverter encodingNames includes: X11Encoding getEncoding) 				ifTrue: [^WinKSX1001ClipboardInterpreter]				ifFalse: [^NoConversionClipboardInterpreter]].	^NoConversionClipboardInterpreter! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:09'!defaultEncodingName	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^'utf-8' copy].	(#('Win32' 'ZaurusOS') includes: platformName) 		ifTrue: [^'euc-kr' copy].	platformName = 'Mac OS'		ifTrue: [^ ('10*' match: SmalltalkImage current osVersion)				ifTrue: ['utf-8']				ifFalse: ['euc-kr']].	(#('unix') includes: platformName) ifTrue: [^'euc-kr' copy].	^'mac-roman'! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:09'!fileNameConverterClass	^ self systemConverterClass! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:10'!inputInterpreterClass	| platformName osVersion encoding |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) 		ifTrue: [^MacRomanInputInterpreter].	platformName = 'Win32' ifTrue: [^WinKSX1001InputInterpreter].	platformName = 'Mac OS' 		ifTrue: 			[('10*' match: SmalltalkImage current osVersion) 				ifTrue: [^MacUnicodeInputInterpreter]				ifFalse: [^WinKSX1001InputInterpreter]].	platformName = 'unix' 		ifTrue: 			[encoding := X11Encoding encoding.			(EUCKRTextConverter encodingNames includes: encoding) 				ifTrue: [^MacRomanInputInterpreter].			(UTF8TextConverter encodingNames includes: encoding) 				ifTrue: [^MacRomanInputInterpreter]].				^MacRomanInputInterpreter! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:11'!leadingChar		^ 7! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:12'!systemConverterClass	| platformName osVersion encoding |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) 		ifTrue: [^UTF8TextConverter].	(#('Win32' 'ZaurusOS') includes: platformName) 		ifTrue: [^EUCKRTextConverter].	platformName = 'Mac OS' 		ifTrue: 			[^('10*' match: SmalltalkImage current osVersion) 				ifTrue: [UTF8TextConverter]				ifFalse: [EUCKRTextConverter]].	platformName = 'unix' 		ifTrue: 			[encoding := X11Encoding encoding.			encoding ifNil: [^EUCKRTextConverter].			(encoding = 'utf-8') 				ifTrue: [^UTF8TextConverter].										^EUCKRTextConverter].	^MacRomanTextConverter! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'yo 9/7/2009 21:26'!fontDownload	"(Locale isoLanguage: 'ja') languageEnvironment fontDownload"	| contents f |	(FileDirectory default fileExists: self fontFullName)		ifTrue: [^ true]."	Cursor read		showWhile: [self fontDownloadUrls				do: [:each | [contents := (each , '/' , self fontFileName) asUrl retrieveContents contents.					(contents first: 2)							= 'PK'						ifTrue: [f := FileStream newFileNamed: self fontFullName.							f binary.							[f nextPutAll: contents]								ensure: [f close].							^ true]]						on: NameLookupFailure						do: [:e | e]]].	self inform: 'Fonts does not found (' , self fontFullName , ')'."	^ false.! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'yo 8/31/2009 16:23'!fontFullName	"(Locale isoLanguage: 'ja') languageEnvironment fontFullName"	| dir |	dir := FileDirectory on: (Smalltalk imagePath, FileDirectory slash, 'fonts').	"dir exists is needed if it is in restricted mode"	dir exists		ifFalse: [dir assureExistence].	^ dir fullNameFor: self fontFileName! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'yo 8/31/2009 16:40'!installFont	"(Locale isoLanguage: 'ja') languageEnvironment installFont"	| result |	result := self fontDownload.	result ifTrue: [SARInstaller installSAR: self fontFullName].	^ result.! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'Richo 6/4/2010 08:20'!isFontAvailable	| encoding f |	encoding := self leadingChar + 1.	f _ TextStyle defaultFont.	f isFontSet ifTrue: [		f fontArray			at: encoding			ifAbsent: [^ false].		^ true	].	encoding = 1 ifTrue: [^ true].	(f fallbackFont fontArray		at: encoding		ifAbsent: [^ false]) isNil ifTrue: [^false].	^ true! !!LanguageEnvironment class methodsFor: 'class initialization' stamp: 'kks 10/13/2010 15:31'!startUp	self clearDefault.	self resetKnownEnvironments. "pick up platform-specific interpreter overrides"	Clipboard startUp.	self setUsePangoFlag.	HandMorph startUp.! !!LassoPatchMorph methodsFor: 'initialization'!justTornOffFromPartsBin	super justTornOffFromPartsBin.	self image: (Form extent: 0 @ 0).	"hide the icon"	ActiveHand showTemporaryCursor: Cursor crossHair! !!LassoPatchMorph methodsFor: 'dropping'!justDroppedInto: aPasteUpMorph event: anEvent 	"The user clicked indicating the beginning of the lassoing sequence."	self delete.	ActiveHand showTemporaryCursor: nil.	ActiveWorld displayWorldSafely; runStepMethods.	^ ActiveWorld grabLassoFromScreen: anEvent! !!LassoPatchMorph methodsFor: 'dropping' stamp: 'kfr 5/23/2009 14:51'!wantsToBeDroppedInto: aMorph	"Only wanted by the world"	^ aMorph isWorldMorph! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'bf 6/26/2010 14:13'!clipboardInterpreterClass	^UTF8ClipboardInterpreter! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'bf 9/6/2010 12:36'!inputInterpreterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion ~= 'CE'])		ifTrue: [^ (self win32VMUsesUnicode) ifTrue: [UTF32InputInterpreter] ifFalse: [MacRomanInputInterpreter]].	platformName = 'Mac OS'		ifTrue: [^ MacUnicodeInputInterpreter].	platformName = 'unix'		ifTrue: [^ UTF32InputInterpreter].	^ MacRomanInputInterpreter! !!LazyListMorph methodsFor: 'accessing' stamp: 'bf 4/21/2005 15:58'!userString	"Do I have a text string to be searched on?"	^ String streamContents: [:strm |		1 to: self getListSize do: [:i |			strm nextPutAll: (self getListItem: i); cr]]! !!Lexicon methodsFor: 'toolbuilder' stamp: 'sw 8/4/2009 17:31'!openOnClass: aTargetClass inWorld: aWorld showingSelector: aSelector	"Create and open a SystemWindow to house the receiver, showing the categories pane.  The target-object parameter is optional -- if nil, the browser will be associated with the class as a whole but not with any particular instance of it."	| window aListMorph catListFraction |	currentVocabulary ifNil: [currentVocabulary _ Vocabulary fullVocabulary].	targetClass _ aTargetClass.	self initialLimitClass.		window _ self windowWithLabel: self startingWindowTitle.	catListFraction _ 0.20.		window addMorph: self newCategoryPane frame: (0 @ 0 corner: 0.5 @ catListFraction).	aListMorph _ PluggableListMorph new.	aListMorph 	setProperty: #balloonTextSelectorForSubMorphs toValue: #balloonTextForLexiconString.	aListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph setNameTo: 'messageList'.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: (0.5 @ 0 corner: 1 @ catListFraction).		"side by side"	self reformulateCategoryList.	"needs to do this here because otherwise the following will break due to change 5738"	self 		addLowerPanesTo: window 		at: (0 @ catListFraction  corner: 1@1) 		with: nil.	window changeAllBorderColorsFrom: Color black to: (self defaultBackgroundColor mixed: 0.5 with: Color black).	window color: self defaultBackgroundColor.	window openInWorld: aWorld.	aSelector ifNotNil: [self selectSelectorItsNaturalCategory: aSelector] ifNil: [self categoryListIndex: 1].	#(navigateToPreviousMethod	 navigateToNextMethod removeFromSelectorsVisited) do:		[:sel |			(self buttonWithSelector: sel) ifNotNilDo:				[:aButton | aButton borderWidth: 0]].	self adjustWindowTitle.	window  paneColor: window paneColor  "don't ask"! !!Locale class methodsFor: 'accessing' stamp: 'bf 8/22/2010 18:16'!previous: aLocale	Previous := aLocale! !!Locale class methodsFor: 'accessing' stamp: 'bf 8/8/2010 13:28'!switchAndInstallFontToID: localeID gently: gentlyFlag	| locale result env envFound ret fontInImage menu |	"Assumption: Rainbow => can try Pango"	"Logic:		- in Sugar, we don't bother asking any questions, and we don't bother automatically loading fonts.			in Sugar, and if the font is available, use the font. 			in Sugar, and if the font is not in the image, try to enable Pango.			- if the previous step fails, notify the user that you cannot switch to the language.		- not in Rainbow, 			- if the font is in the image, use the font.			- if the font is not in the image,				- ask to choose:					- load font					- try to enable pango, if pango is available					- or cancel.			- if the previous step fails, notify the user that you cannot switch to the language.	Details:		- how to check non-pango font is available:			- if the language environment for the locale doesn't exist, the font is not available.			- if font loading fails, it is not available.		- how to check if the language environment doesn't exist:			- if the locales languageEnvironment is Latin1 but the locale isn't it is not available.	"		locale := Locale localeID: localeID.	env := locale languageEnvironment.	result := true.	envFound := (Latin1Environment supportedLanguages includes: locale isoLanguage) or: [(env isMemberOf: Latin1Environment) not].	fontInImage := envFound and: [env isFontAvailable].	SugarLauncher isRunningInSugar ifTrue: [		fontInImage ifFalse: [			"font is not available in the image.  Even don't ask for font installation."			Cursor wait showWhile: [				Preferences setPreference: #usePangoRenderer toValue: true.				TextMorph usePango: true]].	] ifFalse: [		(fontInImage not and: [envFound or: [RomePluginCanvas pangoIsAvailable]]) ifTrue: [			menu := MenuMorph new.			menu defaultTarget: menu.			envFound ifTrue: [menu add: 'load font' translated selector: #modalSelection: argument: #loadFont].			RomePluginCanvas pangoIsAvailable ifTrue: [menu add:  'enable Pango' translated selector: #modalSelection: argument: #enablePango].			menu add:  'cancel' translated selector: #modalSelection: argument: #cancel.			menu addTitle: 'This language needs additional fonts.Do you want to install the fonts?' translated.			ret := menu invokeModal.			ret = #loadFont ifTrue: [result := env installFont. result ifTrue: [StrikeFont setupDefaultFallbackTextStyle]].			ret = #enablePango ifTrue: [				(result := RomePluginCanvas pangoIsAvailable) ifTrue: [					Cursor wait showWhile: [						Preferences setPreference: #usePangoRenderer toValue: true.						TextMorph usePango: true]]].			(ret ~~ #loadFont and: [ret ~~ #enablePango]) ifTrue: [result := false]]].	result ifFalse: [self inform: 'Cannot load additional fonts' translated] ifTrue: [self switchTo: locale gently: gentlyFlag].! !!LocaleID methodsFor: 'accessing' stamp: 'Richo 5/25/2010 22:47'!displayName	"Answer a proper name to represent the receiver in GUI. 	 	The wording is provided by translations of the magic value 	'<language display name>'. 	 	'English' -> 'English'  	'German' -> 'Deutsch'  	"	| magicPhrase translatedMagicPhrase |	magicPhrase := 'Language-Name'.	translatedMagicPhrase := NaturalLanguageTranslator translateWithoutLoading: magicPhrase toLocaleID: self.	^ translatedMagicPhrase = magicPhrase		ifTrue: [self displayLanguage]		ifFalse: [translatedMagicPhrase]! !!M17nEnvironment commentStamp: 'kks 10/2/2010 19:45' prior: 0!This class supports multilingual Unicode environments that use UTF-8 encoding. Such a large scope implies the use of external fonts and external rendering engines like Pango. Currently, it is useful for Indic and a few Asian languages.!!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:38'!clipboardInterpreterClass	^ UTF8ClipboardInterpreter.! !!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:38'!fileNameConverterClass	^ UTF8TextConverter.! !!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:56'!inputInterpreterClass	| platformName |	platformName := SmalltalkImage current platformName.	platformName = 'Win32'			ifTrue: [ 'CE' = (SmalltalkImage current getSystemAttribute: 1002)						ifTrue: [^ MacRomanInputInterpreter]].	platformName = 'MacOS'			ifTrue: [^MacRomanInputInterpreter].	^M17nInputInterpreter.! !!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:42'!leadingChar	^ Unicode leadingChar.! !!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:43'!supportedLanguages	"Include languages that will not conflict with other languages"		^#('bn' 'gu' 'hi' 'kn' 'ml' 'mr' 'ta' 'te' 'sa')! !!M17nEnvironment class methodsFor: 'subclass responsibilities' stamp: 'kks 10/2/2010 19:43'!systemConverterClass	^ UTF8TextConverter.! !!M17nInputInterpreter methodsFor: 'as yet unclassified' stamp: 'kks 10/2/2010 23:35'!initialize	converter _ UTF8TextConverter new.! !!M17nInputInterpreter methodsFor: 'as yet unclassified' stamp: 'kks 10/2/2010 23:40'!nextCharFrom: sensor firstEvt: evtBuf 	| keyValue |	keyValue := evtBuf at: 6.	0 = keyValue ifTrue: [ ^self nextUtf8Char: sensor firstEvt: evtBuf ].	256 > keyValue ifTrue: [ ^keyValue asCharacter ].	^ Character leadingChar: (Locale current languageEnvironment leadingChar) code: keyValue! !!M17nInputInterpreter methodsFor: 'as yet unclassified' stamp: 'kks 10/2/2010 23:44'!nextUtf8Char: sensor firstEvt: evtBuf	"this code should really go into InputSensor>>fullKey"	| aCollection bytes peekEvent keyValue type stream multiChar evt |	self flag: #fixthis.	keyValue _ evtBuf third.	evtBuf fourth = EventKeyChar ifTrue: [type _ #keystroke].	peekEvent _ sensor peekEvent.	(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [		sensor nextEvent.		peekEvent _ sensor peekEvent].	(type == #keystroke	and: [peekEvent notNil 	and: [peekEvent first = EventTypeKeyboard	and: [peekEvent fourth = EventKeyChar]]]) ifTrue: [		aCollection _ OrderedCollection with: keyValue asCharacter.		bytes _ (keyValue <= 127)			ifTrue: [ 0 ]			ifFalse: [ (keyValue bitAnd: 16rE0) = 192				ifTrue: [ 1 ]				ifFalse: [ (keyValue bitAnd: 16rF0) = 224					ifTrue: [ 2 ]					ifFalse: [ 3 ]				]			].		[bytes > 0] whileTrue: [			(evt :=  sensor nextEvent) fourth = EventKeyChar ifTrue: [				bytes := bytes - 1.				aCollection add: (Character value: evt third)]].		"aCollection do: [ :each | Transcript show: (each asciiValue hex , ' ')].		Transcript show: Character cr."		stream _ ReadStream on: (String withAll: aCollection).		multiChar _ converter nextFromStream: stream.		multiChar isOctetCharacter ifFalse: [ sensor nextEvent ].		^ multiChar].	^ keyValue asCharacter! !!M17nInputInterpreter commentStamp: 'kks 10/2/2010 23:26' prior: 0!A flexible input interpreter that is tuned to variations in keyboard events coming in from the VM.Old VMs passed only a 8-bit keycode evt[3] and 0 in evt[6]. This code could be in any one of the code pages. On Mac, this used mac-roman, while on Unix, this could be ASCII or UTF-8 depending on the locale.Newer VMs pass UTF32 in evt[6]. This can be 'cooked' based on the current language setting to generate a Character.!!MacUnicodeInputInterpreter methodsFor: 'initialization' stamp: 'mu 6/30/2009 23:57'!initialize	| satisfiesVersion |	satisfiesVersion := self				majorMinorBuildFrom: SmalltalkImage current vmVersion				satisfies: [:major :minor :build | 					major >= 4 or: [					major >= 3 and: [minor >= 8 and: [build >= 7]]]].	satisfiesVersion		ifTrue: [keyValueIndex := 6]		ifFalse: [keyValueIndex := 3]! !!MacUnicodeInputInterpreter methodsFor: 'version check' stamp: 'mu 10/20/2009 15:04'!majorMinorBuildFrom: aString satisfies: aBlock 	| versionArray |	versionArray := SmalltalkImage current macVmMajorMinorBuildVersion.	^ aBlock valueWithArguments: versionArray! !!MacUTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'mu 6/30/2009 23:45'!fromSystemClipboard: aString	^ aString convertFromWithConverter: UTF8TextConverter new! !!MacUTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'mu 10/20/2009 15:11'!toSystemClipboard: text	| string |	string := text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string ].	^ string convertToWithConverter: UTF8TextConverter new .! !!MagnifierMorph methodsFor: 'drawing' stamp: 'kfr 3/20/2010 19:07'!drawOn: aCanvas       		| stencil newForm bb |		aCanvas isShadowDrawing ifFalse: [		"Optimize because #magnifiedForm is expensive"		self isRound			ifTrue:[stencil := (EllipseMorph new extent: self extent; color: Color white) imageForm.				bb := BitBlt toForm:  stencil.				newForm := (bb  copyForm: self magnifiedForm to: 0@0 rule: Form and) destForm.				aCanvas paintImage: newForm at: self innerBounds origin	]			ifFalse:[super drawOn: aCanvas. "border and fill"		aCanvas paintImage: self magnifiedForm at: self innerBounds origin]]! !!MagnifierMorph methodsFor: 'initialization' stamp: 'kfr 3/14/2010 15:24'!initialize	"initialize the state of the receiver"	super initialize.	trackPointer _ true.	showPointer _ false.	magnification _ 2.	roundness := false.	self extent: 128 @ 128! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'kfr 3/14/2010 14:20'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^(trackPointer not or: [owner notNil and: [owner isHandMorph]])		ifTrue: [self isFlexed ifTrue:[owner center] ifFalse:[self center]]		ifFalse: [self currentHand position]! !!MagnifierMorph methodsFor: 'round view' stamp: 'bf 8/24/2010 15:05'!isRound	^ roundness == true! !!MagnifierMorph methodsFor: 'round view' stamp: 'kfr 3/20/2010 19:09'!toggleRoundness	roundness := roundness not.	self fullBounds changed	! !!MagnifierMorph methodsFor: 'testing' stamp: 'kfr 3/14/2010 14:14'!stepTime	^ 100! !!MagnifierMorph commentStamp: '<historical>' prior: 0!MagnifierMorph instances are magnifying lenses that magnify the morphs below them (if grabbed or if trackPointer is false) or the area around the mouse pointer.Instance variables:magnification	<Number> The magnification to use. If non-integer, smooths the magnified form.trackPointer		<Boolean> If set, magnifies the area around the Hand. If not, magnfies the area underneath the magnifier center.showPointer		<Boolean> If set, display a small reversed rectangle in the center of the lens. Also enables the display of Morphs in the Hand itself.srcExtent		<Rectangle> The extent of the source rectangle.		Class variables:RecursionLock	<MagnifierMorph|nil> Used to avoid infinite recursion when getting the source patch to display.!!MCAddition methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11'!applyTo: anObject	anObject addDefinition: definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09'!baseDefinition	^ nil! !!MCAddition methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:32'!definition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45'!fromSource	^ ''! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:39'!sourceString	^(self toSource asText)		addAttribute: TextColor red;		yourself! !!MCAddition methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18'!summary	^ definition summary! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:17'!targetClass	^definition actualClass ! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09'!targetDefinition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45'!toSource	^ definition source! !!MCAddition methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26'!inverse	^ MCRemoval of: definition! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28'!isClassPatch	^definition isClassDefinition! !!MCAddition methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:22'!isAddition	^ true! !!MCAddition class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03'!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57'!allAncestorsDo: aBlock	self ancestors do:		[:ea |		aBlock value: ea.		ea allAncestorsDo: aBlock]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57'!allAncestorsOnPathTo: aVersionInfo	^ MCFilteredVersionSorter new		target: aVersionInfo;		addAllVersionInfos: self ancestors;		sortedVersionInfos! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57'!ancestorString	^ String streamContents:		[:s | self ancestors do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57'!ancestors	^ ancestors ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'bf 12/22/2004 21:55'!ancestorsDoWhileTrue: aBlock	self ancestors do:		[:ea |		(aBlock value: ea) ifTrue: 			[ea ancestorsDoWhileTrue: aBlock]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03'!breadthFirstAncestors	^ Array streamContents: [:s | self breadthFirstAncestorsDo: [:ea | s nextPut: ea]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47'!breadthFirstAncestorsDo: aBlock	| seen todo next |	seen := Set with: self.	todo := OrderedCollection with: self.	[todo isEmpty] whileFalse:		[next := todo removeFirst.		next ancestors do:			[:ea |			(seen includes: ea) ifFalse:				[aBlock value: ea.				seen add: ea.				todo add: ea]]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47'!commonAncestorsWith: aVersionInfo	| sharedAncestors mergedOrder sorter |	sorter := MCVersionSorter new						addVersionInfo: self;						addVersionInfo: aVersionInfo.	mergedOrder := sorter sortedVersionInfos.	sharedAncestors := (sorter allAncestorsOf: self) intersection: (sorter allAncestorsOf: aVersionInfo).	^ mergedOrder select: [:ea | sharedAncestors includes: ea]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47'!commonAncestorWith: aNode	| commonAncestors |	commonAncestors := self commonAncestorsWith: aNode.	^ commonAncestors at: 1 ifAbsent: [nil]! !!MCAncestry methodsFor: 'ancestry' stamp: 'bf 5/4/2010 18:39'!findAncestor: aVersionInfo	self breadthFirstAncestorsDo: [:each |		each = aVersionInfo ifTrue: [^each]].	^nil! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16'!hasAncestor: aVersionInfo	^ self		hasAncestor: aVersionInfo		alreadySeen: OrderedCollection new! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16'!hasAncestor: aVersionInfo alreadySeen: aList	(aList includes: self) ifTrue: [^ false].	aList add: self.	^ self = aVersionInfo or: [self ancestors anySatisfy: [:ea | ea hasAncestor: aVersionInfo alreadySeen: aList]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:58'!isRelatedTo: aVersionInfo	^ aVersionInfo timeStamp < self timeStamp		ifTrue: [self hasAncestor: aVersionInfo]		ifFalse: [aVersionInfo hasAncestor: self]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/11/2004 15:08'!stepChildren	^ stepChildren ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/14/2004 15:21'!stepChildrenString	^ String streamContents:		[:s | self stepChildren do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'nice 12/27/2009 03:11'!topologicalAncestors		^ Array streamContents:		[:s | | frontier f |		frontier := MCFrontier frontierOn: self.		[f := frontier frontier.		s nextPutAll: f.		frontier removeAll: f.		f isEmpty] whileFalse] ! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03'!withBreadthFirstAncestors	^ (Array with: self), self breadthFirstAncestors! !!MCAncestry methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	ancestors := #().	stepChildren := #()! !!MCAncestry commentStamp: '<historical>' prior: 0!Abstract superclass of records of ancestry.!!MCAncestry class methodsFor: 'as yet unclassified' stamp: 'avi 2/12/2004 21:02'!new	^ self basicNew initialize! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/23/2005 00:52'!basicStoreVersion: aVersion	(aVersion isCacheable and: [self allFileNames includes: aVersion fileName])		ifFalse: [super basicStoreVersion: aVersion]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!cacheForPackage: aPackage	packageCaches ifNil: [packageCaches := Dictionary new].	^ packageCaches at: aPackage ifAbsentPut: [MCPackageCache new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:15'!newFileNames 	^ self allFileNames difference: self seenFileNames! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:13'!packageForFileNamed: aString	^ self packageCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r package]]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:29'!rescan	self newFileNames do:		[:ea |		self versionReaderForFileNamed: ea do:			[:reader |			(self cacheForPackage: reader package)				recordVersionInfo: reader info				forFileNamed: ea.			self seenFileNames add: ea]]		displayingProgress: 'Scanning cache...'! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!seenFileNames	^ seenFiles ifNil: [seenFiles := OrderedCollection new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:05'!versionInfoForFileNamed: aString	^ self infoCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r info]]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:46'!cacheDirectory	^ (FileDirectory default directoryNamed: 'package-cache')		assureExistence;		yourself! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!checkCacheDirectory	default notNil and: [default directory exists ifFalse: [default := nil]]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!default	self checkCacheDirectory.	^ default ifNil: [default := self new directory: self cacheDirectory]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56'!description	^ nil! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 16:21'!initialize	self checkCacheDirectory! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01'!defaultAction	^ (MCChangeSelector new patch: patch; label: label) showModally! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:02'!label	^ label! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!label: aString	label := aString! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:12'!patch	^ patch! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!patch: aPatch	patch := aPatch! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:07'!buttonSpecs	^ #((Select select 'Select these changes')		 (Cancel cancel 'Cancel the operation')		)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26'!cancel	self answer: nil! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01'!defaultLabel	^ 'Change Selector'! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:13'!innerButtonRow	^ self buttonRow:		#(('Select All' selectAll 'select all changes')		  ('Select None' selectNone 'select no changes'))! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!kept	^ kept ifNil: [kept := Set new]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:22'!listSelectionAt: aNumber	^ self kept includes: (self items at: aNumber)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!listSelectionAt: aNumber put: aBoolean	| item |	item := self items at: aNumber.	aBoolean		ifTrue: [self kept add: item ]		ifFalse: [self kept remove: item ifAbsent: []]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26'!select	self answer: (MCPatch operations: kept)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:00'!selectAll	kept addAll: self items.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!selectNone	kept := Set new.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:25'!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCClassDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 19:33'!accept: aVisitor	aVisitor visitClassDefinition: self.	(self hasClassInstanceVariables or: [self hasClassTraitComposition])		ifTrue: [aVisitor visitMetaclassDefinition: self].! !!MCClassDefinition methodsFor: 'visiting' stamp: 'nice 10/31/2009 13:11'!= aDefinition	^(super = aDefinition)		and: [superclassName = aDefinition superclassName		and: [self traitCompositionString = aDefinition traitCompositionString		and: [self classTraitCompositionString = aDefinition classTraitCompositionString		and: [category = aDefinition category		and: [type = aDefinition type		and: [self sortedVariables = aDefinition sortedVariables		and: [comment = aDefinition comment]]]]]]]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'nk 2/25/2005 09:49'!actualClass	^Smalltalk classNamed: self className! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 06:23'!category	^ category! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:32'!classInstVarNames	^ self selectVariables: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:52'!className	^ name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:07'!classTraitComposition	^classTraitComposition! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55'!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'nice 10/20/2009 22:03'!classVarNames	^(self selectVariables: #isClassVariable) asArray sort! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42'!comment	^ comment! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 8/10/2003 16:40'!commentStamp	^ commentStamp! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 12/5/2002 21:24'!description	^ Array with: name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:33'!instVarNames	^ self selectVariables: #isInstanceVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:53'!poolDictionaries	^ self selectVariables: #isPoolImport! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:28'!selectVariables: aSelector	^ variables select: [:v | v perform: aSelector] thenCollect: [:v | v name]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'bf 8/29/2006 11:45'!sortedVariables	"sort variables for comparison purposes"	| sorted |	sorted := variables select: [:var | var isOrderDependend].	sorted addAll: ((variables reject: [:var | var isOrderDependend])		asSortedCollection: [:a :b | a name <= b name]).	^sorted! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 7/19/2003 18:00'!sortKey	^ self className! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 17:41'!superclassName	^ superclassName! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:16'!traitComposition	^traitComposition! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55'!traitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 22:35'!type	^ type! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 06:51'!variables	^ variables! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 7/7/2003 23:19'!addVariables: aCollection ofType: aClass	variables addAll: (aCollection collect: [:var | aClass name: var asString]).! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 8/10/2003 17:39'!defaultCommentStamp	^ String new	"The version below avoids stomping on stamps already in the image	^ (Smalltalk at: name ifPresent: [:c | c organization commentStamp])		ifNil: ['']	"! !!MCClassDefinition methodsFor: 'initializing' stamp: 'bf 8/12/2009 10:55'!initializeWithName: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	superclassName := superclassString ifNil: ['nil'] ifNotNil: [superclassString asSymbol].	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray asSortedCollection ofType: MCClassVariableDefinition.	self addVariables: poolArray asSortedCollection ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'initializing' stamp: 'bf 8/12/2009 10:55'!initializeWithName: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	superclassName := superclassString ifNil: ['nil'] ifNotNil: [superclassString asSymbol].	traitComposition := traitCompositionString.	classTraitComposition := classTraitCompositionString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray asSortedCollection ofType: MCClassVariableDefinition.	self addVariables: poolArray asSortedCollection ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35'!classInstanceVariablesString	^ self stringForVariablesOfType: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:36'!classVariablesString	^ self stringForVariablesOfType: #isClassVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:32'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 8/2/2003 02:03'!definitionString	^ String streamContents: [:stream | self printDefinitionOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35'!instanceVariablesString	^ self stringForVariablesOfType: #isInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 11/24/2002 22:16'!kindOfSubclass	type = #normal ifTrue: [^ ' subclass: '].	type = #words ifTrue: [^ ' variableWordSubclass: '].	type = #variable ifTrue: [^ ' variableSubclass: '].	type = #bytes ifTrue: [^ ' variableByteSubclass: '].	type = #weak ifTrue: [^ ' weakSubclass: ' ].	type = #compiledMethod ifTrue: [^ ' variableByteSubclass: ' ].	self error: 'Unrecognized class type'! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'al 3/28/2006 23:42'!printDefinitionOn: stream		stream 			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className;			cr; tab.		self hasTraitComposition ifTrue: [			stream 				nextPutAll: 'uses: ';		 		nextPutAll: self traitCompositionString;				cr; tab ].		stream			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString;			cr; tab;			nextPutAll: 'classVariableNames: ';			store: self classVariablesString;			cr; tab;			nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString;			cr; tab;			nextPutAll: 'category: ';			store: self category asString! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:54'!sharedPoolsString	^ self stringForVariablesOfType: #isPoolImport! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33'!source	^ self definitionAndCommentString! !!MCClassDefinition methodsFor: 'printing' stamp: 'ab 11/16/2002 17:33'!summary	^ name! !!MCClassDefinition methodsFor: 'installing' stamp: 'ar 3/14/2010 00:25'!createClass	| superClass class composition |	superClass := superclassName == #nil ifFalse:					[Smalltalk at: superclassName].	[class := (ClassBuilder new)			name: name 			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category.	] on: Warning, DuplicateVariableError do:[:ex| ex resume].	"The following is written to support traits unloading"	composition := Compiler evaluate: (self traitComposition ifNil:['{}']).	(composition isCollection and:[composition isEmpty and:[class traitComposition isEmpty]]) ifFalse:[		class setTraitComposition: composition asTraitComposition.	].	composition := Compiler evaluate: (self classTraitComposition ifNil:['{}']).	(composition isCollection and:[composition isEmpty and:[class class traitComposition isEmpty]]) ifFalse:[		class class setTraitComposition: composition asTraitComposition.	].	^class! !!MCClassDefinition methodsFor: 'installing' stamp: 'ul 12/12/2009 14:10'!load	 self createClass ifNotNil:		[:class |		class class instanceVariableNames: self classInstanceVariablesString.		self hasComment ifTrue: [class classComment: comment stamp: commentStamp]]! !!MCClassDefinition methodsFor: 'installing' stamp: 'cwp 2/3/2004 21:35'!stringForVariablesOfType: aSymbol	^ String streamContents:		[:stream |		(self selectVariables: aSymbol) 			do: [:ea | stream nextPutAll: ea]			separatedBy: [stream space]]! !!MCClassDefinition methodsFor: 'installing' stamp: 'ab 11/13/2002 19:39'!unload	Smalltalk removeClassNamed: name! !!MCClassDefinition methodsFor: 'testing' stamp: 'cwp 8/2/2003 02:54'!hasClassInstanceVariables	^ (self selectVariables: #isClassInstanceVariable) isEmpty not! !!MCClassDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 21:59'!hasClassTraitComposition	^self classTraitCompositionString ~= '{}'! !!MCClassDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:13'!hasComment	^ comment isEmptyOrNil not! !!MCClassDefinition methodsFor: 'testing' stamp: 'al 3/29/2006 00:27'!hasTraitComposition	^self traitCompositionString ~= '{}'! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52'!isClassDefinition	^ true! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49'!isCodeDefinition	^ true! !!MCClassDefinition methodsFor: 'comparing' stamp: 'ul 11/2/2009 03:32'!hash	| hash |	hash := name hashWithInitialHash: 0.	hash := superclassName hashWithInitialHash: hash.	hash := self traitCompositionString hashWithInitialHash: hash.	hash := self classTraitComposition asString hashWithInitialHash: hash.	hash := (category ifNil: ['']) hashWithInitialHash: hash.	hash := type hashWithInitialHash: hash.	variables do: [ :v |		hash := v name hashWithInitialHash: hash ].	^hash! !!MCClassDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:12'!provisions	^ Array with: name! !!MCClassDefinition methodsFor: 'comparing' stamp: 'eem 9/25/2009 12:59'!requirements	^superclassName == #nil		ifTrue: [self poolDictionaries]		ifFalse: [(Array with: superclassName), self poolDictionaries]! !!MCClassDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:05'!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #requirements ifTrue: [			self requirements do: [ :req | aStream nextPutAll: req ] separatedBy: [ aStream space ]]	] separatedBy: [ aStream space ].! !!MCClassDefinition methodsFor: 'serializing' stamp: 'al 7/4/2006 10:14'!storeDataOn: aDataStream	| instVarSize |	instVarSize := (self hasTraitComposition or: [ self hasClassTraitComposition ])		ifTrue: [ self class instSize ]		ifFalse: [ self class instSize - 2 ].	aDataStream		beginInstance: self class		size: instVarSize.	1 to: instVarSize do: [ :index |		aDataStream nextPut: (self instVarAt: index) ].! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22'!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: cvarArray			poolDictionaryNames: poolArray			classInstVarNames: civarArray			type: #normal			comment: commentString! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'cwp 8/10/2003 16:33'!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentString	^ self 		name: nameString		superclassName: superclassString		category: categoryString 		instVarNames: ivarArray		classVarNames: cvarArray		poolDictionaryNames: poolArray		classInstVarNames: civarArray		type: typeSymbol		comment: commentString		commentStamp: nil! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22'!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: #()			poolDictionaryNames: #()			classInstVarNames: #()			comment: commentString! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/9/2005 19:16'!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString	^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: '{}'					classTraitComposition: '{}'					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/10/2005 13:58'!name: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString		^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: traitCompositionString					classTraitComposition: classTraitCompositionString					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:31'!isClassInstanceVariable	^ true! !!MCClassInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59'!type	^ #classInstance! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23'!baseTrait	^baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 12/15/2005 11:31'!className	^self baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23'!classTraitComposition	^classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/10/2005 10:12'!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:59'!definitionString	^self baseTrait , ' classTrait	uses: ' , self classTraitCompositionString.! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24'!description	^Array		with: baseTrait		with: classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'ul 11/2/2009 03:32'!hash	| hash |	hash := baseTrait hashWithInitialHash: 0.	hash := self classTraitCompositionString hashWithInitialHash: hash.	^hash! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24'!requirements	^Array with: baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25'!sortKey	^ self baseTrait name , '.classTrait'! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25'!source	^self definitionString! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25'!summary	^self baseTrait , ' classTrait'! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'nice 10/31/2009 13:11'!= aDefinition	^ (super = aDefinition)		and: [baseTrait = aDefinition baseTrait		and: [self classTraitCompositionString = aDefinition classTraitCompositionString]]! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:23'!accept: aVisitor	^ aVisitor visitClassTraitDefinition: self.! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:24'!load		Compiler evaluate: self definitionString! !!MCClassTraitDefinition methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithBaseTraitName: aTraitName classTraitComposition: aString	baseTrait := aTraitName.	classTraitComposition := aString.! !!MCClassTraitDefinition class methodsFor: 'instance creation' stamp: 'al 10/9/2005 20:22'!baseTraitName: aString classTraitComposition: classTraitCompositionString	^self instanceLike: (		self new			initializeWithBaseTraitName: aString			classTraitComposition: classTraitCompositionString).! !!MCClassTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToEnd) withBlanksTrimmed.	definition := MCClassTraitDefinition		baseTraitName: (tokens at: 1) 		classTraitComposition: traitCompositionString.	aCollection add: definition! !!MCClassTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:43'!pattern	^ '*classTrait*uses:*'! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32'!isClassVariable	^ true! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCClassVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:58'!type	^ #class! !!MCCodeTool methodsFor: 'menus' stamp: 'ul 12/12/2009 14:10'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self selectedClassOrMetaClass ifNotNil: [ :cl |		self selectedMessageName ifNotNil: [ :sel |			ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotations ]]! !!MCCodeTool methodsFor: 'menus' stamp: 'ar 3/5/2010 20:57'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	| aClass |	(Smalltalk isMorphic and: [Smalltalk hasClassNamed: #Lexicon]) ifFalse: [^ self spawnFullProtocol].	(aClass := self selectedClassOrMetaClass) ifNotNil:		[(Smalltalk at: #Lexicon) new openOnClass: aClass inWorld: ActiveWorld showingSelector: self selectedMessageName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:26'!browseMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all implementors of the selector chosen."	self systemNavigation browseAllImplementorsOf: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass := self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:54'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self systemNavigation browseAllCallsOn: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector compiledMethod |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	compiledMethod := class compiledMethodAt: selector ifAbsent: [ ^self ].	VersionsBrowser		browseVersionsOf: compiledMethod		class: class theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	self systemNavigation  spawnHierarchyForClass: self selectedClassOrMetaClass		selector: self selectedMessageName	"OK if nil"! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 6/12/2004 14:01'!classListMenu: aMenu 	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse protocol (p)'		browseFullProtocol)"		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)"		-		('show hierarchy'			methodHierarchy)"		('show definition'			editClass)		('show comment'			editComment)""		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)"		-		('find method...'				findMethodInChangeSets)).								^aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47'!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector := self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32'!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName := self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	self systemNavigation methodHierarchyBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 2/16/2004 17:00'!methodListKey: aKeystroke from: aListMorph 	aKeystroke caseOf: {		[$b] -> [self browseMethodFull].		[$h] -> [self classHierarchy].		[$O] -> [self openSingleMessageBrowser].		[$p] -> [self browseFullProtocol].		[$o] -> [self fileOutMessage].		[$c] -> [self copySelector].		[$n] -> [self browseSendersOfMessages].		[$m] -> [self browseMessages].		[$i] -> [self methodHierarchy].		[$v] -> [self browseVersions]}		 otherwise: []! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 10/27/2008 17:07'!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47'!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName := self selectedMessageName) ifNil: [^ self].	mr := MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	self systemNavigation 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:55'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:58'!printOutMessage	"Write a file with the text of the selected message, for printing by a web browser"	self selectedMessageName ifNotNil: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName							asHtml: true]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:00'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotations! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:01'!annotations	"Build an annotations string for the various browsers"	^''! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02'!selectedClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02'!selectedClassOrMetaClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02'!selectedMessageCategoryName	"Answer the method category of the method that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02'!selectedMessageName	"Answer the name of the selected message"	self subclassResponsibility! !!MCCodeTool commentStamp: 'nk 11/10/2003 22:00' prior: 0!MCCodeTool is an abstract superclass for those Monticello browsers that display code.It contains copies of the various CodeHolder methods that perform the various menu operations in the method list.!!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 22:09'!browse	(MCConfigurationBrowser new configuration: self) show! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 10:51'!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19'!load	^self depsSatisfying: [:dep | dep isCurrent not]		versionDo: [:ver | ver load]		displayingProgress: 'loading packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19'!merge	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | ver merge]		displayingProgress: 'merging packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 5/23/2005 15:40'!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:19'!changes	^MCPatch operations: #()! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:17'!info	^MCVersionInfo new! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:32'!dependencies	^dependencies ifNil: [dependencies := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 18:40'!dependencies: aCollection	dependencies := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:22'!fileName	^ self name, '.', self writerClass extension! !!MCConfiguration methodsFor: 'accessing' stamp: 'mp 2/2/2010 20:38'!log	"Answer the receiver's log. If no log exist use the default log"		^log ifNil: [		(name notNil and: [ self class logToFile ]) ifFalse: [ 			Transcript countOpenTranscripts = 0 ifTrue: [Transcript open].			^Transcript ].		self log: ((FileStream fileNamed: self logFileName) setToEnd; yourself).		log ]! !!MCConfiguration methodsFor: 'accessing' stamp: 'ul 12/10/2009 11:56'!logFileName	^self name, '-', (FileDirectory localNameFor: SmalltalkImage current imageName), '.log'	! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 4/28/2005 11:55'!log: aStream	log := aStream.! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23'!name	^name! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23'!name: aString	name := aString! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:35'!repositories	^repositories ifNil: [repositories := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:36'!repositories: aCollection	repositories := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 00:44'!summary	^String streamContents: [:stream |		self dependencies			do: [:ea | stream nextPutAll: ea versionInfo name; cr ]]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:50'!writerClass	^ MCMcmWriter ! !!MCConfiguration methodsFor: 'private' stamp: 'ar 12/30/2009 17:31'!depsSatisfying: selectBlock versionDo: verBlock displayingProgress: progressString	| repoMap count action |	repoMap := Dictionary new.	self repositories do: [:repo |		MCRepositoryGroup default addRepository: repo.		repo allVersionNames			ifEmpty: [self logWarning: 'cannot read from ', repo description]			ifNotEmptyDo: [:all | all do: [:ver | repoMap at: ver put: repo]]].	count := 0.	action := [:dep |		| ver repo |		ver := dep versionInfo name.		repo := repoMap at: ver ifAbsent: [			self logError: 'Version ', ver, ' not found in any repository'.			self logError: 'Aborting'.			^count].		(selectBlock value: dep) ifTrue: [			| new |			new := self versionNamed: ver for: dep from: repo.			new ifNil: [					self logError: 'Could not download version ', ver, ' from ', repo description.					self logError: 'Aborting'.					^count]				ifNotNil: [					self logUpdate: dep package with: new.					self class extraProgressInfo						ifTrue:[ProgressNotification signal: '' extra: 'Installing ', ver].					verBlock value: new.					count := count + 1.				]		].		dep package workingCopy repositoryGroup addRepository: repo.	].	self class extraProgressInfo 		ifTrue:[self dependencies do: action displayingProgress: progressString]		ifFalse:[self dependencies do: action].	^count! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 11:26'!diffBaseFor: aDependency	| wc |	aDependency package hasWorkingCopy ifFalse: [^nil].	wc := aDependency package workingCopy.	wc ancestors ifEmpty: [^nil].	^wc ancestors first name! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:07'!logError: aString	self log		cr; nextPutAll: 'ERROR: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 15:59'!logUpdate: aPackage with: aVersion	self log		cr; nextPutAll: '========== ', aVersion info name, ' =========='; cr;		cr; nextPutAll: aVersion info message asString; cr;		flush.	aPackage hasWorkingCopy ifFalse: [^self].	aPackage workingCopy ancestors do: [:each |		(aVersion info hasAncestor: each)			ifTrue: [(aVersion info allAncestorsOnPathTo: each)				do: [:ver | self log cr; nextPutAll: '>>> ', ver name, ' <<<'; cr;							nextPutAll: ver message; cr; flush]]]! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:08'!logWarning: aString	self log		cr; nextPutAll: 'WARNING: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 5/23/2005 14:47'!mustMerge: aVersion	"answer true if we have to do a full merge and false if we can simply load instead"		| pkg wc current |	(pkg := aVersion package) hasWorkingCopy ifFalse: [^false "no wc -> load"].	(wc := pkg workingCopy) modified ifTrue: [^true "modified -> merge"].	wc ancestors isEmpty ifTrue: [^true "no ancestor info -> merge"].	current := wc ancestors first.	(aVersion info hasAncestor: current) ifTrue: [^false "direct descendant of wc -> load"].	"new branch -> merge"	^true! !!MCConfiguration methodsFor: 'private' stamp: 'ar 8/6/2009 21:48'!versionInfoNamed: newName for: dep from: repo	"Retrieves the version info instead of the version. Searches in-image first, in case the desired version is part of an already loaded package (usual case when doing a partial update). If not present defaults to versionNamed:for:from: an uses its result."	MCWorkingCopy registry at: dep package ifPresent:[:workingCopy| | seen |		"Don't use allAncestorsDo: - apparently this can loop indefinitely.		Rather keep track of the versions that we've seen and make sure we don't loop."		seen := Set new.		workingCopy ancestry ancestorsDoWhileTrue:[:vInfo|			vInfo name = newName ifTrue:[^vInfo].			(seen includes: vInfo) ifTrue:[false] ifFalse:[seen add: vInfo. false]		].	].	^(self versionNamed: newName for: dep from: repo) info! !!MCConfiguration methodsFor: 'private' stamp: 'ar 12/30/2009 17:33'!versionNamed: verName for: aDependency from: repo	| baseName fileName ver |	(repo filterFileNames: repo cachedFileNames forVersionNamed: verName) ifNotEmptyDo: [:cachedNames |		fileName := cachedNames anyOne.		self class extraProgressInfo			ifTrue:[ProgressNotification signal: '' extra: 'Using cached ', fileName].		ver := repo versionFromFileNamed: fileName].	ver ifNil: [		baseName := self diffBaseFor: aDependency.		(baseName notNil and: [baseName ~= verName and: [repo includesVersionNamed: baseName]]) ifTrue: [			fileName := (MCDiffyVersion nameForVer: verName base: baseName), '.mcd'.			self class extraProgressInfo				ifTrue:[ProgressNotification signal: '' extra: 'Downloading ', fileName].			ver := repo versionFromFileNamed: fileName]].	ver ifNil: [		fileName := verName, '.mcz'.		self class extraProgressInfo			ifTrue:[ProgressNotification signal: '' extra: 'Downloading ', fileName].		ver := repo versionFromFileNamed: fileName].	^ver! !!MCConfiguration methodsFor: 'initialize' stamp: 'ar 5/27/2005 17:28'!initialize	super initialize.	log := DefaultLog.! !!MCConfiguration methodsFor: 'testing' stamp: 'bf 3/22/2005 22:56'!isCacheable	^false! !!MCConfiguration methodsFor: 'updating' stamp: 'bf 5/23/2005 17:43'!updateFromImage	self dependencies: (self dependencies collect: [:dep |		dep package hasWorkingCopy			ifTrue: [				dep package workingCopy in: [:wc |					MCVersionDependency package: wc package info: wc ancestors first]]			ifFalse: [dep]]).! !!MCConfiguration methodsFor: 'updating' stamp: 'nice 10/21/2009 00:09'!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asArray sort:		[:a :b | a numericSuffix > b numericSuffix].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | (each copyUpToLast: $-) = dep package name]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo info  |				repo := newNames at: newName.				info := self versionInfoNamed: newName for: dep from: repo.				info ifNil: [dep]					ifNotNil: [MCVersionDependency package: dep package info: info]			])	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27'!defaultLog	"Answer the default configuration log"	^DefaultLog! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27'!defaultLog: aStream	"Set the default configuration log"	DefaultLog := aStream.! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:43'!dependencyFromArray: anArray	^MCVersionDependency		package: (MCPackage named: anArray first)		info: (			MCVersionInfo			name: anArray second			id: (UUID fromString: anArray third)			message: nil			date: nil			time: nil			author: nil			ancestors: nil)! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:44'!dependencyToArray: aDependency	^ {		aDependency package name . 		aDependency versionInfo name . 		aDependency versionInfo id asString }! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 6/9/2005 14:25'!repositoryFromArray: anArray	^ MCRepositoryGroup default repositories		detect: [:repo | repo description = anArray first]		ifNone: [			MCHttpRepository				location: anArray first				user: ''				password: '']! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:51'!repositoryToArray: aRepository	^ {aRepository description}! !!MCConfiguration class methodsFor: 'preferences' stamp: 'ar 12/30/2009 17:30'!extraProgressInfo	"Answer true for additional progress info during load. 	With the newly added MC down/upload operations this seems unnecessary	but some people might disagree, so let's leave it as a preference right now"	<preference: 'Extra Progress Info' 		category: 'Monticello' 		description: 'If true, additional progress information is displayed when loading MC configurations (i.e., during updates)' 		type: #Boolean>	^ExtraProgressInfo ifNil:[false]! !!MCConfiguration class methodsFor: 'preferences' stamp: 'ar 12/30/2009 17:30'!extraProgressInfo: aBool	"Whether to display for additional progress info during load."	ExtraProgressInfo := aBool.! !!MCConfiguration class methodsFor: 'preferences' stamp: 'ar 8/21/2009 21:18'!logToFile	"Whether to log configuration info to files by default.	If true, logs to a file named after the configuration (config.nn.log).	If false, logs to the transcript."	<preference: 'Log config info to disk' 		category: 'Monticello' 		description: 'If true, configuration information (such as change logs) are logged to disk instead of the Transcript. The log file is named after the configuration map (config.nn.log)' 		type: #Boolean>	^LogToFile ifNil:[true].! !!MCConfiguration class methodsFor: 'preferences' stamp: 'ar 8/21/2009 21:13'!logToFile: aBool	"Whether to log configuration info to files by default.		MCConfiguration logToFile: true.		MCConfiguration logToFile: false.	"	LogToFile := aBool! !!MCConfiguration class methodsFor: 'instance creation' stamp: 'bf 3/24/2005 01:51'!fromArray: anArray	| configuration |	configuration := self new.	anArray pairsDo: [:key :value |		key = #repository			ifTrue: [configuration repositories add: (self repositoryFromArray: value)].		key = #dependency			ifTrue: [configuration dependencies add: (self dependencyFromArray: value)].	].	^configuration! !!MCConfiguration class methodsFor: 'class initialization' stamp: 'bf 4/20/2005 17:20'!initialize	"MCConfiguration initialize"	Preferences addPreference: #upgradeIsMerge		categories: #('updates') default: false 		balloonHelp: 'When upgrading packages, use merge instead of load'.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 22:08'!add	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:01'!down	self canMoveDown ifTrue: [		self list swap: self index with: self index + 1.		self index: self index + 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!installMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'load packages' action: #load.	menu add: 'merge packages' action: #merge.	menu add: 'upgrade packages' action: #upgrade.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42'!load	self configuration load.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!loadMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42'!merge	self configuration merge.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'ar 8/6/2009 20:41'!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := UIManager default		request: 'Update name (.cs) will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names := ServerDirectory groupNames asSortedArray.		choice := UIManager default chooseFrom: names values: names.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:05'!remove	self canRemove ifTrue: [		self list removeAt: self index.		self changedList.		self updateIndex.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:10'!store	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	self pickName ifNotNil: [:name |		self configuration name: name.		self pickRepository ifNotNil: [:repo |			repo storeVersion: self configuration]].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 20:53'!up	self canMoveUp ifTrue: [		self list swap: self index with: self index - 1.		self index: self index - 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!updateMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:43'!upgrade	self configuration upgrade.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 22:08'!addDependency	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:36'!checkDependencies	^self checkModified and: [self checkMissing]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:35'!checkMissing	| missing |	missing := (self dependencies collect: [:ea | ea versionInfo name]) asSet.	self repositories		do: [:repo |			repo allVersionNames				do: [:found | missing remove: found ifAbsent: []]]		displayingProgress: 'searching versions'.	^missing isEmpty or: [		self selectDependency: missing anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'No repository found for'; cr.			missing do: [:r | strm nextPutAll: r; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:37'!checkModified	| modified |	modified := self dependencies select: [:dep |		dep isFulfilled and: [dep package workingCopy modified]].		^modified isEmpty or: [		self selectDependency: modified anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'These packages are modified:'; cr.			modified do: [:dep | strm nextPutAll: dep package name; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:28'!dependencyList	^self dependencies collect: [:dep | 		Text string: dep versionInfo name			attributes: (Array streamContents: [:attr |				dep isFulfilledByAncestors					ifFalse: [attr nextPut: TextEmphasis bold]					ifTrue: [dep isCurrent ifFalse: [attr nextPut: TextEmphasis italic]].			])]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 17:56'!selectedDependency	^ self dependencies at: self dependencyIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'ul 12/12/2009 14:10'!selectedPackage	^ self selectedDependency ifNotNil: [:dep | dep package]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'ul 12/12/2009 14:10'!addRepository	(self pickRepositorySatisfying: [:ea | (self repositories includes: ea) not])		ifNotNil: [:repo |			(repo isKindOf: MCHttpRepository)				ifFalse: [^self inform: 'Only HTTP repositories are supported'].			self repositories add: repo.			self changed: #repositoryList.		]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:45'!checkRepositories	| bad |	bad := self repositories reject: [:repo | repo isKindOf: MCHttpRepository].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Please remove these repositories:'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: '(only HTTP repositories are supported)']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:47'!checkRepositoryTemplates	"unused for now - we only do HTTP"	| bad |	bad := self repositories select: [:repo | repo creationTemplate isNil].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Creation template missing for'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: 'Please fill in the details first!!']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 21:15'!repositoryList	^self repositories collect: [:ea | ea description]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 17:58'!selectedRepository	^ self repositories at: self repositoryIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 6/22/2005 12:26'!buttonSpecs	^ #(('Add' add 'Add a dependency')		('Update' updateMenu 'Update dependencies')		('Install' installMenu 'Load/Merge/Upgrade into image')		('Up' up 'Move item up in list' canMoveUp)		('Down' down 'Move item down in list' canMoveDown)		('Remove' remove 'Remove item' canRemove)		('Store' store 'store configuration')		('Post' post 'Post this configuration to an update stream')		)! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:42'!defaultExtent	^ 600@450! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11'!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 20:41'!pickName	| name |	name := UIManager default		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:11'!pickRepository	^self pickRepositorySatisfying: [:ea | true]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:23'!pickRepositorySatisfying: aBlock	| index list |	list := MCRepositoryGroup default repositories select: aBlock.	index := UIManager default chooseFrom: (list collect: [:ea | ea description])		title: 'Repository:'.	^ index = 0 ifFalse: [list at: index]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 20:41'!pickWorkingCopiesSatisfying: aBlock	| copies item |	copies := (MCWorkingCopy allManagers select: aBlock)		asSortedCollection: [:a :b | a packageName <= b packageName].	item := UIManager default chooseFrom: #('match ...'),(copies collect: [:ea | ea packageName]) lines: #(1) title: 'Package:'.	item = 1 ifTrue: [		| pattern |		pattern := UIManager default request: 'Packages matching:' initialAnswer: '*'.		^pattern isEmptyOrNil			ifTrue: [#()]			ifFalse: [				(pattern includes: $*) ifFalse: [pattern := '*', pattern, '*'].				copies select: [:ea | pattern match: ea packageName]]	].	^ item = 0		ifTrue: [#()]		ifFalse: [{copies at: item - 1}]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56'!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 22:01'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: dependencyList dependencyIndex dependencyMenu:) (0 0 1 1) (0 30 0 -180))		((listMorph:selection:menu: repositoryList repositoryIndex repositoryMenu:) (0 1 1 1) (0 -180 0 -120))		((textMorph: description) (0 1 1 1) (0 -120 0 0))	 	)! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44'!canMoveDown	^self index between: 1 and: self maxIndex - 1 ! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44'!canMoveUp	^self index > 1! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:45'!canRemove	^self index > 0! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/21/2005 17:15'!includesPackage: aPackage	^self dependencies anySatisfy: [:each | each package = aPackage]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:54'!changedButtons	self changed: #canMoveDown.	self changed: #canMoveUp.	self changed: #canRemove.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:55'!changedList	self dependencyIndex > 0 ifTrue: [^self changed: #dependencyList].	self repositoryIndex > 0 ifTrue: [^self changed: #repositoryList].	self error: 'nothing selected'! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:56'!dependencyIndex	^dependencyIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55'!dependencyIndex: anInteger	dependencyIndex := anInteger.	dependencyIndex > 0		ifTrue: [self repositoryIndex: 0].	self changed: #dependencyIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:43'!index	^self dependencyIndex max: self repositoryIndex! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00'!index: anInteger	self dependencyIndex > 0 ifTrue: [^self dependencyIndex: anInteger].	self repositoryIndex > 0 ifTrue: [^self repositoryIndex: anInteger].	anInteger > 0 ifTrue: [self error: 'cannot select']! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:51'!list	self dependencyIndex > 0 ifTrue: [^self dependencies].	self repositoryIndex > 0 ifTrue: [^self repositories].	^#()! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:52'!maxIndex	^ self list size! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:57'!repositoryIndex	^repositoryIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55'!repositoryIndex: anInteger	repositoryIndex := anInteger.	repositoryIndex > 0		ifTrue: [self dependencyIndex: 0].	self changed: #repositoryIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:16'!selectDependency: aDependency	self dependencyIndex: (self dependencies indexOf: aDependency)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:15'!selectRepository: aRepository	self repositoryIndex: (self repositories indexOf: aRepository)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00'!updateIndex	self index > 0 ifTrue: [self index: (self index min: self maxIndex)]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:03'!configuration	^configuration ifNil: [configuration := MCConfiguration new]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 14:56'!configuration: aConfiguration	configuration := aConfiguration! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:35'!dependencies	^self configuration dependencies! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 4/19/2005 16:02'!dependencies: aCollection	self configuration dependencies: aCollection.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:41'!repositories	^ self configuration repositories! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 21:15'!repositories: aCollection	^self configuration repositories: aCollection! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'ul 12/12/2009 14:10'!description	self selectedDependency ifNotNil: [:dep | ^ ('Package: ', dep package name, String cr,		dep versionInfo summary) asText].	self selectedRepository ifNotNil: [:repo | ^repo creationTemplate		ifNotNil: [repo creationTemplate asText]		ifNil: [repo asCreationTemplate asText addAttribute: TextColor red]].	^ ''! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'ul 12/12/2009 14:10'!description: aText	self selectedRepository ifNotNil: [:repo | 		| new | 		new := MCRepository readFrom: aText asString.		(new class = repo class 			and: [new description = repo description])				ifTrue: [					repo creationTemplate: aText asString.					self changed: #description]				ifFalse: [					self inform: 'This does not match the previous definition!!'				]	].! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44'!updateFromImage	self configuration updateFromImage.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44'!updateFromRepositories	self configuration updateFromRepositories.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCConfigurationBrowser class methodsFor: 'class initialization' stamp: 'bf 3/21/2005 19:46'!initialize	TheWorldMenu registerOpenCommand: { 'Monticello Configurations' . { self . #open }. 'Monticello Configuration Browser' }.! !!MCConfigurationBrowser class methodsFor: 'opening' stamp: 'bf 3/21/2005 19:50'!open	^self new show! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!annotations	^operation ifNotNil: [ :op | op annotations ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:04'!applyTo: anObject	self isResolved ifFalse: [self error: 'Cannot continue until this conflict has been resolved'].	self remoteChosen ifTrue: [operation applyTo: anObject].! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!chooseLocal	chooseRemote := false! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:16'!chooseNewer	self isLocalNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isRemoteNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22'!chooseOlder	self isRemoteNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isLocalNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!chooseRemote	chooseRemote := true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!clearChoice	chooseRemote := nil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!definition	^operation ifNotNil: [ :op | op definition ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'dvf 8/10/2004 23:24'!isConflict	^true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:11'!isLocalNewer	^ self localDefinition fullTimeStamp > self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:15'!isRemoteNewer	^ self localDefinition fullTimeStamp < self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:02'!isResolved	^ chooseRemote notNil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45'!localChosen	^ chooseRemote notNil and: [chooseRemote not]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10'!localDefinition	^ operation baseDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:19'!operation	^ operation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!operation: anOperation	operation := anOperation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45'!remoteChosen	^ chooseRemote notNil and: [chooseRemote]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10'!remoteDefinition	^ operation targetDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:47'!source	^ self localChosen		ifTrue: [operation fromSource]		ifFalse: [operation source]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:48'!status	^ self isResolved		ifFalse: ['']		ifTrue: [self remoteChosen					ifFalse: ['L']					ifTrue: ['R']]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!summary	| attribute |	attribute := 		self isResolved			ifTrue: [self remoteChosen ifTrue: [#underlined] ifFalse: [#struckOut]]			ifFalse: [#bold].	^ Text string: operation summary attribute: (TextEmphasis perform: attribute)! !!MCConflict class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:07'!operation: anOperation	^ self new operation: anOperation	! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14'!description	self subclassResponsibility! !!MCDefinition methodsFor: 'comparing' stamp: 'nk 10/21/2003 23:18'!fullTimeStamp	^TimeStamp current! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14'!hash	^ self description hash! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 12/5/2002 21:24'!isRevisionOf: aDefinition	^ aDefinition description = self description! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:25'!isSameRevisionAs: aDefinition	^ self = aDefinition! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:04'!sortKey	self subclassResponsibility ! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 17:59'!<= other	^ self sortKey <= other sortKey! !!MCDefinition methodsFor: 'comparing' stamp: 'nice 10/31/2009 13:08'!= aDefinition	^(aDefinition isKindOf: MCDefinition) and: [self isRevisionOf: aDefinition]! !!MCDefinition methodsFor: 'installing' stamp: 'rej 2/26/2007 18:45'!addMethodAdditionTo: aCollection  Transcript show: self printString.  self load! !!MCDefinition methodsFor: 'installing' stamp: 'ab 7/18/2003 21:31'!load	! !!MCDefinition methodsFor: 'installing' stamp: 'avi 2/17/2004 13:19'!loadOver: aDefinition	self load	! !!MCDefinition methodsFor: 'installing' stamp: 'ab 7/18/2003 19:48'!postload! !!MCDefinition methodsFor: 'installing' stamp: 'avi 2/17/2004 13:19'!postloadOver: aDefinition	self postload! !!MCDefinition methodsFor: 'installing' stamp: 'ab 11/14/2002 00:08'!unload! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:27'!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:26'!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 11/10/2003 21:46'!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	aStream nextPutAll: 'not yet implemented'! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51'!isClassDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'bf 11/12/2004 14:46'!isClassDefinitionExtension	"Answer true if this definition extends the regular class definition"	^false! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51'!isMethodDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'cwp 7/11/2003 01:32'!isOrganizationDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'bf 8/12/2009 22:55'!isScriptDefinition	^false! !!MCDefinition methodsFor: 'printing' stamp: 'ab 7/18/2003 19:43'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self summary, ')'! !!MCDefinition methodsFor: 'printing' stamp: 'ab 7/19/2003 18:23'!summary	self subclassResponsibility ! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12'!provisions	^ #()! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12'!requirements	^ #()! !!MCDefinition class methodsFor: 'class initialization' stamp: 'ar 2/26/2010 23:03'!cleanUp	"Flush caches"	self clearInstances.! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2010 22:10'!clearInstances	instances := nil.	self subclassesDo: #clearInstances! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2010 22:10'!instanceLike: aDefinition	^(instances ifNil: [ instances := WeakSet new ])		like: aDefinition		ifAbsent: [ instances add: aDefinition ]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:38'!addAll: aCollection	aCollection do: [:ea | self add: ea]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'nice 3/20/2010 07:58'!add: aDefinition	^definitions at: aDefinition description put: aDefinition! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock	| definition |	definition := definitions at: aDefinition description ifAbsent: [].	^ definition		ifNil: errorBlock		ifNotNil: [foundBlock value: definition]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:42'!definitions	^ definitions values! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	definitions := Dictionary new! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:40'!remove: aDefinition	definitions removeKey: aDefinition description ifAbsent: []! !!MCDefinitionIndex class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:29'!definitions: aCollection	^ self new addAll: aCollection! !!MCDefinitionIndex class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCDependencySorter methodsFor: 'building' stamp: 'bf 11/12/2004 14:50'!addAll: aCollection	aCollection asArray sort do: [:ea | self add: ea]! !!MCDependencySorter methodsFor: 'building' stamp: 'avi 10/7/2004 22:47'!addExternalProvisions: aCollection	(aCollection intersection: self externalRequirements)		do: [:ea | self addProvision: ea]! !!MCDependencySorter methodsFor: 'building' stamp: 'nice 3/20/2010 08:00'!add: anItem	| requirements |	requirements := self unresolvedRequirementsFor: anItem.	requirements isEmpty		ifTrue: [self addToOrder: anItem]		ifFalse: [self addRequirements: requirements for: anItem].	^anItem! !!MCDependencySorter methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!addProvision: anObject	| newlySatisfied |	provided add: anObject.	newlySatisfied := required removeKey: anObject ifAbsent: [#()].	self addAll: newlySatisfied.! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:23'!addRequirements: aCollection for: anObject	aCollection do: [:ea | self addRequirement: ea for: anObject]! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24'!addRequirement: reqObject for: itemObject	(self itemsRequiring: reqObject) add: itemObject! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:15'!addToOrder: anItem	orderedItems add: anItem.	anItem provisions do: [:ea | self addProvision: ea].! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24'!itemsRequiring: anObject	^ required at: anObject ifAbsentPut: [Set new]! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:22'!unresolvedRequirementsFor: anItem	^ anItem requirements difference: provided! !!MCDependencySorter methodsFor: 'accessing' stamp: 'dvf 9/8/2004 00:49'!externalRequirements	| unloaded providedByUnloaded |	unloaded := self itemsWithMissingRequirements.	providedByUnloaded := (unloaded gather: [:e | e provisions]) asSet.	^ required keys reject: [:ea | providedByUnloaded includes: ea ]! !!MCDependencySorter methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!itemsWithMissingRequirements	| items |	items := Set new.	required do: [:ea | items addAll: ea].	^ items! !!MCDependencySorter methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	provided := Set new.	required := Dictionary new.	orderedItems := OrderedCollection new.! !!MCDependencySorter methodsFor: 'sorting' stamp: 'ab 5/22/2003 23:25'!orderedItems	^ orderedItems! !!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'ab 5/23/2003 14:17'!items: aCollection	^ self new addAll: aCollection! !!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!sortItems: aCollection	| sorter |	sorter := self items: aCollection.	sorter externalRequirements do: [:req  | sorter addProvision: req].	^ sorter orderedItems.! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31'!asString	^item description! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2004 17:54'!contents	| list workingCopies |	workingCopies := model unsortedWorkingCopies.	list := item requiredPackages collect: 					[:each | 					workingCopies detect: [:wc | wc package = each] ifNone: [nil]]				thenSelect: [:x | x notNil].	^list collect: [:each | self class with: each model: model]! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31'!hasContents	^item requiredPackages isEmpty not! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:41'!item	^item! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/20/2003 21:04'!allVersionInfos	^ dict values collect: [:ea | ea info]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:20'!basicStoreVersion: aVersion	dict at: aVersion info put: aVersion! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	| info |	info := anAncestry breadthFirstAncestors			detect: [:ea | self includesVersionWithInfo: ea]			ifNone: [^ errorBlock value].	^ self versionWithInfo: info! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:47'!description	^ description ifNil: ['cache']! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!description: aString	description := aString ! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:47'!dictionary	^ dict! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!dictionary: aDictionary	dict := aDictionary! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/21/2003 23:39'!includesVersionNamed: aString	^ dict anySatisfy: [:ea | ea info name = aString]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 19:49'!includesVersionWithInfo: aVersionInfo	^ dict includesKey: aVersionInfo! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	dict := Dictionary new.! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 18:24'!morphicOpen: aWorkingCopy	| names index infos |	infos := self sortedVersionInfos.	infos isEmpty ifTrue: [^ self inform: 'No versions'].	names := infos collect: [:ea | ea name].	index := UIManager default chooseFrom: names title: 'Open version:'.	index = 0 ifFalse: [(self versionWithInfo: (infos at: index)) open]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!sortedVersionInfos	| sorter |	sorter := MCVersionSorter new.	self allVersionInfos do: [:ea | sorter addVersionInfo: ea].	^ sorter sortedVersionInfos! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/16/2003 18:22'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ dict at: aVersionInfo ifAbsent: errorBlock! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:56'!= other	^ self == other! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17'!baseInfo	^ base! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:39'!baseSnapshot	^ (self workingCopy repositoryGroup versionWithInfo: base) snapshot! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/23/2005 15:42'!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^ package hasWorkingCopy		and: [package workingCopy modified not			and: [package workingCopy ancestors includes: self baseInfo]]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 17:39'!fileName	^ (self class nameForVer: info name base: base name), '.', self writerClass extension! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch: aPatch	patch := aPatch.	base := baseVersionInfo.	super initializeWithPackage: aPackage info: aVersionInfo snapshot: nil dependencies: aCollection.! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:24'!isDiffy	^ true! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17'!patch	^ patch! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!snapshot	^ snapshot ifNil: [snapshot := MCPatcher apply: patch to: self baseSnapshot]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/19/2004 22:03'!summary	^ '(Diff against ', self baseInfo name, ')', String cr, super summary! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17'!writerClass	^ MCMcdWriter ! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:45'!baseNameFrom: diffName	| baseId verName |	baseId := (diffName copyAfter: $() copyUpTo: $).	baseId ifEmpty: [^baseId].	(baseId beginsWith: '@')		ifTrue: [^baseId copyAfter: $@].	verName := self verNameFrom: diffName.	^(baseId includes: $.)		ifTrue: [(verName copyUpToLast: $-), '-', baseId]		ifFalse: [(verName copyUpToLast: $.), '.', baseId]! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:58'!canonicalNameFor: aFileName	^(self nameForVer: (self verNameFrom: aFileName)		base: (self baseNameFrom: aFileName))			, '.', MCMcdReader extension! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 17:39'!nameForVer: versionName base: baseName	| baseId |	baseId := (versionName copyUpToLast: $.) = (baseName copyUpToLast: $.)		ifTrue: [baseName copyAfterLast: $.]		ifFalse: [(versionName copyUpToLast: $-) = (baseName copyUpToLast: $-)			ifTrue: [baseName copyAfterLast: $-]			ifFalse: ['@', baseName]].	^ versionName, '(', baseId, ')'! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:19'!verNameFrom: diffName	^diffName copyUpTo: $(! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:07'!package: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:06'!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection baseVersion: aVersion	^ self 		package: aPackage		info: aVersionInfo		dependencies: aCollection		baseInfo: aVersion info		patch: (aSnapshot patchRelativeToBase: aVersion snapshot)! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 15:28'!allFileNames	^ (directory entries sortBy: [:a :b | a modificationTime >= b modificationTime]) collect: [:ea | ea name]! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:57'!description	^ directory pathName! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 17:49'!directory	^ directory! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!directory: aDirectory	directory := aDirectory! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	directory := FileDirectory default! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 11/2/2003 10:55'!isValid	^directory exists! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (directory fullNameFor: aString).	val := aBlock value: file.	file close.	^ val! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	| file sel |	sel := aBoolean ifTrue: [#forceNewFileNamed:] ifFalse: [#newFileNamed:].	file := FileStream perform: sel with: (directory fullNameFor: aString).	aBlock value: file.	file close.! !!MCDirectoryRepository methodsFor: 'comparing' stamp: 'ab 7/19/2003 21:40'!hash	^ directory pathName hash! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ab 7/24/2003 21:20'!description	^ 'directory'! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ul 12/12/2009 14:10'!morphicConfigure	^ FileList2 modalFolderSelector ifNotNil:		[:directory |		self new directory: directory]! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40'!addDefinitionsTo: aCollection	self subclassResponsibility ! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40'!source	^ source! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!source: aString	source := aString! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:29'!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!forDoit: aString	^ (self subclassForDoit: aString) ifNotNil: [:c | c new source: aString]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:51'!isAbstract	^ self pattern isNil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30'!pattern	^ nil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30'!subclassForDoit: aString	^ self concreteSubclasses detect: [:ea | ea pattern match: aString] ifNone: []! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:35'!allFileNames	self subclassResponsibility! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 20:01'!allFileNamesForVersionNamed: aString	^ self filterFileNames: self readableFileNames forVersionNamed: aString! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:40'!allFileNamesOrCache	^ allFileNames ifNil: [self allFileNames]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:40'!allVersionNames	^ self readableFileNames collect: [:ea | self versionNameFromFileName: ea]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!basicStoreVersion: aVersion	self		writeStreamForFileNamed: aVersion fileName		do: [:s | aVersion fileOutOn: s].	aVersion isCacheable ifTrue: [		cache ifNil: [cache := Dictionary new].		cache at: aVersion fileName put: aVersion].! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!cache	^ cache ifNil: [cache := Dictionary new]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ar 1/4/2010 17:21'!cacheAllFileNamesDuring: aBlock	allFileNames ifNotNil:[^aBlock value].	allFileNames := self allFileNames.	^ aBlock ensure: [allFileNames := nil]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bf 6/9/2005 15:47'!cachedFileNames	^cache == nil		ifTrue: [#()]		ifFalse: [cache keys]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!canReadFileNamed: aString	| reader |	reader := MCVersionReader readerClassForFileNamed: aString.	^ reader notNil! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:40'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	^ self cacheAllFileNamesDuring:		[super closestAncestorVersionFor: anAncestry ifNone: errorBlock]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 20:01'!filterFileNames: aCollection forVersionNamed: aString	^ aCollection select: [:ea | (self versionNameFromFileName: ea) = aString] ! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!flushCache	cache := nil! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:36'!includesVersionNamed: aString	^ self allVersionNames includes: aString! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 13:34'!loadVersionFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r version]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 18:37'!loadVersionInfoFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r info]	! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:52'!maxCacheSize	^ 8! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 18:32'!morphicOpen: aWorkingCopy	(MCFileRepositoryInspector repository: self workingCopy: aWorkingCopy)		show! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:51'!notifyList	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd lines]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/11/2005 18:01'!possiblyNewerVersionsOfAnyOf: someVersions	| pkgs |	pkgs := Dictionary new.	someVersions do: [:aVersionInfo |		pkgs at: (aVersionInfo name copyUpToLast: $-)			put: (aVersionInfo name copyAfterLast: $.) asNumber].	^[self allVersionNames select: [:each |		(pkgs at: (each copyUpToLast: $-) ifPresent: [:verNumber |			verNumber < (each copyAfterLast: $.) asNumber				or: [verNumber = (each copyAfterLast: $.) asNumber					and: [someVersions noneSatisfy: [:v | v name = each]]]]) == true]	] on: Error do: [:ex | ex return: #()]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:39'!readableFileNames	| all cached new |	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	new := all difference: cached.	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/18/2005 22:43'!resizeCache: aDictionary	[aDictionary size <= self maxCacheSize] whileFalse:		[aDictionary removeKey: aDictionary keys atRandom]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 23:09'!versionFromFileNamed: aString	| v |	v := self cache at: aString ifAbsent: [self loadVersionFromFileNamed: aString].	self resizeCache: cache.	(v notNil and: [v isCacheable]) ifTrue: [cache at: aString put: v].	^ v! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 18:37'!versionInfoFromFileNamed: aString	self cache at: aString ifPresent: [:v | ^ v info].	^ self loadVersionInfoFromFileNamed: aString! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 22:52'!versionNameFromFileName: aString	^ (aString copyUpToLast: $.) copyUpTo: $(! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionReaderForFileNamed: aString do: aBlock	^ self		readStreamForFileNamed: aString		do: [:s |			(MCVersionReader readerClassForFileNamed: aString) ifNotNil:				[:class | aBlock value: (class on: s fileName: aString)]]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!versionWithInfo: aVersionInfo ifAbsent: errorBlock		(self allFileNamesForVersionNamed: aVersionInfo name) do:		[:fileName | | version |		version := self versionFromFileNamed: fileName.		version info = aVersionInfo ifTrue: [^ version]].	^ errorBlock value! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/31/2003 14:32'!writeStreamForFileNamed: aString do: aBlock	^ self writeStreamForFileNamed: aString replace: false do: aBlock! !!MCFileBasedRepository class methodsFor: 'class initialization' stamp: 'ar 2/26/2010 23:03'!cleanUp	"Flush caches"	self flushAllCaches.! !!MCFileBasedRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/3/2005 00:43'!flushAllCaches	self allSubInstancesDo: [:ea | ea flushCache]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 11/10/2003 22:35'!buttonSpecs	^#(('Refresh' refresh 'refresh the version-list')) , super buttonSpecs! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:34'!defaultExtent	^570@350! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:06'!defaultLabel	^'Repository: ' , repository description! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 9/17/2005 17:21'!hasVersion	^ selectedVersion notNil! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 21:26'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x first <= y first ].		'order by author' -> [ :x :y | x second <= y second ].		'order by version-string' -> [ :x :y | x third <= y third ].		'order by version-number' -> [ :x :y | x third asNumber >= y third asNumber ].		'order by filename' -> [ :x :y | x fourth <= y fourth ].	}! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 21:07'!orderString: anIndex	^String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!order: anInteger	self class order: (order := anInteger).	self changed: #versionList.! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'bf 2/24/2005 18:29'!packageHighlight: aString	newer ifNil: [newer := #()].	^(loaded anySatisfy: [:each | (each copyUpToLast: $-) = aString])		ifTrue: [			Text string: aString				attribute: (TextEmphasis new emphasisCode: (					((newer includes: aString)						ifTrue: [5] ifFalse: [4])))]		ifFalse: [aString]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'ul 11/11/2009 21:15'!packageList	| result loadedPackages |	packageList ifNotNil: [ ^packageList ].	result := Set new: versions size.	versions do: [ :each | result add: each first ].	"sort loaded packages first, then alphabetically"	loadedPackages := Set new: loaded size.	loaded do: [ :each |		loadedPackages add: (each copyUpToLast: $-) ].	result := result asArray sort: [ :a :b |		| loadedA loadedB |		loadedA := loadedPackages includes: a.		loadedB := loadedPackages includes: b.		loadedA = loadedB 			ifTrue: [ a < b ]			ifFalse: [ loadedA ] ].	^packageList := result collect: [ :each | self packageHighlight: each ]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 17:25'!packageListMenu: aMenu	^aMenu! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:17'!packageSelection	^self packageList indexOf: selectedPackage! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!packageSelection: aNumber	selectedPackage := aNumber isZero		ifFalse: [ (self packageList at: aNumber) asString ].	self versionSelection: 0.	self changed: #packageSelection; changed: #versionList! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 2/14/2010 10:10'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ self repository = anotherModel repository ]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!version	^ version ifNil:		[Cursor wait showWhile:			[version := repository versionFromFileNamed: selectedVersion].		version]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'bf 5/30/2005 19:10'!versionHighlight: aString	| verName |	inherited ifNil: [inherited := #()].	verName := (aString copyUpToLast: $.) copyUpTo: $(.	^Text		string: aString		attribute: (TextEmphasis new emphasisCode: (			((loaded includes: verName) ifTrue: [ 4 "underlined" ]				ifFalse: [ (inherited includes: verName)					ifTrue: [ 0 ]					ifFalse: [ 1 "bold" ] ])))! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!versionInfo	^ versionInfo ifNil: [versionInfo := repository versionInfoFromFileNamed: selectedVersion]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'ul 1/11/2010 08:23'!versionList	| result |	result := selectedPackage		ifNil: [ versions copy ]		ifNotNil: [ versions select: [ :each | selectedPackage = each first ] ].	(self orderSpecs at: order) value ifNotNil: [ :sortBlock |		result sort: [:a :b | [ sortBlock value: a value: b ] on: Error do: [ true ] ] ].	^result 	replace: [ :each | self versionHighlight: each fourth ]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 21:07'!versionListMenu: aMenu	1 to: self orderSpecs size do: [ :index |		aMenu addUpdating: #orderString: target: self selector: #order: argumentList: { index } ].	^aMenu! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:18'!versionSelection	^self versionList indexOf: selectedVersion! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!versionSelection: aNumber	aNumber isZero 		ifTrue: [ selectedVersion := version := versionInfo := nil ]		ifFalse: [ 			selectedVersion := (self versionList at: aNumber) asString.			version := versionInfo := nil].	self changed: #versionSelection; changed: #summary; changed: #hasVersion! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 9/17/2005 18:36'!versionSummary	^ version		ifNotNil: [version summary]		ifNil: [self versionInfo summary]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:26'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.6) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/18/2005 10:54'!load	self hasVersion ifTrue:		[self version isCacheable			ifTrue: [version workingCopy repositoryGroup addRepository: repository].		super load.		self refresh].! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'bf 11/16/2004 11:56'!merge	super merge.	self refresh.! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'topa 5/3/2010 11:26'!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setRepository: aFileBasedRepository workingCopy: aWorkingCopy	order := self class order.	repository := aFileBasedRepository.	self refresh.	aWorkingCopy		ifNil: [selectedPackage := self packageList isEmpty ifFalse: [self packageList first]]		ifNotNil: [ selectedPackage := aWorkingCopy ancestry ancestorString copyUpToLast: $- ].	MCWorkingCopy addDependent: self.! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 2/14/2010 20:26'!postAcceptBrowseFor: aModel	"Make the same selections as in aModel."	self 		packageSelection: aModel packageSelection ;		versionSelection: aModel versionSelection! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 2/14/2010 09:54'!repository	^ repository! !!MCFileRepositoryInspector class methodsFor: 'class initialization' stamp: 'bf 3/16/2005 14:41'!initialize	"self initialize"	self migrateInstances! !!MCFileRepositoryInspector class methodsFor: 'class initialization' stamp: 'bf 3/16/2005 14:53'!migrateInstances	self allSubInstancesDo: [:inst |		#(packageList versionList) do: [:each |			[(inst findListMorph: each) highlightSelector: nil]				on: Error do: [:ignore | ]]].! !!MCFileRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!order	Order isNil		ifTrue: [ Order := 5 ].	^Order! !!MCFileRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!order: anInteger	Order := anInteger! !!MCFileRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'lr 9/26/2003 20:09'!repository: aFileBasedRepository workingCopy: aWorkingCopy	^self new		setRepository: aFileBasedRepository workingCopy: aWorkingCopy;		yourself! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'bf 5/28/2005 01:14'!addVersionInfo: aVersionInfo	(aVersionInfo hasAncestor: target)		ifTrue: [super addVersionInfo: aVersionInfo]! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'bf 12/19/2009 17:44'!processVersionInfo: aVersionInfo	| success |	aVersionInfo = target ifTrue: [^ true].	(aVersionInfo hasAncestor: target) ifFalse: [^false].	self pushLayer.	success := (self knownAncestorsOf: aVersionInfo) anySatisfy:				[:ea | self processVersionInfo: ea].	self popLayer.	success ifTrue: [self addToCurrentLayer: aVersionInfo].	^ success	! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!target: aVersionInfo	target := aVersionInfo! !!MCFrontier methodsFor: 'accessing' stamp: 'avi 9/17/2005 22:02'!frontier	^frontier! !!MCFrontier methodsFor: 'initialization' stamp: 'avi 9/17/2005 22:11'!frontier: f bag: remaining	frontier := f asOrderedCollection.	bag := remaining! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:02'!removeAll: collection	collection do: [ :n | self remove: n]! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:13'!remove: aVersionInfo	frontier remove: aVersionInfo.	aVersionInfo ancestors  do:		[ :ancestor |			bag remove: ancestor.			(bag occurrencesOf: ancestor) = 0				ifTrue: [frontier add: ancestor]].	^aVersionInfo! !!MCFrontier class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47'!frontierOnAll: aCollection	| remaining  allVersions |	remaining := Bag new.	allVersions := (aCollection gather: [:ea | ea withBreadthFirstAncestors]) asSet.	allVersions do: [:ea | remaining addAll: ea ancestors].	^self new frontier: aCollection bag: remaining! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07'!frontierOn: aVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo)! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07'!frontierOn: aVersionInfo and: otherVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo with: otherVersionInfo)! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/16/2003 14:04'!allFileNames	^ self clientDo:		[:client |		self parseDirectoryListing: client getDirectory]! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/17/2003 12:52'!description	^ 'ftp://', user, '@', host, '/', directory! !!MCFtpRepository methodsFor: 'required' stamp: 'nice 12/27/2009 03:11'!readStreamForFileNamed: aString do: aBlock		^ self clientDo:		[:client | | stream |		client binary.		stream := RWBinaryOrTextStream on: String new.		stream nextPutAll: (client getFileNamed: aString).		aBlock value: stream reset]! !!MCFtpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47'!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self clientDo:		[:client |		client binary.		client putFileStreamContents: stream reset as: aString]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!clientDo: aBlock	| client |	client := FTPClient openOnHostNamed: host.	client loginUser: user password: password.	directory isEmpty ifFalse: [client changeDirectoryTo: directory].	^ [aBlock value: client] ensure: [client close]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!directory: dirPath	directory := dirPath! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!host: hostname	host := hostname! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!parseDirectoryListing: aString	| stream files line tokens |	stream := aString readStream.	files := OrderedCollection new.	[stream atEnd] whileFalse:		[line := stream nextLine.		tokens := line findTokens: ' '.		tokens size > 2 ifTrue: [files add: tokens last]].	^ files! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!password: passwordString	password := passwordString! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!user: userString	user := userString! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57'!creationTemplate	^'MCFtpRepository	host: ''modules.squeakfoundation.org''	directory: ''mc''	user: ''squeak''	password: ''squeak'''	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57'!description	^ 'FTP'! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02'!fillInTheBlankRequest	^ 'FTP Repository:'	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57'!host: host directory: directory user: user password: password	^ self new		host: host;		directory: directory;		user: user;		password: password! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:38'!templateCreationSelector	^ #host:directory:user:password: ! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:20'!basicStoreVersion: aVersion	self root at: aVersion info put: aVersion.	self db commit.! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'md 9/6/2005 18:37'!db	(connection isNil or: [connection isConnected not]) ifTrue: [		connection := Smalltalk at: #KKDatabase ifPresent: [:cl | 			cl  onHost:hostname port: port		]	].	^ connection! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:35'!description	^ 'goods://', hostname asString, ':', port asString! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!host: aString	hostname := aString! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:10'!morphicOpen: aWorkingCopy	(MCRepositoryInspector repository: self workingCopy: aWorkingCopy) show! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:17'!packages	^ (self root collect: [:ea | ea package]) asSet asSortedCollection! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!port: aNumber	port := aNumber! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:35'!root	self db root ifNil: [self db root: Dictionary new].	^ self db root! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:18'!versionsAvailableForPackage: aPackage	^ self root asArray select: [:ea | ea package = aPackage] thenCollect: [:ea | ea info]! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:21'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ self root at: aVersionInfo ifAbsent: errorBlock! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36'!creationTemplate	^'MCGOODSRepository	host: ''localhost''	port: 6100'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:33'!description	^ 'GOODS'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:33'!fillInTheBlankRequest	^ 'GOODS Repository:'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36'!host: hostname port: portNumber	^ self new		host: hostname;		port: portNumber! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:35'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 12/30/2009 17:02'!allFileNames	| index |	self displayProgress: 'Updating ', self description during:[		index := HTTPSocket httpGet: self locationWithTrailingSlash, '?C=M;O=D' args: nil user: self user passwd: self password.	].	index isString ifTrue: [self error: 'Could not access ', location].	^ self parseFileNamesFromStream: index	! !!MCHttpRepository methodsFor: 'required' stamp: 'ab 7/24/2003 21:10'!description	^ location! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 12/30/2009 16:41'!displayProgress: label during: workBlock	| nextUpdateTime |	nextUpdateTime := 0.	^UIManager default displayProgress: label at: Display center		from: 0.0 to: 1.0 during:[:bar|			[workBlock value] on: HTTPProgress do:[:ex|				(ex total == nil or:[ex amount == nil]) ifFalse:[					(nextUpdateTime < Time millisecondClockValue 						or:[ex total = ex amount]) ifTrue:[							bar value: ex amount asFloat / ex total asFloat.							nextUpdateTime := Time millisecondClockValue + 100.					].				].				ex resume.			]		].! !!MCHttpRepository methodsFor: 'required' stamp: 'al 12/12/2005 11:06'!flushCache	super flushCache.	readerCache := nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 12/30/2009 17:02'!readStreamForFileNamed: aString do: aBlock	| contents |	self displayProgress: 'Downloading ', aString during:[		contents := HTTPSocket httpGet: (self urlForFileNamed: aString) args: nil user: self user passwd: self password.	].	^ contents isString ifFalse: [aBlock value: contents]! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 7/21/2010 19:53'!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	"More robust handling of HTTP responses. Instead of enumerating	all possible return codes and http versions, do a quick parse"	(response beginsWith: 'HTTP/') ifTrue:[		"Looks like an HTTP header, not some error message"		statusLine := response copyUpTo: Character cr.		code := [(statusLine findTokens: ' ') second asInteger] on: Error do:[].	].	(code isInteger and:[code between: 200 and: 299]) 		ifFalse:[self error: response].! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 4/14/2005 17:49'!asCreationTemplate	^self class creationTemplateLocation: location user: user password: password! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 22:17'!locationWithTrailingSlash	^ (location endsWith: '/')		ifTrue: [location]		ifFalse: [location, '/']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!location: aUrlString	location := aUrlString! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!parseFileNamesFromStream: aStream	| names fullName |	names := OrderedCollection new.	[aStream atEnd] whileFalse:		[[aStream upTo: $<. {$a. $A. nil} includes: aStream next] whileFalse.		aStream upTo: $".		aStream atEnd ifFalse: [			fullName := aStream upTo: $".			names add: fullName unescapePercents]].	^ names! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 8/12/2009 11:26'!password	self userAndPasswordFromSettingsDo: [:usr :pwd | ^pwd].	self user isEmpty ifTrue: [^password ifNil: ['']].	[password isEmptyOrNil] whileTrue: [		| answer |		"Give the user a chance to change the login"		answer := UIManager default request: 'User name for ', String cr, location			initialAnswer: self user.		answer isEmpty			ifTrue: [^password]			ifFalse: [self user: answer].				password := UIManager default requestPassword: 'Password for "', self user, '" at ', String cr, location.	].	^ password! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!password: passwordString	password := passwordString! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 13:08'!urlForFileNamed: aString	^ self locationWithTrailingSlash, aString encodeForHTTP! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 8/12/2009 11:21'!user	self userAndPasswordFromSettingsDo: [:usr :pwd | ^usr].	"not in settings"	^user ifNil: ['']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!userAndPasswordFromSettingsDo: aBlock	"The mcSettings file in ExternalSettings preferenceDirectory should contain entries for each account:			account1: *myhost.mydomain* user:password		account2: *otherhost.mydomain/somerep* dXNlcjpwYXNzd29yZA==	That is it must start with 'account', followed by anything to distinguish accounts, and a colon. Then comes a match expression for the repository url, and after a space the user:password string.		To not have the clear text password on your disc, you can base64 encode it:			(Base64MimeConverter mimeEncode: 'user:password' readStream) contents	"		Settings ifNotNil: [		Settings keysAndValuesDo: [:key :value | | userAndPassword entry |			(key asLowercase beginsWith: 'account') ifTrue: [				entry := value findTokens: '	 '.				(entry first match: location) ifTrue: [					userAndPassword := entry second.					(userAndPassword includes: $:) ifFalse: [						userAndPassword := (Base64MimeConverter mimeDecodeToChars: userAndPassword readStream) contents].					userAndPassword := userAndPassword findTokens: $:.					^aBlock value: userAndPassword first 						value: userAndPassword second 					]			]		]	].	^nil! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!user: userString	user := userString! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!versionReaderForFileNamed: aString	readerCache ifNil: [readerCache := Dictionary new].	^ readerCache at: aString ifAbsent:		[self resizeCache: readerCache.		super versionReaderForFileNamed: aString do:			[:r |			r ifNotNil: [readerCache at: aString put: r]]]	! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionReaderForFileNamed: aString do: aBlock	^ (self versionReaderForFileNamed: aString) ifNotNil: aBlock! !!MCHttpRepository class methodsFor: 'class initialization' stamp: 'bf 7/28/2005 19:44'!clearPasswords	self allSubInstancesDo: [:ea | ea password: ''].! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'gsa 12/14/2009 13:47'!creationTemplate	^self creationTemplateLocation: 'http://www.squeaksource.com/'		user: 'squeak'		password: 'squeak'! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bf 4/14/2005 15:27'!creationTemplateLocation: location user: user password: password	^'MCHttpRepository	location: {1}	user: {2}	password: {3}' format: {location printString. user printString. password printString}! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:20'!description	^ 'HTTP'! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:00'!fillInTheBlankRequest	^ 'HTTP Repository:'			! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:32'!location: location user: user password: password	^ self new		location: location;		user: user;		password: password! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:01'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32'!isInstanceVariable	^ true! !!MCInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59'!type	^ #instance! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:33'!baseInfo	^ baseInfo ifNil: [self loadBaseInfo]! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:41'!basicVersion	^ MCDiffyVersion		package: self package		info: self info		dependencies: self dependencies		baseInfo: self baseInfo		patch: self patch! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:37'!buildPatchFrom: oldDefinitions to: newDefinitions	^ MCPatch		fromBase: (MCSnapshot fromDefinitions: oldDefinitions)		target: (MCSnapshot fromDefinitions: newDefinitions)! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!loadBaseInfo	^ baseInfo := self extractInfoFrom: (self parseMember: 'base')! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (DataStream on: m contentStream) next ]			on: Error do: [:fallThrough ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:34'!patch	^ patch ifNil: [self loadPatch]! !!MCMcdReader class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09'!extension	^ 'mcd'! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!writeBaseInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'base'.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:48'!writeDefinitions: aVersion	self writeBaseInfo: aVersion baseInfo.	self writePatch: aVersion patch.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07'!writeNewDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'new/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07'!writeOldDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'old/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!writePatch: aPatch	| old new |	old := OrderedCollection new.	new := OrderedCollection new.	aPatch operations do:		[:ea |		ea isRemoval ifTrue: [old add: ea definition].		ea isAddition ifTrue: [new add: ea definition].		ea isModification ifTrue: [old add: ea baseDefinition. new add: ea definition]].	self writeOldDefinitions: old.	self writeNewDefinitions: new.	self addString: (self serializeInBinary: aPatch) at: 'patch.bin'.! !!MCMcdWriter class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09'!readerClass	^ MCMcdReader! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:05'!configuration	configuration ifNil: [self loadConfiguration].	"browser modifies configuration, but the reader might get cached"	^configuration copy! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17'!configurationName	^fileName ifNotNil: [(fileName findTokens: '/\:') last copyUpToLast: $.]! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17'!fileName: aString	fileName := aString! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:05'!loadConfiguration	stream reset.	configuration := MCConfiguration fromArray: (MCScanner scan: stream).	configuration name: self configurationName.! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:06'!loadVersionInfo	info := self configuration! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:06'!version	^self configuration! !!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCMcmReader class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:47'!extension	^ 'mcm'! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'ar 9/19/2009 11:49'!loadVersionFile: fileName	| version |	version := self versionFromFile: fileName.	version load.! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47'!on: aStream fileName: aFileName	| reader |	reader := self on: aStream.	reader fileName: aFileName.	^reader! !!MCMcmUpdater commentStamp: 'dtl 5/10/2010 23:22' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository, MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration. !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 4/9/2010 20:41'!defaultUpdateURL	"The default update repository URL"	<preference: 'Update URL'		category: 'Monticello'		description: 'The repository URL for loading updates'		type: #String>	^DefaultUpdateURL ifNil:['']! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 4/9/2010 20:40'!defaultUpdateURL: aString	"The default update repository URL"	DefaultUpdateURL := aString! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 4/9/2010 20:41'!updateFromDefaultRepository	"Update from the default repository only"	^self updateFromRepositories: {self defaultUpdateURL}! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 1/4/2010 17:37'!updateFromRepositories: repositoryUrls	"MCMcmUpdater updateFromRepositories: #(		'http://squeaksource.com/MCUpdateTest'	)"	| repos config |	Preferences enable: #upgradeIsMerge.	LastUpdateMap ifNil:[LastUpdateMap := Dictionary new].	"The list of repositories to consult in order"	repos := repositoryUrls collect:[:url| 		MCRepositoryGroup default repositories 			detect:[:r| r description = url]			ifNone:[ | r |				r := MCHttpRepository location: url user: '' password: ''.				MCRepositoryGroup default addRepository: r.				r]].	"The list of updates-author.version.mcm sorted by version"	repos do:[:r| r cacheAllFileNamesDuring:[		| minVersion updateList allNames |		updateList := SortedCollection new.		minVersion := LastUpdateMap at: r description ifAbsent:[0].		"Find all the updates-author.version.mcm files"		'Checking ', r description			displayProgressAt: Sensor cursorPoint			from: 0 to: 1 during:[:bar| 				bar value: 0.				allNames := r allFileNames.			].		allNames do:[:versionedName| | version base parts author type |			parts := versionedName findTokens: '.-'.			parts size = 4 ifTrue:[				base := parts at: 1.				author := parts at: 2.				version := [(parts at: 3) asNumber] on: Error do:[:ex| ex return: 0].				type := parts at: 4.			].			(base = 'update' and:[version >= minVersion and:[type = 'mcm']]) 				ifTrue:[updateList add: version -> versionedName]].				"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: 'Processing ', assoc value.				config := r versionFromFileNamed: assoc value.				(config dependencies allSatisfy:[:dep| dep isFulfilled]) 					ifFalse:[config upgrade].				LastUpdateMap at: r description put: assoc key.			] displayingProgress: 'Processing configurations'.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			config updateFromRepositories.			config upgrade.		]].	].	^config! !!MCMcmUpdater class methodsFor: 'class initialization' stamp: 'ar 4/9/2010 20:41'!initialize	"MCMcmUpdater initialize"	LastUpdateMap ifNil:[		LastUpdateMap := Dictionary new.	].	DefaultUpdateURL ifNil:[		DefaultUpdateURL := 'http://source.squeak.org/trunk'.	].! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/22/2005 18:00'!close	stream close! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/24/2005 01:50'!writeConfiguration: aConfiguration	stream nextPut: $(.	aConfiguration repositories do: [:ea | 		stream cr.		stream nextPutAll: 'repository '.		(MCConfiguration repositoryToArray: ea) printElementsOn: stream].	aConfiguration dependencies do: [:ea | 		stream cr.		stream nextPutAll: 'dependency '.		(MCConfiguration dependencyToArray: ea) printElementsOn: stream].	stream cr.	stream nextPut: $).	stream cr.! !!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCMcmWriter class methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47'!fileOut: aConfiguration on: aStream	| inst |	inst := self on: aStream.	inst writeConfiguration: aConfiguration.	inst close.	! !!MCMcmWriter class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:49'!readerClass	^ MCMcmReader! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'nice 12/28/2009 16:07'!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					result at: key put: (value isString						ifTrue: [value]						ifFalse: [value collect: [:ea | self associate: ea]])].	^ result! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!extractDefinitionsFrom: member	| reader |	(MCSnapshotReader readerClassForFileNamed: member fileName)		ifNotNil: [:rc | reader := rc on: member contentStream text.					definitions addAll: reader definitions]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 16:11'!extractDependencyFrom: zipMember	^ MCVersionDependency		package: (MCPackage named: (zipMember fileName copyAfterLast: $/))		info: (self extractInfoFrom: (self parseMember: zipMember fileName))! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38'!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!infoCache	^ infoCache ifNil: [infoCache := Dictionary new]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (DataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough ]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!loadDependencies	dependencies := (self zip membersMatching: 'dependencies/*') collect: [:m | self extractDependencyFrom: m].	dependencies := dependencies asArray.! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!loadPackage	| dict |	dict := self parseMember: 'package'.	package := MCPackage named: (dict at: #name)! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!loadVersionInfo	info := self extractInfoFrom: (self parseMember: 'version')! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (self zip contentsOf: fileName)) first.	^ self associate: tokens! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:33'!scanner	^ MCScanner! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!zip	zip ifNil:		[zip := ZipArchive new.		zip readFrom: stream].	^ zip! !!MCMczReader class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 14:59'!extension	^ 'mcz'! !!MCMczReader class methodsFor: 'testing' stamp: 'avi 1/19/2004 14:48'!supportsDependencies	^ true! !!MCMczReader class methodsFor: 'testing' stamp: 'cwp 8/1/2003 12:19'!supportsVersions	^ true! !!MCMczWriter methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47'!addString: string at: path	| member |	member := zip addString: string as: path.	member desiredCompressionMethod: ZipArchive compressionDeflated 	! !!MCMczWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:17'!flush	zip writeTo: stream.	stream close! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 01:54'!format	^ '1'! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 02:07'!snapshotWriterClass	^ MCStWriter! !!MCMczWriter methodsFor: 'accessing' stamp: 'cwp 8/1/2003 00:06'!zip	^ zip! !!MCMczWriter methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	zip := ZipArchive new.! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47'!serializeDefinitions: aCollection	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := self snapshotWriterClass on: s.	writer writeDefinitions: aCollection.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47'!serializeInBinary: aSnapshot	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := DataStream on: s.	writer nextPut: aSnapshot.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'cwp 8/13/2003 01:06'!serializePackage: aPackage	^ '(name ''', aPackage name, ''')'! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47'!serializeVersionInfo: aVersionInfo	infoWriter ifNil: [infoWriter := MCVersionInfoWriter new].	^ String streamContents:		[:s |		infoWriter stream: s.		infoWriter writeVersionInfo: aVersionInfo]! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:48'!writeDefinitions: aVersion	self writeSnapshot: aVersion snapshot! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:56'!writeFormat"	self addString: self format at: 'format'."! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:48'!writePackage: aPackage	self addString: (self serializePackage: aPackage) at: 'package'! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 9/28/2004 14:26'!writeSnapshot: aSnapshot	self addString: (self serializeDefinitions: aSnapshot definitions) at: 'snapshot/source.', self snapshotWriterClass extension.	self addString: (self serializeInBinary: aSnapshot) at: 'snapshot.bin'! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47'!writeVersionDependency: aVersionDependency	| string |	string := (self serializeVersionInfo: aVersionDependency versionInfo).	self addString: string at: 'dependencies/', aVersionDependency package name! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47'!writeVersionInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'version'.! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 9/13/2004 16:49'!writeVersion: aVersion	self writeFormat.	self writePackage: aVersion package.	self writeVersionInfo: aVersion info.	self writeDefinitions: aVersion.	aVersion dependencies do: [:ea | self writeVersionDependency: ea]! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!fileOut: aVersion on: aStream	| inst |	inst := self on: aStream.	inst writeVersion: aVersion.	inst flush.	! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 12:35'!readerClass	^ MCMczReader! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry	^entry! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry: anObject	entry := anObject! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector	^selector! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector: anObject	selector := anObject! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target	^target! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target: anObject	target := anObject! !!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:42'!hash	^ self entry hash! !!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:43'!= aMCMenuSpec	^ self class == aMCMenuSpec class and: [self entry = aMCMenuSpec entry].! !!MCMenuSpec commentStamp: 'tfel 6/12/2010 14:57' prior: 0!A MCMenuSpec holds information to add menu entries to the monticello browser menus from external classes.Required is the entry string (#entry), the call target and the selector be called.An external class may use the MCWorkingCopyBrowser class>>addMenuSpec: method to add it's own menu entry to the monticello browser context menu.Note that MCMenuSpecs are compared via their menu entry string and if multiple MCMenuSpecs are added to the MCWorkingCopyBrowser, the last one takes precedence.!!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:35'!buttonSpecs	^ #((Merge merge 'Proceed with the merge' canMerge)		 (Cancel cancel 'Cancel the merge')		('All Newer' chooseAllNewerConflicts 'Choose all newer conflict versions')		('All Older' chooseAllOlderConflicts 'Choose all older conflict versions')		('Rest Local' chooseAllUnchosenLocal 'Choose local versions of all remaining conflicts')		('Rest Remote' chooseAllUnchosenRemote 'Choose remote versions of all remaining conflicts'))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52'!cancel	self answer: false! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:51'!canMerge	^ merger isMerged! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:21'!chooseAllNewerConflicts	conflicts do: [ :ea | ea chooseNewer ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22'!chooseAllOlderConflicts	conflicts do: [ :ea | ea chooseOlder ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34'!chooseAllUnchosenLocal	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseLocal ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34'!chooseAllUnchosenRemote	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseRemote ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41'!chooseLocal	self conflictSelectionDo:		[selection chooseLocal.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41'!chooseRemote	self conflictSelectionDo:		[selection chooseRemote.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41'!clearChoice	self conflictSelectionDo:		[selection clearChoice.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:42'!conflictSelectionDo: aBlock	self selectionIsConflicted		ifTrue: aBlock		ifFalse: [self inform: 'You must have a conflict selected']! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 21:31'!defaultLabel	^ 'Merge Browser'! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:04'!getConflictMenu: aMenu	selection remoteChosen		ifTrue: [aMenu add: 'undo keep change' target: self selector: #clearChoice]		ifFalse: [aMenu add: 'keep change' target: self selector: #chooseRemote].	selection localChosen		ifTrue: [aMenu add: 'undo reject change' target: self selector: #clearChoice]			ifFalse: [aMenu add: 'reject change' target: self selector: #chooseLocal].	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07'!getMenu: aMenu	selection ifNil: [^ aMenu].	^ self selectionIsConflicted		ifTrue: [self getConflictMenu: aMenu]		ifFalse: [self getOperationMenu: aMenu]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:37'!getOperationMenu: aMenu	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:49'!innerButtonRow	^ self buttonRow:		#((Keep chooseRemote 'keep the selected change' selectionIsConflicted)		  (Reject chooseLocal 'reject the selected change' selectionIsConflicted))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:32'!items	^ conflicts, items! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52'!merge	merger isMerged		ifFalse: [self inform: 'You must resolve all the conflicts first']		ifTrue: [self answer: true] ! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 10/14/2009 23:25'!merger: aMerger	merger := aMerger.	items := aMerger operations asSortedCollection.	conflicts := aMerger conflicts sort: [:a :b | a operation <= b operation].! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07'!selectionIsConflicted	^ selection isKindOf: MCConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 22:08'!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCMergeBrowser class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!resolveConflictsInMerger: aMerger	| inst |	inst := self new merger: aMerger.	^ inst showModally ifNil: [false]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!ancestorInfo	^ ancestorInfo ifNil: [ancestorInfo := version info commonAncestorWith: version workingCopy ancestry]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!ancestorSnapshot	^ ancestorSnapshot ifNil: [ancestorSnapshot := version workingCopy findSnapshotWithVersionInfo: self ancestorInfo]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 21:52'!imageIsClean	| ancestors |	ancestors := version workingCopy ancestors.	^ ancestors size = 1		and: [ancestors first = self ancestorInfo		and: [self imagePatch isEmpty]]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!imagePatch	^ imagePatch ifNil: [imagePatch := self packageSnapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithVersion: aVersion	version := aVersion! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14'!isAncestorMerge	^ version workingCopy ancestry hasAncestor: version info! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!mergePatch	^ mergePatch ifNil: [mergePatch := version snapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!packageSnapshot	^ packageSnapshot ifNil: [packageSnapshot := version package snapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14'!updateWorkingCopy	self isAncestorMerge ifFalse:		[self imageIsClean			ifTrue: [version workingCopy loaded: version]			ifFalse: [version workingCopy merged: version]]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52'!version	^ version! !!MCMergeRecord class methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52'!version: aVersion	^ self basicNew initializeWithVersion: aVersion! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:25'!defaultAction	^ (MCMergeBrowser new		merger: merger;		label: messageText) showModally! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:19'!merger	^ merger! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!merger: aMerger	merger := aMerger! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:10'!addConflictWithOperation: anOperation	self conflicts add: (MCConflict operation: anOperation)! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:01'!applyTo: anObject	self isMerged ifFalse: [self error: 'You must resolve all the conflicts first'].	conflicts do: [:ea | ea applyTo: anObject]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!conflicts	^ conflicts ifNil: [conflicts := OrderedCollection new]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/5/2003 19:09'!isMerged	^ self conflicts allSatisfy: [:ea | ea isResolved]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!load	| loader |	loader := MCPackageLoader new.	loader provisions addAll: self provisions.	self applyTo: loader.	loader load! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!loadWithNameLike: baseName	| loader |	loader := MCPackageLoader new.	loader provisions addAll: self provisions.	self applyTo: loader.	loader loadWithNameLike: baseName! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:11'!mergedSnapshot	^ MCPatcher apply: self to: self baseSnapshot! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:34'!operations	^ #()! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19'!provisions	^ #()! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'ul 11/2/2009 03:33'!hash	| hash |	hash := classIsMeta asString hashWithInitialHash: 0.	hash := source hashWithInitialHash: hash.	hash := category hashWithInitialHash: hash.	hash := className hashWithInitialHash: hash.	^ hash! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:11'!requirements	^ Array with: className! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:01'!sortKey	^ self className, '.', (self classIsMeta ifTrue: ['meta'] ifFalse: ['nonmeta']), '.', self selector! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'nice 10/31/2009 13:12'!= aDefinition	^(super = aDefinition)		and: [aDefinition source = self source		and: [aDefinition category = self category		and: [aDefinition timeStamp = self timeStamp]]]! !!MCMethodDefinition methodsFor: 'visiting' stamp: 'ab 7/18/2003 21:47'!accept: aVisitor	^ aVisitor visitMethodDefinition: self! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:10'!actualClass	^Smalltalk at: className		ifPresent: [:class | classIsMeta ifTrue: [class classSide] ifFalse: [class]]! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ar 3/4/2010 23:39'!asMethodAddition	^MethodAddition new		compile: source		classified: category		withStamp: timeStamp		notifying: nil		logSource: true		inClass: self actualClass.! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59'!category	^ category! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 07:26'!classIsMeta	^ classIsMeta! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:12'!className	^className! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'nk 10/21/2003 23:08'!fullTimeStamp	^TimeStamp fromMethodTimeStamp: timeStamp! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ar 3/4/2010 23:39'!load	self actualClass		compile: source		classified: category		withStamp: timeStamp		notifying: nil! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:11'!selector	^selector! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59'!source	^ source! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42'!timeStamp	^ timeStamp! !!MCMethodDefinition methodsFor: 'installing' stamp: 'ar 3/4/2010 23:39'!addMethodAdditionTo: aCollection	| methodAddition |	methodAddition := MethodAddition new		compile: source		classified: category		withStamp: timeStamp		notifying: nil		logSource: true		inClass: self actualClass.	"This might raise an exception and never return"	methodAddition createCompiledMethod.	aCollection add: methodAddition.! !!MCMethodDefinition methodsFor: 'installing' stamp: 'avi 9/17/2003 22:27'!isExtensionMethod	^ category beginsWith: '*'! !!MCMethodDefinition methodsFor: 'installing' stamp: 'avi 11/10/2003 15:45'!isOverrideMethod	"this oughta check the package"	^ self isExtensionMethod and: [category endsWith: '-override']! !!MCMethodDefinition methodsFor: 'installing' stamp: 'bf 1/5/2006 15:22'!postload	self isInitializer		ifTrue: [self actualClass theNonMetaClass initialize].	self isExternalStructureFieldDefinition		ifTrue: [self actualClass theNonMetaClass compileFields].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'ar 12/12/2009 17:05'!removeSelector: aSelector fromClass: aClass	"Safely remove the given selector from the target class.	Be careful not to remove the selector when it has wondered	to another package."	| newCategory |	newCategory := aClass organization categoryOfElement: aSelector.	newCategory ifNotNil:[		"If moved to and fro extension, ignore removal"		(category beginsWith: '*') = (newCategory beginsWith: '*') ifFalse:[^self].		"Check if moved between different extension categories"		((category beginsWith: '*') and:[category ~= newCategory]) ifTrue:[^self]].	aClass removeSelector: aSelector.! !!MCMethodDefinition methodsFor: 'installing' stamp: 'nice 12/27/2009 20:58'!scanForPreviousVersion	| sourceFilesCopy method position |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos tokens preamble methodCategory stamp prevFileIndex |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCMethodDefinition methodsFor: 'installing' stamp: 'ar 12/12/2009 15:40'!unload	| previousVersion |	self isOverrideMethod ifTrue: [previousVersion := self scanForPreviousVersion].	previousVersion		ifNil: [self actualClass ifNotNil:[:class| self removeSelector: selector fromClass: class]]		ifNotNil: [previousVersion fileIn] ! !!MCMethodDefinition methodsFor: 'printing' stamp: 'ab 12/5/2002 21:25'!description	^ Array			with: className		with: selector		with: classIsMeta! !!MCMethodDefinition methodsFor: 'printing' stamp: 'al 12/3/2005 12:15'!fullClassName	"Using #class selector for classes for backwards compatibility"	^ self classIsMeta		ifFalse: [self className]		ifTrue: [			(self actualClass isNil or: [ self actualClass isTrait ])				ifFalse: [self className, ' class']				ifTrue: [self className, ' classSide']]! !!MCMethodDefinition methodsFor: 'printing' stamp: 'ab 4/8/2003 18:04'!summary	^ self fullClassName , '>>' , selector! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithClassName: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	className := classString asSymbol.	selector := selectorString asSymbol.	category := catString asSymbol.	timeStamp := timeString.	classIsMeta := metaBoolean.	source := sourceString withSqueakLineEndings.! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49'!isCodeDefinition	^ true! !!MCMethodDefinition methodsFor: 'testing' stamp: 'bf 1/5/2006 15:56'!isExternalStructureFieldDefinition	^ selector = #fields		and: [classIsMeta			and: [				(Smalltalk at: #ExternalStructure ifPresent: [:externalStructure |					self actualClass theNonMetaClass inheritsFrom: externalStructure]) == true]]				! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 8/8/2003 17:05'!isInitializer	^ selector = #initialize and: [classIsMeta]	! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52'!isMethodDefinition	^true! !!MCMethodDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:06'!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #timeStamp ifTrue: [ aStream nextPutAll: self timeStamp ].		aRequest == #messageCategory ifTrue: [ aStream nextPutAll: self category ].		aRequest == #requirements ifTrue: [			self requirements do: [ :req |				aStream nextPutAll: req ] separatedBy: [ aStream space ]].	] separatedBy: [ aStream space ].! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2010 17:42'!cachedDefinitions		^definitions ifNil: [ definitions := WeakIdentityKeyDictionary new ]! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:05'!className: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self instanceLike:		(self new initializeWithClassName: classString					classIsMeta: metaBoolean					selector: selectorString					category: catString					timeStamp: timeString					source: sourceString)! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 4/1/2003 01:40'!className: classStringselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self	className: classString			classIsMeta: false			selector: selectorString			category: catString			timeStamp: timeString			source: sourceString! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 22:10'!forMethodReference: aMethodReference	| definition |	definition := self cachedDefinitions at: aMethodReference compiledMethod ifAbsent: [].	(definition isNil		or: [definition selector ~= aMethodReference methodSymbol		or: [definition className ~= aMethodReference classSymbol		or: [definition classIsMeta ~= aMethodReference classIsMeta		or: [definition category ~= aMethodReference category]]]])			ifTrue: [definition := self 						className: aMethodReference classSymbol						classIsMeta: aMethodReference classIsMeta						selector: aMethodReference methodSymbol						category: aMethodReference category						timeStamp: aMethodReference timeStamp						source: aMethodReference source.					self cachedDefinitions at: aMethodReference compiledMethod put: definition].	^ definition	! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 18:14'!initialize	Smalltalk addToShutDownList: self! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2010 17:42'!shutDown		definitions := nil.! !!MCMethodDefinition class methodsFor: 'class initialization' stamp: 'ar 2/26/2010 23:03'!cleanUp	"Flush caches"	self shutDown.! !!MCModification methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:12'!applyTo: anObject	anObject modifyDefinition: obsoletion to: modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10'!baseDefinition	^ obsoletion! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:55'!definition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44'!fromSource	^ obsoletion source! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:46'!modification	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:48'!obsoletion	^ obsoletion! !!MCModification methodsFor: 'accessing' stamp: 'nk 10/21/2003 22:54'!summarySuffix	^self fromSource = self toSource		ifTrue: [ ' (source same but rev changed)' ]		ifFalse: [ ' (changed)' ]! !!MCModification methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:18'!targetClass	^ obsoletion actualClass! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10'!targetDefinition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44'!toSource	^ modification source! !!MCModification methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithBase: base target: target	obsoletion := base.	modification := target.! !!MCModification methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:27'!inverse	^ MCModification of: modification to: obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:29'!isClassPatch	^obsoletion isClassDefinition! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:44'!printAnnotations: request on: aStream	aStream nextPutAll: 'old: '.	obsoletion printAnnotations: request on: aStream.	aStream cr.	aStream nextPutAll: 'new: '.	modification printAnnotations: request on: aStream.! !!MCModification methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:23'!isModification	^ true! !!MCModification class methodsFor: 'as yet unclassified' stamp: 'cwp 11/28/2002 07:19'!of: base to: target	^ self new initializeWithBase: base target: target! !!MCNoChangesException methodsFor: 'as yet unclassified' stamp: 'jf 8/21/2003 19:49'!defaultAction	self inform: 'No changes'! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 21:47'!accept: aVisitor	^ aVisitor visitOrganizationDefinition: self! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:51'!categories	^ categories! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!categories: anArray	categories := anArray! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!commonPrefix	| stream |	categories isEmpty ifTrue: [^ ''].		stream := String new writeStream.	categories first withIndexDo:		[:c :i|		categories do:			[:ea |			(ea at: i ifAbsent: []) = c ifFalse: [^ stream contents]].		stream nextPut: c].	^ stream contents! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 9/28/2004 14:53'!description	^ Array with: #organization with: self commonPrefix! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/11/2003 01:33'!isOrganizationDefinition	^ true! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 13:46'!postloadOver: oldDefinition	SystemOrganization categories:		(self			reorderCategories: SystemOrganization categories			original: (oldDefinition ifNil: [#()] ifNotNil: [oldDefinition categories]))! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!reorderCategories: allCategories original: oldCategories	| first |	first := allCategories detect: [:ea | categories includes: ea] ifNone: [^ allCategories].	^ 	((allCategories copyUpTo: first) copyWithoutAll: oldCategories, categories),		categories,		((allCategories copyAfter: first) copyWithoutAll: oldCategories, categories)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:01'!sortKey	^ '<organization>'! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 01:14'!source	^ String streamContents:		[:s |		categories do: [:ea | s nextPutAll: ea] separatedBy: [s cr]]! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:55'!summary	^ categories asArray printString! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:25'!= aDefinition	^ (super = aDefinition)		and: [categories = aDefinition categories]! !!MCOrganizationDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:06'!categories: anArray	^ self instanceLike: (self new categories: anArray)! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57'!hash	^ name asLowercase hash! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2005 16:26'!hasWorkingCopy	^ MCWorkingCopy registry includesKey: self! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 00:57'!name	^ name! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!name: aString	name := aString! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'nk 7/28/2003 13:30'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'bf 3/17/2005 18:35'!snapshot	| packageInfo definitions categories |	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	packageInfo methods do: [:ea | definitions add: ea asMethodDefinition] displayingProgress: 'Snapshotting methods...'.	(packageInfo respondsTo: #overriddenMethods) ifTrue:		[packageInfo overriddenMethods			do: [:ea | definitions add:					(packageInfo changeRecordForOverriddenMethod: ea) asMethodDefinition]			displayingProgress: 'Searching for overrides...'].	packageInfo classes do: [:ea | definitions addAll: ea classDefinitions] displayingProgress: 'Snapshotting classes...'.	(packageInfo respondsTo: #hasPreamble) ifTrue: [		packageInfo hasPreamble ifTrue: [definitions add: (MCPreambleDefinition from: packageInfo)].		packageInfo hasPostscript ifTrue: [definitions add: (MCPostscriptDefinition from: packageInfo)].		packageInfo hasPreambleOfRemoval ifTrue: [definitions add: (MCRemovalPreambleDefinition from: packageInfo)].		packageInfo hasPostscriptOfRemoval ifTrue: [definitions add: (MCRemovalPostscriptDefinition from: packageInfo)]]. 	^ MCSnapshot fromDefinitions: definitions! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:13'!storeOn: aStream	aStream		nextPutAll: 'MCPackage';		space; nextPutAll: 'named: '; store: name.! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:32'!unload	^ self workingCopy unload! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:33'!workingCopy	^ MCWorkingCopy forPackage: self.! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57'!= other	^ other species = self species and: [other name sameAs: name]! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33'!packageInfo	^ PackageInfo named: name! !!MCPackage class methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:17'!named: aString	^ self new name: aString! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	sorter := MCVersionSorter new.	fileNames := Dictionary new.! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:25'!recordVersionInfo: aVersionInfo forFileNamed: aString	Transcript cr; show: aString.	fileNames at: aVersionInfo put: aString.	sorter addVersionInfo: aVersionInfo! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:21'!versionInfos	^ sorter sortedVersionInfos ! !!MCPackageCache class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:12'!new	^ self basicNew initialize! !!MCPackageLoader methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:13'!addDefinition: aDefinition	additions add: aDefinition! !!MCPackageLoader methodsFor: 'patch ops' stamp: 'avi 2/17/2004 13:14'!modifyDefinition: old to: new	self addDefinition: new.	obsoletions at: new put: old.! !!MCPackageLoader methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:14'!removeDefinition: aDefinition	removals add: aDefinition! !!MCPackageLoader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!analyze	| sorter |	sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.		sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed.! !!MCPackageLoader methodsFor: 'private' stamp: 'ar 2/13/2010 15:31'!basicLoad	"Load the contents of some package. This is the core loading method	in Monticello. Be wary about modifying it unless you understand the details	and dependencies of the various entities being modified."	| pkgName |	errorDefinitions := OrderedCollection new.	"Obviously this isn't the package name but we don't have anything else	to use here. ChangeSet current name will generally work since a CS is 	usually installed prior to installation."	pkgName := ChangeSet current name.	[["Pass 1: Load everything but the methods,  which are collected in methodAdditions."	additions do: [:ea | 		ea isMethodDefinition 			ifTrue:[methodAdditions add: ea asMethodAddition]			ifFalse:[[ea load]on: Error do: [errorDefinitions add: ea]].	] displayingProgress: 'Reshaping ', pkgName.	"Try again any delayed definitions"	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea load] 		displayingProgress: 'Reloading ', pkgName.	"Pass 2: We compile new / changed methods"	methodAdditions do:[:ea| ea createCompiledMethod] 		displayingProgress: 'Compiling ', pkgName.	'Installing ', pkgName displayProgressAt: Sensor cursorPoint from: 0 to: 2 during:[:bar|		"There is no progress *during* installation since a progress bar update		will redraw the world and potentially call methods that we're just trying to install."		bar value: 1.		"Pass 3: Install the new / changed methods		(this is a separate pass to allow compiler changes to be loaded)"		methodAdditions do:[:ea| ea installMethod].		"Pass 4: Remove the obsolete methods"		removals do:[:ea| ea unload].	].	"Finally, notify observers for the method additions"	methodAdditions do: [:each | each notifyObservers] 		"the message is fake but actually telling people how much time we spend		in the notifications is embarrassing so lie instead"		displayingProgress: 'Installing ', pkgName.	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] 		displayingProgress: 'Initializing ', pkgName.	] on: InMidstOfFileinNotification do: [:n | n resume: true]	] ensure: [self flushChangesFile]! !!MCPackageLoader methodsFor: 'private' stamp: 'ab 5/25/2003 01:24'!dependencyWarning	^ String streamContents:		[:s |		s nextPutAll: 'This package depends on the following classes:'; cr.		requirements do: [:ea | s space; space; nextPutAll: ea; cr].		s nextPutAll: 'You must resolve these dependencies before you will be able to load these definitions: '; cr.		unloadableDefinitions do: [:ea | s space; space; nextPutAll: ea summary; cr]] ! !!MCPackageLoader methodsFor: 'private' stamp: 'avi 1/24/2004 17:44'!errorDefinitionWarning	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading.  Press Proceed to try to load them again (they may work on a second pass):'; cr.		errorDefinitions do: [:ea | s space; space; nextPutAll: ea summary; cr]] ! !!MCPackageLoader methodsFor: 'private' stamp: 'cwp 11/13/2003 02:01'!flushChangesFile	"The changes file is second in the SourceFiles array"	(SourceFiles at: 2) flush! !!MCPackageLoader methodsFor: 'private' stamp: 'abc 2/26/2007 21:39'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new.	methodAdditions := OrderedCollection new. ! !!MCPackageLoader methodsFor: 'private' stamp: 'ar 8/30/2009 20:25'!loadClassDefinition: aDefinition	[aDefinition isClassDefinition ifTrue:[aDefinition load]] on: Error do: [errorDefinitions add: aDefinition].! !!MCPackageLoader methodsFor: 'private' stamp: 'avi 2/17/2004 13:15'!obsoletionFor: aDefinition	^ obsoletions at: aDefinition ifAbsent: [nil]! !!MCPackageLoader methodsFor: 'private' stamp: 'ab 5/25/2003 01:19'!orderDefinitionsForLoading: aCollection	^ (self sorterForItems: aCollection) orderedItems! !!MCPackageLoader methodsFor: 'private' stamp: 'ab 5/24/2003 16:52'!orderedAdditions	^ additions! !!MCPackageLoader methodsFor: 'private' stamp: 'ar 3/5/2010 20:44'!provisions	^ provisions ifNil: [provisions := Set withAll: Smalltalk globals keys]! !!MCPackageLoader methodsFor: 'private' stamp: 'avi 1/25/2004 13:32'!shouldWarnAboutErrors	^ errorDefinitions isEmpty not and: [false "should make this a preference"]! !!MCPackageLoader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!sorterForItems: aCollection	| sorter |	sorter := MCDependencySorter items: aCollection.	sorter addExternalProvisions: self provisions.	^ sorter! !!MCPackageLoader methodsFor: 'private' stamp: 'rej 2/26/2007 10:41'!tryToLoad: aDefinition	[aDefinition addMethodAdditionTo: methodAdditions] on: Error do: [errorDefinitions add: aDefinition].! !!MCPackageLoader methodsFor: 'private' stamp: 'pk 10/17/2006 09:41'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader methodsFor: 'private' stamp: 'nk 8/30/2004 08:38'!useNewChangeSetDuring: aBlock	^self useNewChangeSetNamedLike: 'MC' during: aBlock! !!MCPackageLoader methodsFor: 'private' stamp: 'nk 2/23/2005 07:50'!useNewChangeSetNamedLike: baseName during: aBlock	^self useChangeSetNamed: (ChangeSet uniqueNameLike: baseName) during: aBlock! !!MCPackageLoader methodsFor: 'private' stamp: 'ab 5/25/2003 01:22'!warnAboutDependencies 	self notify: self dependencyWarning! !!MCPackageLoader methodsFor: 'private' stamp: 'avi 1/24/2004 17:42'!warnAboutErrors	self notify: self errorDefinitionWarning.! !!MCPackageLoader methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:47'!installSnapshot: aSnapshot	| patch |	patch := aSnapshot patchRelativeToBase: MCSnapshot empty.	patch applyTo: self.! !!MCPackageLoader methodsFor: 'public' stamp: 'ab 8/24/2003 01:03'!load	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetDuring: [self basicLoad]! !!MCPackageLoader methodsFor: 'public' stamp: 'nk 8/30/2004 08:39'!loadWithNameLike: baseName	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetNamedLike: baseName during: [self basicLoad]! !!MCPackageLoader methodsFor: 'public' stamp: 'nk 2/23/2005 07:51'!loadWithName: baseName	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useChangeSetNamed: baseName during: [self basicLoad]! !!MCPackageLoader methodsFor: 'public' stamp: 'avi 10/5/2003 11:09'!unloadPackage: aPackage	self updatePackage: aPackage withSnapshot: MCSnapshot empty! !!MCPackageLoader methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:47'!updatePackage: aPackage withSnapshot: aSnapshot	|  patch packageSnap |	packageSnap := aPackage snapshot.	patch := aSnapshot patchRelativeToBase: packageSnap.	patch applyTo: self.	packageSnap definitions do: [:ea | self provisions addAll: ea provisions]! !!MCPackageLoader commentStamp: 'rej 2/26/2007 07:35' prior: 0!A MCPackageLoader is responsible for loading packages.  It gets used by VersionLoader, so it is eventually responsible for loading everything.Instance Variables	additions:		<Definitions>  Definitions that need to be added	errorDefinitions:		<Object>	obsoletions:		<Object>	provisions:		<Object>	removals:		<Object>	requirements:		<Object>	unloadableDefinitions:		<Object>	methodAdditions  <MethodAdditions> MethodDefinitions corresponding to the Definitions in "additions" that have been added so far.additions	- xxxxxerrorDefinitions	- xxxxxobsoletions	- xxxxxprovisions	- xxxxxremovals	- xxxxxrequirements	- xxxxxunloadableDefinitions	- xxxxx!!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:30'!installSnapshot: aSnapshot	self new		installSnapshot: aSnapshot;		load! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:00'!unloadPackage: aPackage	self new		unloadPackage: aPackage;		loadWithNameLike: aPackage name, '-unload'! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 12:11'!updatePackage: aPackage withSnapshot: aSnapshot	self new		updatePackage: aPackage withSnapshot: aSnapshot;		load! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!classModified: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!classMoved: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!classRemoved: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!methodModified: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!methodMoved: anEvent 	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!methodRemoved: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!registerForNotifications	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!registerForNotificationsFrom: aNotifier	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17'!systemChange: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'system changes' stamp: 'avi 11/11/2003 12:06'!update: aSymbol	InMidstOfFileinNotification signal ifFalse: [	[((aSymbol = #recentMethodSubmissions)		and: [self packageInfo				includesMethodReference: Utilities recentMethodSubmissions last])					ifTrue: [self modified: true]]		on: Error do: []]! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	modified := false.	self registerForNotifications.! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithPackage: aPackage	package := aPackage.	self initialize.! !!MCPackageManager methodsFor: 'accessing' stamp: 'cwp 11/13/2003 14:12'!modified	^ modified! !!MCPackageManager methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:10'!modified: aBoolean     modified = aBoolean ifTrue: [^ self].	modified := aBoolean.	self changed: #modified.		modified ifFalse:		[(((Smalltalk classNamed: 'SmalltalkImage') ifNotNil: [:si | si current]) ifNil: [Smalltalk])			logChange: '"', self packageName, '"'].! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 16:47'!package	^ package! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33'!packageInfo	^ package packageInfo! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 12:18'!packageName	^ package name! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:18'!packageNameWithStar	^ modified		ifTrue: ['* ', self packageName]		ifFalse: [self packageName]! !!MCPackageManager methodsFor: 'operations' stamp: 'ab 7/19/2003 23:30'!unregister	self class registry removeKey: package.	self class changed: #allManagers! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'ab 3/31/2003 20:45'!allManagers	^ self registry values! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!forPackage: aPackage	^ self registry at: aPackage ifAbsent:		[|mgr|		mgr := self new initializeWithPackage: aPackage.		self registry at: aPackage put: mgr.		self changed: #allManagers.		mgr]! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2005 02:09'!initialize	"Remove this later"	Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|		(cls uniqueInstance) noMoreNotificationsFor: self.	].! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!registry	^ registry ifNil: [registry := Dictionary new]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:28'!classModified: anEvent	self managersForClass: anEvent item do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:31'!classMoved: anEvent	self classModified: anEvent.	self managersForCategory: anEvent oldCategory do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:31'!classRemoved: anEvent	self classModified: anEvent! !!MCPackageManager class methodsFor: 'system changes' stamp: 'md 3/14/2006 23:11'!managersForCategory: aSystemCategory do: aBlock	"Got to be careful here - we might get method categories where capitalization is problematic."	| cat foundOne index |	foundOne := false.	cat := aSystemCategory ifNil:[^nil]. "yes this happens; for example in eToy projects"	"first ask PackageInfos, their package name might not match the category"	self registry do: [:mgr | 		(mgr packageInfo includesSystemCategory: aSystemCategory)	ifTrue: [			aBlock value: mgr.			foundOne := true.		]	].	foundOne ifTrue: [^self].	["Loop over categories until we found a matching one"	self registry at: (MCPackage named: cat) ifPresent:[:mgr|		aBlock value: mgr.		foundOne := true.	].	index := cat lastIndexOf: $-.	index > 0]whileTrue:[		"Step up to next level package"		cat := cat copyFrom: 1 to: index-1.	].	foundOne ifFalse:[		"Create a new (but only top-level)"		aBlock value: (MCWorkingCopy forPackage: (MCPackage named: (aSystemCategory copyUpTo: $-) capitalized)).	].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:11'!managersForClass: aClass category: methodCategory do: aBlock	(methodCategory isEmptyOrNil or:[methodCategory first ~= $*]) ifTrue:[		"Not an extension method"		^self managersForClass: aClass do: aBlock.	].	self managersForCategory: methodCategory allButFirst do: aBlock.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'bf 5/20/2005 16:50'!managersForClass: aClass do: aBlock	self registry do: [:mgr |		(mgr packageInfo includesClass: aClass)			ifTrue: [aBlock value: mgr]]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40'!managersForClass: aClass selector: aSelector do: aBlock	^self managersForClass: aClass category: (aClass organization categoryOfElement: aSelector) do: aBlock! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40'!methodModified: anEvent	^self managersForClass: anEvent itemClass selector: anEvent itemSelector do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40'!methodMoved: anEvent	self managersForClass: anEvent itemClass category: anEvent oldCategory do:[:mgr| mgr modified: true].	self methodModified: anEvent.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:12'!methodRemoved: anEvent	self managersForClass: anEvent itemClass category: anEvent itemProtocol do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15'!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCPackageManager class methodsFor: 'cleanup' stamp: 'ar 6/16/2010 19:56'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCPackageManager."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCPatch methodsFor: 'applying' stamp: 'ab 5/24/2003 16:12'!applyTo: anObject	operations do: [:ea | ea applyTo: anObject].! !!MCPatch methodsFor: 'ui' stamp: 'cwp 8/2/2003 13:34'!browse	^ (MCPatchBrowser forPatch: self) show! !!MCPatch methodsFor: 'intializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithBase: baseSnapshot target: targetSnapshot	| base target |		operations := OrderedCollection new.	base := MCDefinitionIndex definitions: baseSnapshot definitions.	target := MCDefinitionIndex definitions: targetSnapshot definitions.		target definitions do:		[:t |		base			definitionLike: t			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]			ifAbsent: [operations add: (MCAddition of: t)]]		displayingProgress: 'Diffing...'.			base definitions do:		[:b |		target			definitionLike: b			ifPresent: [:t]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!MCPatch methodsFor: 'intializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithOperations: aCollection	operations := aCollection! !!MCPatch methodsFor: 'querying' stamp: 'cwp 6/9/2003 11:53'!isEmpty	^ operations isEmpty! !!MCPatch methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18'!operations	^ operations! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:49'!fromBase: baseSnapshot target: targetSnapshot	^ self new initializeWithBase: baseSnapshot target: targetSnapshot! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:50'!operations: aCollection	^ self basicNew initializeWithOperations: aCollection! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:41'!annotations	^selection ifNil: [ super annotations ]		ifNotNil: [ selection annotations ]! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 08:04'!changeSetNameForInstall	"Answer the name of the change set into which my selection will be installed.	Derive this from my label.	If I have no label, use the current change set."	| tokens |	label ifNil: [ ^ChangeSet current name ].	tokens := label findTokens: ' '.	tokens removeAllFoundIn: { 'changes'. 'between'. 'and' }.	(tokens size = 3 and: [ tokens second = '<working' ]) ifTrue: [ ^tokens first, '-to-working' ].	tokens size = 2 ifFalse: [ ^'InstalledPatches' ].	^'{1}-to-{2}' format: tokens ! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 8/22/2003 02:21'!buttonSpecs	^ #((Invert invert 'Show the reverse set of changes')		 (Export export 'Export the changes as a change set'))! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31'!defaultLabel	^ 'Patch Browser'! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'nk 11/10/2003 20:55'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'nice 1/20/2010 09:01'!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 0 0 0))		((textMorph: text) (0 0.4 1 1))		) ].	^ {		#((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 0 0 0)).		{ #(textMorph: annotations). #(0 0.4 1 0.4). { 0. 0. 0. self defaultAnnotationPaneHeight. } }.		{ #(textMorph: text). #(0 0.4 1 1). { 0. self defaultAnnotationPaneHeight. 0. 0. } }.		}! !!MCPatchBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!installSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader new.		selection applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'actions' stamp: 'ar 7/10/2009 22:46'!revertSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader new.		selection inverse applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!invert	items := items collect: [:ea | ea inverse].	self changed: #list; changed: #text; changed: #selection! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'ab 7/16/2003 14:30'!selection	^ selection 		ifNil: [0]		ifNotNil: [self items indexOf: selection]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!selection: aNumber	selection := aNumber = 0 ifFalse: [self items at: aNumber].	self changed: #selection; changed: #text; changed: #annotations! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:36'!items	^ items! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:39'!list	^ self items collect: [:ea | ea summary]! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!patch: aPatch	items := aPatch operations asSortedCollection! !!MCPatchBrowser methodsFor: 'menus' stamp: 'ar 7/10/2009 22:46'!methodListMenu: aMenu	selection ifNotNil:		[aMenu addList:#(			('install'	 installSelection)			('revert'	 revertSelection)			-)].	super methodListMenu: aMenu.	^ aMenu! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47'!selectedClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^Smalltalk at: definition className ifAbsent: [ ]! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47'!selectedClassOrMetaClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition actualClass! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47'!selectedMessageCategoryName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition category! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47'!selectedMessageName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition  selector! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:40'!text	^ selection ifNil: [''] ifNotNil: [selection source]! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:27'!text: aTextOrString	self changed: #text! !!MCPatchBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/16/2003 14:35'!forPatch: aPatch	^ self new patch: aPatch! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46'!addDefinition: aDefinition	definitions add: aDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithSnapshot: aSnapshot	definitions := MCDefinitionIndex definitions: aSnapshot definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:23'!modifyDefinition: baseDefinition to: targetDefinition	self addDefinition: targetDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:48'!patchedSnapshot	^ MCSnapshot fromDefinitions: definitions definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46'!removeDefinition: aDefinition	definitions remove: aDefinition! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!apply: aPatch to: aSnapshot	| loader |	loader := self snapshot: aSnapshot.	aPatch applyTo: loader.	^ loader patchedSnapshot! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:22'!snapshot: aSnapshot	^ self new initializeWithSnapshot: aSnapshot! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:48'!addDefinition: aDefinition	stream nextPutAll: 'A'; tab; nextPutAll: aDefinition summary; cr! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!modifyDefinition: oldDefinition to: newDefinition	stream nextPutAll: 'M'; tab; nextPutAll: newDefinition summary; cr! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!removeDefinition: aDefinition	stream nextPutAll: 'D'; tab; nextPutAll: aDefinition summary; cr! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 16:29'!message	^stream contents! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 17:44'!patch: aPatch	stream ifNil: [stream := WriteStream on: (String new: 100)].	aPatch operations asSortedCollection		do: [:op | op applyTo: self]! !!MCPatchOperation methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:11'!<= other	^ self definition <= other definition! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:38'!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:39'!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:59'!definition	^ self subclassResponsibility ! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:26'!inverse	self subclassResponsibility! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:53'!prefixForOperation: aSymbol	aSymbol == #insert ifTrue: [^ '+'].	aSymbol == #remove ifTrue: [^ '-'].	^ ' '! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:40'!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	self definition printAnnotations: requests on: aStream.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:55'!source	^ self sourceText! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:26'!sourceString	^self sourceText asString! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:29'!sourceText	| builder |	builder := (Preferences diffsWithPrettyPrint and: [ self targetClass notNil and: [ self isClassPatch not ] ])				ifTrue: 					[PrettyTextDiffBuilder 						from: self fromSource						to: self toSource						inClass: self targetClass]				ifFalse: [TextDiffBuilder from: self fromSource to: self toSource].	^builder buildDisplayPatch.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06'!summary	^ self definition summary, self summarySuffix! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06'!summarySuffix	^ ''! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30'!isAddition	^ false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30'!isModification	^ false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30'!isRemoval	^ false! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28'!isClassPatch	^false! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 18:17'!targetClass	self subclassResponsibility.! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51'!isPoolImport	^ true! !!MCPoolImportDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59'!type	^ #pool! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:16'!postload	self evaluate! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:16'!sortKey	^ 'zzz' "force to the end so it gets loaded late"! !!MCPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04'!scriptSelector	^ #postscript! !!MCPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:15'!load	super load.	self evaluate! !!MCPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04'!scriptSelector	^ #preamble! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54'!localName	^localName! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54'!localName: aString	localName := aString! !!MCPseudoFileStream commentStamp: '<historical>' prior: 0!A pseudo file stream which can be used for updates.!!MCReader methodsFor: 'lifecycle' stamp: 'avi 1/24/2004 17:52'!initialize! !!MCReader methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!stream: aStream	stream := aStream! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:00'!canReadFileNamed: fileName	^ (fileName endsWith: self extension)! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01'!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01'!isAbstract	^ (self respondsTo: #extension) not! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:03'!readerClassForFileNamed: fileName	^ self concreteSubclasses		detect: [:c | c canReadFileNamed: fileName]		ifNone: [nil]! !!MCReader class methodsFor: 'instance creation' stamp: 'avi 1/21/2004 19:02'!new	^ self basicNew initialize! !!MCReader class methodsFor: 'instance creation' stamp: 'avi 1/21/2004 19:02'!on: aStream	^ self new stream: aStream! !!MCReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47'!on: aStream name: aFileName	| class |	class := self readerClassForFileNamed: aFileName.	^ class		ifNil: [self error: 'Unsupported format: ', aFileName]		ifNotNil: [class on: aStream]! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11'!applyTo: anObject	anObject removeDefinition: definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10'!baseDefinition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'cwp 11/27/2002 10:02'!definition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44'!fromSource	^ definition source! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:38'!sourceString	^self fromSource asText		addAttribute: TextEmphasis struckOut;		addAttribute: TextColor blue;		yourself! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:05'!summarySuffix	^ ' (removed)'! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:23'!targetClass	^ definition actualClass! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10'!targetDefinition	^ nil! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44'!toSource	^ ''! !!MCRemoval methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26'!inverse	^ MCAddition of: definition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28'!isClassPatch	^definition isClassDefinition! !!MCRemoval methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:24'!isRemoval	^ true! !!MCRemoval class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03'!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCRemovalPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:15'!unload	super unload.	self evaluate! !!MCRemovalPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04'!scriptSelector	^ #postscriptOfRemoval ! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:14'!sortKey	^ 'zzz' "force to the end so it gets unloaded early"! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:15'!unload	super unload.	self evaluate! !!MCRemovalPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04'!scriptSelector	^ #preambleOfRemoval! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2004 01:08'!alwaysStoreDiffs	^ storeDiffs ifNil: [false]! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:48'!asCreationTemplate	^ self creationTemplate! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:20'!basicStoreVersion: aVersion	self subclassResponsibility! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	anAncestry breadthFirstAncestorsDo:		[:ancestorInfo |		(self versionWithInfo: ancestorInfo) ifNotNil: [:v | ^ v]].	^ errorBlock value! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:46'!creationTemplate	^ creationTemplate! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!creationTemplate: aString	self creationTemplate ifNotNil: [ self error: 'Creation template already set for this MCRepository instance.' ].		creationTemplate := aString.! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:53'!description	^ self class name! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!doAlwaysStoreDiffs	storeDiffs := true! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!doNotAlwaysStoreDiffs	storeDiffs := false! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:36'!hash	^ self description hash! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 20:13'!initialize! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:27'!notificationForVersion: aVersion	^ MCVersionNotification version: aVersion repository: self! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:23'!notifyList	^ #()! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2005 23:01'!possiblyNewerVersionsOfAnyOf: someVersions	^#()! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2004 01:06'!prepareVersionForStorage: aVersion	^ self alwaysStoreDiffs		ifTrue: [aVersion asDiffAgainst:				 (self closestAncestorVersionFor: aVersion info ifNone: [^ aVersion])]		ifFalse: [aVersion]! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'mas 9/24/2003 04:21'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self description;		nextPut: $).! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!sendNotificationsForVersion: aVersion	| notification notifyList |	notifyList := self notifyList.	notifyList isEmpty ifFalse:		[notification := self notificationForVersion: aVersion.		notifyList do: [:ea | notification notify: ea]]! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2004 01:05'!storeVersion: aVersion	self basicStoreVersion: (self prepareVersionForStorage: aVersion).	self sendNotificationsForVersion: aVersion! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:36'!= other	^ other species = self species and: [other description = self description]! !!MCRepository methodsFor: 'interface' stamp: 'ab 8/21/2003 12:40'!includesVersionNamed: aString	self subclassResponsibility! !!MCRepository methodsFor: 'interface' stamp: 'lr 9/26/2003 20:03'!morphicOpen	self morphicOpen: nil! !!MCRepository methodsFor: 'interface' stamp: 'lr 9/26/2003 20:03'!morphicOpen: aWorkingCopy	self subclassResponsibility ! !!MCRepository methodsFor: 'interface' stamp: 'bf 4/14/2005 17:30'!openAndEditTemplateCopy	^ self class fillInTheBlankConfigure: (self asCreationTemplate ifNil: [^nil])! !!MCRepository methodsFor: 'interface' stamp: 'avi 10/9/2003 12:42'!versionWithInfo: aVersionInfo	^ self versionWithInfo: aVersionInfo ifAbsent: [nil]! !!MCRepository methodsFor: 'interface' stamp: 'ab 8/16/2003 18:22'!versionWithInfo: aVersionInfo ifAbsent: aBlock	self subclassResponsibility ! !!MCRepository methodsFor: 'testing' stamp: 'nk 11/2/2003 10:55'!isValid	^true! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:30'!allConcreteSubclasses	^ self withAllSubclasses reject: [:ea | ea isAbstract]! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:59'!creationTemplate	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:29'!description	^ nil! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:05'!fillInTheBlankConfigure	^ self fillInTheBlankConfigure: self creationTemplate			! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!fillInTheBlankConfigure: aTemplateString	| chunk repo |		aTemplateString ifNil: [ ^ false ].	chunk := FillInTheBlankMorph 			request: self fillInTheBlankRequest			initialAnswer: aTemplateString			centerAt: Sensor cursorPoint			inWorld: World			onCancelReturn: nil			acceptOnCR: false			answerExtent: 400@120.				chunk 		ifNotNil: [ 			repo := self readFrom: chunk readStream.			repo creationTemplate: chunk. 	].	^ repo! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:58'!fillInTheBlankRequest	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:59'!isAbstract	^ self description isNil! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:01'!morphicConfigure	^ self new! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCRepository class methodsFor: 'external settings' stamp: 'stephaneducasse 2/4/2006 20:47'!fetchExternalSettingsIn: aDirectory	"Scan for settings file"	"MCRepository fetchExternalSettingsIn: ExternalSettings preferenceDirectory"	| stream |	(aDirectory fileExists: self settingsFileName)		ifFalse: [^self].	stream := aDirectory readOnlyFileNamed: self settingsFileName.	stream		ifNotNil: [			[Settings := ExternalSettings parseServerEntryArgsFrom: stream]				ensure: [stream close]].! !!MCRepository class methodsFor: 'external settings' stamp: 'bf 12/17/2004 20:30'!releaseExternalSettings	Settings := nil.! !!MCRepository class methodsFor: 'external settings' stamp: 'bf 12/17/2004 20:36'!settingsFileName	^ 'mcSettings'! !!MCRepository class methodsFor: 'class initialization' stamp: 'bf 4/15/2005 10:19'!initialize	"self initialize"	ExternalSettings registerClient: self.! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 1/27/2004 00:29'!addRepository: aRepository	((repositories includes: aRepository) or: [aRepository == MCCacheRepository default])		ifFalse: [repositories add: aRepository.				self class default addRepository: aRepository].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'abc 11/6/2004 20:32'!includesVersionNamed: aString	self repositoriesDo: [:ea | (ea includesVersionNamed: aString) ifTrue: [^ true]].	^ false	! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:20'!includes: aRepository	^ self repositories includes: aRepository! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	repositories := OrderedCollection new! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:11'!removeRepository: aRepository	repositories remove: aRepository ifAbsent: [].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'nk 11/2/2003 10:57'!repositories	^ ((Array with: MCCacheRepository default), repositories) select: [ :ea | ea isValid ]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:51'!repositoriesDo: aBlock	self repositories do: [:ea | [aBlock value: ea] on: Error do: []]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'klc 5/25/2008 20:20'!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ nil ]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionWithInfo: aVersionInfo ifNone: aBlock	self repositoriesDo: [:ea | (ea versionWithInfo: aVersionInfo) ifNotNil: [:v | ^ v]].	^aBlock value! !!MCRepositoryGroup commentStamp: '<historical>' prior: 0!A singleton class, holds the list of repositories. Can look for a requested VersionInfo among its repositories.!!MCRepositoryGroup class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!default	^ default ifNil: [default := self new]! !!MCRepositoryGroup class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 18:51'!buttonSpecs	^#(('Refresh' refresh 'refresh the version-list')) , super buttonSpecs! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:30'!defaultExtent	^570@350! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 18:51'!defaultLabel	^'Repository: ' , repository description! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:09'!packageList	^ packages collect: [:ea | ea name]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 18:51'!packageListMenu: aMenu	^aMenu! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:07'!packageSelection	^ packages indexOf: selectedPackage! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!packageSelection: aNumber	selectedPackage := aNumber isZero ifFalse: [ packages at: aNumber ].	versions := repository versionsAvailableForPackage: selectedPackage.	self changed: #packageSelection; changed: #versionList! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!sortedVersions	| sorter |	sorter := MCVersionSorter new.	sorter addAllVersionInfos: versions.	^ sorter sortedVersionInfos select: [:ea | versions includes: ea]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/29/2004 11:32'!versionList	^ self sortedVersions collect: [:ea | ea name]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 18:57'!versionListMenu: aMenu	^aMenu! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:07'!versionSelection	^ versions indexOf: selectedVersion! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!versionSelection: aNumber	aNumber isZero 		ifTrue: [ selectedVersion := nil ]		ifFalse: [ 			selectedVersion := versions at: aNumber].	self changed: #versionSelection; changed: #summary! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 18:51'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.6) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:20'!hasVersion	^ selectedVersion notNil! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:11'!load	self hasVersion ifTrue:		[super load.		self version workingCopy repositoryGroup addRepository: repository].! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!refresh	packages := repository packages.	self changed: #packageList.	self packageSelection: self packageSelection.! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setRepository: aRepository workingCopy: aWorkingCopy	repository := aRepository.	aWorkingCopy isNil ifFalse: [ selectedPackage := aWorkingCopy package].	self refresh! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:20'!summary	^ selectedVersion		ifNotNil: [selectedVersion summary]		ifNil: ['']! !!MCRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!version	^ version ifNil: [version := repository versionWithInfo: selectedVersion]! !!MCRepositoryInspector methodsFor: 'private' stamp: 'cmm 2/14/2010 20:26'!postAcceptBrowseFor: aModel	"Make the same selections as in aModel."	self 		packageSelection: aModel packageSelection ;		versionSelection: aModel versionSelection! !!MCRepositoryInspector methodsFor: 'private' stamp: 'cmm 2/14/2010 09:54'!repository	^ repository! !!MCRepositoryInspector methodsFor: 'private' stamp: 'cmm 2/14/2010 10:30'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ self repository = anotherModel repository ]! !!MCRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 18:51'!repository: aFileBasedRepository workingCopy: aWorkingCopy	^self new		setRepository: aFileBasedRepository workingCopy: aWorkingCopy;		yourself! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:28'!accept	self answer:		(Array			with: (self findTextMorph: #versionName) text asString			with: (self findTextMorph: #logMessage) text asString)	! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:10'!buttonSpecs	^ #((Accept accept 'accept version name and log message')		(Cancel cancel 'cancel saving version')		) ! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:41'!cancel	self answer: nil! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'bf 8/18/2010 15:36'!defaultExtent 	^ 500@300! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:43'!defaultLabel	^ 'Edit Version Name and Message:'! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:41'!logMessage	^ message ifNil: ['empty log message']! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!logMessage: aString	message := aString.	self changed: #logMessage! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'cmm 2/14/2010 09:37'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ self versionName = anotherModel versionName ]! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:37'!versionName	^ name! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!versionName: aString	name := aString.	self changed: #versionName! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'jrp 7/2/2005 10:33'!widgetSpecs	^ #(			((textMorph: versionName) (0 0 1 0) (0 0 0 30))		((textMorph: logMessage) (0 0 1 1) (0 30 0 -30))		((buttonRow) (0 1 1 1) (0 -40 0 0))		)! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!next	| c |	stream skipSeparators.	c := stream peek.	c = $# ifTrue: [c := stream next; peek].	c = $' ifTrue: [^ self nextString].	c = $( ifTrue: [^ self nextArray].	c isAlphaNumeric ifTrue: [^ self nextSymbol].	self error: 'Unknown token type'.	! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:27'!nextArray	stream next. "("	^ Array streamContents:		[:s |		[stream skipSeparators.		(stream peek = $)) or: [stream atEnd]] whileFalse: [s nextPut: self next].		stream next = $) ifFalse: [self error: 'Unclosed array']]! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:09'!nextString	^ stream nextDelimited: $'! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:16'!nextSymbol	^ (String streamContents:		[:s |		[stream peek isAlphaNumeric] whileTrue: [s nextPut: stream next]]) asSymbol			! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!stream: aStream	stream := aStream! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:32'!scanTokens: aString	"compatibility"	^ Array with: (self scan: aString readStream)! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:14'!scan: aStream	^ (self new stream: aStream) next! !!MCScriptDefinition methodsFor: 'comparing' stamp: 'avi 2/28/2005 16:55'!= aDefinition	^ (super = aDefinition)		and: [script = aDefinition script]! !!MCScriptDefinition methodsFor: 'visiting' stamp: 'bf 8/12/2009 21:41'!accept: aVisitor	aVisitor visitScriptDefinition: self! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:12'!description	^ Array with: packageName with: self scriptSelector! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:22'!packageInfo	^ PackageInfo named: packageName! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'bf 8/13/2009 00:09'!packageName	^ packageName! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 16:54'!script	^ script! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:10'!scriptSelector	^ self class scriptSelector! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'bf 10/25/2005 19:05'!sortKey	^ '!!', self scriptSelector "force to the front so it gets loaded first"! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:04'!source	^ script! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:12'!summary	^ packageName, ' ', self scriptSelector! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:03'!evaluate	Compiler evaluate: script! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:11'!installScript	self installScript: script! !!MCScriptDefinition methodsFor: 'installing' stamp: 'bf 10/25/2005 18:55'!installScript: aString	| sel pi |	sel := (self scriptSelector, ':') asSymbol.	pi := self packageInfo.	(pi respondsTo: sel)		ifTrue: [pi perform: sel with: aString]! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:12'!load	self installScript! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:12'!unload	self installScript: nil! !!MCScriptDefinition methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithScript: aString packageName: packageString	script := aString.	packageName := packageString! !!MCScriptDefinition methodsFor: 'testing' stamp: 'bf 8/12/2009 22:55'!isScriptDefinition	^true! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'bf 4/4/2005 12:20'!from: aPackageInfo	^ self script: (aPackageInfo perform: self scriptSelector) contents asString packageName: aPackageInfo name! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:00'!scriptSelector	self subclassResponsibility! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:24'!scriptSelector: selectorString script: aString packageName: packageString	^ (self subclassForScriptSelector: selectorString)		script: aString packageName: packageString! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:59'!script: aString packageName: packageString	^ self instanceLike: (self new initializeWithScript: aString packageName: packageString)! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:25'!subclassForScriptSelector: selectorString	^self allSubclasses detect: [:ea | ea scriptSelector = selectorString]! !!MCScriptParser methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:13'!addDefinitionsTo: aCollection	| tokens  definition |	tokens := Scanner new scanTokens: source.	definition := MCScriptDefinition		scriptSelector: tokens second allButLast		script: tokens third		packageName: tokens first third.	aCollection add: definition.! !!MCScriptParser class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:07'!pattern	^'(PackageInfo named: *'! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:46'!allFileNames	^self allFullFileNames collect: [ :ea | self directory localNameFor: ea ]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!allFullFileNames	| cachedPackages |	cachedPackages := smCache map installedPackages select: [ :ea | ea isCached ].	^Array streamContents: [ :s |		cachedPackages do: [ :ea | | d |			d := ea cacheDirectory.			(d fileNamesMatching: '*.mcz') do: [ :fn | s nextPut: (d fullNameFor: fn) ]]]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40'!description	^ smCache directory pathName! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40'!directory	^ smCache directory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40'!directory: aDirectory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:55'!fullNameFor: aFileName	^self allFullFileNames detect: [ :ffn | (self directory localNameFor: ffn) = aFileName ] ifNone: []! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:37'!smCache	^smCache! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:45'!smCache: aSMFileCache	| |	smCache := aSMFileCache.	self directory: aSMFileCache directory.! !!MCSMCacheRepository methodsFor: 'comparing' stamp: 'nk 1/23/2004 09:55'!hash	^ smCache hash! !!MCSMCacheRepository methodsFor: 'initialize-release' stamp: 'ar 1/3/2010 14:22'!initialize	super initialize.	Smalltalk at: #SMSqueakMap ifPresent:[:aClass|		smCache := aClass default cache.	].! !!MCSMCacheRepository methodsFor: 'testing' stamp: 'nk 1/23/2004 09:47'!isValid	^smCache notNil and: [ self directory exists ]! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'stephaneducasse 2/4/2006 20:47'!readStreamForFileNamed: aString do: aBlock	| file fileName |	fileName := self fullNameFor: aString.	fileName ifNil: [		"assume that this will come from the cache."		^MCCacheRepository default readStreamForFileNamed: aString do: aBlock ].	file := FileStream readOnlyFileNamed: fileName.	^[ aBlock value: file ] ensure: [ file close ].! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'nk 1/23/2004 09:57'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	"Can't write into the SM cache, so..."	^MCCacheRepository default writeStreamForFileNamed: aString replace: aBoolean do: aBlock! !!MCSMCacheRepository commentStamp: 'nk 1/23/2004 09:57' prior: 0!I am a Monticello repository that reflects the caching of SqueakMap v2.I refer write attempts to the default MCCacheRepository.!!MCSMCacheRepository class methodsFor: 'instance creation' stamp: 'nk 1/23/2004 10:04'!description	^ 'SqueakMap Cache'! !!MCSMCacheRepository class methodsFor: 'instance creation' stamp: 'nk 1/23/2004 10:05'!morphicConfigure	^self new! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!basicStoreVersion: aVersion	| url |	url := self uploadVersion: aVersion.	self releaseVersion: aVersion url: url! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:11'!checkResult: resultString(#( 'HTTP/1.1 201 ' 'HTTP/1.1 200 ' 'HTTP/1.0 201 ' 'HTTP/1.0 200 ')		anySatisfy: [:code | resultString beginsWith: code ])			ifFalse: [self error: resultString].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15'!description	^ 'sm://', packageName! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithPackage: packageString user: userString password: passString	packageName := packageString.	user := userString.	password := passString.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!releaseVersion: aVersion url: urlString	| result |	result := HTTPSocket		httpPost: self squeakMapUrl, '/packagebyname/', packageName, '/newrelease'		args: {'version' -> {(aVersion info name copyAfter: $.) extractNumber asString}.			   'note' -> {aVersion info message}.			   'downloadURL' -> {urlString}}		user: user		passwd: password.	result contents size > 4 ifTrue: [self error: result contents]! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:58'!squeakMapUrl 	^ 'http://localhost:9070/sm'! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!stringForVersion: aVersion	| stream |	stream := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: stream.	^ stream contents! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!uploadVersion: aVersion	| result stream |	result := HTTPSocket		httpPut: (self stringForVersion: aVersion)		to: self squeakMapUrl, '/upload/', aVersion fileName		user: user		passwd: password.	self checkResult: result.	stream := result readStream.	stream upToAll: 'http://'.	^ 'http://', stream upToEnd! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15'!creationTemplate	^'MCSMReleaseRepository	package: ''mypackage''	user: ''squeak''	password: ''squeak'''	! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 13:42'!description	^ 'SqueakMap Release'! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03'!fillInTheBlankRequest	^  'SqueakMap Release Repository:'		! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:14'!package: packageString user: userString password: passString	^ self basicNew initializeWithPackage: packageString user: userString password: passString! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:21'!basicStoreVersion: aVersion	MailSender sendMessage: (self messageForVersion: aVersion)! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:11'!bodyForVersion: aVersion	^ String streamContents:		[ :s |		s nextPutAll: 'from version info:'; cr; cr.		s nextPutAll:  aVersion info summary]! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56'!description	^ 'mailto://', email! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!emailAddress: aString	email := aString	! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!messageForVersion: aVersion	| message data |	message := MailMessage empty.	message setField: 'from' toString: MailSender userName.	message setField: 'to' toString: email.	message setField: 'subject' toString: (self subjectForVersion: aVersion). 	message body:		(MIMEDocument			contentType: 'text/plain'			content: (self bodyForVersion: aVersion)).	"Prepare the gzipped data"	data := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: data.	message addAttachmentFrom: data reset withName: aVersion fileName.	^ message! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:14'!subjectForVersion: aVersion	^ '[Package] ', aVersion info name! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56'!description	^ 'SMTP'! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!morphicConfigure	| address |	address := FillInTheBlankMorph request: 'Email address:'.	^ address isEmpty ifFalse: [self new emailAddress: address]! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 12/4/2002 18:09'!definitions	^ definitions! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05'!hash	^ definitions asArray hash! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05'!= other	^ definitions asArray = other definitions asArray! !!MCSnapshot methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithDefinitions: aCollection	definitions := aCollection.! !!MCSnapshot methodsFor: 'loading' stamp: 'ab 7/6/2003 23:31'!install	MCPackageLoader installSnapshot: self! !!MCSnapshot methodsFor: 'loading' stamp: 'ab 7/7/2003 12:11'!updatePackage: aPackage	MCPackageLoader updatePackage: aPackage withSnapshot: self! !!MCSnapshot methodsFor: 'patching' stamp: 'ab 7/7/2003 00:37'!patchRelativeToBase: aSnapshot	^ MCPatch fromBase: aSnapshot target: self! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:48'!empty	^ self fromDefinitions: #()! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:48'!fromDefinitions: aCollection	^ self new initializeWithDefinitions: aCollection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07'!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'cwp 7/10/2003 20:23'!extensionClassNames	^ (self allClassNames difference: self packageClassNames) asSortedCollection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:41'!extensionsCategory	^ '*Extensions'! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nice 1/1/2010 21:51'!methodsForSelectedClass	^ items select: [:ea | (ea className = classSelection) 									and: [ea isMethodDefinition									and: [ea classIsMeta = self switchIsClass]]].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nice 1/1/2010 21:51'!methodsForSelectedClassCategory	| visibleClasses |	visibleClasses := self visibleClasses.	^ items select: [:ea | (visibleClasses includes: ea className) 									and: [ea isMethodDefinition									and: [ea classIsMeta = self switchIsClass]]].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!methodsForSelectedProtocol	| methods |	protocolSelection ifNil: [^ Array new].	methods := self methodsForSelectedClass asOrderedCollection.	(protocolSelection = '-- all --') 		ifFalse: [methods removeAllSuchThat: [:ea | ea category ~= protocolSelection]].	^ methods 									! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/18/2003 15:48'!packageClasses	^ items select: [:ea | ea isClassDefinition]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/18/2003 15:48'!packageClassNames	^ self packageClasses collect: [:ea | ea className]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:53'!selectedClass	classSelection ifNil: [ ^nil ].	^Smalltalk at: classSelection ifAbsent: [ nil ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!selectedClassOrMetaClass	| class |	classSelection ifNil: [ ^nil ].	class := Smalltalk at: classSelection ifAbsent: [ ^nil ].	^self switchIsClass ifTrue: [ class class ]		ifFalse: [ class ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:29'!selectedMessageCategoryName	^protocolSelection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:45'!selectedMessageName	^methodSelection ifNotNil: [^ methodSelection selector ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!snapshot: aSnapshot	items := aSnapshot definitions asSortedCollection.	self categorySelection: 0.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:40'!annotations	methodSelection ifNotNil: [^ methodSelection annotations ].	^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:41'!annotations: stuff	self changed: #annotations! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'ab 7/18/2003 15:48'!classCommentString	^ (items 		detect: [:ea | ea isClassDefinition and: [ea className = classSelection]]		ifNone: [^ '']) comment.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'stephaneducasse 2/4/2006 20:47'!classDefinitionString	| defs |	defs := items select: [:ea | (ea isClassDefinition or: [ea isClassDefinitionExtension])			and: [ea className = classSelection]].	defs isEmpty ifTrue: [^ 'This class is defined elsewhere.'].	^ String streamContents: [:stream | 		defs asArray sort 			do: [:ea | ea printDefinitionOn: stream]			separatedBy: [stream nextPut: $.; cr]	].! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'tfel 8/28/2009 20:42'!scriptDefinitionString	| defs |	defs := items select: [:ea | ea isScriptDefinition].	defs isEmpty ifTrue: [^'(package defines no scripts)'].		^ String streamContents: [:stream | 		defs asArray sort 			do: [:ea | stream nextPutAll: '---------- package ';					nextPutAll: ea scriptSelector;					nextPutAll: ' ----------'; cr;					nextPutAll: ea script; cr]			separatedBy: [stream cr]].! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'bf 8/12/2009 23:00'!text	self switchIsComment ifTrue: [^ self classCommentString].	methodSelection ifNotNil: [^ methodSelection source].	protocolSelection ifNotNil: [^ ''].	classSelection ifNotNil: [^ self classDefinitionString].	categorySelection ifNil: [^self scriptDefinitionString].	^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'cwp 7/11/2003 00:30'!text: aTextOrString	self changed: #text! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:33'!buttonSpecs	^ #(('instance' switchBeInstance 'show instance' buttonEnabled switchIsInstance)		('?' switchBeComment 'show comment' buttonEnabled switchIsComment)		('class' switchBeClass 'show class' buttonEnabled switchIsClass))! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:29'!defaultExtent	^ 650@400.! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31'!defaultLabel	^ 'Snapshot Browser'! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'kb 2/24/2010 21:48'!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((codePane: text) (0 0.4 1 1))		) ].	^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((textMorph: annotations) (0 0.4 1 0.4) (0 0 0 30))		((codePane: text) (0 0.4 1 1) (0 30 0 0))		)! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 18:33'!categoryList	^ self visibleCategories! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 20:20'!classList	^ self visibleClasses! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/13/2003 02:11'!methodList	^ self visibleMethods collect: [:ea | ea selector]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:07'!protocolList	^ self visibleProtocols! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'ab 7/18/2003 15:48'!visibleCategories	^ (self packageClasses collect: [:ea | ea category]) 			asSet asSortedCollection add: self extensionsCategory; yourself.! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'ab 7/18/2003 15:48'!visibleClasses	^ categorySelection = self extensionsCategory		ifTrue: [self extensionClassNames]		ifFalse: [self packageClasses					select: [:ea | ea category = categorySelection]					thenCollect: [:ea | ea className]].! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:46'!visibleMethods	^ classSelection 		ifNil: [#()]		ifNotNil: [self methodsForSelectedProtocol]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'stephaneducasse 2/4/2006 20:47'!visibleProtocols	| methods protocols |	self switchIsComment ifTrue: [^ Array new].	methods := self methodsForSelectedClass.	protocols := (methods collect: [:ea | ea category]) asSet asSortedCollection.	(protocols size > 1) ifTrue: [protocols add: '-- all --'].	^ protocols ! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:52'!categoryListMenu: aMenu 	categorySelection		ifNotNil: [aMenu				add: (categorySelection = '*Extensions'						ifTrue: ['load all extension methods' translated]						ifFalse: ['load class category {1}' translated format: {categorySelection}])				action: #loadCategorySelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 6/12/2004 14:01'!classListMenu: aMenu 	classSelection ifNil: [ ^aMenu ].	super classListMenu: aMenu.	aMenu		addLine;				add: ('load class {1}' translated format: {classSelection})				action: #loadClassSelection.	^ aMenu! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'cwp 7/10/2003 18:03'!inspectSelection	^ self methodSelection inspect! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:53'!loadCategorySelection	"Load the entire selected category"	categorySelection ifNil: [ ^self ].	self methodsForSelectedClassCategory do: [ :m | m load ].! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/30/2004 15:06'!loadClassSelection	classSelection ifNil: [ ^self ].	(self packageClasses detect: [ :ea | ea className = classSelection ] ifNone: [ ^self ]) load.	self methodsForSelectedClass do: [ :m | m load ].! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:45'!loadMethodSelection	methodSelection ifNil: [ ^self ].	methodSelection load.! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:46'!loadProtocolSelection	protocolSelection ifNil: [ ^self ].	self methodsForSelectedProtocol do: [ :m | m load ].! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'ul 12/12/2009 14:09'!methodListMenu: aMenu 	super methodListMenu: aMenu.	self selectedMessageName		ifNotNil: [:msgName | aMenu addLine; add: 'load method' translated action: #loadMethodSelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:43'!protocolListMenu: aMenu 	protocolSelection		ifNotNil: [aMenu				add: ('load protocol ''{1}''' translated format: {protocolSelection})				action: #loadProtocolSelection ].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:33'!categorySelection	^ categorySelection ifNil: [0] ifNotNil: [self visibleCategories indexOf: categorySelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!categorySelection: aNumber	categorySelection := aNumber = 0 ifFalse: [self visibleCategories at: aNumber].	self classSelection: 0.	self changed: #categorySelection;		changed: #annotations;		changed: #classList.! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:28'!classSelection	^ classSelection ifNil: [0] ifNotNil: [self visibleClasses indexOf: classSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!classSelection: aNumber	classSelection := aNumber = 0 ifFalse: [self visibleClasses at: aNumber].	self protocolSelection: 0.	self changed: #classSelection; 		changed: #protocolList;		changed: #annotations;		changed: #methodList.! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 20:26'!methodSelection	^ methodSelection			ifNil: [0] 			ifNotNil: [self visibleMethods indexOf: methodSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!methodSelection: aNumber	methodSelection := aNumber = 0 ifFalse: [self visibleMethods at: aNumber].	self changed: #methodSelection; changed: #text; changed: #annotations! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 19:35'!protocolSelection	^ protocolSelection 		ifNil: [0]		ifNotNil: [self visibleProtocols indexOf: protocolSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47'!protocolSelection: anInteger	protocolSelection := (anInteger = 0 ifFalse: [self visibleProtocols at: anInteger]).	self methodSelection: 0.	self changed: #protocolSelection;		changed: #methodList;			changed: #annotations! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:57'!signalSwitchChanged	self protocolSelection: 0.	self 		changed: #switchIsInstance;		changed: #switchIsComment;		changed: #switchIsClass;		changed: #protocolList;		changed: #methodList;		changed: #text.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47'!switchBeClass	switch := #class.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47'!switchBeComment	switch := #comment.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47'!switchBeInstance	switch := #instance.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:05'!switchIsClass	^ switch = #class! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:04'!switchIsComment	^ switch = #comment.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47'!switchIsInstance	switch ifNil: [switch := #instance].	^ switch = #instance.! !!MCSnapshotBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:03'!forSnapshot: aSnapshot	^ self new snapshot: aSnapshot! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 23:09'!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 23:10'!snapshot	^ MCSnapshot fromDefinitions: self definitions! !!MCSnapshotReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 22:56'!snapshotFromStream: aStream	^ (self on: aStream) snapshot! !!MCSnapshotTest methodsFor: '*monticello-mocks' stamp: 'ab 7/7/2003 23:21'!mockClassExtension! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!addDefinitionsFromDoit: aString	(MCDoItParser forDoit: aString) ifNotNil:		[:parser |		parser addDefinitionsTo: definitions]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!categoryFromDoIt: aString	| tokens  |	tokens := Scanner new scanTokens: aString.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!classDefinitionFrom: aPseudoClass	| tokens traitCompositionString lastIndex classTraitCompositionString |	tokens := Scanner new scanTokens: aPseudoClass definition.	traitCompositionString := ((ReadStream on: aPseudoClass definition)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	classTraitCompositionString := ((ReadStream on: aPseudoClass metaClass definition asString)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	traitCompositionString isEmpty ifTrue: [traitCompositionString := '{}'].	classTraitCompositionString isEmpty ifTrue: [classTraitCompositionString := '{}'].	lastIndex := tokens size.	^ MCClassDefinition		name: (tokens at: 3)		superclassName: (tokens at: 1)		traitComposition: traitCompositionString		classTraitComposition: classTraitCompositionString		category: (tokens at: lastIndex)		instVarNames: ((tokens at: lastIndex - 6) findTokens: ' ')		classVarNames: ((tokens at: lastIndex - 4) findTokens: ' ')		poolDictionaryNames: ((tokens at: lastIndex - 2) findTokens: ' ')		classInstVarNames: (self classInstVarNamesFor: aPseudoClass)		type: (self typeOfSubclass: (tokens at: 2))		comment: (self commentFor: aPseudoClass)		commentStamp: (self commentStampFor: aPseudoClass)! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!classInstVarNamesFor: aPseudoClass	| tokens |		self flag: #traits.	aPseudoClass metaClass hasDefinition ifFalse: [^ #()].	tokens := Scanner new scanTokens: aPseudoClass metaClass definition.	"tokens size = 4 ifFalse: [self error: 'Unrecognized metaclass definition']."	^ tokens last findTokens: ' '! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!commentFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^ comment asString = ''		ifTrue: [comment]		ifFalse: [comment string]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!commentStampFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^  [comment stamp] on: MessageNotUnderstood do: [nil]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 3/3/2004 15:23'!methodDefinitionsFor: aPseudoClass	^ aPseudoClass selectors collect: 		[:ea |		 MCMethodDefinition			className: aPseudoClass name			classIsMeta: aPseudoClass isMeta			selector: ea			category: (aPseudoClass organization categoryOfElement: ea)			timeStamp: (aPseudoClass stampAt: ea)			source: (aPseudoClass sourceCodeAt: ea)]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!systemOrganizationFromRecords: changeRecords	| categories |	categories := changeRecords					select: [:ea | 'SystemOrganization*' match: ea string]					thenCollect: [:ea | (self categoryFromDoIt: ea string)].	^ categories isEmpty ifFalse: [MCOrganizationDefinition categories: categories asArray]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 21:56'!typeOfSubclass: aSymbol	#(		(subclass: normal)		(variableSubclass: variable)		(variableByteSubclass: bytes)		(variableWordSubclass: words)		(weakSubclass: weak)		) do: [:ea | ea first = aSymbol ifTrue: [^ ea second]].	self error: 'Unrecognized class definition'! !!MCStReader methodsFor: 'evaluating' stamp: 'stephaneducasse 2/4/2006 20:47'!loadDefinitions	| filePackage |	filePackage :=		FilePackage new			fullName: 'ReadStream';			fileInFrom: self readStream.	definitions := OrderedCollection new.	filePackage classes do:		[:pseudoClass |		pseudoClass hasDefinition			ifTrue: [definitions add:					(self classDefinitionFrom: pseudoClass)].		definitions addAll: (self methodDefinitionsFor: pseudoClass).		definitions addAll: (self methodDefinitionsFor: pseudoClass metaClass)].	filePackage doIts do:		[:ea |		self addDefinitionsFromDoit: ea string].	! !!MCStReader methodsFor: 'evaluating' stamp: 'avi 1/21/2004 14:21'!readStream	^ ('!!!!', stream contents) readStream! !!MCStReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:17'!extension	^ 'st'! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:34'!chunkContents: aBlock	stream cr; nextChunkPut: (String streamContents: aBlock); cr! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 01:46'!writeCategory: categoryName	stream		nextChunkPut: 'SystemOrganization addCategory: ', categoryName printString;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'ab 8/17/2003 17:09'!writeClassComment: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition className;		nextPutAll: ' commentStamp: ';		store: definition commentStamp;		nextPutAll: ' prior: 0!!';		cr;		nextChunkPut: definition comment;		cr.! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:16'!writeClassDefinition: definition	self chunkContents: [:s | definition printDefinitionOn: stream]! !!MCStWriter methodsFor: 'writing' stamp: 'dvf 9/8/2004 10:28'!writeDefinitions: aCollection	"initStream is an ugly hack until we have proper init defs"	initStream := String new writeStream.	(MCDependencySorter sortItems: aCollection)		do: [:ea | ea accept: self]		displayingProgress: 'Writing definitions...'.		stream nextPutAll: initStream contents.! !!MCStWriter methodsFor: 'writing' stamp: 'al 12/2/2005 15:17'!writeMetaclassDefinition: definition	self chunkContents: [:str |		str	nextPutAll: definition className;			nextPutAll: ' class';			cr; tab.			definition hasClassTraitComposition ifTrue: [				str	nextPutAll: 'uses: ';					nextPutAll: definition classTraitCompositionString;					cr; tab].			str	nextPutAll: 'instanceVariableNames: ''';				nextPutAll: definition classInstanceVariablesString;				nextPut: $']! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:24'!writeMethodInitializer: aMethodDefinition	aMethodDefinition isInitializer ifTrue:		[initStream nextChunkPut: aMethodDefinition className, ' initialize'; cr]! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 12:43'!writeMethodPostscript	stream		space;		nextPut: $!!;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'avi 9/23/2003 17:42'!writeMethodPreamble: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition fullClassName;		nextPutAll: ' methodsFor: ';		nextPutAll: definition category asString printString;		nextPutAll: ' stamp: ';		nextPutAll: definition timeStamp asString printString;		nextPutAll: '!!';		cr! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/4/2003 01:35'!writeMethodSource: definition	stream nextChunkPut: definition source! !!MCStWriter methodsFor: 'writing' stamp: 'bf 8/13/2009 00:21'!writeScriptDefinition: definition	stream nextChunkPut: (		'(PackageInfo named: {1}) {2}: {3}'		format: {			"{1}" definition packageName printString.			"{2}" definition scriptSelector. 			"{3}" definition script printString		}); cr! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:25'!writeSnapshot: aSnapshot	self writeDefinitions: aSnapshot definitions! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02'!visitClassDefinition: definition	self writeClassDefinition: definition.	definition hasClassInstanceVariables ifTrue: [self writeMetaclassDefinition: definition].	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:52'!visitClassTraitDefinition: definition	self chunkContents: [:s | s		nextPutAll: definition baseTrait;		nextPutAll: ' classTrait';		cr; tab;		nextPutAll: 'uses: ';		nextPutAll: (definition classTraitComposition ifNil: ['{}'])]! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40'!visitMetaclassDefinition: definition	self writeMetaclassDefinition: definition! !!MCStWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 02:23'!visitMethodDefinition: definition	self writeMethodPreamble: definition.	self writeMethodSource: definition.	self writeMethodPostscript.	self writeMethodInitializer: definition.! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02'!visitOrganizationDefinition: defintion	defintion categories do: [:cat | self writeCategory: cat].! !!MCStWriter methodsFor: 'visiting' stamp: 'bf 8/12/2009 21:41'!visitScriptDefinition: definition	self writeScriptDefinition: definition! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40'!visitTraitDefinition: definition	self writeClassDefinition: definition.	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:16'!readerClass	^ MCStReader! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 18:55'!allDirectories	| remaining dir dirs |	remaining := OrderedCollection new.	dirs := OrderedCollection new.	remaining addLast: directory.	[remaining isEmpty]		whileFalse: [dir := remaining removeFirst.			dirs add: dir.			dir entries				do: [:ent | ent isDirectory						ifTrue: [remaining								addLast: (dir directoryNamed: ent name)]]].	^ dirs! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 20:25'!allFileNames	"sorting {entry. dirName. name}"	| sorted |	sorted := SortedCollection sortBlock: [:a :b |		a first modificationTime >= b first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [sorted add: {ent. dir fullName. ent name}]]].	^ sorted		collect: [:ea | ea third ]! !!MCSubDirectoryRepository methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:23'!description	^ directory pathName, '/*'! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!findFullNameForReading: aBaseName	"Answer the latest version of aBaseName"	| possible |	possible := SortedCollection sortBlock: [ :a :b | b first modificationTime < a first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [							(ent name = aBaseName) ifTrue: [ possible add: {ent. dir fullNameFor: ent name}]]]].	^(possible at: 1 ifAbsent: [ ^nil ]) second! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!findFullNameForWriting: aBaseName	| possible split prefix fpattern now |	split := directory splitNameVersionExtensionFor: aBaseName.	fpattern := split first, '*'.	possible := SortedCollection sortBlock: [ :a :b |		a first = b first			ifTrue: [ a second = b second					ifFalse: [ a second < b second ]					ifTrue: [ a third fullName size < b third fullName size ]]			ifFalse: [ a first > b first ] ].	now := Time totalSeconds.	prefix := directory pathParts size.	self allDirectories do: [:dir | | parts dirScore fileScore |		parts := dir pathParts allButFirst: prefix.		dirScore := (parts select: [ :part | fpattern match: part ]) size.		fileScore := (dir entries collect: [ :ent |			(ent isDirectory not and: [ fpattern match: ent name ])				ifFalse: [ SmallInteger maxVal ]				ifTrue: [ now - ent modificationTime ]]).	"minimum age"		fileScore := fileScore isEmpty ifTrue: [ SmallInteger maxVal  ]			ifFalse: [ fileScore min ].		possible add: { dirScore. fileScore. dir } ].	^ (possible first third) fullNameFor: aBaseName! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (self findFullNameForReading: aString).	val := aBlock value: file.	file close.	^ val! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 6/11/2004 20:34'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock 	| file |	file := aBoolean				ifTrue: [FileStream						forceNewFileNamed: (self findFullNameForReading: aString)]				ifFalse: [FileStream						newFileNamed: (self findFullNameForWriting: aString)].	aBlock value: file.	file close! !!MCSubDirectoryRepository commentStamp: 'nk 6/11/2004 18:56' prior: 0!A MCDirectoryRepository that looks in subdirectories too.!!MCSubDirectoryRepository class methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:48'!description	^ 'directory with subdirectories'! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addDefinitionsTo: aCollection	| definition |	definition := aCollection detect: [:ea | ea isOrganizationDefinition ] ifNone: [aCollection add: (MCOrganizationDefinition categories: #())].	definition categories: (definition categories copyWith: self category).! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!category	| tokens  |	tokens := Scanner new scanTokens: source.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCSystemCategoryParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:41'!pattern	^ 'SystemOrganization*'! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:18'!addBaseSnapshot: aSnapshot	aSnapshot definitions do:		[:ea |		index add: ea.		provisions addAll: ea provisions]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!addDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other |			(self removalForDefinition: aDefinition)				ifNotNil:					[:op |					self addOperation: (MCModification of: other to: aDefinition).					self removeOperation: op.					^ self].			other = aDefinition				ifFalse: [self addConflictWithOperation: (MCModification of: other to: aDefinition)]				ifTrue: [self redundantAdds add: aDefinition]]		ifAbsent: [self addOperation: (MCAddition of: aDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:30'!addOperation: anOperation	self operations add: anOperation! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:52'!applyPatch: aPatch	aPatch applyTo: self! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:32'!applyTo: anObject	super applyTo: anObject.	self operations do: [:ea | ea applyTo: anObject]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:49'!baseSnapshot	^ (MCSnapshot fromDefinitions: index definitions)! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	index := MCDefinitionIndex new.	provisions := Set new! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:22'!modificationConflictForDefinition: aDefinition	^ conflicts ifNotNil:		[conflicts detect:			[:ea | (ea definition isRevisionOf: aDefinition) and:				[ea operation isModification]] ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:34'!modifyDefinition: baseDefinition to: targetDefinition	index		definitionLike: baseDefinition		ifPresent: [:other | other = baseDefinition								ifTrue: [self addOperation: (MCModification of:  baseDefinition to: targetDefinition)]								ifFalse: [other = targetDefinition											ifFalse: [self addConflictWithOperation:														(MCModification of: other to: targetDefinition)]]]		ifAbsent: [self addConflictWithOperation: (MCAddition of: targetDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!operations	^ operations ifNil: [operations := OrderedCollection new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19'!provisions	^ provisions! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!redundantAdds	^ redundantAdds ifNil: [redundantAdds := Set new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40'!removalForDefinition: aDefinition	^ operations ifNotNil:		[operations			detect: [:ea | (ea definition isRevisionOf: aDefinition) and: [ea isRemoval]]			ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40'!removeConflict: aConflict	conflicts remove: aConflict! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!removeDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other | other = aDefinition								ifTrue:									[(self modificationConflictForDefinition: aDefinition)										ifNotNil:											[:c |											self addOperation: c operation.											self removeConflict: c.											^ self]. 									(self redundantAdds includes: aDefinition)										ifFalse: [self addOperation: (MCRemoval of: aDefinition)]]								ifFalse:									[self addConflictWithOperation: (MCRemoval of: other)]]		ifAbsent: []! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40'!removeOperation: anOperation	operations remove: anOperation! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:53'!base: aSnapshot patch: aPatch	aPatch isEmpty ifTrue: [MCNoChangesException signal].	^ self new		addBaseSnapshot: aSnapshot;		applyPatch: aPatch;		yourself		! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:09'!base: aSnapshot target: targetSnapshot ancestor: ancestorSnapshot	^ self base: aSnapshot patch: (targetSnapshot patchRelativeToBase: ancestorSnapshot)! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:52'!new	^ self basicNew initialize! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!answer: anObject	modalValue := anObject.	self close.! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50'!arrowKey: aCharacter from: aPluggableListMorph 	"backstop"! !!MCTool methodsFor: 'morphic ui' stamp: 'bp 8/9/2009 19:25'!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	self widgetSpecs do: [:spec |		| send fractions offsets |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		window			addMorph: (self perform: send first withArguments: send allButFirst)			fullFrame:				(LayoutFrame					fractions: 						((fractions first)@(fractions second) corner: 							(fractions third)@(fractions fourth))					offsets:						((offsets first)@(offsets second)  corner:							(offsets third)@(offsets fourth)))].	^ window! !!MCTool methodsFor: 'morphic ui' stamp: 'bp 4/2/2010 21:35'!buildWith: builder	|  windowBuilder |	windowBuilder := MCToolWindowBuilder builder: builder tool: self.	self widgetSpecs do:		[:spec | | send fractions offsets |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		windowBuilder frame: (LayoutFrame			fractions: (fractions first @ fractions second corner: fractions third @ fractions fourth)			offsets: (offsets first @ offsets second corner: offsets third @ offsets fourth)).		windowBuilder perform: send first withArguments: send allButFirst].	^ windowBuilder build! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:19'!buttonEnabled	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:34'!buttonRow	^ self buttonRow: self buttonSpecs! !!MCTool methodsFor: 'morphic ui' stamp: 'nice 12/27/2009 03:11'!buttonRow: specArray	| aRow |	aRow := AlignmentMorph newRow.	aRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [Color gray alpha: 0.2]);		borderWidth: 0.	aRow hResizing: #spaceFill; vResizing: #spaceFill; rubberBandCells: true.	aRow clipSubmorphs: true.	aRow layoutInset:2@2; cellInset: 1; color: Color white.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	specArray do:		[:triplet | | aButton state |			state := triplet at: 4 ifAbsent: [#buttonState].			aButton := PluggableButtonMorph				on: self				getState: state				action: #performButtonAction:enabled:.			aButton				hResizing: #spaceFill;				vResizing: #spaceFill;				label: triplet first asString;				arguments: (Array with: triplet second with: state); 				onColor: Color white offColor: Color white.			aRow addMorphBack: aButton.			aButton setBalloonText: triplet third].	^ aRow! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:22'!buttonSelected	^ false! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:23'!buttonSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:45'!buttonState	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:42'!close	self window delete! !!MCTool methodsFor: 'morphic ui' stamp: 'kb 2/24/2010 22:04'!codePane: aSymbol	| textMorph |	textMorph := PluggableTextMorphPlus 		on: self 		text: aSymbol 		accept: (aSymbol, ':') asSymbol.	textMorph useDefaultStyler.	^textMorph! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 7/24/2003 13:31'!defaultAnnotationPaneHeight 	"Answer the receiver's preferred default height for new annotation panes."	^ Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'tfel 2/27/2010 22:23'!defaultBackgroundColor 	^ Preferences monticelloToolWindowColor! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:22'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:10'!defaultExtent	^ 500@500! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:11'!defaultLabel	^ self class name! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:33'!fillMenu: aMenu fromSpecs: anArray	anArray do:		[:pair |		aMenu add: pair first target: self selector: pair second].	^ aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 3/16/2005 14:48'!findListMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getListSelector) and: [ea getListSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 8/24/2003 20:15'!findTextMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getTextSelector) and: [ea getTextSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:23'!getMenu: aMenu	^aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:36'!label	^ label ifNil: [self defaultLabel]! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!label: aString	label := aString! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 17:30'!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 17:03'!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46'!listMorph: listSymbol selection: selectionSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46'!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50'!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	^ (PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 9/11/2004 16:19'!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	^ PluggableListMorphOfMany		on: self		list: listSymbol		primarySelection: selectionSymbol		changePrimarySelection: (selectionSymbol, ':') asSymbol		listSelection: listSelectionSymbol		changeListSelection: (listSelectionSymbol, 'put:') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 10/5/2003 09:09'!performButtonAction: anActionSelector enabled: anEnabledSelector	(self perform: anEnabledSelector) 		ifTrue: [ self perform: anActionSelector ]! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:18'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCTool methodsFor: 'morphic ui' stamp: 'cmm 2/13/2010 20:35'!postAcceptBrowseFor: aModel	"Nothing to do."! !!MCTool methodsFor: 'morphic ui' stamp: 'cmm 2/14/2010 09:36'!representsSameBrowseeAs: anotherModel 	^ false! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!show	modal := false.	Smalltalk at: #ToolBuilder ifPresent: [:tb | tb open: self. ^ self].	^self window openInWorldExtent: self defaultExtent; yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!showLabelled: labelString	modal := false.	self label: labelString.	^(self window)		openInWorldExtent: self defaultExtent;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:39'!showModally	modal := true.	self window openInWorld.	[self window world notNil] whileTrue: [		self window outermostWorldMorph doOneCycle.	].	morph := nil.	^ modalValue! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 6/12/2004 14:11'!step! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:36'!textMorph: aSymbol	^ PluggableTextMorph on: self text: aSymbol accept: (aSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:27'!treeMorph: listSymbol	^ self		treeMorph: (listSymbol, 'Tree') asSymbol		selection: (listSymbol, 'SelectionWrapper') asSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:43'!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ SimpleHierarchicalListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol		keystroke: nil! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 3/6/2005 22:31'!treeOrListMorph: aSymbol	^ self treeMorph: aSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:40'!widgetSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!window	^ morph ifNil: [morph := self buildWindow]! !!MCTool class methodsFor: 'window color' stamp: 'tfel 2/27/2010 22:21'!windowColorSpecification	^ WindowColorSpec 		classSymbol: self name 		wording: 'Monticello Tool' 		brightColor:  (Color r: 0.627 g: 0.69 b: 0.976)		pastelColor: (Color r: 0.65 g: 0.753 b: 0.976) paler		helpMessage: 'A Tool Window for the Monticello VCS'! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:03'!build	^ builder build: window! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04'!buttonRow	^ self buttonRow: tool buttonSpecs! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!buttonRow: specArray	| panel |	panel := builder pluggablePanelSpec new.	panel children: OrderedCollection new.	specArray do:		[:spec | | button |				button := builder pluggableButtonSpec new.		button model: tool.		button label: spec first asString.		button action: spec second.		button help: spec third.		button enabled: (spec at: 4 ifAbsent: [#buttonEnabled]).		button state: (spec at: 5 ifAbsent: [#buttonSelected]).		panel children add: button].	panel layout: #horizontal.	panel frame: currentFrame.	window children add: panel! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kb 2/24/2010 19:39'!codePane: aSymbol	| text |	text := builder pluggableCodePaneSpec new.	text 		model: tool;		getText: aSymbol; 		setText: (aSymbol, ':') asSymbol;		frame: currentFrame.	window children add: text! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!frame: aLayoutFrame	currentFrame := aLayoutFrame! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithBuilder: aBuilder tool: aTool	builder := aBuilder.	tool := aTool.	window := builder pluggableWindowSpec new.	window children: OrderedCollection new.	window label: tool label asString.	window model: tool.	window extent: tool defaultExtent.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04'!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04'!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:15'!listMorph: listSymbol selection: selectionSymbol	self listMorph: listSymbol selection: selectionSymbol menu: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:16'!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	self listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:51'!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| list |	list := builder pluggableListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	keystrokeSymbol ifNotNil: [list keyPress: keystrokeSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52'!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	| list |	list := builder pluggableMultiSelectionListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		getSelectionList: listSelectionSymbol;		setSelectionList: (listSelectionSymbol, 'put:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52'!textMorph: aSymbol	| text |	text := builder pluggableTextSpec new.	text 		model: tool;		getText: aSymbol; 		setText: (aSymbol, ':') asSymbol;		frame: currentFrame.	window children add: text! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:05'!treeMorph: listSymbol	^ self		treeMorph: (listSymbol, 'Tree') asSymbol		selection: (listSymbol, 'SelectionWrapper') asSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52'!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	self notYetImplemented! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 3/6/2005 22:31'!treeOrListMorph: listSymbol	^ self listMorph: listSymbol! !!MCToolWindowBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:02'!builder: aBuilder tool: aTool	^ self basicNew initializeWithBuilder: aBuilder tool: aTool! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 20:28'!accept: aVisitor	^ aVisitor visitTraitDefinition: self! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'ar 12/27/2009 19:07'!createClass	^ClassDescription		newTraitNamed: name		uses: (Compiler evaluate: self traitCompositionString)		category: category		! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'nice 10/31/2009 13:10'!= aDefinition	self flag: #traits. "Ugly we harcoded the super superclass method.  We will have to refactor the definition hierarchy"		^ (aDefinition isKindOf: MCDefinition)		and: [(self isRevisionOf: aDefinition)		and: [self traitCompositionString = aDefinition traitCompositionString		and: [category = aDefinition category		and: [comment = aDefinition comment]]]]! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 6/5/2006 14:05'!classTraitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:29'!traitComposition	^traitComposition! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:28'!hasClassInstanceVariables	^ false! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 6/5/2006 14:13'!hasTraitComposition	^self traitCompositionString ~= '{}'! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'ul 11/2/2009 04:55'!hash	| hash |	hash := name hashWithInitialHash: 0.	hash := self traitCompositionString hashWithInitialHash: hash.	hash := (category ifNil: ['']) hashWithInitialHash: hash.	^hash! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'al 6/5/2006 14:13'!requirements	"Assuming that traits in a composition can be identified by	testing for the first character beeing an uppercase character	(and thus not a special character such as {, # etc.)"	| tokens traitNames |	self hasTraitComposition ifFalse: [ ^Array new ].	tokens := Scanner new scanTokens: self traitComposition.	traitNames := tokens select: [:each | each first isUppercase].	^traitNames asArray! !!MCTraitDefinition methodsFor: 'initializing' stamp: 'al 6/5/2006 14:14'!initializeWithName: classNameString 	traitComposition:  traitCompositionString	category:  categoryString	comment:  commentString  	commentStamp:   commentStampString							name := classNameString asSymbol.		traitComposition := traitCompositionString.	     category := categoryString.		comment := commentString withSqueakLineEndings.		commentStamp :=  commentStampString ifNil: [self defaultCommentStamp]! !!MCTraitDefinition methodsFor: 'installing' stamp: 'ul 12/12/2009 14:09'!load	 self createClass ifNotNil: [:trait |		self hasComment ifTrue: [trait classComment: comment stamp: commentStamp]]! !!MCTraitDefinition methodsFor: 'printing' stamp: 'al 6/5/2006 14:15'!printDefinitionOn: stream	stream nextPutAll: 'Trait named: #', self className;		 cr;		 tab;		 nextPutAll: 'uses: ';		 nextPutAll: self traitCompositionString;		 cr;		 tab;		 nextPutAll: 'category: ';		 store: self category asString! !!MCTraitDefinition class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:28'!name: classNameString traitComposition:  traitCompositionString category:  categoryString comment:  commentString commentStamp:   commentStamp	^ self instanceLike:		(self new initializeWithName: classNameString 			traitComposition:  traitCompositionString			category:  categoryString			comment:  commentString  			commentStamp:   commentStamp)! !!MCTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToAll: 'category:') withBlanksTrimmed.	definition := MCTraitDefinition		name: (tokens at: 3) 		traitComposition: traitCompositionString		category:  tokens last		comment:  ''  		commentStamp:   ''.	aCollection add: definition.! !!MCTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 21:09'!pattern	^ 'Trait named:*'! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02'!hash	^ name hash! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02'!= other	^ (self species = other species)		and: [self name = other name]! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31'!isClassInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:08'!isClassInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:30'!isClassVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31'!isInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:10'!isInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^true! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51'!isPoolImport	^ false! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 05:57'!name	^ name! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!name: aString	name := aString! !!MCVariableDefinition methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 14:56'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!MCVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:18'!name: aString	^ self new name: aString	! !!MCVersion methodsFor: 'actions' stamp: 'avi 10/9/2003 13:00'!addToCache	MCCacheRepository default storeVersion: self! !!MCVersion methodsFor: 'actions' stamp: 'avi 2/12/2004 19:37'!adopt	self workingCopy adopt: self! !!MCVersion methodsFor: 'actions' stamp: 'kb 2/24/2010 19:40'!browse	(MCSnapshotBrowser forSnapshot: self snapshot)		label: 'Snapshot of ', self fileName;		show! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/22/2004 12:44'!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/24/2004 20:13'!load	MCVersionLoader loadVersion: self! !!MCVersion methodsFor: 'actions' stamp: 'abc 2/13/2004 15:58'!merge	MCVersionMerger mergeVersion: self! !!MCVersion methodsFor: 'actions' stamp: 'ab 7/12/2003 00:19'!open	(MCVersionInspector new version: self) show! !!MCVersion methodsFor: 'enumerating' stamp: 'nice 12/27/2009 20:59'!allAvailableDependenciesDo: aBlock		self dependencies do:		[:ea |		[ | version |		version := ea resolve.		version allAvailableDependenciesDo: aBlock.		aBlock value: version]			on: Error do: []]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 11:58'!allDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored | true]! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47'!allDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock! !!MCVersion methodsFor: 'enumerating' stamp: 'nice 12/27/2009 03:11'!allDependenciesNotIn: aDictionary do: aBlock ifUnresolved: failBlock		self dependencies do: 		[:ea | | version | 		version := aDictionary at: ea ifAbsent: [ea resolve].		version 			ifNil: [failBlock value: ea]			ifNotNil: [(aDictionary includes: version) ifFalse:						[aDictionary at: ea put: version.						version 							allDependenciesNotIn: aDictionary 							do: aBlock							ifUnresolved: failBlock.						aBlock value: version]]]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 14:24'!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored].	aBlock value: self! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47'!withAllDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock.	aBlock value: self! !!MCVersion methodsFor: 'converting' stamp: 'avi 2/19/2004 21:00'!asDiffAgainst: aVersion	aVersion info = self info ifTrue: [self error: 'Cannot diff against self!!'].	^ MCDiffyVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies		baseVersion: aVersion! !!MCVersion methodsFor: 'testing' stamp: 'bf 5/23/2005 15:43'!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^false! !!MCVersion methodsFor: 'testing' stamp: 'bf 3/22/2005 23:00'!isCacheable	^true! !!MCVersion methodsFor: 'testing' stamp: 'avi 2/13/2004 23:24'!isDiffy	^ false! !!MCVersion methodsFor: 'accessing' stamp: 'avi 2/13/2004 22:42'!changes	^ self snapshot patchRelativeToBase: package snapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 00:24'!dependencies	^ dependencies ifNil: [#()]! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44'!fileName	^ info name, '.', self writerClass extension! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:28'!info	^ info! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:19'!package	^ package! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:10'!snapshot	^ snapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:07'!summary	^ String streamContents:		[:s |		s nextPutAll: info summaryHeader.		(dependencies isNil or: [dependencies isEmpty]) ifFalse:			[s cr; nextPutAll: 'Dependencies: '.			dependencies				do: [:ea | s nextPutAll: ea versionInfo name]				separatedBy: [s nextPutAll: ', ']].		s cr; cr; nextPutAll: info message]! !!MCVersion methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38'!workingCopy	^ package workingCopy! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44'!writerClass	^ MCMczWriter ! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection.	self addToCache.! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!setPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection! !!MCVersion methodsFor: 'printing' stamp: 'nk 3/8/2004 23:54'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self info name.	aStream nextPut: $).! !!MCVersion class methodsFor: 'instance creation' stamp: 'ab 7/7/2003 16:13'!package: aPackage	^ self package: aPackage info: MCVersionInfo new! !!MCVersion class methodsFor: 'instance creation' stamp: 'ab 7/7/2003 16:13'!package: aPackage info: aVersionInfo	^ self package: aPackage info: aVersionInfo snapshot: aPackage snapshot! !!MCVersion class methodsFor: 'instance creation' stamp: 'cwp 11/7/2004 13:02'!package: aPackage info: aVersionInfo snapshot: aSnapshot	^ self package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: #()! !!MCVersion class methodsFor: 'instance creation' stamp: 'avi 1/19/2004 13:11'!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	^ self new initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:06'!hash	^ versionInfo hash! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:12'!= other	^ other species = self species		and: [other versionInfo = versionInfo				and: [other package = package]]! !!MCVersionDependency methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithPackage: aPackage info: aVersionInfo	package := aPackage.	versionInfo := aVersionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29'!isCurrent	^ package hasWorkingCopy		and: [self isFulfilled			and: [package workingCopy modified not]]! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29'!isFulfilled	^package hasWorkingCopy		and: [self isFulfilledBy: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29'!isFulfilledByAncestors	^ package hasWorkingCopy		and: [self isFulfilledByAncestorsOf: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'nk 7/13/2004 08:45'!isFulfilledByAncestorsOf: anAncestry	^ anAncestry hasAncestor: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'avi 3/4/2004 00:34'!isFulfilledBy: anAncestry	^ anAncestry ancestors includes: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29'!isOlder	"Answer true if I represent an older version of a package that is loaded."	^ package hasWorkingCopy		and: [self isFulfilled not			and: [ self isFulfilledByAncestors				and: [package workingCopy modified not]]]! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40'!package	^ package! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38'!repositoryGroup	^ self package workingCopy repositoryGroup! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40'!versionInfo	^ versionInfo! !!MCVersionDependency methodsFor: 'resolving' stamp: 'nk 6/13/2004 19:21'!resolve	^ self repositoryGroup		versionWithInfo: versionInfo		ifNone: [ MCRepositoryGroup default versionWithInfo: versionInfo ifNone: []]! !!MCVersionDependency class methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 13:13'!package: aPackage info: aVersionInfo	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!ancestry: anAncestry	ancestry := anAncestry! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:10'!baseSnapshot	^ self snapshotForInfo: ancestry! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:41'!index	"Answer the value of index"	^ index! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!index: anObject	"Set the value of index"	index := anObject! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!infos	^ infos ifNil: [infos := ancestry withBreadthFirstAncestors]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:10'!list	^ self infos collect: [:ea | ea name]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!package: aMCPackage	package := aMCPackage! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/7/2003 21:27'!repositoryGroup	^ MCRepositoryGroup default! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:09'!selectedInfo	^ self infos at: self selection ifAbsent: [nil]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:39'!selectedSnapshot	^ self snapshotForInfo: self selectedInfo! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:24'!selection	^ index ifNil: [0]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!selection: aNumber	index := aNumber.	self changed: #selection; changed: #summary! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:38'!snapshotForInfo: aVersionInfo	^ (self repositoryGroup versionWithInfo: aVersionInfo) snapshot! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!summary	| selInfo |	selInfo := self selectedInfo.	^ selInfo 		ifNil: ['']		ifNotNil: [selInfo summary]! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:35'!defaultExtent	^ 650@300	! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09'!defaultLabel	^ ancestry name, ' History'! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09'!getMenu: aMenu	index < 2 ifTrue: [^ aMenu].	self fillMenu: aMenu fromSpecs: 		(Array			with: (Array with: 'view changes -> ', ancestry name with: #viewChanges)			with: #('spawn history' spawnHistory)).	^ aMenu! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:10'!spawnHistory	MCVersionHistoryBrowser new		ancestry: self selectedInfo;		package: package;		show! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!viewChanges	"Note that the patchLabel will be parsed in MCPatchBrowser>>installSelection, so don't translate it!!"	| patch patchLabel |	patchLabel := 'changes between {1} and {2}' format: { self selectedInfo name. ancestry name }.	patch := self baseSnapshot patchRelativeToBase: self selectedSnapshot.	(MCPatchBrowser forPatch: patch) label: patchLabel; show! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'nk 7/28/2003 18:05'!widgetSpecs	^ #(		((listMorph:selection:menu: list selection getMenu:) (0 0 0.3 1))		((textMorph: summary) (0.3 0 1 1))	 	)! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:09'!hash	^ id hash! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:23'!= other	^ other species = self species		and: [other hasID: id]! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25'!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26'!author	^ author! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26'!date	^ date! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:24'!id	^ id ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26'!time	^ time! !!MCVersionInfo methodsFor: 'private' stamp: 'ab 7/5/2003 14:10'!hasID: aUUID	^ id = aUUID! !!MCVersionInfo methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName.	id := aUUID.	message := aString.	date := aDate.	time := aTime.	author := initials.	ancestors :=  aCollection.	stepChildren := stepCollection! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/12/2003 00:04'!message	^ message ifNil: ['']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:33'!name	^ name ifNil: ['<working copy>']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:08'!summary	^ String streamContents:		[:s |		s			nextPutAll: self summaryHeader; cr; cr;			nextPutAll: self message.		]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 9/14/2004 15:22'!summaryHeader	^ String streamContents:		[:s |		s			nextPutAll: 'Name: '; nextPutAll: self name; cr.		date ifNotNil:			[s				nextPutAll: 'Author: '; nextPutAll: author; cr;				nextPutAll: 'Time: '; nextPutAll:  date asString, ', ', time asString; cr].		id ifNotNil:			[s nextPutAll: 'UUID: '; nextPutAll: id asString; cr].		s			nextPutAll: 'Ancestors: '; nextPutAll: self ancestorString.		self stepChildren isEmpty ifFalse:			[s cr; nextPutAll: 'Backported From: '; nextPutAll: self stepChildrenString].		]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/22/2004 16:45'!timeStamp	^ TimeStamp date: date time: time! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 9/17/2003 11:24'!timeString	^ date asString, ', ', time asString! !!MCVersionInfo methodsFor: 'printing' stamp: 'ab 7/5/2003 18:00'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)	! !!MCVersionInfo commentStamp: '<historical>' prior: 0!Adds to the record of ancestry, other identifying details.!!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:44'!name: vName id: id message: message date: date time: time author: author ancestors: ancestors	^ self 		name: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: #()! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:43'!name: vName id: id message: message date: date time: time author: author ancestors: ancestors stepChildren: stepChildren	^ self new		initializeWithName: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: stepChildren! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10'!isWritten: aVersionInfo	^ self written includes: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 16:53'!writeVersionInfo: aVersionInfo	(self isWritten: aVersionInfo)		ifTrue: [^ stream nextPutAll: '(id ', aVersionInfo id asString printString, ')'].	stream nextPut: $(.	#(name message id date time author) 		do: [:sel | 			stream nextPutAll: sel.			stream nextPut: $ .			((aVersionInfo perform: sel) ifNil: ['']) asString printOn: stream.			stream nextPut: $ ].	stream nextPutAll: 'ancestors ('.	aVersionInfo ancestors do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: ') stepChildren ('.	aVersionInfo stepChildren do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: '))'.	self wrote: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!written	^ written ifNil: [written := Set new]! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10'!wrote: aVersionInfo	self written add: aVersionInfo! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19'!adopt	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version adopt]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'bf 3/22/2005 22:12'!browse	self version browse! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'nk 4/17/2004 10:05'!changes	(MCPatchBrowser forPatch: self version changes)		showLabelled: 'Changes from ', self version info name! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!diff	| ancestorVersion |	self pickAncestor ifNotNil:		[:ancestor |		ancestorVersion := self version workingCopy repositoryGroup versionWithInfo: ancestor.		(self version asDiffAgainst: ancestorVersion) open]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'lr 9/26/2003 20:15'!hasVersion	^version notNil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:14'!history	(MCVersionHistoryBrowser new ancestry: self versionInfo) show! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'bf 3/14/2005 15:32'!load	Cursor wait showWhile: [self version load]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19'!merge	self version merge! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!save	self pickRepository ifNotNil:		[:ea |		ea storeVersion: self version]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16'!summary	^self hasVersion		ifTrue: [ self versionSummary ]		ifFalse: [ String new ]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19'!version	^ version! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16'!versionInfo	^ self version info! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16'!versionSummary	^ self version summary! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!version: aVersion	version := aVersion! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'Rik 12/17/200406:07'!buttonSpecs       ^ #((Browse browse 'Browse this version' hasVersion)               (History history 'Browse the history of this version' hasVersion)               (Changes changes 'Browse the changes this version would make to theimage' hasVersion)               (Load load 'Load this version into the image' hasVersion)               (Merge merge 'Merge this version into the image' hasVersion)               (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)               (Copy save 'Copy this version to another repository' hasVersion)               (Diff diff 'Create an equivalent version based on an earlier release'hasVersion))! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:33'!defaultExtent	^ 500@300! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:18'!defaultLabel	^ 'Version: ', self version info name! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:25'!pickAncestor	| index versions |	versions := self version info breadthFirstAncestors.	index := UIManager default chooseFrom: (versions collect: [:ea | ea name])				title: 'Ancestor:'.	^ index = 0 ifFalse: [versions at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:25'!pickRepository	| index |	index := UIManager default chooseFrom: (self repositories collect: [:ea | ea description])				title: 'Repository:'.	^ index = 0 ifFalse: [self repositories at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 8/31/2003 00:44'!repositories	^ MCRepositoryGroup default repositories! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:43'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((textMorph: summary) (0 0 1 1) (0 30 0 0))		)! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:06'!addDependency: aDependency	| dep |	aDependency isCurrent ifTrue: [^ self].	(self depAgeIsOk: aDependency) ifFalse: [^ self].	dep := aDependency resolve.	dep		ifNil: [self confirmMissingDependency: aDependency]		ifNotNil: [(versions includes: dep) ifFalse: [self addVersion: dep]]! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:04'!addVersion: aVersion	aVersion dependencies do: [ :ea | self addDependency: ea].	versions add: aVersion.! !!MCVersionLoader methodsFor: 'loading' stamp: 'stephaneducasse 2/4/2006 20:47'!load	| loader |	self checkForModifications.	loader := MCPackageLoader new.	versions do: [:ea |		ea canOptimizeLoading			ifTrue: [ea patch applyTo: loader]			ifFalse: [loader updatePackage: ea package withSnapshot: ea snapshot]].	loader loadWithNameLike: versions first info name.	versions do: [:ea | ea workingCopy loaded: ea]! !!MCVersionLoader methodsFor: 'checking' stamp: 'stephaneducasse 2/4/2006 20:47'!checkForModifications	| modifications |	modifications := versions select: [:ea | ea package workingCopy modified].	modifications isEmpty ifFalse: [self warnAboutLosingChangesTo: modifications].! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:00'!checkIfDepIsOlder: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:06'!confirmMissingDependency: aDependency	| name |	name := aDependency versionInfo name.	(self confirm: 'Can''t find dependency ', name, '. ignore?')		ifFalse: [self error: 'Can''t find dependency ', name]! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:02'!depAgeIsOk: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'checking' stamp: 'avi 1/24/2004 20:17'!warnAboutLosingChangesTo: versionCollection	self notify: (String streamContents: [:s |		s nextPutAll: 'You are about to load new versions of the following packages that have unsaved changes in the image.  If you continue, you will lose these changes.'; cr.		versionCollection do:			[:ea |			s cr; space; space; nextPutAll: ea package name]])! !!MCVersionLoader methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	versions := OrderedCollection new! !!MCVersionLoader class methodsFor: 'as yet unclassified' stamp: 'avi 1/24/2004 20:06'!loadVersion: aVersion	self new		addVersion: aVersion;		load! !!MCVersionLoader class methodsFor: 'as yet unclassified' stamp: 'avi 1/24/2004 19:51'!new	^ self basicNew initialize! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!addVersion: aVersion		records add: (MCMergeRecord version: aVersion).	aVersion dependencies do:		[:ea | | dep |		dep := ea resolve.		(records anySatisfy: [:r | r version = dep]) ifFalse: [self addVersion: dep]]! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	records := OrderedCollection new.	merger := MCThreeWayMerger new.! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:15'!merge	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger load.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:32'!mergeWithNameLike: baseName	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger loadWithNameLike: baseName.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:29'!resolveConflicts	(records allSatisfy: [:ea | ea isAncestorMerge]) ifTrue: [MCNoChangesException signal. ^ false].	^ ((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', records first version info name) = true! !!MCVersionMerger class methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:35'!mergeVersion: aVersion	self new		addVersion: aVersion;		mergeWithNameLike: aVersion info name! !!MCVersionMerger class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:41'!new	^ self basicNew initialize! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:38'!defaultAction	^ MCSaveVersionDialog new		versionName: suggestion;		logMessage: initialMessage;		showModally! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage	^ initialMessage! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage: aString	initialMessage := aString! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:07'!suggestedName	^ suggestion! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!suggestedName: aString	suggestion := aString! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:13'!fromAddress	^ 'monticello@beta4.com'! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithVersion: aVersion repository: aRepository	version := aVersion.	repository := aRepository.	ancestor := repository closestAncestorVersionFor: version info ifNone: []. 	changes := ancestor				ifNil: [#()]				ifNotNil: [(version snapshot patchRelativeToBase: ancestor snapshot) 							operations asSortedCollection]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:12'!messageText	^ String streamContents:		[:s |		s nextPutAll: 'Committed to repository: ', repository description; cr; cr.		s nextPutAll: version summary.		changes isEmpty ifFalse:			[s cr; cr.			s nextPutAll: '-----------------------------------------------------'; cr.			s nextPutAll: 'Changes since ', ancestor info name, ':'; cr.			changes do:			[:ea |			s cr; nextPutAll: ea summary; cr.			s nextPutAll: ea sourceString]]]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!messageTo: aString	| message |	message := MailMessage empty.	message setField: 'from' toString: self fromAddress.	message setField: 'to' toString: aString.	message setField: 'subject' toString: '[MC] ', version info name.	message body: (MIMEDocument contentType: 'text/plain' content: self messageText).	^ message! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!notify: aString	| message |	message := self messageTo: aString.	SMTPClient		deliverMailFrom: message from		to: (Array with: message to)		text: message text		usingServer: MailSender smtpServer! !!MCVersionNotification class methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:27'!version: aVersion repository: aRepository	^ self basicNew initializeWithVersion: aVersion repository: aRepository! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 16:52'!basicVersion	^ MCVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/21/2004 23:10'!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 14:50'!dependencies	dependencies ifNil: [self loadDependencies].	^ dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53'!info	info ifNil: [self loadVersionInfo].	^ info! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53'!package	package ifNil: [self loadPackage].	^ package! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:54'!snapshot	^ MCSnapshot fromDefinitions: self definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:38'!version	^ self basicVersion! !!MCVersionReader methodsFor: 'lifecycle' stamp: 'cwp 8/3/2003 18:48'!initialize! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54'!loadDefinitions	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'avi 1/19/2004 14:50'!loadDependencies	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54'!loadPackage	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54'!loadVersionInfo	self subclassResponsibility! !!MCVersionReader class methodsFor: 'testing' stamp: 'cwp 8/4/2003 00:32'!canReadFileNamed: fileName	^ (fileName endsWith: self extension)! !!MCVersionReader class methodsFor: 'reading' stamp: 'ul 1/11/2010 07:48'!file: fileName streamDo: aBlock	^FileStream readOnlyFileNamed: fileName do: [ :file |		aBlock value: file ]! !!MCVersionReader class methodsFor: 'reading' stamp: 'bf 3/23/2005 01:20'!on: s fileName: f	^ self on: s! !!MCVersionReader class methodsFor: 'reading' stamp: 'cwp 7/31/2003 23:03'!versionFromFile: fileName	^ self file: fileName streamDo: [:stream | self versionFromStream: stream]! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:58'!versionFromStream: aStream	^ (self on: aStream) version! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:59'!versionInfoFromStream: aStream	^ (self on: aStream) info! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 10/15/2003 02:01'!fileReaderServicesForFile: fullName suffix: suffix	self isAbstract ifTrue: [^ #()].	^ ((suffix = self extension) or: [ suffix = '*' ])		ifTrue: [self services]		ifFalse: [Array new: 0]		! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 1/24/2004 19:01'!initialize	"MCVersionReader initialize"	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | FileList unregisterFileReader: installer].	self concreteSubclasses do: [:aClass | FileList registerFileReader: aClass].	"get rid of AnObsoleteMCMcReader and AnObsoleteMCMcvReader"	(FileList registeredFileReaderClasses  select: [ :ea | ea isObsolete ]) do: 		[ :ea | FileList unregisterFileReader: ea ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'stephaneducasse 2/4/2006 20:47'!loadVersionFile: fileName	| version |	version := self versionFromFile: fileName.	version workingCopy repositoryGroup addRepository:		(MCDirectoryRepository new directory:			(FileDirectory on: (FileDirectory dirPathFor: fileName))).	version load.! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46'!mergeVersionFile: fileName	(self versionFromFile: fileName) merge! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46'!openVersionFile: fileName	(self versionFromFile: fileName) open! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 1/21/2004 22:55'!services	^ Array 		with: self serviceLoadVersion		with: self serviceMergeVersion		with: self serviceOpenVersion! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:33'!unload	FileList unregisterFileReader: self ! !!MCVersionReader class methodsFor: '*monticello-file services' stamp: 'stephaneducasse 2/4/2006 20:47'!loadVersionStream: stream fromDirectory: directory	| version |	version := self versionFromStream: stream.	directory isRemoteDirectory ifFalse: [	version workingCopy repositoryGroup addRepository:		(MCDirectoryRepository new directory: directory). ].	version load.! !!MCVersionReader class methodsFor: '*monticello-file services' stamp: 'nk 2/25/2005 11:17'!mergeVersionStream: stream	(self versionFromStream: stream) merge! !!MCVersionReader class methodsFor: '*monticello-file services' stamp: 'nk 2/25/2005 11:12'!openVersionFromStream: stream	(self versionFromStream: stream) open! !!MCVersionReader class methodsFor: '*monticello-file services-override-override' stamp: 'nk 2/25/2005 11:15'!serviceLoadVersion	^ (SimpleServiceEntry		provider: self		label: 'load version'		selector: #loadVersionStream:fromDirectory:		description: 'load a package version'		buttonLabel: 'load')		argumentGetter: [ :fileList | { fileList readOnlyStream . fileList directory } ]! !!MCVersionReader class methodsFor: '*monticello-file services-override-override' stamp: 'nk 2/25/2005 11:16'!serviceMergeVersion	^ (SimpleServiceEntry		provider: self		label: 'merge version'		selector: #mergeVersionStream:		description: 'merge a package version into the image'		buttonLabel: 'merge')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!MCVersionReader class methodsFor: '*monticello-file services-override-override' stamp: 'nk 2/25/2005 11:16'!serviceOpenVersion	^ (SimpleServiceEntry		provider: self		label: 'open version'		selector: #openVersionFromStream:		description: 'open a package version'		buttonLabel: 'open')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:19'!addAllAncestorsOf: aVersionInfo to: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	(self knownAncestorsOf: aVersionInfo) do:		[:ea |		self addAllAncestorsOf: ea to: aSet]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 21:30'!addAllVersionInfos: aCollection	aCollection do: [:ea | self addVersionInfo: ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addToCurrentLayer: aVersionInfo	| layer |	layer := layers at: depthIndex.	(layer includes: aVersionInfo) ifFalse:		[depths at: aVersionInfo ifPresent:			[:i |			i < depthIndex				ifTrue: [(layers at: i) remove: aVersionInfo]				ifFalse: [^ false]].		layer add: aVersionInfo.		depths at: aVersionInfo put: depthIndex.		^ true].	^ false ! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:49'!addVersionInfo: aVersionInfo	roots add: aVersionInfo.	self registerStepChildrenOf: aVersionInfo seen: Set new! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!allAncestorsOf: aVersionInfo	| all |	all := Set new.	self addAllAncestorsOf: aVersionInfo to: all.	^ all! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	stepparents := Dictionary new.	roots := OrderedCollection new.! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:37'!knownAncestorsOf: aVersionInfo	^ aVersionInfo ancestors, (self stepParentsOf: aVersionInfo) asArray! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 15:53'!layers	^ layers! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!popLayer	depthIndex := depthIndex - 1! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:39'!processVersionInfo: aVersionInfo	(self addToCurrentLayer: aVersionInfo) ifTrue:		[self pushLayer.		(self knownAncestorsOf: aVersionInfo) do: [:ea | self processVersionInfo: ea].		self popLayer]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!pushLayer	depthIndex := depthIndex + 1.	depthIndex > layers size ifTrue: [layers add: OrderedCollection new].	! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:34'!registerStepChildrenOf: aVersionInfo seen: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	aVersionInfo stepChildren do: [:ea | (self stepParentsOf: ea) add: aVersionInfo].	aVersionInfo ancestors do: [:ea | self registerStepChildrenOf: ea seen: aSet].! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!sortedVersionInfos	layers := OrderedCollection with: OrderedCollection new.	depthIndex := 1.	depths := Dictionary new.	roots do: [:ea | self processVersionInfo: ea].	^ layers gather: [:ea | ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:40'!stepParentsOf: aVersionInfo	^ (stepparents at: aVersionInfo ifAbsentPut: [Set new])! !!MCVersionSorter class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addAncestor: aNode	ancestors := (self ancestors reject: [:each | aNode hasAncestor: each])		copyWith: aNode! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addStepChild: aVersionInfo	stepChildren := stepChildren copyWith: aVersionInfo! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:31'!infoWithName: nameString message: messageString	^ MCVersionInfo		name: nameString		id: UUID new		message: messageString		date: Date today		time: Time now		author: Utilities authorInitials		ancestors: ancestors asArray		stepChildren: self stepChildren asArray! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14'!name	^ '<working copy>'! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14'!summary	^ 'Ancestors: ', self ancestorString! !!MCWorkingAncestry commentStamp: '<historical>' prior: 0!The interim record of ancestry for a working copy, gets merged version added to the ancestry, and is used to create the VersionInfo when the working copy becomes a version. !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07'!adopt: aVersion	ancestry addAncestor: aVersion info.	self changed.! !!MCWorkingCopy methodsFor: 'operations' stamp: 'ul 12/12/2009 14:09'!backportChangesTo: aVersionInfo	| baseVersion fullPatch currentVersionInfo currentVersion newSnapshot newAncestry |	currentVersionInfo := self currentVersionInfo.	baseVersion := self repositoryGroup versionWithInfo: aVersionInfo.	currentVersion := self repositoryGroup versionWithInfo: currentVersionInfo.	fullPatch := currentVersion snapshot patchRelativeToBase: baseVersion snapshot.	(MCChangeSelectionRequest new		patch: fullPatch;		label: 'Changes to Backport';		signal ) ifNotNil:		[:partialPatch |		newSnapshot := MCPatcher apply: partialPatch to: baseVersion snapshot.		newAncestry := MCWorkingAncestry new							addAncestor: aVersionInfo;							addStepChild: currentVersionInfo;							yourself.		MCPackageLoader updatePackage: package withSnapshot: newSnapshot.		ancestry := newAncestry.		self modified: false; modified: true]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47'!changesRelativeToRepository: aRepository	| ancestorVersion ancestorSnapshot |	ancestorVersion := aRepository closestAncestorVersionFor: ancestry ifNone: [].	ancestorSnapshot := ancestorVersion ifNil: [MCSnapshot empty] ifNotNil: [ancestorVersion snapshot].	^ package snapshot patchRelativeToBase: ancestorSnapshot! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47'!loaded: aVersion	ancestry := MCWorkingAncestry new addAncestor: aVersion info.	requiredPackages := OrderedCollection withAll: (aVersion dependencies collect: [:ea | ea package]).	self modified: false.	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'abc 2/13/2004 15:57'!merged: aVersion	ancestry addAncestor: aVersion info.	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'nice 1/1/2010 21:51'!merge: targetVersion	| ancestorInfo merger ancestorSnapshot packageSnapshot |	targetVersion dependencies do: [:ea | ea resolve merge].	ancestorInfo := targetVersion info commonAncestorWith: ancestry.		ancestorInfo = targetVersion info ifTrue: [^ MCNoChangesException signal].		packageSnapshot := package snapshot.	ancestorSnapshot := ancestorInfo							ifNotNil: [(self findSnapshotWithVersionInfo: ancestorInfo)]							ifNil: [self notifyNoCommonAncestorWith: targetVersion.  MCSnapshot empty].		(ancestry ancestors size = 1		and: [ancestry ancestors first = ancestorInfo		and: [(packageSnapshot patchRelativeToBase: ancestorSnapshot) isEmpty]])				ifTrue: [^ targetVersion load].		merger := MCThreeWayMerger 				base: packageSnapshot				target: targetVersion snapshot				ancestor: ancestorSnapshot.	((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', targetVersion info name) = true ifTrue:			[merger loadWithNameLike: targetVersion info name.			ancestry addAncestor: targetVersion info].	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:54'!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName		initialMessage: self patchMessageSuggestion) ifNotNil:			[:pair |			self newVersionWithName: pair first				message: (self patchMessageStripped: pair last)].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47'!newVersionWithName: nameString message: messageString	| info deps |	info := ancestry infoWithName: nameString message: messageString.	ancestry := MCWorkingAncestry new addAncestor: info.	self modified: true; modified: false.		deps := self requiredPackages collect:		[:ea | 		MCVersionDependency			package: ea			info: ea workingCopy currentVersionInfo].	^ MCVersion		package: package		info: info		snapshot: package snapshot		dependencies: deps! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07'!notifyNoCommonAncestorWith: aVersion	self notify:'Could not find a common ancestor between (',aVersion info name,') and (',ancestry ancestorString, ').Proceeding with this merge may cause spurious conflicts.'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageChanges	| changes parentInfo parentSnapshot |	parentInfo := self ancestors		ifEmpty: [nil]		ifNotEmpty: [self ancestors first].	parentSnapshot := 	self findSnapshotWithVersionInfo: parentInfo.	changes := package snapshot patchRelativeToBase: parentSnapshot.	^ (MCPatchMessage new patch: changes) message! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:00'!patchMessageChangesDelimiter	^'=== text below is ignored ==='! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:04'!patchMessageChangesHeader	^ancestry summary, String cr,	'Added, Modified, Deleted',	(self ancestors ifEmpty: [''] ifNotEmpty: [' vs. ', self ancestors first name]), ':'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:15'!patchMessageDefault	^ 'empty log message'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageStripped: aString	| pos |	pos := aString findString: self patchMessageChangesDelimiter.	^ (pos > 0		ifTrue: [aString first: pos - 1]		ifFalse: [aString]) withBlanksTrimmed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:35'!patchMessageSuggestion	^	self patchMessageDefault, String cr, String cr,		self patchMessageChangesDelimiter, String cr,		self patchMessageChangesHeader, String cr,		self patchMessageChanges! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 10/5/2003 11:09'!unload	MCPackageLoader unloadPackage: self package.	self unregister.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:07'!ancestors	^ ancestry ancestors! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:13'!ancestry	^ ancestry! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!clearRequiredPackages	requiredPackages := nil! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 20:01'!currentVersionInfo	^ (self needsSaving or: [ancestry ancestors isEmpty])		ifTrue: [self newVersion info]		ifFalse: [ancestry ancestors first]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:05'!description	^ self packageNameWithStar, ' (', ancestry ancestorString, ')'! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 20:02'!needsSaving	^ self modified or: [self requiredPackages anySatisfy: [:ea | ea workingCopy needsSaving]]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!requiredPackages	^ requiredPackages ifNil: [requiredPackages := OrderedCollection new]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:04'!requirePackage: aPackage	(self requiredPackages includes: aPackage) ifFalse: [requiredPackages add: aPackage]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!versionInfo: aVersionInfo	ancestry := MCWorkingAncestry new addAncestor: aVersionInfo! !!MCWorkingCopy methodsFor: 'private' stamp: 'nice 12/25/2009 14:39'!findSnapshotWithVersionInfo: aVersionInfo	^ aVersionInfo		ifNil: [MCSnapshot empty]		ifNotNil: [(self repositoryGroup versionWithInfo: aVersionInfo)			ifNil: [MCSnapshot empty]			ifNotNil: [:aVersion | aVersion snapshot]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	super initialize.	ancestry := MCWorkingAncestry new! !!MCWorkingCopy methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!nextVersionName	| branch oldName |	ancestry ancestors isEmpty		ifTrue: [counter ifNil: [counter := 0]. branch := package name]		ifFalse:			[oldName := ancestry ancestors first name.			oldName last isDigit				ifFalse: [branch := oldName]				ifTrue: [branch := oldName copyUpToLast: $-].			counter ifNil: [				counter := (ancestry ancestors collect: [:each |					each name last isDigit						ifFalse: [0]						ifTrue: [(each name copyAfterLast: $-) extractNumber]]) max]].	counter := counter + 1.	^ branch, '-',  Utilities authorInitials, '.', counter asString! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58'!possiblyNewerVersions	^Array streamContents: [:strm |		self repositoryGroup repositories do: [:repo |			strm nextPutAll: (self possiblyNewerVersionsIn: repo)]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58'!possiblyNewerVersionsIn: aRepository	^aRepository possiblyNewerVersionsOfAnyOf: self ancestors! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/4/2010 15:29'!requestVersionNameAndMessageWithSuggestion: nameString initialMessage: msgString	^ (MCVersionNameAndMessageRequest new		suggestedName: nameString;		initialMessage: msgString		) signal! !!MCWorkingCopy methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!uniqueVersionName	|versionName|	counter := nil.	[versionName := self nextVersionName.	self repositoryGroup includesVersionNamed: versionName] whileTrue.	^ versionName! !!MCWorkingCopy methodsFor: 'private' stamp: 'avi 2/4/2004 14:11'!versionSeparator	^ $_! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47'!repositoryGroup	^ repositoryGroup ifNil: [repositoryGroup := MCRepositoryGroup new]! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47'!repositoryGroup: aRepositoryGroup	repositoryGroup := aRepositoryGroup! !!MCWorkingCopy methodsFor: 'migration' stamp: 'stephaneducasse 2/4/2006 20:47'!updateInstVars	ancestry ifNil:		[ancestry := MCWorkingAncestry new.		versionInfo ifNotNil:			[versionInfo ancestors do: [:ea | ancestry addAncestor: ea].			versionInfo := nil]]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:00'!adoptVersionInfoFrom: anInstaller	|viCache|	viCache := Dictionary new.	anInstaller versionInfo keysAndValuesDo: [:packageName :info |		(self forPackage: (MCPackage named: packageName))			versionInfo: (self infoFromDictionary:  info cache: viCache)].	[anInstaller clearVersionInfo] on: Error do: ["backwards compat"].! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:23'!ancestorsFromArray: anArray cache: aDictionary	^ anArray ifNotNil: [anArray collect: [:dict | self infoFromDictionary: dict cache: aDictionary]]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39'!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21'!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:36'!updateInstVars	self allInstances do: [:ea | ea updateInstVars]! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRepository	self newRepository ifNotNil:		[:repos | self addRepository: repos ].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:12'!addRepositoryToPackage	self repository ifNotNil:		[:repos |		(self pickWorkingCopySatisfying: [ :p | (p repositoryGroup includes: repos) not ]) ifNotNil:			[:wc |			workingCopy := wc.			workingCopy repositoryGroup addRepository: repos.			self repository: repos.				self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRepositoryToWorkingCopy	workingCopy ifNotNil:		[:wc |			workingCopy repositoryGroup addRepository: self repository.			self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58'!addRepository: aRepository	self repository: aRepository.	self repositoryGroup addRepository: aRepository.	self changed: #repositoryList; changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRequiredPackage	| chosen |	workingCopy ifNotNil:		[:wc |		chosen := self pickWorkingCopySatisfying: 			[:ea | ea ~= wc and: [(wc requiredPackages includes: ea package) not]].		chosen ifNotNil:			[wc requirePackage: chosen package.			self workingCopyListChanged]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!addWorkingCopy	|name|	name := FillInTheBlankMorph request: 'Name of package:'.	name isEmptyOrNil ifFalse:		[PackageInfo registerPackageName: name.		workingCopy := MCWorkingCopy forPackage: (MCPackage new name: name).		workingCopyWrapper := nil.		self repositorySelection: 0].	self workingCopyListChanged; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!backportChanges	self canBackport ifFalse: [^self].	workingCopy ifNotNil:		[workingCopy needsSaving ifTrue: [^ self inform: 'You must save the working copy before backporting.'].		self pickAncestorVersionInfo ifNotNil:			[:baseVersionInfo |			workingCopy backportChangesTo: baseVersionInfo]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ab 7/19/2003 22:58'!browseWorkingCopy	workingCopy ifNotNil:		[(MCSnapshotBrowser forSnapshot: workingCopy package snapshot)			label: 'Snapshot Browser: ', workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 9/14/2004 14:57'!canBackport	^ self hasWorkingCopy and: [workingCopy needsSaving not]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 3/10/2010 21:14'!checkForNewerVersions	| newer |	newer := workingCopy possiblyNewerVersionsIn: self repository.	^ newer isEmpty or: [		self confirm: 'CAUTION!! These versions in the repository may be newer:', 			String cr, (newer asString truncateWithElipsisTo: 150), String cr,			'Do you really want to save this version?'].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!clearRequiredPackages	workingCopy ifNotNil:		[:wc |		wc clearRequiredPackages.		self workingCopyListChanged]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46'!deleteWorkingCopy	workingCopy unregister.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 1/12/2010 01:03'!editRepository	| newRepo |		newRepo := self repository openAndEditTemplateCopy.	newRepo ifNotNil: [ 		newRepo class = self repository class			ifTrue: [				self repository copyFrom: newRepo.				self changed: #repositoryList ]			ifFalse: [self inform: 'Must not change repository type!!']]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/3/2005 15:08'!flushAllCaches	| beforeBytes afterBytes beforeVersions afterVersions |	Cursor wait showWhile: [		beforeBytes := Smalltalk garbageCollect.		beforeVersions := MCVersion allSubInstances size.		MCFileBasedRepository flushAllCaches.		afterBytes := Smalltalk garbageCollect.		afterVersions := MCVersion allSubInstances size.	].	^self inform: (beforeVersions - afterVersions) asString, ' versions flushed', String cr, 		(afterBytes - beforeBytes) asStringWithCommas, ' bytes reclaimed'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 9/11/2004 15:32'!inspectWorkingCopy	workingCopy ifNotNil: [workingCopy inspect]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58'!loadRepositories	FileStream fileIn: 'MCRepositories.st'.	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 8/6/2009 18:25'!newRepository	| types index |	types := MCRepository allConcreteSubclasses asArray.	index := UIManager default chooseFrom: (types collect: [:ea | ea description])				title: 'Repository type:'.	^ index = 0 ifFalse: [(types at: index) morphicConfigure]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!openRepository	self repository ifNotNil: [:repos | repos morphicOpen: workingCopy ]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'jf 1/25/2004 14:06'!recompilePackage	workingCopy package packageInfo methods		do: [:ea | ea actualClass recompile: ea methodSymbol]		displayingProgress: 'Recompiling...'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!removeRepository	self repository ifNotNil:		[:repos |		self repositoryGroup removeRepository: repos.		self repositorySelection: (1 min: self repositories size)].	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!repository	workingCopy ifNotNil: [repository := self defaults at: workingCopy ifAbsent: []].	^ repository! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!repository: aRepository	repository := aRepository.	workingCopy ifNotNil: [self defaults at: workingCopy put: aRepository]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!revertPackage	self pickAncestorVersionInfo ifNotNil: [:info |		(self repositoryGroup versionWithInfo: info			ifNone: [^self inform: 'No repository found for ', info name]		) load]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'nice 3/31/2010 22:30'!saveRepositories	FileStream forceNewFileNamed: 'MCRepositories.st' do: [:f |		MCRepositoryGroup default repositoriesDo: [:r |			r asCreationTemplate ifNotNil: [:template |				f nextPutAll: 'MCRepositoryGroup default addRepository: (', template , ')!!'; cr]]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 3/9/2010 17:13'!saveVersion	| repo |	self canSave ifFalse: [^self].	self checkForNewerVersions ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNil:		[:v |		(MCVersionInspector new version: v) show.		Cursor wait showWhile: [repo storeVersion: v].		MCCacheRepository default cacheAllFileNamesDuring: 			[repo cacheAllFileNamesDuring: 				[v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]]]]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46'!unloadPackage	workingCopy unload.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!viewChanges	| patch |	self canSave ifTrue:		[patch := workingCopy changesRelativeToRepository: self repository.		patch isNil ifTrue: [^ self].		patch isEmpty			ifTrue: [ workingCopy modified: false.				self inform: 'No changes' ]			ifFalse:				[ workingCopy modified: true.				(MCPatchBrowser forPatch: patch)					label: 'Patch Browser: ', workingCopy description;					show]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 2/13/2004 01:13'!viewHistory	workingCopy ifNotNil:		[(MCWorkingHistoryBrowser new				ancestry: workingCopy ancestry;				package: workingCopy package)			label:  'Version History: ',  workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 2/28/2005 16:28'!buttonSpecs       ^ #(               ('+Package' addWorkingCopy 'Add a new package and make it the working copy')               (Browse browseWorkingCopy 'Browse the working copy of the selected package' hasWorkingCopy)               (Scripts editLoadScripts 'Edit the load/unload scripts of this package' hasWorkingCopy)               (History viewHistory 'View the working copy''s history' hasWorkingCopy)               (Changes viewChanges 'View the working copy''s changes relative to the installed version from the repository' canSave)               (Backport backportChanges 'Backport the working copy''s changes to an ancestor' canBackport)               (Save saveVersion 'Save the working copy as a new version to the selected repository' canSave)             ('+Repository' addRepository 'Add an existing repository to the list of those visible')               (Open openRepository 'Open a browser on the selected repository' hasRepository)               )! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:22'!canSave	^ self hasWorkingCopy and: [self hasRepository]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:50'!changedButtons	self changed: #hasWorkingCopy.	self changed: #canSave.	self changed: #canBackport.	self changed: #hasRepository.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 8/18/2010 15:36'!defaultExtent	^ 700@400! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:38'!defaultLabel	^ 'Monticello Browser'! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!defaults	^ defaults ifNil: [defaults := Dictionary new]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!editLoadScripts	| menu |	self hasWorkingCopy ifFalse: [^self].	menu := MenuMorph new defaultTarget: self.	menu add: 'edit preamble' selector: #editScript: argument: #preamble.	menu add: 'edit postscript' selector: #editScript: argument: #postscript.	menu add: 'edit preambleOfRemoval' selector: #editScript: argument: #preambleOfRemoval.	menu add: 'edit postscriptOfRemoval' selector: #editScript: argument: #postscriptOfRemoval.	menu popUpInWorld.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!editScript: scriptSymbol| script |script := workingCopy packageInfo perform: scriptSymbol.script openLabel: scriptSymbol asString, ' of the Package ', workingCopy package name.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:21'!hasRepository	^ self repository notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:46'!hasWorkingCopy	^ workingCopy notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 11/16/2003 20:21'!initialize	MCWorkingCopy addDependent: self.	self workingCopies do: [:ea | ea addDependent: self].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'tfel 6/12/2010 13:47'!insertExternalMenuEntries: aMenu		self class externalMenuEntries ifNotEmpty: [		aMenu addLine.		self class externalMenuEntries do: [:each |			aMenu 				add: each entry 				target: each target				selector: each selector				argument: self]].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:26'!pickAncestorVersionInfo	| ancestors index |	ancestors := workingCopy ancestry breadthFirstAncestors.	index := UIManager default chooseFrom: (ancestors collect: [:ea | ea name])				title: 'Ancestor:'.	^ index = 0 ifFalse: [ ancestors at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'nk 3/9/2004 14:39'!pickWorkingCopy	^self pickWorkingCopySatisfying: [ :c | true ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:26'!pickWorkingCopySatisfying: aBlock	| copies index |	copies := self workingCopies select: aBlock.	copies isEmpty ifTrue: [ ^nil ].	index := UIManager default chooseFrom: (copies collect: [:ea | ea packageName])				title: 'Package:'.	^ index = 0 ifFalse: [ copies at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32'!repositories	^ self repositoryGroup repositories! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32'!repositoryGroup	^ workingCopy		ifNil: [MCRepositoryGroup default]		ifNotNil: [workingCopy repositoryGroup]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:04'!repositoryList	^ self repositories collect: [:ea | ea description]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/6/2005 13:20'!repositoryListMenu: aMenu	self repository ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('open repository' #openRepository)		    ('edit repository info' #editRepository)		   ('add to package...' #addRepositoryToPackage)		   ('remove repository' #removeRepository)			   ('load repositories' #loadRepositories)			   ('save repositories' #saveRepositories)		   ('flush cached versions' #flushAllCaches)			).		aMenu		add: (self repository alwaysStoreDiffs					ifTrue: ['store full versions']					ifFalse: ['store diffs'])		target: self		selector: #toggleDiffs.	^ aMenu				! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:22'!repositorySelection	^ self repositories indexOf: self repository! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:56'!repositorySelection: aNumber	aNumber = 0		ifTrue: [self repository: nil]		ifFalse: [self repository: (self repositories at: aNumber)].	self changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'cmm 2/13/2010 20:03'!representsSameBrowseeAs: anotherModel	^ self class = anotherModel class! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 8/31/2004 01:14'!toggleDiffs	self repository alwaysStoreDiffs		ifTrue: [self repository doNotAlwaysStoreDiffs]		ifFalse: [self repository doAlwaysStoreDiffs]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54'!unsortedWorkingCopies	^ MCWorkingCopy allManagers ! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54'!update: aSymbol	self unsortedWorkingCopies do: [:ea | ea addDependent: self].	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 3/6/2005 22:30'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((treeOrListMorph: workingCopy) (0 0 0.5 1) (0 30 0 0))		((listMorph: repository) (0.5 0 1 1) (0 30 0 0))		)! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 1/20/2004 16:09'!workingCopies	^ MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 1/19/2004 16:41'!workingCopyList	^ self workingCopies collect:		[:ea |		(workingCopy notNil and: [workingCopy requiredPackages includes: ea package])			ifTrue: [Text string: ea description emphasis: (Array with: TextEmphasis bold)]			ifFalse: [ea description]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:51'!workingCopyListChanged	self changed: #workingCopyList.	self changed: #workingCopyTree.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'tfel 6/12/2010 11:22'!workingCopyListMenu: aMenu	workingCopy ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)			('recompile package' #recompilePackage)			('revert package...' #revertPackage)			('unload package' #unloadPackage)			('delete working copy' #deleteWorkingCopy)).	(Smalltalk includesKey: #SARMCPackageDumper) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	self insertExternalMenuEntries: aMenu.	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:11'!workingCopyListMorph	^ PluggableMultiColumnListMorph		on: self		list: #workingCopyList		selected: #workingCopySelection		changeSelected: #workingCopySelection:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:05'!workingCopySelection	^ self workingCopies indexOf: workingCopy! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:38'!workingCopySelectionWrapper	^workingCopyWrapper! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:57'!workingCopySelectionWrapper: aWrapper	workingCopyWrapper := aWrapper.	self changed: #workingCopySelectionWrapper.	self workingCopy: (aWrapper ifNotNil:[aWrapper item])! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:48'!workingCopySelection: aNumber	self workingCopy: 		(aNumber = 0 			ifTrue:[nil]			ifFalse:[self workingCopies at: aNumber]).	! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:30'!workingCopyTree	^ self workingCopies collect:[:each| MCDependentsWrapper with: each model: self].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 5/11/2005 15:25'!workingCopyTreeMenu: aMenu	workingCopy ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)			('recompile package' #recompilePackage)			('revert package...' #revertPackage)			('unload package' #unloadPackage)			('delete working copy' #deleteWorkingCopy)			('inspect working copy' #inspectWorkingCopy)).	(Smalltalk includesKey: #SARMCPackageDumper) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:24'!workingCopyTreeMorph	^ SimpleHierarchicalListMorph		on: self		list: #workingCopyTree		selected: #workingCopyWrapper		changeSelected: #workingCopyWrapper:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 3/19/2010 12:32'!workingCopy: wc	workingCopy := wc.	self changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser class methodsFor: 'preferences' stamp: 'ar 3/10/2010 21:12'!checkForNewerVersionsBeforeSave	"Preference accessor"	<preference: 'Check for new versions before save'		category: 'Monticello'		description: 'If true, MC will warn before committing to repositories that have possibly newer versions of the package being saved.'		type: #Boolean>	^CheckForNewerVersionsBeforeSave ifNil:[true]! !!MCWorkingCopyBrowser class methodsFor: 'preferences' stamp: 'ar 3/10/2010 21:12'!checkForNewerVersionsBeforeSave: aBool	"Sets the CheckForNewerVersionsBeforeSave preference"	CheckForNewerVersionsBeforeSave := aBool! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 23:38'!initialize	 (TheWorldMenu respondsTo: #registerOpenCommand:)         ifTrue: [TheWorldMenu registerOpenCommand: {'Monticello Browser'. {self. #open}}]! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:04'!new	^ self basicNew initialize! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 23:27'!open	self new show! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 14:55'!addMenuSpec: aMCMenuSpec	"Register a context menu entry in the monticello browser from an external package.	 The MCWorkingCopyBrowser model is passed as argument."	self externalMenuEntries 		remove: aMCMenuSpec 		ifAbsent: ["Remove any previous entry with description string"];		add: aMCMenuSpec.! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 11:44'!externalMenuEntries		ExternalMenuEntries ifNil: [ExternalMenuEntries := Set new].	^ ExternalMenuEntries! !!MCWorkingHistoryBrowser methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 01:37'!baseSnapshot	^ package snapshot! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52'!includesVersionNamed: aString	^ false! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:53'!morphicOpen: aWorkingCopy	self inform: 'This repository is write-only'! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52'!versionWithInfo: aVersionInfo ifAbsent: aBlock	^ aBlock value! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 01:14'!stream	^ stream! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!stream: aStream	stream := aStream! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 15:00'!extension	^ self readerClass extension! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 7/28/2003 23:46'!readerClass	^ self subclassResponsibility ! !!MCWriter class methodsFor: 'writing' stamp: 'cwp 8/1/2003 01:16'!on: aStream	^ self new stream: aStream! !!MenuMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 21:40'!setTarget: evt 	"Set the default target object to be used for add item commands, and re-target all existing items to the new target or the the invoking hand."	| oldDefaultTarget |	oldDefaultTarget := defaultTarget .	self sightTargets: evt. 	oldDefaultTarget ~~ defaultTarget 		ifTrue: [self updateItemsWithTarget: defaultTarget orWithHand: evt hand ].	! !!MenuMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 21:26'!target: aMorph"Set defaultTarget since thats what we got.For the sake of targetSighting which assumes #target is a word we know."defaultTarget := aMorph! !!MenuMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 21:31'!updateItemsWithTarget: aTarget orWithHand: aHand	"re-target all existing items"	self items do: 			[:item | 			item target isHandMorph 				ifTrue: [item target: aHand]				ifFalse: [item target: aTarget]]! !!MessageNames methodsFor: 'initialization' stamp: 'kfr 5/29/2010 16:41'!inMorphicWindowWithInitialSearchString: initialString	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstDivider secondDivider horizDivider typeInPane searchButton plugTextMor |	window _ (SystemWindow labelled: 'Message Names') model: self.	firstDivider _ 0.1.	secondDivider _ 0.5.	horizDivider _ 0.5.	typeInPane _ AlignmentMorph newRow vResizing: #spaceFill; height: 14.	typeInPane hResizing: #spaceFill.	typeInPane listDirection: #leftToRight.	plugTextMor _ PluggableTextMorph on: self					text: #searchString accept: #searchString:notifying:					readSelection: nil menu: #codePaneMenu:shifted:.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor setNameTo: 'Search'.	plugTextMor vResizing: #spaceFill; hResizing: #spaceFill.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor setTextMorphToSelectAllOnMouseEnter.	searchButton _ SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Search';		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	typeInPane addMorphFront: searchButton.	typeInPane addTransparentSpacerOfSize: 6@0.	typeInPane addMorphBack: plugTextMor.	initialString isEmptyOrNil ifFalse:		[plugTextMor setText: initialString].	window addMorph: typeInPane frame: (0@0 corner: horizDivider @ firstDivider).	selectorListView _ PluggableListMorph on: self		list: #selectorList		selected: #selectorListIndex		changeSelected: #selectorListIndex:		menu: #selectorListMenu:		keystroke: #selectorListKey:from:.	selectorListView menuTitleSelector: #selectorListMenuTitle.	window addMorph: selectorListView frame: (0 @ firstDivider corner: horizDivider @ secondDivider).	window addMorph: self buildMorphicMessageList frame: (horizDivider @ 0 corner: 1@ secondDivider).	self 		addLowerPanesTo: window 		at: (0 @ secondDivider corner: 1@1) 		with: nil.	initialString isEmptyOrNil ifFalse:		[self searchString: initialString notifying: nil].	^ window! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/23/2008 10:47'!emitIfNil: stack on: strm value: forValue	| theNode theSize |	theNode := arguments first.	theSize := sizes at: 1.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: selector key == #ifNotNil:		dist: theSize 		pop: stack 		on: strm.	pc := strm position.	forValue 		ifTrue: 			[strm nextPut: Pop.			 stack pop: 1.			 theNode emitForEvaluatedValue: stack on: strm]			ifFalse:			[theNode emitForEvaluatedEffect: stack on: strm].! !!MessageNode methodsFor: 'private' stamp: 'vb 4/15/2007 09:10'!checkBlock: node as: nodeName from: encoder	^self checkBlock: node as: nodeName from: encoder maxArgs: 0! !!MessageNode methodsFor: 'private' stamp: 'eem 9/25/2008 14:48'!checkBlock: node as: nodeName from: encoder maxArgs: maxArgs	"vb: #canBeSpecialArgument for blocks hardcodes 0 arguments as the requirement for special blocks. We work around that here by further checking the number of arguments for blocks.."	node canBeSpecialArgument ifTrue: 		[^node isBlockNode].	^node isBlockNode		ifTrue:			[node numberOfArguments <= maxArgs				ifTrue: [true]				ifFalse: [encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' has too many arguments']]		ifFalse:			[encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 10:51'!compile    "This method is the how compiling a method used to work.  All these steps were done at once.     This method should not normally be used, because the whole point of MethodAddition is to let	you first create a compiled method and then install the method later."	self createCompiledMethod.	self installMethod.	self notifyObservers.	^selector! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:36'!compile: aString classified: aString1 withStamp: aString2 notifying: aRequestor logSource: aBoolean inClass: aClass	text := aString.	category := aString1.	changeStamp := aString2.	requestor := aRequestor.	logSource := aBoolean.	myClass := aClass! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 05:17'!createCompiledMethod	methodAndNode := myClass compile: text asString classified: category notifying: requestor							trailer: myClass defaultMethodTrailer ifFail: [^nil].	selector := methodAndNode selector.	compiledMethod := methodAndNode method.	self writeSourceToLog.	priorMethodOrNil := myClass compiledMethodAt: selector ifAbsent: [nil].! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:09'!installMethod	myClass addSelectorSilently: selector withMethod: compiledMethod.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:12'!notifyObservers	SystemChangeNotifier uniqueInstance 		doSilently: [myClass organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: myClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: myClass requestor: requestor].	"The following code doesn't seem to do anything."	myClass instanceSide noteCompilationOf: selector meta: myClass isClassSide.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:42'!writeSourceToLog	logSource ifTrue: [		myClass logMethodSource: text forMethodWithNode: methodAndNode 			inCategory: category withStamp: changeStamp notifying: requestor.	].! !!MethodAddition commentStamp: 'rej 2/25/2007 19:30' prior: 0!I represent the addition of a method to a class.  I can produce the CompiledMethod, install it, and then notify the system that the method has been added.  This allows Monticello to implement atomic addition.  A loader can compile all classes and methods first and then install all methods only after they have been all compiled, and in a way that executes little code.!!MethodNode methodsFor: 'initialize-release' stamp: 'eem 5/2/2010 18:26'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	"Initialize the receiver with respect to the arguments given."	encoder := anEncoder.	selectorOrFalse := selOrFalse.	precedence := p.	arguments := args.	temporaries := temps.	block := blk.	primitive := prim.	properties := AdditionalMethodState new! !!MethodNode methodsFor: 'initialize-release' stamp: 'ar 1/4/2002 00:23'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict	"Initialize the receiver with respect to the arguments given."	encoder := anEncoder.	selectorOrFalse := selOrFalse.	precedence := p.	arguments := args.	temporaries := temps.	block := blk.	primitive := prim.	properties := propDict.! !!MethodNode methodsFor: 'code generation' stamp: 'eem 1/23/2010 16:05'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| literals blkSize method nArgs nLits primErrNode stack strm |	self generate: trailer ifQuick: 		[:m |		literals := encoder allLiterals.		(nLits := literals size) > 255 ifTrue:			[^self error: 'Too many literals referenced'].		1 to: nLits do: [:lit | m literalAt: lit put: (literals at: lit)].		m properties: properties.		^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	nArgs := arguments size.	blkSize := (block sizeForEvaluatedValue: encoder)				+ (primErrNode ifNil: [0] ifNotNil: [2 "We force store-long (129)"]).	(nLits := (literals := encoder allLiterals) size) > 255 ifTrue:		[^self error: 'Too many literals referenced'].	method := CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm := ReadWriteStream with: method.	strm position: method initialPC - 1.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitStore: stack on: strm].	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue:		[^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53'!properties	^properties! !!MethodNode methodsFor: 'code generation' stamp: 'eem 1/23/2010 14:38'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in me) -> sourceRange (an Interval) in source text."	| methNode |	methNode _ self.	sourceText ifNil: [		"No source, use decompile string as source to map from"		methNode _ self parserClass new			parse: self decompileString			class: self methodClass	].	methNode generate: #(0 0 0 0).  "set bytecodes to map to"	^ methNode encoder sourceMap! !!MethodNode methodsFor: 'printing' stamp: 'eem 1/23/2010 14:12'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream dialect = #SQ00					ifTrue: [(kwd endsWith: ':')							ifTrue: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd allButLast].									aStream nextPutAll: ' (']							ifFalse: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd].									aStream space]]					ifFalse: [aStream nextPutAll: kwd; space].				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: ') ']					ifFalse: [aStream space]]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream dialect = #SQ00				ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Use']]				ifFalse: [aStream nextPutAll: '|'].			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].			aStream dialect = #SQ00				ifTrue: [aStream nextPutAll: '.']				ifFalse: [aStream nextPutAll: ' |']].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "			[aStream crtab: 1.			self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:35'!printPragmasOn: aStream	properties ifNil: [^self].	properties pragmas do:		[:pragma|		"Primitives are printed in printPrimitiveOn:; skip these"		(Parser primitivePragmaSelectors includes: pragma keyword) ifFalse:			[aStream crtab: 1.			 pragma printOn: aStream]]! !!MethodNode methodsFor: 'printing' stamp: 'eem 1/23/2010 14:08'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primDecl |	primitive = 0 ifTrue:		[^self].	primitive = 120 ifTrue: "External call spec"		[^aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primitive = 117		ifTrue:			[primDecl := encoder literals at: 1.			 (primDecl at: 2) asString printOn: aStream.			 (primDecl at: 1) ifNotNilDo:				[:moduleName|				aStream nextPutAll:' module: '.				moduleName asString printOn: aStream]]		ifFalse:			[aStream print: primitive].	self primitiveErrorVariableName ifNotNilDo:		[:primitiveErrorVariableName|		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "',							((cls classPool at: #PrimitiveTable) at: primitive + 1),							'" ']! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:25'!printPropertiesOn: aStream	properties ifNil: [^self].	properties propertyKeysAndValuesDo:		[:prop :val|		aStream crtab; nextPut: $<.		prop = #on:in:			ifTrue:				[prop keywords with: val do:					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]			ifFalse:				[prop = #on					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 		aStream nextPut: $>]! !!MethodNode methodsFor: 'accessing' stamp: 'eem 1/19/2009 10:28'!primitiveErrorVariableName	"Answer the primitive error code temp name, or nil if none."	(primitive isInteger and: [primitive > 0]) ifTrue:		[properties pragmas do:			[:pragma| | kwds ecIndex |			((kwds := pragma keyword keywords) first = 'primitive:'			and: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:				[^pragma argumentAt: ecIndex]]].	^nil	"(Parser new parse: (MethodNode sourceCodeAt: #primitiveErrorVariableName) class: Parser) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: ''foo''> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: ''foo'' error: foo module: ''bar''> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: ''foo'' module: ''bar'' error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) generate"! !!MethodNode methodsFor: 'accessing' stamp: 'eem 6/11/2009 17:27'!removeProperty: aSymbol	properties := properties copyWithout: (Association											key: aSymbol											value: (properties propertyValueAt: aSymbol))! !!MethodNode methodsFor: 'primitive error codes' stamp: 'eem 1/23/2010 14:09'!removeAndRenameLastTempIfErrorCode	self primitiveErrorVariableName ifNotNilDo:		[:primitiveErrorVariableName|		 temporaries last			name: primitiveErrorVariableName			key: primitiveErrorVariableName			code: temporaries last code.		 temporaries removeLast]! !!MethodReference methodsFor: 'queries' stamp: 'ab 5/23/2003 22:58'!category	^ self actualClass organization categoryOfElement: methodSymbol! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:55'!asMethodDefinition	^ MCMethodDefinition forMethodReference: self! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58'!compiledMethod	^ self actualClass compiledMethodAt: methodSymbol! !!MethodReference methodsFor: '*monticello' stamp: 'al 10/9/2005 20:05'!isLocalSelector	^self actualClass		includesLocalSelector: self methodSymbol! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:59'!source	^ (self actualClass sourceCodeAt: methodSymbol) asString withSqueakLineEndings! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58'!timeStamp	^ self compiledMethod timeStamp! !!MidiInputMorph methodsFor: 'as yet unclassified' stamp: 'bf 9/14/2010 15:09'!disableReverb: aBoolean	Preferences setPreference: #soundReverb toValue: aBoolean not! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemDef	mDefMemo _ Array new: stream size + 1 withAll: Untried.	mDefNextPos _ Array new: stream size + 1! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemExpr	mExprMemo _ Array new: stream size + 1 withAll: Untried.	mExprNextPos _ Array new: stream size + 1! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemExpr1	mExpr1Memo _ Array new: stream size + 1 withAll: Untried.	mExpr1NextPos _ Array new: stream size + 1! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemExpr2	mExpr2Memo _ Array new: stream size + 1 withAll: Untried.	mExpr2NextPos _ Array new: stream size + 1! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemExpr3	mExpr3Memo _ Array new: stream size + 1 withAll: Untried.	mExpr3NextPos _ Array new: stream size + 1! !!MMetaParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemExpr4	mExpr4Memo _ Array new: stream size + 1 withAll: Untried.	mExpr4NextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializecomment	commentMemo _ Array new: stream size + 1 withAll: Untried.	commentNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaChar	metaCharMemo _ Array new: stream size + 1 withAll: Untried.	metaCharNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaCode	metaCodeMemo _ Array new: stream size + 1 withAll: Untried.	metaCodeNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaName	metaNameMemo _ Array new: stream size + 1 withAll: Untried.	metaNameNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaSpecial	metaSpecialMemo _ Array new: stream size + 1 withAll: Untried.	metaSpecialNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaString	metaStringMemo _ Array new: stream size + 1 withAll: Untried.	metaStringNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializemetaSymbol	metaSymbolMemo _ Array new: stream size + 1 withAll: Untried.	metaSymbolNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializetoken	tokenMemo _ Array new: stream size + 1 withAll: Untried.	tokenNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializetokenize	tokenizeMemo _ Array new: stream size + 1 withAll: Untried.	tokenizeNextPos _ Array new: stream size + 1! !!MMetaTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializewhitespace	whitespaceMemo _ Array new: stream size + 1 withAll: Untried.	whitespaceNextPos _ Array new: stream size + 1! !!MOFile methodsFor: 'public' stamp: 'yo 8/27/2008 13:09'!atRandom	^ self translatedString:nStrings atRandom.! !!MOFile methodsFor: 'public' stamp: 'KR 10/4/2007 01:46'!fileName	^fileName! !!MOFile methodsFor: 'public' stamp: 'KR 10/16/2007 19:03'!fileName: path	fileName _ path! !!MOFile methodsFor: 'public' stamp: 'KR 10/16/2007 17:16'!load: aFileName localeID: id	"all of original/translated strings are loaded. 		but conversion of translation string (in utf-8 bytestring) to Squeak format will be defered.		original-string/index pairs are registerd to Dictionary on load time.		hash search can't be used"	| strm originalTable translatedTable |	localeID _ id.	strm_ FileStream readOnlyFileNamed: aFileName.	fileName _ aFileName.	[		self loadHeader: strm.		originalTable _ self loadStringPointers: strm 								offset: originalTableOffset.		originalStrings _ self loadStrings: strm 								pointers: originalTable.		translatedTable _ self loadStringPointers: strm 								offset: translatedTableOffset.		translatedStrings _ self loadStrings: strm 								pointers: translatedTable.		translations _ Dictionary new: nStrings * 2.  "make too enough room to avoid #grow"		1 to: nStrings do: [:index |			| key |			key _ originalStrings at: index.			translations at: key put: index.		].		originalStrings _ nil.	] ensure: [strm close].! !!MOFile methodsFor: 'public' stamp: 'KR 10/5/2007 01:41'!searchByDictionary: aString	| index |	index _ translations at: aString ifAbsent: [^nil].	^self translatedString: index	! !!MOFile methodsFor: 'public' stamp: 'Richo 5/26/2010 11:17'!translationFor: aString 	| |	aString size = 0 ifTrue: [^ '']. "Gettext header"	^ (self searchByDictionary: aString) ifNil: [aString]! !!MOFile methodsFor: 'private' stamp: 'KR 12/22/2007 09:18'!loadHeader: strm	strm binary.	magic _  strm uint32.	magic = 16rDE120495 		ifTrue: [isLittleEndian _ true]		ifFalse: [			magic = 16r950412DE 				ifTrue: [isLittleEndian _ false]				ifFalse: [ self error: 'invalid MO']		].	revision _ self nextInt32From: strm.	nStrings _ self nextInt32From: strm.	originalTableOffset _ self nextInt32From: strm.	translatedTableOffset _ self nextInt32From: strm.	hashTableSize _ self nextInt32From: strm.	hashTableOffset _ self nextInt32From: strm.! !!MOFile methodsFor: 'private' stamp: 'KR 10/16/2007 13:31'!loadStringPointers: strm offset: tableOffset	"returns tupple {arrayOfOffsetToString  arrayOfLengthOfString}"	| offsetTable lenTable len offset tupple |	offsetTable _ IntegerArray new: nStrings.	lenTable _ IntegerArray new: nStrings.	strm binary.	strm position: tableOffset.	1 to: nStrings do: [:index |		len _ self nextInt32From: strm.		offset _ self nextInt32From: strm.		offsetTable at: index put: offset.		lenTable at: index put: len.	].	tupple _ Array new: 2.	tupple at: 1 put: offsetTable.	tupple at: 2 put:  lenTable.	^tupple! !!MOFile methodsFor: 'private' stamp: 'KR 10/16/2007 17:08'!loadStrings: strm pointers: table	^self loadStrings: strm pointers: table encoding: nil languageEnvironment: nil! !!MOFile methodsFor: 'private' stamp: 'KR 10/16/2007 16:56'!loadStrings: strm pointers: tupple encoding: encodingName languageEnvironment: env	| strings rawStr str offsetTable lenTable |	offsetTable _  tupple first.	lenTable _ tupple second.	strings _ Array new: nStrings.	1 to: nStrings do: [:index |		rawStr _ self loadString: strm 					pointer:  (offsetTable at: index)					length: (lenTable at: index).		str _ encodingName isNil ifTrue: [rawStr] 						ifFalse: [ encodingName = 'utf8' 									ifTrue: [rawStr utf8ToSqueak applyLanguageInfomation: env]									ifFalse: [self error: 'this encoding isn''t supported']						].		strings at: index put: str.	].	^strings.! !!MOFile methodsFor: 'private' stamp: 'KR 12/12/2007 13:14'!loadString: strm pointer: top  length: len	| str |	str _ ByteString new: len.	strm position:  top.	strm nextInto: str.	^str replaceAll: Lf with: Cr.! !!MOFile methodsFor: 'private' stamp: 'KR 10/4/2007 00:27'!nextInt32From: strm	^isLittleEndian 			ifTrue: [^strm nextLittleEndianNumber: 4]			ifFalse: [^strm nextInt32]! !!MOFile methodsFor: 'private' stamp: 'KR 10/16/2007 13:41'!originalString: index	^originalStrings at: index.! !!MOFile methodsFor: 'private' stamp: 'KR 10/17/2007 13:16'!translatedString: index	"KNOWN PROBLEM: conversion is executed everytimes this method called"	| str |	str _ translatedStrings at: index.	^str utf8ToSqueak applyLanguageInfomation: (Locale localeID: localeID) languageEnvironment.! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/4/2007 00:18'!hashPjw: aString	"So called `hashpjw' function by P.J. Weinberger   	[see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,   	1986, 1987 Bell Telephone Laboratories, Inc.] "	| stringSize hash g |	stringSize _ aString size.	hash _ 0.	1 to: stringSize do: [:pos |		hash _ hash bitShift: 4.		hash _ hash + ((aString at: pos) asInteger).		g _ hash bitAnd: 16rF0000000.		g = 0 ifFalse: [			hash _ hash  bitXor: (g bitShift: -24).			hash _ hash bitXor: g.		]	].	^hash.! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/16/2007 17:40'!load1: aFileName localeID: id	"CASE1: 		all of strings are loaded. 		translation strings are converted to Squeak format on load time.		original-string/index pairs are registerd to Dictionary on load time.		hash search can't be used"	| strm originalTable translatedTable |	localeID _ id.	strm_ FileStream readOnlyFileNamed: aFileName.	fileName _ aFileName.	[		self loadHeader: strm.		originalTable _ self loadStringPointers: strm 								offset: originalTableOffset.		originalStrings _ self loadStrings: strm 								pointers: originalTable.		translatedTable _ self loadStringPointers: strm 								offset: translatedTableOffset.		translatedStrings _ self loadStrings: strm 								pointers: translatedTable								encoding: 'utf8'								languageEnvironment: (Locale localeID: localeID) languageEnvironment .		translations _ Dictionary new.		1 to: nStrings do: [:index |			| key |			key _ originalStrings at: index.			translations at: key put: index.		].		originalTable _ nil.	] ensure: [strm close].! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/16/2007 17:33'!load4: aFileName localeID: id	"CASE4: 		all of strings are loaded. 		loading and conversion of translation strings to Squeak format is executed on initialization time.		only hash search can be used"	| strm originalTable translatedTable |	localeID _ id.	strm_ FileStream readOnlyFileNamed: aFileName.	fileName _ aFileName.	[		self loadHeader: strm.		self loadHashTable: strm.		originalTable _ self loadStringPointers: strm 								offset: originalTableOffset.		originalStrings _ self loadStrings: strm 								pointers: originalTable.		translatedTable _ self loadStringPointers: strm 								offset: translatedTableOffset.		translatedStrings _ self loadStrings: strm 								pointers: translatedTable								encoding: 'utf-8'								languageEnvironment: (Locale localeID: localeID) languageEnvironment .	] ensure: [strm close].! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/4/2007 00:27'!loadHashTable: strm	| entry |	hashTable _ IntegerArray  ofSize: hashTableSize.	strm binary.	strm position: hashTableOffset.	1 to: hashTableSize do: [:index |		entry _ self nextInt32From: strm.		hashTable at:  index put: entry.	]! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/5/2007 01:43'!searchByHash: aString	| hashValue nstr index incr key |	hashValue _  self hashPjw: aString.	incr _ 1 + (hashValue \\ (hashTableSize -2)).	index _ (hashValue \\ hashTableSize) .	[ 	nstr _ (hashTable at: index +1 ).		nstr = 0 ifTrue: [^nil].		key _ self originalString: nstr.		key = aString ifTrue: [^self translatedString: nstr].		index >= (hashTableSize - incr) 				ifTrue: [index _ index - (hashTableSize - incr)  ]				ifFalse:[index _ index + incr].		] doWhileTrue: true.! !!MOFile methodsFor: 'experimental' stamp: 'tak 10/18/2007 21:15'!testSearchByDictionary	InternalTranslator allKnownPhrases 		do: [:each |			self searchByDictionary: each		].	! !!MOFile methodsFor: 'experimental' stamp: 'tak 10/18/2007 21:15'!testSearchByHash	InternalTranslator allKnownPhrases 		do: [:each |			self searchByHash: each		].	! !!MOFile methodsFor: 'experimental' stamp: 'KR 10/5/2007 02:02'!translateByHash: aString	| trans |	trans _ self searchByHash: aString.	trans isNil ifTrue: [^aString]			ifFalse: [^trans].! !!MOFile commentStamp: '<historical>' prior: 0!Wrapper for MO file of gettext.Known limitation:  	currently don't support prural form.	translation strings have to be encoded in utf-8.Implementation notes:	Testing on XO showed emulation of hash search without plugin + on demand loading is slow.	The test also showed conversion of utf8 string to Squeak's String is really slow (especially for non-latin language).	so in this version, all of original/translated strings are loaded on initiaization,	but "translated strings" is left as ByteString on loading time, to reduce loading time.	After that the translated string is converted on demand. !!MOFile class methodsFor: 'instance creation' stamp: 'KR 10/16/2007 19:05'!fileName: path localeID: id	^self new 			load:path localeID: id! !!MOFile class methodsFor: 'class initialization' stamp: 'KR 12/12/2007 13:13'!initialize	Cr := Character cr.	Lf := Character lf.! !!Morph methodsFor: 'WiW support' stamp: 'yo 8/3/2009 20:17'!addMorphInLayer: aMorph centeredNear: aPoint	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."	| trialRect delta |	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.	delta _ trialRect amountToTranslateWithin: bounds.	aMorph position: trialRect origin + delta.	self addMorphInLayer: aMorph.! !!Morph methodsFor: 'classification' stamp: 'sw 3/24/2009 13:15'!defersHaloToInteriorMorph: aMorph	"Answer whether  when a halo-click goes down over some subobject within me, I should defer to it rather than seize the halo myself."	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'yo 8/24/2009 22:45'!vanishAfterSlidingTo: aPosition event: evt	"Slide the receiver to the given position and then remove it."	| aForm aWorld startPoint endPoint |	aForm _ self imageForm offset: 0@0.	(aWorld _ self world) ifNil: [^ self].  "Happens with interrupted replay"	startPoint _ evt hand fullBounds origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	"The OLPC Virtual Screen wouldn't notice the last update here."	Display forceToScreen: (endPoint extent: self extent).	Preferences soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'events-processing' stamp: 'bf 6/24/2010 15:17'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	(anEvent controlKeyPressed			and: [anEvent blueButtonChanged not				and: [Preferences cmdGesturesEnabled]])		ifTrue: [^ self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].		"this mouse down could be the start of a gesture, or the end of a gesture focus"	(self isGestureStart: anEvent)		ifTrue: [^ self gestureStart: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'fileIn/out' stamp: 'Richo 7/16/2010 17:14'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName ok |	aFileName := self knownName ifNil: 		[('my {1}' translated format: {self class name})].	aFileName := aFileName asFileName.	aFileName _ FillInTheBlank request: 'File name? (".morph" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok _ aFileName endsWith: '.morph'.	"don't double them"	ok _ ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName _ aFileName,'.morph'].	self saveOnFile: aFileName.! !!Morph methodsFor: 'fileIn/out' stamp: 'Richo 7/27/2010 15:17'!saveOnFile: fileName 	| file |	file := [[FileStream newFileNamed: fileName]				on: FileExistsException				do: [:err | err defaultAction]]				on: Error				do: [:err | ^ self].	[file		nextPutAll: (SmartRefStream streamedRepresentationOf: self topRendererOrSelf)]		ensure: [file close]! !!Morph methodsFor: 'geometry' stamp: 'kfr 11/28/2009 17:14'!overlapsShadowForm: itsShadow bounds: itsBounds	"Answer true if itsShadow and my shadow overlap at all"	| overlapExtent overlap myRect myShadow goalRect goalShadow bb |	overlap _ self fullBounds intersect: itsBounds.	overlapExtent _ overlap extent.	overlapExtent > (0 @ 0)		ifFalse: [^ false].	myRect := overlap translateBy: 0 @ 0 - self topLeft.	myShadow := (self imageForm contentsOfArea: myRect) stencil.	goalRect := overlap translateBy: 0 @ 0 - itsBounds topLeft.	goalShadow := (itsShadow contentsOfArea: goalRect) stencil.			"compute a pixel-by-pixel AND of the two stencils.  Result will be black 			(pixel value = 1) where black parts of the stencils overlap"			bb := BitBlt toForm: myShadow.			bb 				copyForm: goalShadow				to: 0 @ 0				rule: Form and.		^(bb destForm tallyPixelValues second) > 0 ! !!Morph methodsFor: 'menus' stamp: 'sw 8/6/2009 18:35'!addHaloActionsTo: aMenu	"Add items to aMenu representing actions requestable via halo"	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu addTitle: self externalName.	subMenu addStayUpItemSpecial.	subMenu addLine.	subMenu add: 'delete' translated action: #dismissViaHalo.	subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!!' translated.	self maybeAddCollapseItemTo: subMenu.	subMenu add: 'grab' translated action: #openInHand.	subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' translated.	subMenu addLine.	subMenu add: 'resize' translated action: #resizeFromMenu.	subMenu balloonTextForLastItem: 'Change the size of this object' translated.	subMenu add: 'duplicate' translated action: #maybeDuplicateMorph.	subMenu balloonTextForLastItem: 'Hand me a copy of this object' translated.	"Note that this allows access to the non-instancing duplicate even when this is a uniclass instance"	self couldMakeSibling ifTrue:		[subMenu add: 'make a sibling' translated action: #handUserASibling.		subMenu balloonTextForLastItem: 'Make a new sibling of this object and hand it to me' translated].	subMenu addLine.	subMenu add: 'property sheet' translated target: self renderedMorph action: #openAPropertySheet.	subMenu balloonTextForLastItem: 'Open a property sheet for me. Allows changing lots of stuff at once.' translated.	subMenu add: 'set color' translated target: self renderedMorph action: #changeColor.	subMenu balloonTextForLastItem: 'Change the color of this object' translated.	subMenu add: 'viewer' translated target: self action: #beViewed.	subMenu balloonTextForLastItem: 'Open a Viewer that will allow everything about this object to be seen and controlled.' translated.	subMenu add: 'tile browser' translated target: self action: #openInstanceBrowserWithTiles.	subMenu balloonTextForLastItem: 'Open a tool that will facilitate tile scripting of this object.' translated.	subMenu add: 'tile representing this object' translated target: self action: #tearOffTile.	subMenu balloonTextForLastItem: 'Hand me a tile represting this object' translated.	subMenu addLine.	subMenu add: 'inspect' translated target: self action: #inspect.	subMenu balloonTextForLastItem: 'Open an Inspector on this object' translated.	aMenu add: 'halo actions...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'wiz 8/10/2010 02:10'!addPaintingItemsTo: aMenu hand: aHandMorph	"Add items relating to the painting subsystem to the given menu"	| subMenu movies |	subMenu _ MenuMorph new defaultTarget: self.	subMenu addTranslatedList: #(		('repaint' editDrawing)	"	('set form by grabbing from screen' setFormByGrabbingFromScreen)"		-		('set rotation center' setRotationCenter)		('reset forward-direction' resetForwardDirection)		('set rotation style' setRotationStyle)		-		('erase pixels of color' erasePixelsOfColor:)		('recolor pixels of color' recolorPixelsOfColor:)		('reduce color palette' reduceColorPalette:)		-		('add a border around this shape...' addBorderToShape:)		('restore original aspect ratio' restoreOriginalAspectRatio)) translatedNoop.	movies _		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translatedNoop action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'meta-actions' stamp: 'sw 3/24/2009 13:18'!handlerForBlueButtonDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.	Note: Halos handle blue button events themselves so we will only be asked if there is currently no halo on top of us."	self wantsHaloFromClick ifFalse:[^nil].	anEvent handler ifNil:[^self].	(anEvent handler defersHaloToInteriorMorph: self) ifTrue:		[^ self]. "by default exclude playfields and books, allowing innermost clicked-on morph to get the halo."	(anEvent shiftPressed)		ifFalse:[^nil] "let outer guy have it"		ifTrue:[^self] "let me have it"! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 11/9/2006 23:04'!potentialTargetsAt: aPoint 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| realOwner |	realOwner := self topRendererOrSelf	owner		ifNil: [^ #()].	^ realOwner		morphsAt: aPoint		! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 8/12/2010 22:30'!sightTargets: event 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| bullseye menu |	owner		ifNil: [^ #()].	bullseye := Point fromUser.    	menu := CustomMenu new.	(self potentialTargetsAt: bullseye)		do: [:m | menu				add: (m knownName						ifNil: [m class name asString])				action: m] .	self targetFromMenu: menu popupAt: bullseye! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 8/12/2010 22:35'!sightWorldTargets: event 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| bullseye myWorld menu |	myWorld := self world		ifNil: [^ #()].	bullseye := Point fromUser.	menu := CustomMenu new.	(myWorld potentialTargetsAt: bullseye)		do: [:m | menu				add: (m knownName						ifNil: [m class name asString])				action: m] .	self targetFromMenu: menu popupAt: bullseye! !!Morph methodsFor: 'meta-actions' stamp: 'bf 8/14/2010 19:41'!targetFromMenu: aMenu popupAt: aPoint 	"Some other morph become target of the receiver"	| newTarget caption |	caption := 'Target for {1}' translated format: {self externalName}.	newTarget := aMenu startUpWithCaption: caption at: aPoint .	newTarget		ifNil: [^ self].	self target: newTarget! !!Morph methodsFor: 'structure' stamp: 'sw 4/2/2009 14:56'!pasteUpMorphHandlingTabAmongFields	"For the purpose of determing how to service a 'tab' character hit  within some text field, answer the nearest PasteUpMorph in my owner chain that would want to interpret the tab key as an attempt to navigate from field to field.  Unless some playfield, book-page, or some such, has explicitly had its #tabAmongFields property set, this will normally be the World.  Note that the only situation in which nil will be returned by this method is if the #tabAmongFields preference is set to false *and* there is no pasteup in the owner chain of the text-morph into which the tab-key was it which itself has the #tabAmongFields property."	| aPasteUp next |	aPasteUp _ self pasteUpMorphOrWorld.	[aPasteUp notNil] whileTrue:		[((aPasteUp hasProperty: #tabAmongFields) or: [aPasteUp isWorldMorph and: [Preferences tabAmongFields]]) ifTrue:			[^ aPasteUp].		next := aPasteUp pasteUpMorphOrWorld.		next == aPasteUp ifTrue: [^ nil].		aPasteUp := next].	^ nil! !!Morph methodsFor: '*Etoys-scripting' stamp: 'kfr 6/2/2010 00:33'!filterViewerCategoryDictionary: dict	"dict has keys of categories and values of priority.	You can  remove categories here."		self wantsConnectionVocabulary		ifFalse: [ dict removeKey: #'connections to me' ifAbsent: [].			dict removeKey: #connection ifAbsent: []].	self wantsConnectorVocabulary		ifFalse: [ dict removeKey: #connector ifAbsent: [] ].	self wantsEmbeddingsVocabulary		ifFalse: [dict removeKey: #embeddings ifAbsent: []].	self isWorldMorph ifFalse:		[dict removeKey: #'world geometry' ifAbsent: []].	Preferences eToyFriendly ifTrue:		[#(layout preferences display #'as object') do:			[:sym | dict removeKey: sym ifAbsent: []].	self isWorldMorph ifFalse:[		dict removeKey: #preferences ifAbsent: []].		dict removeKey: #display ifAbsent: []]! !!Morph methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/9/2006 17:11'!isMorphCostume	^false! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 6/17/2010 00:01'!bubble	^self valueOfProperty: #bubble ifAbsent: [nil].! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/31/2010 10:28'!bubble: aSpeechBubbleMorphself setProperty: #bubble toValue: aSpeechBubbleMorph ! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:51'!sayGraphic: aFormself showGraphic: aForm inBubbleType: #speech! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/6/2010 15:44'!sayObject: aPlayerself showObject: aPlayer inBubbleType: #speech! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 6/16/2010 21:37'!say: aStringself showMessage: aString inBubbleType: #speech! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/31/2010 10:29'!showGraphic: aForm inBubbleType: typeSymbol| currentBubble |currentBubble := self bubble.currentBubble notNil ifTrue: [	(currentBubble form = aForm and: [currentBubble type = typeSymbol and: [currentBubble isInWorld]]) ifTrue: [^self].	currentBubble delete].self bubble: (SpeechBubbleMorph form: aForm type: typeSymbol for: self).! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/31/2010 10:29'!showMessage: aString inBubbleType: typeSymbol| currentBubble |currentBubble := self bubble.currentBubble notNil ifTrue: [	(currentBubble string = aString and: [currentBubble type = typeSymbol and: [currentBubble isInWorld]]) ifTrue: [^self].	currentBubble delete].aString isEmpty ifTrue: [^self removeProperty: #bubble].self bubble: (SpeechBubbleMorph string: aString type: typeSymbol for: self)! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/31/2010 10:29'!showObject: aPlayer inBubbleType: typeSymbol| currentBubble morph |morph := aPlayer costume renderedMorph.currentBubble := self bubble.currentBubble notNil ifTrue: [	(currentBubble msgMorph = morph and: [currentBubble type = typeSymbol and: [currentBubble isInWorld]]) ifTrue: [^self].	currentBubble delete].self bubble: (SpeechBubbleMorph morph: morph  type: typeSymbol for: self).! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/31/2010 12:03'!stopSayingOrThinking| currentBubble |currentBubble := self bubble.currentBubble isNil ifTrue: [^self].currentBubble topRendererOrSelf delete.self bubble: nil! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:52'!thinkGraphic: aFormself showGraphic: aForm inBubbleType: #thought! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/6/2010 15:44'!thinkObject: aPlayerself showObject: aPlayer inBubbleType: #thought! !!Morph methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 6/16/2010 21:37'!think: aStringself showMessage: aString inBubbleType: #thought! !!Morph class methodsFor: 'fileIn/Out' stamp: 'Richo 7/20/2010 09:42'!fromFileName: fullName	| file |	[file := FileStream readOnlyFileNamed: fullName.	[(Morph fromStreamedRepresentation: file contents) openInWorld] ensure: [file close].	] on: Error do: [self inform: 'The file doesn''t exists']! !!Morph class methodsFor: 'fileIn/Out' stamp: 'Richo 7/20/2010 09:43'!fromStreamedRepresentation: aString	^SmartRefStream objectFromStreamedRepresentation: aString! !!Morph class methodsFor: 'scripting' stamp: 'sw 5/18/2009 01:38'!additionsToViewerCategoryMoreGeometry	"answer additions to the more geometry viewer category"	^ #(#'more geometry' 		(			(slot location 'The position of the object, expressed as a point' Point readWrite Player getLocationRounded Player setLocation:)			(slot  length  'The length' Number readWrite Player getLength  Player  setLength:) 			(slot  width  'The width' Number readWrite Player getWidth  Player  setWidth:)			(slot headingTheta 'The angle, in degrees, that my heading vector makes with the positive x-axis' Number readWrite Player getHeadingTheta Player setHeadingTheta:)			(slot distance 'The length of the vector connecting the origin to the object''s position' Number readWrite Player getDistance Player setDistance:)			(slot theta 'The angle between the positive x-axis and the vector connecting the origin to the object''s position' Number readWrite Player getTheta Player setTheta: )			(slot rotationCenterX 'The x coordinate of rotation center in parent''s coordinate system.' Number readWrite Player getRotationCenterX Player setRotationCenterX: )			(slot rotationCenterY 'The y coordinate of rotation center in parent''s coordinate system.' Number readWrite Player getRotationCenterY Player setRotationCenterY: )			"(command forceAxisToX: 'Force change x of axis for rotation' Number )			(command forceAxisToY: 'Force change y of axis for rotation' Number )"		)	)! !!Morph class methodsFor: '*eToys-scripting' stamp: 'sw 5/16/2009 05:42'!additionsToViewerCategoryGeometry	"answer additions to the geometry viewer category"	^ #(geometry 		(			(slot x   'The x coordinate' Number readWrite Player  getX   Player setX:)			(slot y   'The y coordinate' Number readWrite Player  getY  Player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' Number readWrite Player getHeading  Player setHeading:)			(slot  scaleFactor 'The factor by which the object is magnified' Number readWrite Player getScaleFactor Player setScaleFactor:)			(slot  left   'The left edge' Number readWrite Player getLeft  Player  setLeft:)			(slot  right  'The right edge' Number readWrite Player getRight  Player  setRight:)			(slot  top  'The top edge' Number readWrite Player getTop  Player  setTop:) 			(slot  bottom  'The bottom edge' Number readWrite Player getBottom  Player  setBottom:) 			(slot forwardDirection 'The angle of my forward direction without rotating myself' Number readWrite Player getForwardDirection Player setForwardDirection: )		)	)! !!Morph class methodsFor: '*eToys-scripting' stamp: 'sw 8/31/2009 17:21'!additionsToViewerCategoryMiscellaneous	"Answer viewer additions for the 'miscellaneous' category"	^#(		miscellaneous 		(			(command doMenuItem: 'do the menu item' Menu)			(command show 'make the object visible')			(command hide 'make the object invisible')		"	(command wearCostumeOf: 'wear the costume of...' Player)"			(command fire 'trigger any and all of this object''s button actions')			(slot copy 'returns a copy of this object' Player readOnly Player getNewClone	 unused unused)			(slot elementNumber 'my index in my container' Number readWrite Player getIndexInOwner Player setIndexInOwner:)			(slot holder 'the object''s container' Player readOnly Player getHolder Player setHolder:)			(command stamp 'add my image to the pen trails')			(command erase 'remove this object from the screen')			(command stampAndErase 'add my image to the pen trails and go away')		)	)! !!Morph class methodsFor: '*eToys-scripting' stamp: 'Richo 8/16/2010 21:55'!additionsToViewerCategoryWorldGeometry	"answer additions to the geometry viewer category"	^ #( #'world geometry' 		(			(slot  length  'The length' Number readWrite Player getLength  Player  setLength:  ) 			(slot  width  'The width' Number readWrite Player getWidth  Player  setWidth:  )			(slot  left   'The left edge' Number readWrite Player getLeft  Player  setLeft:  )			(slot  right  'The right edge' Number readWrite Player getRight  Player  setRight:  )			(slot  top  'The top edge' Number readWrite Player getTop  Player  setTop:   ) 			(slot  bottom  'The bottom edge' Number readWrite Player getBottom  Player  setBottom:  ) 					)	)! !!Morph class methodsFor: '*eToys-scripting' stamp: 'sw 8/31/2009 17:22'!helpContributions	"Answer a list of pairs of the form (<symbol> <help message> ) to contribute to the system help dictionary"	"NB: Many of the items here are not needed any more since they're specified as part of command definitions now.  Someone needs to take the time to go through the list and remove items no longer needed.  But who's got that kind of time?"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new variable to the object')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(append:			'add an object to this container')		(prepend:			'add an object to this container')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(bounce			'If object strayed beyond the boundaries of its container, make it reflect back into it')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(clearOwnersPenTrails			'Clear all the pen trails in my container.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(copy			'Return a new object that is very much like this one')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(doMenuItem:			'Do a menu item, the same way as if it were chosen manually')		(doScript:			'Perform the given script once, on the next tick.')		(elementNumber			'My element number as seen by my owner')		(fire			'Run any and all button-firing scripts of this object')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCardInStack			'Go to the next card')		(goToPreviousCardInStack			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(insertCard			'Create a new card.')		(nextPage			'Go to next page.')		(numberAtCursor			'The number held by the object at the chosen element')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(obtrudes			'Whether any part of the object sticks out beyond its container''s borders')		(offerScriptorMenu			'The Scriptee.Press here to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(clearPenTrails			'Clear all pen trails in the current playfield')		(playerSeeingColorPhrase			'The player who "sees" a given color')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(tellAllSiblings:			'send a message to all of my sibling instances')		(try			'Run this command once.' translatedNoop)		(tryMe			'Click here to run this script once; hold button down to run repeatedly'  translatedNoop)		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.')		(userSlot			'This is a variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Make this object''s appearance be the same as that of another object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!Morph class methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/14/2010 20:45'!additionsToViewerCategorySpeechBubbles	^#(		#'speech bubbles' 		(			(command sayText: 'Show a text in a speech bubble' String)			(command thinkText: 'Show a text in a thought bubble' String)			(command sayNumber: 'Show a number in a speech bubble' Number)			(command thinkNumber: 'Show a number in a thought bubble' Number)			(command sayGraphic: 'Show a picture in a speech bubble' Graphic)			(command thinkGraphic: 'Show a picture in a thought bubble' Graphic)			(command sayObject: 'Show an object in a speech bubble' Player)			(command thinkObject: 'Show an object in a thought bubble' Player)			(command stopSayingOrThinking 'Erase all speech bubbles attached to this object, if any')			(slot bubble 'The bubble currently attached to this object' Player readOnly Player getBubble Player unused)				))! !!MouseOverHandler methodsFor: '*DrGeoII-Core-accessing' stamp: 'HilaireFernandes 2/22/2006 21:27'!mouseOverMorphs	^mouseOverMorphs! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 6/5/2007 20:51'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt  targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MSExpParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializecomponent	componentMemo _ Array new: stream size + 1 withAll: Untried.	componentNextPos _ Array new: stream size + 1! !!MSExpParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializekeyword	keywordMemo _ Array new: stream size + 1 withAll: Untried.	keywordNextPos _ Array new: stream size + 1! !!MSExpParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializeksexp	ksexpMemo _ Array new: stream size + 1 withAll: Untried.	ksexpNextPos _ Array new: stream size + 1! !!MSExpParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializename	nameMemo _ Array new: stream size + 1 withAll: Untried.	nameNextPos _ Array new: stream size + 1! !!MSExpParser methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializestring	stringMemo _ Array new: stream size + 1 withAll: Untried.	stringNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializecharOrSequence	charOrSequenceMemo _ Array new: stream size + 1 withAll: Untried.	charOrSequenceNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializekeyword	keywordMemo _ Array new: stream size + 1 withAll: Untried.	keywordNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializename	nameMemo _ Array new: stream size + 1 withAll: Untried.	nameNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializeparen	parenMemo _ Array new: stream size + 1 withAll: Untried.	parenNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializestring	stringMemo _ Array new: stream size + 1 withAll: Untried.	stringNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializetoken	tokenMemo _ Array new: stream size + 1 withAll: Untried.	tokenNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializetokenize	tokenizeMemo _ Array new: stream size + 1 withAll: Untried.	tokenizeNextPos _ Array new: stream size + 1! !!MSExpTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializeunicodeOneSequence	unicodeOneSequenceMemo _ Array new: stream size + 1 withAll: Untried.	unicodeOneSequenceNextPos _ Array new: stream size + 1! !!MTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializechar	charMemo _ Array new: stream size + 1 withAll: Untried.	charNextPos _ Array new: stream size + 1! !!MTokenizer methodsFor: 'initializers' stamp: 'meta-auto 4/29/2010 12:12'!initializespace	spaceMemo _ Array new: stream size + 1 withAll: Untried.	spaceNextPos _ Array new: stream size + 1! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'ar 7/30/2009 22:13'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex 	"XXXX: The following is an interesting bug. All stopConditions exept #endOfRun		have lastIndex past the last character displayed. #endOfRun sets it *on* the character.		If we display up until lastIndex then we will also display invisible characters like		CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex		consistently) but I don't want to deal with the fallout right now so we keep the		fix minimally invasive."				to: (stopCondition == #endOfRun ifTrue:[lastIndex] ifFalse:[lastIndex-1])				at: lastPos kern: kern baselineY: baselineY].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done := true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!NaturalLanguageTranslator class methodsFor: 'accessing' stamp: 'bf 8/8/2010 13:17'!default	"Answer translator for backstop"	"self default translate: 'test'"	^ InternalTranslator new		localeID: (LocaleID isoLanguage: 'en')! !!NCPinMorph methodsFor: 'submorphs-accessing' stamp: 'bf 9/8/2009 03:35'!droppedIntoPasteUp: aMorph	| targets |	targets := (aMorph rootMorphsAt: self center) reject: [ :ea | ea isPinMorph ].	targets size < 1 ifTrue: [ ^self ].	WorldState addDeferredUIMessage: [ 		self isInWorld ifTrue: [self offerToEmbedIn: targets]].! !!Object methodsFor: 'accessing' stamp: 'Igor.Stasenko 11/13/2009 07:19'!enclosedSetElement	"The receiver is included into a set as an element. 	Since some objects require wrappers (see SetElement) to be able to be included into a Set,	a set sends this message to its element to make sure it getting real object,	instead of its wrapper.	Only SetElement instance or its subclasses allowed to answer something different than receiver itself"	! !!Object methodsFor: 'error handling' stamp: 'hg 10/2/2001 20:49'!notify: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Warning signal: aString	"nil notify: 'confirmation message'"! !!Object methodsFor: 'testing' stamp: 'eem 5/8/2008 11:13'!isArray	^false! !!Object methodsFor: 'testing' stamp: 'ar 2/28/2006 18:43'!isMethodProperties	^false! !!Object methodsFor: 'testing' stamp: 'dtl 2/10/2010 17:28'!isTextView	"True if the reciever is a view on a text model, such as a view on a TranscriptStream"	^false! !!Object methodsFor: 'testing' stamp: 'pmm 7/6/2006 20:46'!isTrait	"Return true if the receiver is a trait.	Note: Do not override in any class except TraitBehavior."	^false! !!Object methodsFor: '*monticello' stamp: 'dvf 8/10/2004 23:25'!isConflict	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/4/2006 09:51'!isAngleItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/16/2006 21:17'!isArcItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isCircleItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/1/2006 10:01'!isCompositeItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 11/13/2007 20:27'!isConstrainedPointItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isCurveItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isDirectionItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:24'!isFreePointItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/3/2006 10:53'!isGeometricItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:26'!isIntersectionPointItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isLineItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/25/2008 22:59'!isLocusItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 18:24'!isNumberItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 18:24'!isPointItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 3/10/2006 19:25'!isPointItemOnCurve	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/6/2006 21:16'!isPolygonItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isRayItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 8/3/2008 18:29'!isScriptItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isSegmentItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 2/2/2006 11:18'!isValueItem	^false! !!Object methodsFor: '*DrGeoII-Core-testing' stamp: 'HilaireFernandes 1/2/2006 16:17'!isVectorItem	^false! !!ObjectWithDocumentation methodsFor: 'accessing' stamp: 'bf 9/17/2010 15:22'!helpMessage	"Check if there is a getterSetterHelpMessage. 	Otherwise try the normal help message or return nil."	^ self getterSetterHelpMessage		ifNil: [(self propertyAt: #helpMessage ifAbsent:			[self legacyHelpMessage ifNil: [^ nil]]) translatedInDomain: 'Etoys-Tiles']! !!ObjectWithDocumentation methodsFor: 'accessing' stamp: 'Richo 8/16/2010 22:27'!wording	"Answer the receiver's wording"	| wording |	(wording := self propertyAt: #wording ifAbsent: [nil])		ifNotNil: [^wording translatedInDomain: 'Etoys-Tiles' or: 'Etoys'].	self initWordingAndDocumentation.	^self propertyAt: #wording ifAbsent: ['']! !!OLPCVirtualScreen methodsFor: 'private' stamp: 'bf 5/8/2010 11:49'!actualDisplay	"The display known to the VM"	^display ifNil: [self]! !!OLPCVirtualScreen class methodsFor: 'installing' stamp: 'yo 11/20/2009 11:11'!setupIfNeeded	self actualScreenSize = self virtualScreenExtent		ifFalse: [			(Display class ~= self or: [Display extent ~= self virtualScreenExtent]) ifTrue: [				self install]]		ifTrue: [Display class = self ifTrue: [self unInstall]]! !!OrderedCollection methodsFor: 'sorting' stamp: 'ul 11/2/2009 05:18'!sort: aSortBlock 	"Sort this collection using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one.	If aSortBlock is nil then <= is used for comparison."	self ifNotEmpty: [		array			mergeSortFrom: firstIndex			to: lastIndex			by: aSortBlock ]! !!PackageInfo methodsFor: 'testing' stamp: 'nk 4/28/2004 14:20'!category: categoryName matches: prefix	| prefixSize catSize |	categoryName ifNil: [ ^false ].	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'testing' stamp: 'bf 4/19/2010 02:54'!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:28'!extensionMethodsForClass: aClass	^ (self extensionCategoriesForClass: aClass)		gather: [:cat | self methodsInCategory: cat ofClass: aClass ]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:34'!includesChangeRecord: aChangeRecord	^ aChangeRecord methodClass notNil and:		[self			includesMethodCategory: aChangeRecord category			ofClass: aChangeRecord methodClass]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideCategory: aString	^ aString endsWith: '-override'! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideMethod: aMethodReference	^ self isOverrideCategory: aMethodReference category! !!PackageInfo methodsFor: 'testing' stamp: 'ar 12/23/2009 18:32'!isOverrideOfYourMethod: aMethodReference	"Answers true if the argument overrides a method in this package"	^ (self isYourClassExtension: aMethodReference category) not and:		[(self changeRecordForOverriddenMethod: aMethodReference) notNil]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:41'!methodsInCategory: aString ofClass: aClass 	^Array streamContents: [:stream |		self methodsInCategory: aString ofClass: aClass 			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'testing' stamp: 'nice 1/5/2010 14:01'!outsideClasses	^ProtoObject withAllSubclasses asSet difference: self classesAndMetaClasses! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:44'!overrideCategoriesForClass: aClass	^Array streamContents: [:stream |		self overrideCategoriesForClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/17/2002 00:05'!categoryName	|category|	category := self class category.	^ (category endsWith: '-Info')		ifTrue: [category copyUpToLast: $-]		ifFalse: [category]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 6/10/2003 17:21'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self packageName asLowercase]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:57'!packageName	^ packageName ifNil: [packageName := self categoryName]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:56'!packageName: aString	packageName := aString! !!PackageInfo methodsFor: 'listing' stamp: 'bp 2/26/2010 20:45'!allOverriddenMethods	"search classes and meta classes"	^ Array streamContents: [:stream |		self allOverriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'ac 5/14/2003 16:23'!classes	^(self systemCategories gather:		[:cat |		(SystemOrganization listAtCategoryNamed: cat)			collect: [:className | Smalltalk at: className]])				sortBy: [:a :b | a className <= b className]! !!PackageInfo methodsFor: 'listing' stamp: 'ul 11/13/2009 16:29'!classesAndMetaClasses	"Return a Set with all classes and metaclasses belonging to this package"	| baseClasses result |	baseClasses := self classes.	result := (Set new: baseClasses size * 2) 		addAll: baseClasses;		yourself.	baseClasses do: [ :c | 		result add: c classSide].	^result! !!PackageInfo methodsFor: 'listing' stamp: 'al 3/1/2006 21:51'!extensionClasses	^ self externalBehaviors reject: [:classOrTrait | (self extensionCategoriesForClass: classOrTrait) isEmpty]! !!PackageInfo methodsFor: 'listing' stamp: 'al 3/1/2006 21:51'!extensionMethods	^ self externalBehaviors gather: [:classOrTrait | self extensionMethodsForClass: classOrTrait]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:38'!foreignClasses	| s |	s := IdentitySet new.	self foreignSystemCategories		do: [:c | (SystemOrganization listAtCategoryNamed: c)				do: [:cl | 					| cls | 					cls := Smalltalk at: cl. 					s add: cls;					  add: cls class]].	^ s! !!PackageInfo methodsFor: 'listing' stamp: 'nice 1/1/2010 21:54'!methods	^ (self extensionMethods, self coreMethods) select: [:method |		method isValid			and: [method isLocalSelector			and: [method methodSymbol isDoIt not]]]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 17:40'!overriddenMethods	^ Array streamContents: [:stream |		self overriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:43'!overriddenMethodsInClass: aClass	^Array streamContents: [:stream |		self overriddenMethodsInClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'nk 5/1/2004 08:40'!overrideMethods	^ self extensionMethods select: [:ea | self isOverrideMethod: ea]! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 6/10/2003 17:18'!externalClasses	| myClasses |	myClasses := self classesAndMetaClasses.	^ Array streamContents:		[:s |		ProtoObject withAllSubclassesDo:			[:class |			(myClasses includes: class) ifFalse: [s nextPut: class]]]! !!PackageInfo methodsFor: 'dependencies' stamp: 'nice 12/26/2009 19:07'!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			| refs |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'dependencies' stamp: 'cwp 11/13/2002 00:24'!externalSubclasses	| pkgClasses subClasses |	pkgClasses := self classes.	subClasses := Set new.	pkgClasses do: [:c | subClasses addAll: (c allSubclasses)].	^ subClasses difference: pkgClasses! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:40'!addCoreMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: category		suppressIfDefault: false! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:17'!addExtensionMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: self methodCategoryPrefix, '-', category! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:39'!baseCategoryOfMethod: aMethodReference	| oldCat oldPrefix tokens | 	oldCat := aMethodReference category.	({ 'as yet unclassified'. 'all' } includes: oldCat) ifTrue: [ oldCat := '' ].	tokens := oldCat findTokens: '*-' keep: '*'.	"Strip off any old prefixes"	((tokens at: 1 ifAbsent: [ '' ]) = '*') ifTrue: [		[ ((tokens at: 1 ifAbsent: [ '' ]) = '*') ]			whileTrue: [ tokens removeFirst ].		oldPrefix := tokens removeFirst asLowercase.		[ (tokens at: 1 ifAbsent: [ '' ]) asLowercase = oldPrefix ]			whileTrue: [ tokens removeFirst ].	].	tokens isEmpty ifTrue: [^ 'as yet unclassified'].	^ String streamContents:		[ :s |		tokens			do: [ :tok | s nextPutAll: tok ]			separatedBy: [ s nextPut: $- ]]! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 21:42'!externalBehaviors	^self externalClasses , self externalTraits! !!PackageInfo methodsFor: 'modifying' stamp: 'nice 12/26/2009 19:07'!externalTraits	^ Array streamContents: [:s |		| behaviors |		behaviors := self classesAndMetaClasses.		Smalltalk allTraits do: [:trait |			(behaviors includes: trait) ifFalse: [s nextPut: trait].			(behaviors includes: trait classSide) ifFalse: [s nextPut: trait classSide]]].			! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 22:43'!hasPostscript	^ postscript notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:43'!hasPostscriptOfRemoval	^ postscriptOfRemoval notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 22:39'!hasPreamble	^ preamble notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:43'!hasPreambleOfRemoval	^ preambleOfRemoval notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 12:55'!name^ self packageName! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 23:23'!postscript^ postscript ifNil: [postscript := StringHolder new contents: '"below, add code to be run after the loading of this package"'].! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 23:14'!postscriptOfRemoval^ postscriptOfRemoval ifNil: [postscriptOfRemoval := StringHolder new contents: '"below, add code to clean up after the unloading of this package"']! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:45'!postscriptOfRemoval: aStringpostscriptOfRemoval := StringHolder new contents: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:44'!postscript: aStringpostscript := StringHolder new contents: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 23:27'!preamble	^ preamble ifNil: [preamble := StringHolder new contents: '"below, add code to be run before the loading of this package"'].! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 23:15'!preambleOfRemoval^ preambleOfRemoval ifNil: [preambleOfRemoval := StringHolder new contents: '"below, add code to prepare for the unloading of this package"']! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/19/2005 00:41'!preambleOfRemoval: aStringpreambleOfRemoval := StringHolder new contents: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/19/2005 00:37'!preamble: aStringpreamble := StringHolder new contents: aString! !!PackageInfo methodsFor: 'enumerating' stamp: 'bp 2/26/2010 20:47'!allOverriddenMethodsDo: aBlock	"Evaluates aBlock with all the overridden methods in the system"	^ ProtoObject withAllSubclassesDo: [:class | 		self overriddenMethodsInClass: class do: aBlock]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:29'!methodsInCategory: aString ofClass: aClass do: aBlock	((aClass organization listAtCategoryNamed: aString) ifNil: [^self])		do: [:sel | aBlock value: (self referenceForMethod: sel ofClass: aClass)]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bp 2/26/2010 20:46'!overriddenMethodsDo: aBlock	"Enumerates the methods the receiver contains which have been overridden by other packages"	^ self allOverriddenMethodsDo: [:ea |		(self isOverrideOfYourMethod: ea)			ifTrue: [aBlock value: ea]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:35'!overriddenMethodsInClass: aClass do: aBlock	"Evaluates aBlock with the overridden methods in aClass"	^ self overrideCategoriesForClass: aClass do: [:cat |		self methodsInCategory: cat ofClass: aClass do: aBlock]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:28'!overrideCategoriesForClass: aClass do: aBlock	"Evaluates aBlock with all the *foo-override categories in aClass"	^ aClass organization categories do: [:cat |		(self isOverrideCategory: cat) ifTrue: [aBlock value: cat]]! !!PackageInfo methodsFor: 'source code management' stamp: 'bp 2/26/2010 21:14'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	^self methods inject: 0 into: [:sum :each | sum + each compiledMethod linesOfCode]! !!PackageInfo methodsFor: 'printing' stamp: 'bp 2/26/2010 20:37'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self packageName;		nextPut: $)! !!PackageInfo commentStamp: '<historical>' prior: 0!Subclass this class to create new Packages.!!PackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 11/14/2002 15:05'!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageList methodsFor: 'morphic' stamp: 'avi 2/18/2004 00:28'!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	window addMorph: self buildList fullFrame: (LayoutFrame fractions: (0@0 corner: 1@1)).	^ window! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:41'!packageSelection: aNumber	selectedPackage := self packages at: aNumber ifAbsent: [].	self changed: #packageSelection! !!PackageList methodsFor: 'actions' stamp: 'rbb 3/1/2005 11:05'!addPackage	| packageName |	packageName := UIManager default request: 'Package name:'.	packageName isEmpty ifFalse:		[selectedPackage := self packageOrganizer registerPackageNamed: packageName.		self changed: #packageSelection]! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:23'!update: aSymbol	aSymbol = #packages ifTrue:		[packages := nil.		self changed: #packageList; changed: #packageSelection]! !!PackageList methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 00:18'!packages	^ packages ifNil: [packages := self packageOrganizer packages asSortedCollection:									[:a :b | a packageName <= b packageName]]! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 14:43'!initialize	TheWorldMenu registerOpenCommand: {'Package List'. {self. #open}}! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass	^self packageOfMethodCategory: categoryName ofClass: aClass ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock	^ self packages detect: [:ea | ea includesMethodCategory: categoryName ofClassNamed: aClass] ifNone: errorBlock		! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:55'!packageOfSystemCategory: aSystemCategory	^ self packageOfSystemCategory: aSystemCategory ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:54'!packageOfSystemCategory: aSystemCategory ifNone: errorBlock	^ self packages detect: [:ea | ea includesSystemCategory: aSystemCategory] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'initializing' stamp: 'avi 11/12/2003 23:01'!initialize	packages := Dictionary new! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 00:17'!default	^ default ifNil: [default := self new]! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 12:59'!initialize	ServiceClasses := Set new! !!PaintBoxMorph methodsFor: 'other' stamp: 'kfr 5/10/2009 15:39'!offsetFromMaxBounds	"location of normal PaintBox within maxBounds."	| left |	left _ self left.	Preferences useBiggerPaintingBox ifTrue: [left _ left  - (( self width * 1.5)- self width)].	^ left - colorMemory left @ 0! !!PaintBoxMorph methodsFor: 'other' stamp: 'kfr 4/25/2010 11:06'!willingToBeDiscarded	^ false! !!PaintBoxMorph class methodsFor: 'instance creation' stamp: 'kfr 4/25/2010 11:03'!new	| pb button dualUse formCanvas rect |	pb _ Prototype veryDeepCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb submorphNamed: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ button onImage getCanvas.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	pb fixUpRecentColors.	pb addLabels.	pb resistsRemoval: true.	^ pb! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 6/19/2008 12:08'!asPangoAttributes	pangoAttrCache ifNil: [pangoAttrCache := text pangoLanguageAttributes].	^ pangoAttrCache, text asPangoAttributes.! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 6/18/2008 23:52'!characterBlockAtPoint: aPoint	| r b rect index |	r := RomePluginCanvas composingCanvas.	r ifNil: [^ super characterBlockAtPoint: aPoint].	rect := self compositionRectangle.	b := CharacterBlock new.	index := r pangoIndexIn: text string attributeArray: self asPangoAttributes at: (aPoint - positionWhenComposed) width: rect width height: rect height into: b.	^ b textLine: (self textLineIncludes: index).! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 6/24/2008 00:33'!characterBlockForIndex: index	| r b rect |	r := RomePluginCanvas composingCanvas.	r ifNil: [^ super characterBlockForIndex: index].	rect := self compositionRectangle.	b := CharacterBlock new.	r pangoBlockIn: text string attributeArray: self asPangoAttributes at: index at: positionWhenComposed width: rect width height: rect height into: b.	^ b textLine: (self textLineIncludes: index).! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 6/24/2008 01:41'!composeAll	| r rect w myLines |	pangoAttrCache := nil.	r := RomePluginCanvas composingCanvas.	r ifNil: [^ super composeAll].	rect := self compositionRectangle.	w := r pangoComposeString: text string attributeArray: self asPangoAttributes at: rect origin width: rect width height: rect height withWrap: true.	w ifNotNil: [		lines := w second.		maxRightX := w first.	] ifNil: [		myLines := (1 to: 100) collect: [:i | TextLine new].		w := r pangoComposeString: text string attributeArray: self asPangoAttributes at: rect origin width: rect width height: rect height into: myLines withWrap: true.		lines := self validLines: myLines.		maxRightX := w.	].! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2008 18:32'!pangoDrawOn: aCanvas in: bnds color: c	| r start stop clip |	(aCanvas isKindOf: FormCanvas) ifFalse: [^ self].	clip := (bnds intersect: aCanvas clipRect) translateBy: aCanvas origin.	r := RomePluginCanvas drawingCanvasFor: aCanvas.	r clipRectangle: clip.	r clear.	start := selectionStart ifNil: [-1] ifNotNil: [selectionStart stringIndex].	stop := selectionStop ifNil: [-1] ifNotNil: [selectionStop stringIndex].	r		pangoString: text string		attributeArray: self asPangoAttributes		at: (container origin + aCanvas origin + (0@1))		width: bnds width		height: bnds height		selectionStart: start		selectionEnd: stop		selectionColorPixel: (self insertionPointColor pixelValueForDepth: 32).	r finish: clip.! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 6/11/2007 10:53'!replaceFrom: start to: stop with: aText displaying: displayBoolean 	text replaceFrom: start to: stop with: aText.	self composeAll.! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 5/27/2007 23:06'!textLineIncludes: index	lines do: [:l |		(l first <= index and: [index <= l last]) ifTrue: [^ l]	].	^ lines last.! !!PangoParagraph methodsFor: 'as yet unclassified' stamp: 'yo 5/25/2007 13:03'!validLines: dataLines	1 to: dataLines size do: [:i |		((dataLines at: i) left) ifNil: [^ dataLines copyFrom: 1 to: i-1].	].	^  dataLines.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'bf 9/29/2009 13:55'!clipboardText	^ Clipboard clipboardText! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'yo 4/16/2009 16:44'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	self clearParens.  	char asciiValue = 13 ifTrue: [		^ sensor controlKeyPressed			ifTrue: [self crWithIndent: typeAheadStream]			ifFalse: [self normalCharacter: typeAheadStream]].	((honorCommandKeys _ Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream].	Preferences blinkParen ifTrue: [		(')]}' includes: char)			ifTrue: [self blinkPrevParen]].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParseNode methodsFor: 'testing' stamp: 'eem 9/25/2008 12:11'!isBlockNode	^false! !!Parser methodsFor: 'expression types' stamp: 'eem 6/2/2009 10:26'!assignment: varNode	" var ':=' expression => AssignmentNode."	| loc start |	(loc := varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	start := self startOfNextToken.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode := AssignmentNode new				variable: varNode				value: parseNode				from: encoder				sourceRange: (start to: self endOfLastToken).	varNode nowHasDef.	^true! !!Parser methodsFor: 'expression types' stamp: 'eem 1/23/2010 13:59'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	properties := AdditionalMethodState new.	encoder := encoderToUse.	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	properties selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode isArg: true].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:17'!primitive: anIntegerOrString	"Create indexed primitive."		^self primitive: anIntegerOrString error: nil! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:21'!primitive: anIntegerOrString error: errorCodeVariableOrNil	"Create indexed primitive with optional error code."		^anIntegerOrString isInteger		ifTrue:			[errorCodeVariableOrNil ifNotNil:				[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].			 anIntegerOrString]		ifFalse:			[anIntegerOrString isString				ifTrue: [self primitive: anIntegerOrString module: nil error: errorCodeVariableOrNil]				ifFalse: [self expected: 'Indexed primitive']]! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:20'!primitive: aNameString error: errorCodeVariableOrNil module: aModuleStringOrNil	"Create named primitive with optional error code."		^self primitive: aNameString module: aModuleStringOrNil error: errorCodeVariableOrNil! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:21'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		^self primitive: aNameString module: aModuleStringOrNil error: nil! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:18'!primitive: aNameString module: aModuleStringOrNil error: errorCodeVariableOrNil	"Create named primitive with optional error code."		(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	errorCodeVariableOrNil ifNotNil:		[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].	^117! !!Parser methodsFor: 'pragmas' stamp: 'eem 11/29/2008 16:44'!addPragma: aPragma	properties := properties copyWith: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'eem 12/1/2008 11:39'!pragmaLiteral: selectorSoFar	"Read a pragma literal.  As a nicety we allow a variable name (rather	 than a literal string) as the second argument to primitive:error:"	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	"This nicety allows one to supply a primitive error	 temp as a variable name, rather than a string."	((selectorSoFar beginsWith: 'primitive:')	 and: [(selectorSoFar endsWith: 'error:')	 and: [hereType == #word]]) ifTrue:		[^self advance].	^self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'eem 12/1/2008 14:33'!pragmaPrimitives	| primitives |	properties isEmpty ifTrue:		[^0].	primitives := properties pragmas select:					[:pragma|					self class primitivePragmaSelectors includes: pragma keyword].	primitives isEmpty ifTrue:		[^0].	primitives size > 1 ifTrue:		[^self notify: 'Ambigous primitives'].	^self perform: primitives first keyword withArguments: primitives first arguments! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'eem 7/9/2007 16:20'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: (self pragmaLiteral: selector) ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser class methodsFor: 'accessing' stamp: 'eem 12/1/2008 14:32'!primitivePragmaSelectors	"Answer the selectors of pragmas that specify VM primitives.	 Needed for compile and decomple."	^#(primitive:		primitive:error:		primitive:error:module:		primitive:module:		primitive:module:error:)! !!PartsBin methodsFor: 'dropping/grabbing' stamp: 'sw 8/3/2009 18:18'!acceptDroppingMorph: dropped event: evt	"Accept a dropped morph; intercepted here for a couple of special cases."	(dropped hasProperty: #ignorePartsBinDrop) ifTrue: [^ self].	(dropped hasProperty: #beFullyVisibleAfterDrop) ifTrue:		[dropped vanishAfterSlidingTo: dropped formerPosition event: evt.		^ self].	^ super acceptDroppingMorph: dropped event: evt! !!PasteUpMorph methodsFor: 'classification' stamp: 'sw 3/24/2009 13:17'!defersHaloToInteriorMorph: aMorph	"Answer whether  when a halo-click goes down over some subobject within me, I should defer to it rather than seize the halo myself."	^ true! !!PasteUpMorph methodsFor: 'drawing' stamp: 'sw 2/19/2009 14:38'!drawOn: aCanvas 	"Draw in order:	- background color	- grid, if any	- background sketch, if any	- Update and draw the turtleTrails form. See the comment in updateTrailsForm.	- cursor box if any	Later (in drawSubmorphsOn:) I will skip drawing the background sketch."	"draw background fill"	super drawOn: aCanvas.	"draw grid"	(self griddingOn and: [self gridVisible]) 		ifTrue: 			[aCanvas fillRectangle: self bounds				fillStyle: (self 						gridFormOrigin: self gridOrigin						grid: self gridModulus						background: nil						line: Color lightGray)].	"draw background sketch."	backgroundMorph ifNotNil: [		self clipSubmorphs ifTrue: [			aCanvas clipBy: self clippingBounds				during: [ :canvas | canvas fullDrawMorph: backgroundMorph ]]			ifFalse: [ aCanvas fullDrawMorph: backgroundMorph ]].	"draw turtle trails"	self updateTrailsForm.	turtleTrailsForm 		ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	"draw cursor"	(submorphs notEmpty and: [self indicateCursor]) 		ifTrue: 			[self clipSubmorphs				ifTrue:					[aCanvas clipBy: self clippingBounds						during: [ :canvas | canvas 						frameRectangle: self selectedRect						width: 2						color: Color black]]					ifFalse:					[aCanvas frameRectangle: self selectedRect width: 2 color: Color black]]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 9/8/2009 15:17'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add the standard items to the aMenu which will serve as the World's halo menu."	| wm |	aMenu add: 'about this system...' translated target: SmalltalkImage current selector: #aboutThisSystem.	aMenu addLine.	aMenu add: 'redraw screen (r)' translated action: #restoreMorphicDisplay.	aMenu add: 'preferences...' translated target: Preferences selector: #openPreferencesInspector.	aMenu add: 'authoring tools...' translated target: (wm := TheWorldMenu new adaptToWorld: self) selector: #scriptingDo.	aMenu add: 'display mode...' translated target: wm selector: #offerScalingMenu..		aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	Preferences eToyFriendly ifFalse:		[Preferences sugarNavigator ifFalse:			[self addExportMenuItems: aMenu hand: aHandMorph]].	self addLockingItemsTo: aMenu.	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addPenMenuItems: aMenu hand: aHandMorph.	self addPlayfieldMenuItems: aMenu hand: aHandMorph.	(owner isKindOf: BOBTransformationMorph) ifTrue:  "wow, blast from the past"		[self addScalingMenuItems: aMenu hand: aHandMorph].	Preferences eToyFriendly		ifFalse:			[aMenu addLine.			aMenu add: 'world menu...' translated target: self action: #putUpDesktopMenu:]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/2009 15:47'!addWorldToggleItemsToHaloMenu: aMenu	"Add toggle items for the world to the halo menu ....  July 2009:  no longer in world halo menu"	"aMenu addUpdating: #showTabsString				target: CurrentProjectRefactoring 				action: #currentToggleFlapsSuppressed  "! !!PasteUpMorph methodsFor: 'world menu' stamp: 'kfr 5/23/2009 14:58'!grabDrawingFromScreen: evt	"Allow the user to designate a rectangular area of the screen to 'grab' as a drawing."	| selection |	selection _SimpleSelectionMorph newBounds: (evt cursorPoint extent: 0@0).		Cursor crossHair showWhile:		[[Sensor anyButtonPressed] whileFalse:			[self currentWorld displayWorldSafely; runStepMethods].		self addMorph: selection. ^selection extendByHand:evt hand ]! !!PasteUpMorph methodsFor: 'menu' stamp: 'bf 1/19/2010 14:55'!abandonUnsituatedPlayers	"If any objects in the project have references, in player-valued variables, to other objects otherwise not present in the project, abandon them and replace former references to them by references to Dot"	| aList dot slotInfo varName ref allPlayers count |	count := 0.	allPlayers := ActiveWorld presenter reallyAllExtantPlayersNoSort.	aList := allPlayers select: [:m | m belongsToUniClass].	dot := self presenter standardPlayer.	aList do:		[:p |			p class slotInfo associationsDo:				[:assoc |					slotInfo := assoc value.					varName := assoc key.					(slotInfo type = #Player) ifTrue:						[ref := p instVarNamed: varName.						(allPlayers includes: ref) ifFalse:							[p instVarNamed: varName put: dot.							count := count + 1.							Transcript cr; show: ('Variable named "{1}"  in player named "{2}" changed to point to Dot' translated format: {varName. ref externalName})]]]].	aList := nil.  "Increases chance of the next line having desired effect."	self inform: ('{1} item(s) fixed up' translated format: {count}).	WorldState addDeferredUIMessage: [Smalltalk garbageCollect]! !!PasteUpMorph methodsFor: 'menu' stamp: 'sw 5/30/2009 02:22'!toggleFullScreen	"Toggle the full-screenness; we simply flip the global flaps-suppressed setting."	| tab |	(Preferences navControlInNavBar and:			[(tab := self findA: SugarNavTab) notNil])		ifTrue:			[tab collapsedMode				ifTrue:					[tab showNavBar]				ifFalse:					[tab hideNavBar]]		ifFalse:			[CurrentProjectRefactoring currentToggleFlapsSuppressed]! !!PasteUpMorph methodsFor: '*Etoys-world menu' stamp: 'sw 9/24/2008 12:57'!attemptCleanupReporting: whetherToReport	"Try to fix up some bad things that are known to occur in some etoy projects we've seen. If the whetherToReport parameter is true, an informer is presented after the cleanups"	| fixes faultyStatusControls |	fixes _ 0.	ActiveWorld ifNotNil:		[(ActiveWorld submorphs select:			[:m | (m isKindOf: ScriptEditorMorph) and: [m submorphs isEmpty]]) do:				[:m | m delete.  fixes _ fixes + 1]].	TransformationMorph allSubInstancesDo:		[:m | (m player notNil and: [m renderedMorph ~~ m])			ifTrue:				[m renderedMorph visible ifFalse:					[m renderedMorph visible: true.  fixes _ fixes + 1]]].	(Player class allSubInstances select: [:cl | cl isUniClass]) do:		[:aUniclass |			fixes _ fixes + aUniclass cleanseScripts].	self presenter flushPlayerListCache; allExtantPlayers.	faultyStatusControls := ScriptStatusControl allInstances select: [:m |m  fixUpScriptInstantiation].	fixes := fixes + faultyStatusControls size.	ScriptNameTile allInstancesDo: 		[:aTile | aTile submorphs isEmpty ifTrue: 			[aTile setLiteral: aTile literal.			fixes := fixes + 1]].	whetherToReport		ifTrue:			[self inform: ('{1} [or more] repair(s) made' translated format: {fixes printString})]		ifFalse:			[fixes > 0 ifTrue: [Transcript cr; show: fixes printString, ' repairs made to existing content.']]	"ActiveWorld attemptCleanupReporting: true.ActiveWorld attemptCleanupReporting: false."! !!PasteUpMorph class methodsFor: 'scripting' stamp: 'sw 6/5/2009 14:43'!additionsToViewerCategoryDisplay	"Answer display additions"	^ #(display(		(command showNavigationBar 'Show the navigation bar at the top of the screen')		(command hideNavigationBar 'Hide the navigation bar at the top of the screen')		(command useBlueprintCanvas 'Display the world as a blueprint' )		(command useNormalCanvas  'Display the world normally' Boolean)))! !!PasteUpMorph class methodsFor: 'system startup' stamp: 'generated 9/29/2009 01:13'!startUp		World ifNotNil:[		"Don't process events, yet. In particular, entering a dropped project would terminate the startup (happend on the Mac)"		| events evt |		events := OrderedCollection new.		[(evt := Sensor nextEvent) isNil] whileFalse: [events add: evt].		World restoreMorphicDisplay.		World triggerEvent: #aboutToEnterWorld.		World doOneCycleNow.		events do: [:each | Sensor queueEvent: each].	].! !!PasteUpMorph class methodsFor: '*eToys-scripting' stamp: 'bf 6/26/2010 17:19'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ # ((playfield ((command initiatePainting 'Initiate painting of a new object in the standard playfield.')(slot mouseX 'The x coordinate of the mouse pointer' Number readWrite Player getMouseX  unused unused)(slot mouseY 'The y coordinate of the mouse pointer' Number readWrite Player getMouseY  unused unused)(slot timer 'The elapsed time in seconds' Number readWrite Player getTimer  Player setTimer:)(command roundUpStrays 'Bring all out-of-container subparts back into view.')(slot graphic 'The graphic shown in the background of this object' Graphic readWrite Player getPasteUpGraphic Player setGraphic:)(command unhideHiddenObjects 'Unhide all hidden objects.')))(scripting ((command tellAllContents: 'Send a message to all the objects inside the playfield' ScriptName)))(collections ((slot cursor 'The index of the chosen element' Number readWrite Player getPasteUpCursor Player setCursorWrapped:)(slot count 'How many elements are within me' Number readOnly Player getCount unused unused)(slot stringContents 'The characters of the objects inside me, laid end to end' String readOnly Player getStringContents unused unused)(slot playerAtCursor 'the object currently at the cursor' Player readWrite Player getValueAtCursor  unused unused)(slot firstElement  'The first object in my contents' Player  readWrite Player getFirstElement  Player  setFirstElement:)(slot numberAtCursor 'the number at the cursor' Number readWrite Player getNumberAtCursor Player setNumberAtCursor: )(slot graphicAtCursor 'the graphic worn by the object at the cursor' Graphic readOnly Player getGraphicAtCursor  unused unused)(command tellAllContents: 'Send a message to all the objects inside the playfield' ScriptName)(command removeAll 'Remove all elements from the playfield')(command shuffleContents 'Shuffle the contents of the playfield')(command append: 'Add the object to the end of my contents list.' Player)(command prepend: 'Add the object at the beginning of my contents list.' Player)(command includeAtCursor: 'Add the object to my contents at my current cursor position' Player)(command include: 'Add the object to my contents' Player)))"(#'stack navigation' ((command goToNextCardInStack 'Go to the next card')(command goToPreviousCardInStack  'Go to the previous card')(command goToFirstCardInBackground 'Go to the first card of the current background')(command goToFirstCardOfStack 'Go to the first card of the entire stack')(command goToLastCardInBackground 'Go to the last card of the current background')(command goToLastCardOfStack 'Go to the last card of the entire stack')(command deleteCard 'Delete the current card')(command insertCard 'Create a new card')))""(viewing ((slot viewingNormally 'whether contents are viewed normally' Boolean readWrite Player getViewingByIcon Player setViewingByIcon: )))"(#'pen trails' ((command liftAllPens 'Lift the pens on all the objects in my interior.')(command lowerAllPens  'Lower the pens on all the objects in my interior.')(command trailStyleForAllPens:  'Set the trail style for pens of all objects within' TrailStyle)(command clearTurtleTrails 'Clear all the pen trails in the interior.')(slot batchPenTrails 'Whether pen trails should reflect small movements within the same tick or only should integrate all movement between ticks' Boolean readWrite Player getBatchPenTrails Player setBatchPenTrails:)))(#sound ((slot soundPitch 'pitch of sound' Number readOnly Player getPitch unused unused)(slot soundLevel 'level of sound' Number readOnly Player getLevel unused unused)(slot dialNumber 'dial number of sound' String readOnly Player getDialNumber unused unused)(slot soundListening 'whether the stethoscope is listening' Boolean readWrite Player getListening Player setListening:))))! !!PhraseTileForTest methodsFor: 'as yet unclassified' stamp: 'yo 10/14/2006 23:33'!addCommandFeedback: evt	"Add screen feedback showing what would be torn off in a drag"	| aMorph rect |	(self owner owner isMemberOf: PhraseTileMorph) ifTrue: [self owner owner addCommandFeedback: evt. ^ self].	rect _ self bounds.	aMorph _ RectangleMorph new bounds: rect.	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	ActiveWorld addHighlightMorph: aMorph for: self outmostScriptEditor! !!PhraseTileForTest methodsFor: 'as yet unclassified' stamp: 'tak 8/31/2007 17:25'!initialize	super initialize.	self color: Color orange muchLighter.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1;		borderColor: ScriptingSystem standardTileBorderColor.	self setupCostume.! !!PhraseTileForTest methodsFor: 'as yet unclassified' stamp: 'yo 9/13/2006 15:56'!setupCostume	| stringMorph |	stringMorph _ StringMorph new contents: 'Test' translated.	stringMorph name: 'Test' translated.	stringMorph font: Preferences standardEToysFont.	self addMorphBack: stringMorph.	self addMorphBack: (Morph new color: color;			 extent: 15 @ 5).	stringMorph _ StringMorph new contents: 'Yes' translated.	stringMorph name: 'Yes' translated.	stringMorph font: Preferences standardEToysFont.	self addMorphBack: stringMorph.	self addMorphBack: (Morph new color: color;			 extent: 15 @ 5).	stringMorph _ StringMorph new contents: 'No' translated.	stringMorph name: 'No' translated.	stringMorph font: Preferences standardEToysFont.	self addMorphBack: stringMorph.	self addMorphBack: (Morph new color: color;			 extent: 15 @ 5).! !!PhraseTileForTest methodsFor: 'mouse' stamp: 'sw 10/4/2006 05:22'!mouseDown: evt 	"Handle a mouse-down on the receiver"	| guyToTake catViewer |	guyToTake _ CompoundTileMorph new.	guyToTake setNamePropertyTo: 'TestTile' translated.	guyToTake position: evt position + (-25@8).	guyToTake formerPosition: ActiveHand position.	"self startSteppingSelector: #trackDropZones."	(catViewer := self ownerThatIsA: CategoryViewer) ifNotNil:		[guyToTake setProperty: #newPermanentPlayer toValue: catViewer scriptedPlayer.		guyToTake setProperty: #newPermanentScript toValue: true].	guyToTake justGrabbedFromViewer: true.	^ evt hand grabMorph: guyToTake! !!PhraseTileForTimesRepeat methodsFor: 'hilighting'!addCommandFeedback: evt	"Add screen feedback showing what would be torn off in a drag"	| aMorph rect |	(self owner owner isMemberOf: PhraseTileMorph) ifTrue: [self owner owner addCommandFeedback: evt. ^ self].	rect _ self bounds.	aMorph _ RectangleMorph new bounds: rect.	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	ActiveWorld addHighlightMorph: aMorph for: self outmostScriptEditor! !!PhraseTileForTimesRepeat methodsFor: 'initialization' stamp: 'tak 8/31/2007 17:25'!initialize	"Initialize the receiver."	super initialize.	self color: Color orange muchLighter.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1;		borderColor: ScriptingSystem standardTileBorderColor.	self setupCostume! !!PhraseTileForTimesRepeat methodsFor: 'initialization' stamp: 'sw 12/19/2006 18:12'!setupCostume	"Set up the details that make up the receiver's appearance."	| stringMorph |	stringMorph _ StringMorph new contents: 'Repeat' translated.	stringMorph name: 'Repeat' translated.	stringMorph font: Preferences standardEToysFont.	self addMorphBack: stringMorph.	self addMorphBack: (Morph new color: color;			 extent: 15 @ 5).	stringMorph _ StringMorph new contents: 'Times' translated.	stringMorph name: 'Times' translated.	stringMorph font: Preferences standardEToysFont.	self addMorphBack: stringMorph.	self addMorphBack: (Morph new color: color;			 extent: 15 @ 5).! !!PhraseTileForTimesRepeat methodsFor: 'mouse' stamp: 'sw 6/15/2007 17:49'!mouseDown: evt 	"Handle a mouse-down on the receiver"	| guyToTake catViewer |	guyToTake _ TimesRepeatTile new.	guyToTake setNamePropertyTo: 'Repeat Tile' translated.	guyToTake position: evt position + (-25@8).	guyToTake formerPosition: ActiveHand position.	"self startSteppingSelector: #trackDropZones."	(catViewer := self ownerThatIsA: CategoryViewer) ifNotNil:		[guyToTake setProperty: #newPermanentPlayer toValue: catViewer scriptedPlayer.		guyToTake setProperty: #newPermanentScript toValue: true].	guyToTake justGrabbedFromViewer: true.	^ evt hand grabMorph: guyToTake! !!PhraseTileForTimesRepeat commentStamp: 'sw 12/19/2006 18:15' prior: 0!A place-holder for a Times-Repeat complex of etoy tiles.  Used in a Viewer; when the user drags one of these, he ends up with a fully-instantiated Times/Repeat complex of tiles in his hand; if he drops such a group on the desktop, a new script is created for the object associated with the Viewer in question, with the Times/Repeat as its initial contents.!!PhraseTileMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/27/2009 14:53'!justDroppedInto: newOwner event: evt	"Phrase tiles only auto-expand if they originate from viewers.  Any phrase tile, once dropped, loses its auto-phrase-expansion thing"	(justGrabbedFromViewer = true and: [newOwner isKindOf: Viewer]) ifTrue: [		self formerPosition ifNotNil: [			^ self vanishAfterSlidingTo: self formerPosition event: evt		].	].	justGrabbedFromViewer _ false.	super justDroppedInto: newOwner event: evt.	((owner isKindOf: TilePadMorph) and: [submorphs size = 3] and: [#(bearingTo: distanceToPlayer:) includes:  submorphs second operatorOrExpression])		ifTrue:			[owner wrapInFunction.			owner owner operator: #grouped wording: '()'  helpString: 'parenthesized' translated pad: owner.			owner scriptEdited]! !!PhraseWrapperMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/1/2000 22:30'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or:		[aMorph hasProperty: #newPermanentScript]! !!PhraseWrapperMorph methodsFor: 'parts bin' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PhraseWrapperMorph commentStamp: '<historical>' prior: 0!An alignment morph designed for use in scripting Viewers; it wraps a set of phrases in a category viewer, and repels attempts to drop phrases upon it.!!PhraseWrapperMorph class methodsFor: 'new-morph participation' stamp: 'sw 11/9/1998 16:16'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'kfr 3/15/2009 23:01'!buildKeyboard	| wtWid bkWid keyRect octavePt nWhite nBlack keyHeight |	self removeAllMorphs.	wtWid _16. bkWid _ 10.	keyHeight _ 75.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | keyRect _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@keyHeight.			self addMorph: ((RectangleMorph newBounds: keyRect color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j))].		1 to: nBlack do:			[:j | keyRect _ octavePt + ((#(12 28 58 75 92) at: j)@1) extent: bkWid@(keyHeight * 0.618).			self addMorph: ((Morph newBounds: keyRect color: blackKeyColor)				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j))]].	self submorphsDo:		[:m | m on: #mouseMove send: #mouseMovePitch:event:noteMorph: to: self;				on: #mouseUp send: #mouseUpPitch:event:noteMorph: to: self;				on: #mouseEnterDragging send: #mouseDownPitch:event:noteMorph: to: self;				on: #mouseLeaveDragging send: #mouseUpPitch:event:noteMorph: to: self].	self extent: (self fullBounds extent + borderWidth - 1)! !!PlaybackInvoker methodsFor: 'notification' stamp: 'sw 9/10/2010 00:40'!fire	"Fire the receiver."	self launchPlayback! !!Player methodsFor: 'costume' stamp: 'bf 8/18/2010 01:29'!flipLeftRight	self costume renderedMorph allMorphsDo: [ :m |		m isSketchMorph ifTrue: [m flipHorizontal]]! !!Player methodsFor: 'costume' stamp: 'bf 8/18/2010 01:29'!flipUpDown	self costume renderedMorph allMorphsDo: [ :m |		m isSketchMorph ifTrue: [m flipVertical]]! !!Player methodsFor: 'costume' stamp: 'sw 9/2/2009 16:05'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	| aForm itsMorph |	aForm := anotherPlayer getGraphic deepCopy.	aForm offset: 0 @ 0.	itsMorph := anotherPlayer costume.	costume rotationStyle: itsMorph rotationStyle.	costume forwardDirection: itsMorph forwardDirection.	self setGraphic: aForm rotationCenter: itsMorph rotationCenter"	self renderedCostume: (anotherPlayer costume renderedMorph asWearableCostumeOfExtent: self costume extent) remember: anotherPlayer costume shouldRememberCostumes"! !!Player methodsFor: 'misc' stamp: 'kfr 6/6/2010 16:07'!arrowDeltaFor: aGetSelector	"Answer the arrowDelta to use in conjunction with a readout for aGetSelector, which will be of the form 'getXXX'"	"(self slotInfoForGetter: aGetSelector) ifNotNilDo: [ :slotInfo |				^slotInfo floatPrecision]."	costume ifNotNil:		[^ costume renderedMorph arrowDeltaFor: aGetSelector].	^ 1! !!Player methodsFor: 'misc' stamp: 'bf 10/13/2010 00:05'!beep: anObject	"Play given sound or at least beep."	| sound |	anObject isString		ifTrue:			[sound := SoundService default playSoundNamedOrBeep: anObject.			(sound respondsTo: #stopGracefully)				ifTrue: [self costume setProperty: #playingSound toValue: sound]]		ifFalse:			[SoundPlayer resumePlaying: anObject quickStart: true]! !!Player methodsFor: 'misc' stamp: 'bf 8/18/2010 01:00'!defaultScriptName	^'script' translated asLegalSelector! !!Player methodsFor: 'misc' stamp: 'kfr 6/16/2010 15:49'!grabScriptorForSelector: itsSelector in: aWorld	"Grab the scriptor for the given selector and place it in the hand"	| editor |	editor := self scriptEditorFor: itsSelector.	editor fixLayout.	aWorld currentHand attachMorph: (editor).							! !!Player methodsFor: 'misc' stamp: 'sw 6/5/2009 14:44'!hideNavigationBar	"Hide the navigation bar at the top of the screen"	| tab |	((tab := costume world findA: SugarNavTab) notNil)		ifTrue:			[tab collapsedMode				ifFalse:					[tab hideNavBar]]! !!Player methodsFor: 'misc' stamp: 'kfr 6/6/2010 18:33'!noteDecimalPlaces: aNumber forGetter: aGetter	"Note the given preference of decimal places for the given getter"	| slotInfo |	slotInfo := self slotInfoForGetter: aGetter.	slotInfo ifNotNil:[ slotInfo floatPrecision: (Utilities floatPrecisionForDecimalPlaces: aNumber)].	costume noteDecimalPlaces: aNumber forGetter: aGetter! !!Player methodsFor: 'misc' stamp: 'sw 8/4/2009 17:44'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver.  If the shift key is held down, put up the alternate menu. The menu omits the 'add a new variable' item when in eToyFriendly mode, as per request from teachers using Squeakland in 2003 once the button for adding a new variable was added to the viewer"	| aMenu aWorld  |	(evt notNil and: [evt shiftPressed and: [Preferences eToyFriendly not]]) ifTrue:		[^ self offerAlternateViewerMenuFor: aViewer event: evt].	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	aMenu title: self externalName.	aMenu addStayUpItem.	self costume renderedMorph offerCostumeViewerMenu: aMenu.	Preferences eToyFriendly ifFalse: "exclude this from squeakland-like UI "		[aMenu add: 'add a new variable' translated target: self action: #addInstanceVariable.		aMenu balloonTextForLastItem: 'Add a new variable to this object and all of its siblings.  You will be asked to supply a name for it.' translated].	aMenu add: 'add a new script' translated target: aViewer action: #newPermanentScript.	aMenu balloonTextForLastItem: 'Add a new script that will work for this object and all of its siblings' translated.	aMenu addLine.	aMenu add: 'grab this object' translated target: self selector: #grabPlayerIn: argument: aWorld.	aMenu balloonTextForLastItem: 'This will actually pick up the object this Viewer is looking at, and hand it to you.  Click the (left) button to drop it' translated.	aMenu add: 'reveal this object' translated target: self selector: #revealPlayerIn: argument: aWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object that this Viewer is looking at, use this item to (try to) make it visible' translated.	aMenu add: 'tile representing this object' translated action: #tearOffTileForSelf.	aMenu balloonTextForLastItem: 'choose this to obtain a tile which represents the object associated with this script' translated.	aMenu addLine.	aMenu add: 'add search pane' translated target: aViewer action: #addSearchPane.	Preferences eToyFriendly ifFalse: [		aMenu addLine.		aMenu add: 'more...' translated target: self selector: #offerAlternateViewerMenuFor:event: argumentList: {aViewer. evt}].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'kfr 11/28/2009 21:02'!overlaps: aPlayer 	"Answer whether my costume overlaps that of another player"	| goalCostume intersection |	aPlayer ifNil: [^false].	goalCostume := aPlayer costume.	costume world == goalCostume world ifFalse: [^false].	"check if the 2 player costumes intersect"	intersection := costume bounds intersect: goalCostume bounds.	(intersection width = 0 or: [intersection height = 0]) 		ifTrue: [^false]		ifFalse: 			[ ^self costume overlapsShadowForm: goalCostume imageForm stencil bounds: goalCostume fullBounds ]! !!Player methodsFor: 'misc' stamp: 'sw 6/5/2009 14:43'!showNavigationBar	"Show the navigation bar at the top of the screen"	| tab |	((tab := costume world findA: SugarNavTab) notNil)		ifTrue:			[tab collapsedMode				ifTrue:					[tab showNavBar]]! !!Player methodsFor: 'misc' stamp: 'bf 8/18/2010 01:01'!unusedScriptName	"answer a name of the form 'scriptN', where N is one higher than the highest-numbered similarly-named script"	| defaultStem highestThus aPair |	defaultStem := self defaultScriptName.	highestThus := 0.	self class tileScriptNames do:		[:aName |			aPair := (aName copyWithout: $:) stemAndNumericSuffix.			aPair first = defaultStem ifTrue: [highestThus := highestThus max: aPair last]].	^ (defaultStem, (highestThus + 1) printString) asSymbol! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 3/2/2009 13:56'!acceptScript: aScriptEditorMorph for: aSelector	"Accept the tile code in the script editor as the code for the given selector.  This branch is only for the classic-tile system, 1997-2001"	| aUniclassScript node |	aScriptEditorMorph generateParseNodeDirectly ifTrue: [		(node _ aScriptEditorMorph methodNode) ifNotNil: [			self class addSelectorSilently: aScriptEditorMorph scriptName withMethod: (node generate: #(0 0 0 0)).			SystemChangeNotifier uniqueInstance doSilently: [self class organization classify: aSelector under: 'scripts']		].	] ifFalse: [		self class compileSilently: aScriptEditorMorph methodString			classified: 'scripts' for: self.	].	aUniclassScript _ self class assuredMethodInterfaceFor: aSelector asSymbol.	aUniclassScript currentScriptEditor: aScriptEditorMorph.	aScriptEditorMorph world ifNotNil: [aScriptEditorMorph world removeHighlightFeedback].! !!Player methodsFor: 'scripts-kernel' stamp: 'bf 8/18/2010 00:59'!isExpendableScript: aScriptName	^ (self isEmptyTileScript: aScriptName) and:		[aScriptName beginsWith: self defaultScriptName]! !!Player methodsFor: 'scripts-standard' stamp: 'kfr 11/28/2009 17:30'!overlapsAny: aPlayer 	"Answer true if my costume overlaps that of aPlayer, or any of its  	siblings (if aPlayer is a scripted player)  	or if my costume overlaps any morphs of the same class (if aPlayer is  	unscripted)."	| possibleCostumes itsCostume itsCostumeClass myShadow |	(self ~= aPlayer			and: [self overlaps: aPlayer])		ifTrue: [^true].	possibleCostumes := IdentitySet new.	aPlayer belongsToUniClass		ifTrue: [aPlayer class				allSubInstancesDo: [:anInstance | (anInstance ~~ self							and: [itsCostume := anInstance costume.								(itsCostume bounds intersects: costume bounds)									and: [itsCostume world == costume world]])						ifTrue: [possibleCostumes add: itsCostume]]]		ifFalse: [itsCostumeClass := aPlayer costume class.			self costume world presenter allExtantPlayers				do: [:ep | self ~= ep ifTrue:[ ep costume 						ifNotNilDo: [:ea | (ea class == itsCostumeClass									and: [ea bounds intersects: costume bounds])								ifTrue: [possibleCostumes add: ea]]]]].	possibleCostumes isEmpty		ifTrue: [^ false].	myShadow := costume shadowForm.	^possibleCostumes		anySatisfy: [:m | m overlapsShadowForm: myShadow bounds: costume fullBounds].	! !!Player methodsFor: 'slot getters/setters' stamp: 'bf 9/7/2010 12:58'!getTimer	| last msecs |	last := costume renderedMorph		valueOfProperty:  #timerStart		ifAbsent: [0].	msecs := Time millisecondsSince: last.	"allow negative timer values, e.g. for count downs"	msecs > (SmallInteger maxVal // 2)		ifTrue: [msecs := msecs - SmallInteger maxVal]. 	^msecs / 1000.0! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/2/2009 15:22'!setGraphic: aForm rotationCenter: aPoint	"Set the receiver's graphic as indicated"	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm rotationCenter: aPoint]		ifFalse:			[aMorph isPlayfieldLike				ifTrue: 					[aMorph backgroundForm: aForm]				ifFalse:					["what to do?"]]! !!Player methodsFor: 'slot getters/setters' stamp: 'Richo 8/16/2010 21:57'!setLength: aLength	"Set the length of the receiver."	| cost lengthToUse |	cost _ self costume.	cost isWorldMorph ifTrue: [^self].	cost isLineMorph		ifTrue:			[^ cost unrotatedLength: aLength].	lengthToUse _ cost isRenderer		ifTrue:			[aLength / cost scaleFactor]		ifFalse:			[aLength].	cost renderedMorph height: lengthToUse! !!Player methodsFor: 'slot getters/setters' stamp: 'bf 6/26/2010 17:13'!setTimer: seconds	costume renderedMorph		setProperty:  #timerStart		toValue: Time millisecondClockValue - (seconds * 1000) asInteger! !!Player methodsFor: 'slots-kernel' stamp: 'kfr 6/2/2010 00:17'!categoriesForWorld	"Answer the list of categories given that the receiver is the Player representing a World"	| aList |	aList _ #(color #'fill & border' scripting #'pen trails' #'world geometry' playfield collections sound) asOrderedCollection.	aList add: #input.	Preferences eToyFriendly ifFalse:		[aList addAll: #(preferences #'as object'  display) ].	aList addAll: {ScriptingSystem nameForInstanceVariablesCategory.  ScriptingSystem nameForScriptsCategory}.	^ aList! !!Player methodsFor: 'slots-user' stamp: 'kfr 6/16/2010 17:49'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName _ Utilities inherentSelectorForGetter: aGetter.	typeChoices _ Vocabulary typeChoices asOrderedCollection.	[self costume renderedMorph defaultPatch] on:Exception do:[ typeChoices remove: #Patch ifAbsent: [typeChoices]].	typeChosen _ (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor {1}' translated, slotName, '(currently {2})' translated format: {slotName. (self slotInfoAt: slotName) type translated}).	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	self updateAllViewers.	"does siblings too"	self changeTypesInWatchersOf: slotName.  "does siblings too"	! !!Player methodsFor: 'slots-user' stamp: 'kks 10/6/2009 23:09'!getPrecisionFor: slotName 	"get the precision for the given slot name"	| aGetter places precision |	precision _ 1.	(self slotInfo includesKey: slotName) 				ifTrue: 					["it's a user slot"					precision _ (self slotInfoAt: slotName) floatPrecision]				ifFalse: 					["reference to system slots"					aGetter := Utilities getterSelectorFor: slotName.					self costume renderedMorph ifNotNilDo: [ :morph |						places _ morph decimalPlacesForGetter: aGetter.						precision _ Utilities floatPrecisionForDecimalPlaces: places ]].	^precision! !!Player methodsFor: 'vertices operation' stamp: 'tetha 2/26/2009 17:29'!setVerticesCount: aInteger 	self costume setVerticesCount: aInteger! !!Player methodsFor: 'special numeric slots' stamp: 'sw 2/4/2009 10:49'!bearingFrom: aPlayer	"Answer the bearing to the receiver from another player"	^ (aPlayer costume referencePositionInWorld bearingToPoint: costume referencePositionInWorld) asSmallAngleDegrees! !!Player methodsFor: 'special numeric slots' stamp: 'sw 2/4/2009 10:48'!bearingTo: aPlayer	"Answer the bearing from the receiver to another player."	^ (costume referencePositionInWorld bearingToPoint: aPlayer costume referencePositionInWorld) asSmallAngleDegrees! !!Player methodsFor: 'special numeric slots' stamp: 'sw 12/15/2008 02:44'!distanceToPlayer: aPlayer	"Simplified distance... simply answer the distance between the reference positions of the two objects."	^ costume referencePositionInWorld dist: aPlayer costume referencePositionInWorld! !!Player methodsFor: 'slots-clock' stamp: 'chronograph  9/16/2003 12:11'!getHours	^ self getValueFromCostume: #hours! !!Player methodsFor: 'slots-clock' stamp: 'chronograph  9/16/2003 12:11'!getMinutes	^ self getValueFromCostume: #minutes! !!Player methodsFor: 'slots-clock' stamp: 'chronograph  9/16/2003 12:11'!getSeconds	^ self getValueFromCostume: #seconds! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:08'!getCurveAbscissa	^costume getCurveAbscissa! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:09'!getMathItemValue	^costume getMathItemValue! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:09'!getWorldX	^costume getWorldX! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:10'!getWorldY	^costume getWorldY! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:10'!setCurveAbscissa: aFloat	costume setCurveAbscissa: aFloat! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:10'!setMathItemValue: aValue	^ costume setMathItemValue: aValue! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:10'!setWorldX: aFloat	costume setWorldX: aFloat! !!Player methodsFor: '*DrGeoII-Etoys-slots' stamp: 'HilaireFernandes 11/1/2009 10:11'!setWorldY: aFloat	costume setWorldY: aFloat! !!Player methodsFor: 'slots-color components'!getAlpha	^ self getColor alpha * 100! !!Player methodsFor: 'slots-color components'!getBlue	^ self getColor blue * 100! !!Player methodsFor: 'slots-color components'!getBrightness	^ self getColor brightness * 100! !!Player methodsFor: 'slots-color components'!getGreen	^ self getColor green * 100! !!Player methodsFor: 'slots-color components'!getHue	| hue |	hue := self getColor hue.	^ hue > 180		ifTrue: [-360 + hue]		ifFalse: [hue]! !!Player methodsFor: 'slots-color components'!getRed	^ self getColor red * 100! !!Player methodsFor: 'slots-color components'!getSaturation	^ self getColor saturation * 100! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:52'!setAlpha: aFloat	"Set the alpha component of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		r: aColor red		g: aColor green		b: aColor blue		alpha: aValue)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:53'!setBlue: aFloat	"Set the blue component of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		r: aColor red		g: aColor green		b: aValue		alpha: aColor alpha)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:57'!setBrightness: aFloat 	"Set the brightness of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		h: aColor hue		s: aColor saturation		v: aValue		alpha: aColor alpha)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:53'!setGreen: aFloat	"Set the green component of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		r: aColor red		g: aValue		b: aColor blue		alpha: aColor alpha)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:57'!setHue: aFloat	"Set the hue of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := aFloat \\ 360.	self setColor: (Color		h: aValue		s: aColor saturation		v: aColor brightness		alpha: aColor alpha)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:53'!setRed: aFloat	"Set the red component of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		r: aValue		g: aColor green		b: aColor blue		alpha: aColor alpha)! !!Player methodsFor: 'slots-color components' stamp: 'bf 12/10/2009 23:58'!setSaturation: aFloat 	"Set the saturation of my costume, if appropriate."	| aColor aValue |	aColor := self getColor.	aValue := (aFloat / 100 max: 0) min: 1.	self setColor: (Color		h: aColor hue		s: aValue		v: aColor brightness		alpha: aColor alpha)! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/12/2010 20:16'!attachTo: aPlayerself sendMessageToCostume: #target: with: aPlayer costume renderedMorph! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/12/2010 20:16'!getAttachment	^ [(self sendMessageToCostume: #target) assuredPlayer]		on: Error		do: [self presenter standardPlayer] ! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 6/17/2010 00:02'!getBubble^[self costume renderedMorph bubble assuredPlayer] on: Error do: [self presenter standardPlayer]! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:50'!sayGraphic: aGraphicself costume renderedMorph sayGraphic: aGraphic! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:48'!sayNumber: aNumberself costume renderedMorph say: aNumber asString! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/6/2010 15:43'!sayObject: aPlayerself costume renderedMorph sayObject: aPlayer! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:47'!sayText: aStringself costume renderedMorph say: aString! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 8/12/2010 20:16'!stopAttaching	self sendMessageToCostume: #target: with: nil! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/9/2010 14:47'!stopSayingOrThinkingself costume renderedMorph stopSayingOrThinking! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:50'!thinkGraphic: aGraphicself costume renderedMorph thinkGraphic: aGraphic! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:48'!thinkNumber: aNumberself costume renderedMorph think: aNumber asString! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/6/2010 15:43'!thinkObject: aPlayerself costume renderedMorph thinkObject: aPlayer! !!Player methodsFor: '*Etoys-SpeechBubbles' stamp: 'Richo 7/2/2010 17:48'!thinkText: aStringself costume renderedMorph think: aString! !!Player class methodsFor: 'slots' stamp: 'bf 9/19/2010 16:46'!compileInstVarAccessorsFor: varName	"Compile getters and setteres for the given instance variable name"	| nameString |	nameString := varName asString capitalized.	self compileSilently: ('get{1}	^ {2}' format: {nameString. varName})		classified: 'access'.	self compileSilently: ('set{1}: a{1}	{2} := a{1}' format: {nameString. varName})		classified: 'access'! !!Player class methodsFor: 'other' stamp: 'bf 5/4/2010 08:33'!compileAllFrom: oldClass	"protect script references"	scripts isEmptyOrNil		ifTrue: [^super compileAllFrom: oldClass]. 	ProjectLoading worldLoading: (self myProject ifNotNilDo: [:p | p world]).	[super compileAllFrom: oldClass]		ensure: [ProjectLoading worldLoading: nil].! !!Player class methodsFor: 'other' stamp: 'bf 5/4/2010 08:28'!myProject	"Find the project I was defined in, or nil"	self isSystemDefined ifTrue: [^nil].	Project allProjects do: [:prj |		prj world presenter allExtantPlayers do: [:plr |			 plr class == self ifTrue: [^prj]]].	^nil! !!PlayerSurrogate methodsFor: 'updating' stamp: 'bf 8/23/2010 13:18'!localeChanged	"Update myself to reflect the change in locale"	self bringUpToDate! !!PluggableListMorph methodsFor: 'debug and other' stamp: 'bf 9/6/2009 16:17'!userString	"Do I have a text string to be searched on?"	^ String streamContents: [:strm |		1 to: self getListSize do: [:i |			strm nextPutAll: (self getListItem: i); cr]]! !!PluggableTextMorph methodsFor: 'testing' stamp: 'dtl 2/10/2010 17:28'!isTextView	"True if the reciever is a view on a text model, such as a view on a TranscriptStream"	^true! !!PluggableTextMorphPlus methodsFor: 'initialize' stamp: 'bf 4/19/2010 03:29'!useDefaultStyler! !!PluggableTextView methodsFor: 'testing' stamp: 'dtl 2/10/2010 17:28'!isTextView	"True if the reciever is a view on a text model, such as a view on a TranscriptStream"	^true! !!Point methodsFor: 'arithmetic' stamp: 'bf 7/25/2010 14:40'!grouped	"Sent as a pseudo-function for parenthesizing in tile scripts."	^ self! !!Point methodsFor: '*DrGeoII-Core-point functions' stamp: 'HilaireFernandes 1/3/2006 14:06'!reflexionBy: aPoint direction: aDirection"the reflected point according to the axe defined by aPoint and aDirection"	^ ((self - aPoint) vectorReflexionBy: aDirection) + aPoint! !!Point methodsFor: '*DrGeoII-Core-point functions' stamp: 'HilaireFernandes 2/7/2006 21:56'!rotateVector: anAngle|cosa sina|	cosa := anAngle cos.	sina := anAngle sin.	^ (x * cosa - (y * sina))@(x * sina + (y * cosa))! !!Point methodsFor: '*DrGeoII-Core-point functions' stamp: 'HilaireFernandes 1/3/2006 13:47'!vectorReflexionBy: aDirection"the reflected vector according to the axe defined by aPoint and aVector"|unit normal|	unit := aDirection normalized.	normal := unit normal.	^((self dotProduct: unit) * unit) - ((self dotProduct: normal) * normal)! !!PolygonMorph methodsFor: 'vertices operations' stamp: 'tetha 2/26/2009 17:36'!setVerticesCount: anInteger 	| verticesCount |	verticesCount := vertices size.	verticesCount > anInteger		ifTrue: [verticesCount - anInteger				timesRepeat: [self removeVertexAtCursor]].	verticesCount < anInteger		ifTrue: [anInteger - verticesCount				timesRepeat: [self insertVertexAtCursor]]! !!PolygonMorph methodsFor: 'editing' stamp: 'tetha 2/26/2009 17:15'!updateHandles	| newVert oldVert midPts nextVertIx tweens |	(handles at: self vertexCursor * 2 - 1)		color: Color blue.	smoothCurve		ifTrue: [handles first center: vertices first.			handles last center: vertices last.			midPts := OrderedCollection new.			nextVertIx := 2.			tweens := OrderedCollection new.			vertices				withIndexDo: [:vertPt :vertIndex | 					oldVert := handles at: vertIndex * 2 - 1.					oldVert position: vertPt - (oldVert extent // 2).					(closed							or: [vertIndex < vertices size])						ifTrue: [newVert := handles at: vertIndex * 2.							newVert position: vertPt									+ (vertices atWrap: vertIndex + 1) - newVert extent // 2 + (1 @ -1)]].			self				lineSegmentsDo: [:p1 :p2 | 					tweens addLast: p2 asIntegerPoint.					((p2							= (vertices atWrap: nextVertIx)) and: [vertices size > 1])						ifTrue: ["Found endPoint."							midPts addLast: (tweens at: tweens size // 2)									+ (tweens at: tweens size + 1 // 2) // 2.							tweens := OrderedCollection new.							nextVertIx := nextVertIx + 1]].			midPts				withIndexDo: [:midPt :vertIndex | (closed							or: [vertIndex < vertices size])						ifTrue: [newVert := handles at: vertIndex * 2.							newVert position: midPt - (newVert extent // 2)]]]		ifFalse: [vertices				withIndexDo: [:vertPt :vertIndex | 					oldVert := handles at: vertIndex * 2 - 1.					oldVert position: vertPt - (oldVert extent // 2).					(closed							or: [vertIndex < vertices size])						ifTrue: [newVert := handles at: vertIndex * 2.							newVert position: vertPt									+ (vertices atWrap: vertIndex + 1) - newVert extent // 2 + (1 @ -1)]]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sw 9/7/2009 14:44'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| msg |	msg := self name = 'a stream' translated		ifTrue:			['']		ifFalse:			[self name].	^ self fileInAnnouncing: 'Reading ' translated,  msg! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/20/2006 02:10'!argumentAt: anInteger	"Answer one of the arguments of the pragma."		^ self arguments at: anInteger.! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:54'!arguments	"Answer the arguments of the receiving pragma. For a pragma defined as <key1: val1 key2: val2> this will answer #(val1 val2)."		^ arguments! !!Pragma methodsFor: 'accessing-pragma' stamp: 'eem 12/1/2008 10:42'!key	"Answer the keyword of the pragma (the selector of its message pattern).	 This accessor provides polymorphism with Associations used for properties."	^keyword! !!Pragma methodsFor: 'accessing-pragma' stamp: 'eem 12/1/2008 10:42'!keyword	"Answer the keyword of the pragma (the selector of its message pattern).	 For a pragma defined as <key1: val1 key2: val2> this will answer #key1:key2:."		^ keyword! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:55'!message	"Answer the message of the receiving pragma."		^ Message selector: self keyword arguments: self arguments. ! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/20/2006 02:10'!numArgs	"Answer the number of arguments in the pragma."	^ self arguments size.! !!Pragma methodsFor: 'testing' stamp: 'eem 11/29/2008 17:03'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in the receiver, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	^(aBlock value: keyword)	   or: [arguments hasLiteralSuchThat: aBlock]! !!Pragma methodsFor: 'testing' stamp: 'eem 11/29/2008 16:39'!hasLiteral: aLiteral	^keyword == aLiteral 	   or: [arguments hasLiteral: aLiteral]! !!Pragma methodsFor: 'accessing-method' stamp: 'lr 1/20/2006 02:04'!method	"Answer the compiled-method containing the pragma."		^ method! !!Pragma methodsFor: 'accessing-method' stamp: 'lr 1/20/2006 02:08'!methodClass	"Answer the class of the method containing the pragma."		^ method methodClass! !!Pragma methodsFor: 'accessing-method' stamp: 'eem 12/1/2008 10:43'!selector	"Answer the selector of the method containing the pragma.	 Do not confuse this with the selector of the pragma's message pattern."		^method selector! !!Pragma methodsFor: 'printing' stamp: 'lr 2/6/2006 19:56'!printOn: aStream	aStream nextPut: $<.	self keyword precedence = 1		ifTrue: [ aStream nextPutAll: self keyword ]		ifFalse: [			self keyword keywords with: self arguments do: [ :key :arg |				aStream nextPutAll: key; space; print: arg; space ].			aStream skip: -1 ].	aStream nextPut: $>.! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/20/2006 00:53'!setArguments: anArray	arguments := anArray! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/20/2006 00:53'!setKeyword: aSymbol	keyword := aSymbol! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/19/2006 23:39'!setMethod: aCompiledMethod	method := aCompiledMethod! !!Pragma methodsFor: 'comparing' stamp: 'eem 3/7/2009 11:54'!analogousCodeTo: anObject 	^self class == anObject class	  and: [keyword == anObject keyword	  and: [arguments = anObject arguments]]! !!Pragma commentStamp: '<historical>' prior: 0!I represent an occurrence of a pragma in a compiled method.  A pragma is a literal message pattern that occurs between angle brackets at the start of a method after any temporaries.  A common example is the primitive pragma:	<primitive: 123 errorCode: 'errorCode'>but one can add one's own and use them as metadata attached to a method.  Because pragmas are messages one can browsse senders and implementors and perform them.  One can query a method for its pragmas by sendng it the pragmas message, which answers an Array of instances of me, one for each pragma in the method.I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.Instances are retrieved using one of the pragma search methods of the 'finding' protocol on the class side.To browse all methods with pragmas in the system evaluate	SystemNavigation default browseAllSelect: [:m| m pragmas notEmpty]and to browse all nonprimitive methods with pragmas evaluate	SystemNavigation default browseAllSelect: [:m| m primitive isZero and: [m pragmas notEmpty]]!!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 08:54'!allNamed: aSymbol from: aSubClass to: aSuperClass	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol."		^ Array streamContents: [ :stream |		aSubClass withAllSuperclassesDo: [ :class |			self withPragmasIn: class do:  [ :pragma |				pragma keyword = aSymbol					ifTrue: [ stream nextPut: pragma ] ].			aSuperClass = class				ifTrue: [ ^ stream contents ] ] ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 18:16'!allNamed: aSymbol from: aSubClass to: aSuperClass sortedByArgument: anInteger	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol, sorted according to argument anInteger."	^ self allNamed: aSymbol from: aSubClass to: aSuperClass sortedUsing: [ :a :b | (a argumentAt: anInteger) < (b argumentAt: anInteger) ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/19/2006 20:12'!allNamed: aSymbol from: aSubClass to: aSuperClass sortedUsing: aSortBlock	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol, sorted according to aSortBlock."		^ (self allNamed: aSymbol from: aSubClass to: aSuperClass) sort: aSortBlock.! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 08:55'!allNamed: aSymbol in: aClass	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol."		^ Array streamContents: [ :stream |		self withPragmasIn: aClass do: [ :pragma |			pragma keyword = aSymbol				ifTrue: [ stream nextPut: pragma ] ] ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 18:16'!allNamed: aSymbol in: aClass sortedByArgument: anInteger	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol, sorted according to argument anInteger."	^ self allNamed: aSymbol in: aClass sortedUsing: [ :a :b | (a argumentAt: anInteger) < (b argumentAt: anInteger) ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/19/2006 20:06'!allNamed: aSymbol in: aClass sortedUsing: aSortBlock	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol, sorted according to aSortBlock."		^ (self allNamed: aSymbol in: aClass) sort: aSortBlock.! !!Pragma class methodsFor: 'instance creation' stamp: 'eem 11/29/2008 14:00'!for: aMethod selector: aSelector arguments: anArray	^self new		setMethod: aMethod;		setKeyword: aSelector;		setArguments: anArray;		yourself! !!Pragma class methodsFor: 'private' stamp: 'lr 1/20/2006 00:34'!keyword: aSymbol arguments: anArray	^ self new		setKeyword: aSymbol;		setArguments: anArray;		yourself.! !!Pragma class methodsFor: 'private' stamp: 'lr 1/20/2006 08:50'!withPragmasIn: aClass do: aBlock	aClass selectorsAndMethodsDo: [ :selector :method | method pragmas do: aBlock ].! !!Preference methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:18'!isDisabledOnStartupString	"Answer a string representing whether this preference is persisted to false"	| aStr |	aStr :=  'disable preference on startup' translated.	^ self persistedValue == false		ifTrue: ['<yes>', aStr]		ifFalse: 	['<no>', aStr]! !!Preference methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:18'!isEnabledOnStartupString	"Answer a string representing whether this preference is persisted to true"	| aStr |	aStr :=  'enable preference on startup' translated.	^ self persistedValue == true		ifTrue: ['<yes>', aStr]		ifFalse: 	['<no>', aStr]! !!Preference methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:19'!isNotSetOnStartupString	"Answer a string representing whether this preference is not persisted"	| aStr |	aStr :=  'do not set preference on startup' translated.	^ self persistedValue == nil		ifTrue: ['<yes>', aStr]		ifFalse: 	['<no>', aStr]! !!Preference methodsFor: 'persistence' stamp: 'bf 8/8/2010 18:18'!persistedValue	"Answer the value of this preference saved on file, otherwise nil"	^Preferences persistedValueFor: self name! !!Preference methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:33'!persistValue: aBooleanOrNil	"Save this preference on file, so it can be restored on startup. If nil, delete persistent value."	Preferences persistValue: aBooleanOrNil for: self name! !!Preferences class methodsFor: 'fonts' stamp: 'Richo 9/30/2009 12:37'!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	Preferences setDefaultFonts: #(			(setListFontTo:			BitstreamVeraSans		15)	        	(setFlapsFontTo:			BitstreamVeraSansBold	15)			(setEToysButtonFontTo:	BitstreamVeraSans		15)			(setEToysFontTo:			BitstreamVeraSansBold	15)			(setEToysCodeFontTo:		BitstreamVeraSans		15)			(setEToysTitleFontTo: 	BitstreamVeraSans		32)			(setPaintBoxButtonFontTo:	BitstreamVeraSans		9)			(setMenuFontTo:			BitstreamVeraSans		15)			(setWindowTitleFontTo:	BitstreamVeraSans		15)			(setBalloonHelpFontTo:		BitstreamVeraSans		15)		).! !!Preferences class methodsFor: 'fonts' stamp: 'bf 8/31/2009 18:57'!restoreDefaultFontsForSqueakland	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFontsForSqueakland	"	Preferences restoreDefaultFonts.	Preferences setDefaultFonts: #(			(setCodeFontTo: 	BitstreamVeraSans 				15)			(setSystemFontTo: BitstreamVeraSans 				15)		).! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34'!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33'!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!Preferences class methodsFor: 'preferences panel' stamp: 'bf 5/8/2010 12:45'!initializePreferencePanel: aPanel in: aPasteUpMorph	"Initialize the given Preferences panel. in the given pasteup, which is the top-level panel installed in the container window.  Also used to reset it after some change requires reformulation"	| tabbedPalette controlPage aColor aFont maxEntriesPerCategory tabsMorph anExtent  prefObjects cc |	aPasteUpMorph removeAllMorphs.	aFont := Preferences standardListFont.	aColor := aPanel defaultBackgroundColor.	tabbedPalette := TabbedPalette newSticky.	tabbedPalette dropEnabled: false.	(tabsMorph := tabbedPalette tabsMorph) color: aColor darker;		 highlightColor: Color red regularColor: Color brown darker darker.	tabbedPalette on: #mouseDown send: #yourself to: #().	maxEntriesPerCategory := 0.	self listOfCategories do: 		[:aCat | 			controlPage := AlignmentMorph newColumn beSticky color: aColor.			controlPage on: #mouseDown send: #yourself to: #().			controlPage dropEnabled: false.			Preferences alternativeWindowLook ifTrue:				[cc := Color transparent.				controlPage color: cc].			controlPage borderColor: aColor;				 layoutInset: 4.			(prefObjects := self preferenceObjectsInCategory: aCat) do:				[:aPreference | | button |					button _ aPreference representativeButtonWithColor: cc inPanel: aPanel.					button ifNotNil: [controlPage addMorphBack: button]].			controlPage setNameTo: aCat asString.			aCat = #?				ifTrue:	[aPanel addHelpItemsTo: controlPage].			tabbedPalette addTabFor: controlPage font: aFont.			aCat = 'search results' ifTrue:				[(tabbedPalette tabNamed: aCat) setBalloonText:					'Use the ? category to find preferences by keyword; the results of your search will show up here' translated].		maxEntriesPerCategory := maxEntriesPerCategory max: prefObjects size].	tabbedPalette selectTabNamed: '?'.	tabsMorph rowsNoWiderThan: aPasteUpMorph width.	aPasteUpMorph on: #mouseDown send: #yourself to: #().	anExtent := aPasteUpMorph width @ (490 max: (25 + tabsMorph height + (24 * maxEntriesPerCategory))).	aPasteUpMorph extent: anExtent.	aPasteUpMorph color: aColor.	aPasteUpMorph 	 addMorphBack: tabbedPalette.! !!Preferences class methodsFor: 'preferences panel' stamp: 'bf 5/8/2010 12:35'!openNewPreferencesPanel	"Create and open a new Preferences Panel"	| window |	window := self preferencesControlPanel.	self currentWorld addMorphFront: window.	window center: self currentWorld center.	window activateAndForceLabelToShow."Preferences openNewPreferencesPanel"! !!Preferences class methodsFor: 'preferences panel' stamp: 'bf 5/8/2010 12:19'!preferencesControlPanel	"Answer a Preferences control panel window"	"Preferences preferencesControlPanel openInHand"	| window playfield aPanel |	aPanel _ PreferencesPanel new.	playfield _ PasteUpMorph new width: 450.	playfield dropEnabled: false.	window _ (SystemWindow labelled: 'Preferences' translated) model: aPanel.	self initializePreferencePanel: aPanel in: playfield.	window on: #keyStroke send: #keyStroke: to: aPanel.	window bounds: (100 @ 100 - (0 @ window labelHeight + window borderWidth) extent: playfield extent + (2 * window borderWidth)).	window addMorph: playfield frame: (0 @ 0 extent: 1 @ 1).	window updatePaneColors.	window setProperty: #minimumExtent toValue: playfield extent + (12@15).	^ window! !!Preferences class methodsFor: 'standard queries'!monticelloToolWindowColor	^ self		valueOfFlag: #monticelloToolWindowColor		ifAbsent: [Color				r: 0.627				g: 0.69				b: 0.976]! !!Preferences class methodsFor: 'themes' stamp: 'bf 10/12/2010 20:26'!cambridge	"A theme for Squeakland and OLPC project"	"Preferences cambridge"	"This method has three parts.  Don't forget to look at the stuff at the bottom."	self setPreferencesFrom: #(		(allowCelesteTell false)		(alternativeScrollbarLook true)		(alternativeWindowLook true)		(annotationPanes true)		(automaticKeyGeneration true)		(biggerHandles true)		(blinkParen false)		(browseWithDragNDrop true)		(canRecordWhilePlaying true)		(classicNavigatorEnabled false)		(compactViewerFlaps true)		(enableLocalSave false)		(escapeKeyProducesMenu false)		(eToyFriendly true)		(eToyLoginEnabled true)		(extraDebuggerButtons false)		(gradientMenu false)		(haloTransitions false)		(honorDesktopCmdKeys true)		(includeSoundControlInNavigator true)		(magicHalos false)		(menuAppearance3d false)		(menuKeyboardControl false)		(modalColorPickers true)		(mouseOverHalos false)		(mvcProjectsAllowed false)		(preserveTrash true)		(projectViewsInWindows false)		(promptForUpdateServer false)		(propertySheetFromHalo false)		(roundedMenuCorners false)		(roundedWindowCorners false)		(securityChecksEnabled true)		(showDirectionHandles false)		(showDirectionForSketches true)		(showProjectNavigator false)		(showSecurityStatus false)		(soundQuickStart true)	"see setPlatformPreferences"		(soundReverb false)		(soundStopWhenDone true) 	"see setPlatformPreferences"		(startInUntrustedDirectory true)		(sugarAutoSave false)		(swapControlAndAltKeys false)	"see setPlatformPreferences"		(uniqueNamesInHalos true)		(unlimitedPaintArea false)		(useArtificialSweetenerBar true)		(useBiggerPaintingBox true)		(useFormsInPaintBox false)		(useLocale true)		(usePangoRenderer false)		(usePlatformFonts false)		(usePopUpArrows true)		(warnAboutInsecureContent false)	"The following is to make sure the default is set properly."	(abbreviatedBrowserButtons false)	(allowEtoyUserCustomEvents false)	(alphabeticalProjectMenu false)	(alternativeBrowseIt false)	(alternativeButtonsInScrollBars false)	(alternativeWindowBoxesLook true)	(alwaysHideHScrollbar false)	(alwaysShowConnectionVocabulary false)	(alwaysShowHScrollbar false)	(alwaysShowVScrollbar true)	(ansiAssignmentOperatorWhenPrettyPrinting true)	(areaFillsAreTolerant false)	(areaFillsAreVeryTolerant false)	(autoAccessors false)	(automaticFlapLayout true)	(automaticPlatformSettings true)	"enables setPlatformPreferences"	(automaticViewerPlacement true)	(balloonHelpEnabled true)	(balloonHelpInMessageLists false)	(batchPenTrails false)	(biggerCursors true)	(browserNagIfNoClassComment true)	(browserShowsPackagePane false)	(browseWithPrettyPrint false)	(capitalizedReferences true)	(caseSensitiveFinds false)	(cautionBeforeClosing false)	(celesteHasStatusPane false)	(celesteShowsAttachmentsFlag false)	(changeSetVersionNumbers true)	(checkForSlips true)	(checkForUnsavedProjects true)	(classicNewMorphMenu false)	(clickOnLabelToEdit false)	(cmdDotEnabled true)	(collapseWindowsInPlace false)	(colorWhenPrettyPrinting false)	(compressFlashImages false)	(confirmFirstUseOfStyle true)	(conversionMethodsAtFileOut false)	(cpuWatcherEnabled false)	(debugHaloHandle false)	(debugPrintSpaceLog false)	(debugShowDamage false)	(decorateBrowserButtons true)	(defaultFileOutFormatMacRoman false)	(diffsInChangeList true)	(diffsWithPrettyPrint false)	(dismissAllOnOptionClose false)	(dismissEventTheatreUponPublish true)	(dragNDropWithAnimation false)	(dropProducesWatcher true)	(duplicateControlAndAltKeys false)	(easySelection false)	(enableInternetConfig false)	(enablePortraitMode false)	(enableVirtualOLPCDisplay false)	(expandedPublishing true)	(extractFlashInHighestQuality false)	(extractFlashInHighQuality true)	(fastDragWindowForMorphic true)	(fenceEnabled true)	(fenceSoundEnabled false)	(fullScreenLeavesDeskMargins true)	(gradientScrollBars true)	(haloEnclosesFullBounds false)	(higherPerformance false)	(ignoreStyleIfOnlyBold true)	(implicitSelfInTiles false)	(inboardScrollbars true)	(infiniteUndo false)	(keepTickingWhilePainting false)	(logDebuggerStackToFile true)	(menuButtonInToolPane false)	(menuColorFromWorld false)	(menuWithIcons true)	(morphicProgressStyle true)	(mouseOverForKeyboardFocus false)	(navigatorOnLeftEdge true)	(noviceMode false)	(okToReinitializeFlaps true)	(oliveHandleForScriptedObjects false)	(optionalButtons true)	(passwordsOnPublish false)	(personalizedWorldMenu true)	(postscriptStoredAsEPS false)	(printAlternateSyntax false)	(projectsSentToDisk false)	(projectZoom true)	(readDocumentAtStartup true)	(restartAlsoProceeds false)	(reverseWindowStagger true)	(rotationAndScaleHandlesInPaintBox false)	(scrollBarsNarrow false)	(scrollBarsOnRight true)	(scrollBarsWithoutMenuButton false)	(selectionsMayShrink true)	(selectiveHalos true)	(showAdvancedNavigatorButtons false)	(showBoundsInHalo false)	(showDeprecationWarnings false)	(showFlapsWhenPublishing false)	(showLinesInHierarchyViews true)	(showSharedFlaps true)	(signProjectFiles true)	(simpleMenus false)	(slideDismissalsToTrash true)	(smartUpdating true)	(soundsEnabled true)	(sugarNavigator true)	(swapMouseButtons false)	(systemWindowEmbedOK false)	(tabAmongFields true)	(testRunnerShowAbstractClasses false)	(thoroughSenders true)	(tileTranslucentDrag true)	(timeStampsInMenuTitles true)	(translationWithBabel false)	(turnOffPowerManager false)	(twentyFourHourFileStamps true)	(twoSidedPoohTextures true)	(typeCheckingInTileScripting true)	(unifyNestedProgressBars true)	(uniTilesClassic true)	(universalTiles false)	(updateFromServerAtStartup false)	(updateSavesFile false)	(useButtonProprtiesToFire false)	(useFileList2 true)	(useSmartLabels false)	(useUndo true)	(useVectorVocabulary false)	(viewersInFlaps true)	(warnIfNoChangesFile false)	(warnIfNoSourcesFile false)	(warningForMacOSFileNameLength false)	(wordStyleCursorMovement true)	).Preferences setPreference: #haloTheme toValue: #iconicHaloSpecifications.! !!Preferences class methodsFor: 'themes' stamp: 'bf 9/11/2010 16:12'!chicago	"A theme for Squeakland developers"	"Preferences chicago"	self cambridge.		self setPreferencesFrom: #(		(eToyFriendly false)		(showSecurityStatus true)	).! !!Preferences class methodsFor: 'class initialization' stamp: 'bf 8/8/2010 18:26'!initialize	ExternalSettings registerClient: self.	self registerInFlapsRegistry.	! !!Preferences class methodsFor: 'persistence' stamp: 'bf 9/17/2010 00:29'!deletePersistedPreferences	| d files |	self ensurePersistedPreferencesAccessible		ifFalse: [^self].	d := ExternalSettings preferenceDirectory.	files := d fileNamesMatching: '*', self persistedFileNameExtension.	(self confirm: ('This will remove {1} stored preferences.Are you sure?' translated format: {files size}))		ifTrue: [files do: [:f | d deleteFileNamed: f]].! !!Preferences class methodsFor: 'persistence' stamp: 'bf 9/17/2010 00:10'!ensurePersistedPreferencesAccessible	self persistedPreferencesAccessible		ifTrue: [^true].	self inform: ('{1} is in secure mode.You cannot access the persistent preferences now.To change them, start {1} without loading a project.' translated	format: {SystemVersion current baseName capitalized}).	^false! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 17:58'!fetchExternalSettingsIn: aDirectory	"Load persisted preferences"	"Preferences fetchExternalSettingsIn: ExternalSettings preferenceDirectory"	^ (aDirectory fileNamesMatching: '*', self persistedFileNameExtension)			do: [:fileName |				| pref value |				pref := fileName allButLast: self persistedFileNameExtension size.				value := self persistedValueFor: pref in: aDirectory.				(value isKindOf: Boolean) ifTrue:					[self enableOrDisable: pref asSymbol asPer: value]]! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:42'!persistedFileNameExtension	^'.pref'! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 17:39'!persistedFileNameFor: aSymbol	^aSymbol, self persistedFileNameExtension! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 14:54'!persistedPreferencesAccessible	^SecurityManager default hasFileAccess! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 17:57'!persistedValueFor: aSymbol	^self persistedValueFor: aSymbol in: ExternalSettings preferenceDirectory! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 18:20'!persistedValueFor: aSymbol in: aDirectory	"Read the value of preference aSymbol from file. Answer nil if not found."	| tokens value f |	aDirectory ifNil: [^nil].	f := (aDirectory oldFileOrNoneNamed: (self persistedFileNameFor: aSymbol)) ifNil: [^nil].	[		f wantsLineEndConversion: true.		f contentsOfEntireFile linesDo: [:line |			tokens := line findTokens: ' 	:' keep: ':'.			(tokens size = 3 and: [tokens second = ':']) ifTrue: [				tokens first caseOf: { 					['value'] -> [tokens third caseOf: {						['true'] -> [value := true].						['false'] -> [value := false].					} otherwise: []].				} otherwise: []]].	] ensure: [f close].	^value! !!Preferences class methodsFor: 'persistence' stamp: 'bf 8/8/2010 17:42'!persistValue: aBooleanOrNil for: aSymbol	"Save the preference aSymbol on file, so it can be restored to the given value on startup. If nil, delete persistent value."	| fileName file |	fileName := self persistedFileNameFor: aSymbol.	aBooleanOrNil ifNil: [		^ExternalSettings preferenceDirectory ifNotNilDo: [:fd |			fd deleteFileNamed: fileName ifAbsent: []]].	file := ExternalSettings assuredPreferenceDirectory		forceNewFileNamed: fileName.	[file		wantsLineEndConversion: true;		nextPutAll: 'value: '; print: aBooleanOrNil; cr.	]	ensure: [file close]! !!PreferencesPanel methodsFor: 'find' stamp: 'bf 9/17/2010 00:18'!addHelpItemsTo: panelPage	"Add the items appropriate the the ? page of the receiver"	| aButton aTextMorph aMorph firstTextMorph |	panelPage hResizing: #shrinkWrap; vResizing: #shrinkWrap.	firstTextMorph _  TextMorph new contents: 'Search Preferences for:' translated.	"firstTextMorph beAllFont: ((TextStyle default fontOfSize: 13) emphasized: 1)."	panelPage addMorphBack: firstTextMorph lock.	panelPage addTransparentSpacerOfSize: 0@10.	aMorph _ RectangleMorph new clipSubmorphs: true; beTransparent; borderWidth: 2; borderColor: Color black; extent: 250 @ 36.	aMorph vResizing: #rigid; hResizing: #rigid.	aTextMorph _  PluggableTextMorph new				on: self				text: #searchString				accept: #setSearchStringTo:				readSelection: nil				menu: nil."	aTextMorph hResizing: #rigid."	aTextMorph borderWidth: 0.	aTextMorph font: ((TextStyle default fontOfSize: 21) emphasized: 1); setTextColor: Color red.	aMorph addMorphBack: aTextMorph.	aTextMorph acceptOnCR: true.	aTextMorph position: (aTextMorph position + (6@5)).	aMorph clipLayoutCells: true.	aTextMorph extent: 240 @ 25.	panelPage addMorphBack: aMorph.	aTextMorph setBalloonText: 'Type what you want to search for here, then hit the "Search" button, or else hit RETURN or ENTER' translated.	aTextMorph setTextMorphToSelectAllOnMouseEnter.	aTextMorph hideScrollBarsIndefinitely.	panelPage addTransparentSpacerOfSize: 0@10.	aButton _ SimpleButtonMorph new 				target: self; 				color: Color transparent; 				actionSelector: #initiateSearch:;				 arguments: {aTextMorph};				 label: 'Search' translated.	panelPage addMorphBack: aButton.	aButton setBalloonText: 'Type what you want to search for in the box above, then click here (or hit RETURN or ENTER) to start the search; results will appear in the "search results" category.' translated.	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent;								 label: 'Reset preferences on startup' translated;								 target: Preferences;								 actionSelector: #deletePersistedPreferences;								 setBalloonText: 'Click here to delete all the preferences saved on file. On the next start, they will have their original value.' translated ; yourself).	panelPage addTransparentSpacerOfSize: 0@14.Preferences eToyFriendly ifFalse: [ 	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent;								 label: 'Restore all Default Preference Settings' translated;								 target: Preferences;								 actionSelector: #chooseInitialSettings;								 setBalloonText: 'Click here to reset all the preferences to their standard default values.' translated ; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent; 								label: 'Save Current Settings as my Personal Preferences' translated; 								target: Preferences;								 actionSelector: #savePersonalPreferences;								 setBalloonText: 'Click here to save the current constellation of Preferences settings as your personal defaults; you can get them all reinstalled with a single gesture by clicking the "Restore my Personal Preferences".' translated; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent; 								label: 'Restore my Personal Preferences' translated;								 target: Preferences;								 actionSelector: #restorePersonalPreferences;								 setBalloonText: 'Click here to reset all the preferences to their values in your Personal Preferences.' translated; yourself).	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent; 								label: 'Save Current Settings to Disk' translated; 								target: Preferences; 								actionSelector: #storePreferencesToDisk;								setBalloonText: 'Click here to save the current constellation of Preferences settings to a file; you can get them all reinstalled with a single gesture by clicking "Restore Settings From Disk".' translated; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent; 								label: 'Restore Settings from Disk' translated; 								target: Preferences; 								actionSelector: #restorePreferencesFromDisk; 								setBalloonText: 'Click here to load all the preferences from their saved values on disk.' translated; yourself).	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new								color: Color transparent;								label: 'Inspect Parameters' translated; 								target: Preferences; 								actionSelector: #inspectParameters; 								setBalloonText: 'Click here to view all the values stored in the system Parameters dictionary' translated; yourself).	panelPage addTransparentSpacerOfSize: 0@10.	panelPage addMorphBack: (Preferences themeChoiceButtonOfColor: Color transparent font: TextStyle defaultFont).	panelPage addTransparentSpacerOfSize: 0@10.].	panelPage addMorphBack: (SimpleButtonMorph new 								color: Color transparent; 								label: 'Help!!' translated;								target: Preferences;								actionSelector: #giveHelpWithPreferences; 								setBalloonText: 'Click here to get some hints on use of this Preferences Panel' translated; yourself).	panelPage wrapCentering: #center.! !!Presenter methodsFor: 'stubs' stamp: 'sw 8/13/2009 13:41'!viewMorph: aMorph 	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	aMorph		allMorphsWithPlayersDo: [:mwp :p | (mwp ~~ aMorph					and: [mwp wantsConnectionWhenEmbedded])				ifTrue: [self viewMorph: mwp]].	Sensor leftShiftDown		ifFalse: [((aPalette := aMorph standardPalette) notNil					and: [aPalette isInWorld])				ifTrue: [^ aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	aViewer := aPlayer allOpenViewers				at: 1				ifAbsent: [self nascentPartsViewerFor: aPlayer].	self cacheSpecs: topItem.	flapLoc := associatedMorph.	Preferences viewersInFlaps		ifTrue: [aViewer owner				ifNotNilDo: [:f | 					f dropEnabled: false.					f flapTab						ifNotNilDo: [:aFlap | ^ aFlap showFlap; yourself]].			aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aViewer visible: true.			aFlapTab applyThickness: aViewer width.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent submorphs				do: [:m | (m isKindOf: Viewer)						ifTrue: [m delete]].			aFlapTab referent addMorph: aViewer beSticky.			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			aFlapTab referent dropEnabled: false.			aFlapTab dropEnabled: false.			aViewer dropEnabled: false.			^ aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	Preferences automaticViewerPlacement		ifTrue: [aPoint := aMorph bounds right @ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight)						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			^ aViewer].	aMorph primaryHand		attachMorph: (aViewer visible: true).	^ aViewer! !!Project methodsFor: 'initialization' stamp: 'yo 4/4/2009 17:32'!installVirtualDisplayIfNeededFor: ext	| actual allowance |	allowance := 50.	actual := Display class actualScreenSize.	actual = OLPCVirtualScreen defaultVirtualScreenExtent ifTrue: [^ self].	(Display isVirtualScreen and: [Display extent = ext]) ifTrue: [^ self].	((ext x > (actual x + allowance)) or: [ext y > (actual y + allowance)]) ifTrue: [		OLPCVirtualScreen virtualScreenExtent: ext.		OLPCVirtualScreen install.		^ self	].	((ext x <= (actual x - allowance)) and: [ext y <= (actual y - allowance)]) ifTrue: [		OLPCVirtualScreen virtualScreenExtent: ext.		OLPCVirtualScreen install.		Display zoomOut: true.		^ self.	].	OLPCVirtualScreen virtualScreenExtent: nil.	OLPCVirtualScreen unInstall.! !!Project methodsFor: 'initialization' stamp: 'bf 4/30/2009 16:36'!setChangeSet: aChangeSet	isolatedHead == true ifTrue: [^ self].  "ChangeSet of an isolated project cannot be changed"	changeSet := aChangeSet.	self isCurrentProject ifTrue: [self nameChangedWhileCurrent].! !!Project methodsFor: 'accessing' stamp: 'bf 4/30/2009 18:01'!nameChangedWhileCurrent	Preferences projectNameInTitle ifTrue: [		| title |		title := self name ifNil: [''].		(title beginsWith: 'zzTemp') ifTrue: [title := ''].		title ifNotEmpty: [title := ': ', title].		title := SystemVersion current baseName capitalized, title.		DisplayScreen hostWindowTitle: title].! !!Project methodsFor: 'menu messages' stamp: 'sw 9/28/2009 01:48'!acceptDetailsAndStoreProjectWithForget: details	"The user having hit the ok button in the dialog, send the details back to the project, store the project on the server, "	self acceptProjectDetails: details.	self isCurrentProject		ifTrue:			["exit, then do the command"			(world hasProperty: #forgetURL)					ifTrue: [self forgetExistingURL]					ifFalse: [urlList isEmptyOrNil ifTrue: [urlList _ parentProject urlList]]. 			self				armsLengthCommand: #storeOnServerAssumingNameValid				withDescription: 'Publishing' translated]		ifFalse:			[self storeOnServerWithProgressInfo]! !!Project methodsFor: 'menu messages' stamp: 'sw 9/28/2009 00:44'!acceptDetailsAndStoreProject: details	"The user having hit the ok button in the dialog, send the details back to the project, store the project on the server, "	self acceptProjectDetails: details.	self isCurrentProject		ifTrue:			["exit, then do the command"			self				armsLengthCommand: #storeOnServerAssumingNameValid				withDescription: 'Publishing' translated]		ifFalse:			[self storeOnServerWithProgressInfo]! !!Project methodsFor: 'menu messages' stamp: 'sw 9/28/2009 15:48'!acceptProjectDetails: details	"Store project details back into a property of the world, and if a name is provided, make sure the name is properly installed in the project."	world setProperty: #ProjectDetails toValue: details.	details at: 'projectname' ifPresent: [ :newName | 		self renameTo: newName]! !!Project methodsFor: 'menu messages' stamp: 'bf 8/29/2010 19:13'!displayProgressWithJump: aMessage	"Answer a block to display progress while some time-consuming action is going on; the message provided is shown within a tableau of special chars.  This is basically Andreas's code."	| done b guy guys c text idx |	done := false.	b := ScriptableButton new.	guy _ TextMorph new.	guy usePango: false.	guys _ #('\o/_I_' '_o_I/  \' 'o/ I \| |' '_o_I/  \').	b color: Color yellow.	b borderWidth: 1; borderColor: Color black.	[		idx _ 0.		[done] whileFalse:[			c _ Display getCanvas.			b label: aMessage font: (Preferences standardEToysFont emphasized: 1).			b extent: 200@100.			b center: Display center.			b fullDrawOn: Display getCanvas.			guy beAllFont: (Preferences standardEToysFont  emphasized: 1).			text _ (guys atWrap: (idx := idx + 1)) asText.			text addAttribute: (TextAlignment centered) from: 1 to: text string size.			guy contents: text.			guy center: b position + (30@50); top: b top + 20.			guy fullDrawOn: c.			guy center: b position + (170@50); top: b top + 20.			guy fullDrawOn: c.			Display forceToScreen: b bounds.			(Delay forMilliseconds: 500) wait.		].	] forkAt: Processor userInterruptPriority.	^[done := true]! !!Project methodsFor: 'menu messages' stamp: 'bf 9/7/2010 23:31'!finalEnterActions	"Perform the final actions necessary as the receiver project is entered"	| navigator armsLengthCmd navType thingsToUnhibernate |	self projectParameters 		at: #projectsToBeDeleted 		ifPresent: [ :projectsToBeDeleted |			self removeParameter: #projectsToBeDeleted.			projectsToBeDeleted do: [ :each | 				Project deletingProject: each.				each removeChangeSetIfPossible]].	Preferences preserveProjectLocale		ifTrue: [Locale switchAndInstallFontToID: self localeID gently: true]		ifFalse: [self localeID = LocaleID current ifFalse: [			Locale previous: (Locale localeID: self localeID).			self localeChanged]].	(self projectParameterAt: #oldProject ifAbsent: [false])		ifTrue:			[(self isFlapIDEnabled: 'Sugar Navigator Flap' translated)				ifTrue:					[(world findA: SugarNavTab) ifNotNilDo:						[:tab |							 tab hideNavBar.							tab firstSubmorph  putUpInitialBalloonHelpFor:								{{#showNavBar.								 'show the tool bar' translated.								#bottomLeft.								false}}]]]		ifFalse:			[(self isFlapIDEnabled: 'Sugar Navigator Flap' translated)				ifFalse: [Flaps enableGlobalFlapWithID: 'Sugar Navigator Flap' translated]].	self removeParameter: #oldProject.	thingsToUnhibernate _ world valueOfProperty: #thingsToUnhibernate ifAbsent: [#()].	thingsToUnhibernate do: [:each | each unhibernate].	world removeProperty: #thingsToUnhibernate.	(self projectParameterAt: #substitutedFont) ifNotNil: [		self removeParameter: #substitutedFont.		self world presenter allPlayersWithUniclasses do: [:uni | uni allScriptEditors do: [:scr |			scr setProperty: #needsLayoutFixed toValue: true ]].	].	navType _ ProjectNavigationMorph preferredNavigator.	armsLengthCmd _ self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator _ world findA: navType.	(Preferences classicNavigatorEnabled and: [Preferences showProjectNavigator and: [navigator isNil]]) ifTrue:		[(navigator _ navType new addButtons)			bottomLeft: world bottomLeft;			openInWorld: world].	navigator notNil & armsLengthCmd notNil ifTrue:		[navigator color: Color lightBlue].	armsLengthCmd ifNotNil: [armsLengthCmd openInWorld: world].	Smalltalk isMorphic ifTrue:		[world reformulateUpdatingMenus.		world hands do: [:h | h releaseCachedState].		world presenter positionStandardPlayer].	WorldState addDeferredUIMessage: [self startResourceLoading].! !!Project methodsFor: 'menu messages' stamp: 'sw 9/28/2009 02:43'!validateProjectNameIfOK: aMessageSend	"Validate the project name, possibly putting up the project-info dialog, and if all is well, evaluate the message-send provided."	| details |	details _ world valueOfProperty: #ProjectDetails.	details ifNotNil:		["ensure project info matches real project name"		details at: 'projectname' put: self name].	self doWeWantToRename ifFalse: [^aMessageSend value].	EToyProjectDetailsMorph		getFullInfoFor: self 		ifValid: aMessageSend		expandedFormat: false! !!Project methodsFor: 'file in/out' stamp: 'bf 9/17/2010 21:38'!compressFilesIn: tempDir to: localName in: localDirectory	"Compress all the files in tempDir making up a zip file in localDirectory named localName"	| archive archiveName entry fileNames |	archive := ZipArchive new.	fileNames := tempDir fileNames.	(fileNames includes: 'manifest')		ifTrue: [fileNames := #('manifest'), (fileNames copyWithout: 'manifest')].	fileNames do:[:fn|		archiveName := fn.		entry := archive addFile: (tempDir fullNameFor: fn) as: archiveName.		entry desiredCompressionMethod: (			fn = 'manifest'				ifTrue: [ZipArchive compressionLevelNone] 				ifFalse: [ZipArchive compressionDeflated]).	].	archive writeToFileNamed: (localDirectory fullNameFor: localName).	archive close.	tempDir fileNames do:[:fn|		tempDir deleteFileNamed: fn ifAbsent:[]].	localDirectory deleteDirectory: tempDir localName.! !!Project methodsFor: 'file in/out' stamp: 'sw 7/16/2009 18:15'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileName directory: aDirectory withoutInteraction: noInteraction	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  Whatdo we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can contain its own classes"	world isMorph ifFalse: [		self projectParameters at: #isMVC put: true.		^ false].	"Only Morphic projects for now"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.		world cleanUpReferences.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"	"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers.	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		noInteraction ifTrue: [^ false].		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	ScriptEditorMorph writingUniversalTiles: (self projectParameterAt: #universalTiles ifAbsent: [false]).	holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots _ OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand.	"; addAll: classList; addAll: (classList collect: [:cls | cls class])"	roots _ roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	fd _ aDirectory directoryNamed: self resourceDirectoryName.	fd assureExistence.	"Clean up resource references before writing out"	mgr _ self resourceManager.	self resourceManager: nil.	ResourceCollector current: ResourceCollector new.	ResourceCollector current localDirectory: fd.	ResourceCollector current baseUrl: self resourceUrl.	ResourceCollector current initializeFrom: mgr.	ProgressNotification signal: '2:findingResources' extra: '(collecting resources...)' translated.	"Must activate old world because this is run at #armsLength.	Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent	will not be captured correctly if referenced from blocks or user code."	world becomeActiveDuring:[		is _ ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is _ ImageSegment new copyFromRootsForExport: roots asArray)"	].	self resourceManager: mgr.	collector _ ResourceCollector current.	ResourceCollector current: nil.	ProgressNotification signal: '2:foundResources' extra: ''.	is state = #tooBig ifTrue: [		collector replaceAll.		^ false].	str _ ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str _ str, '\Project''s own world is not in the segment.' translated withCRs].	str isEmpty ifFalse: [		ans _ noInteraction ifTrue: [2] ifFalse: [(PopUpMenu labels: 'Do not write fileWrite file anywayDebug' translated) startUpWithCaption: str].		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].			collector replaceAll.			^ false].		ans = 3 ifTrue: [			collector replaceAll.			self error: 'Segment not written' translated]].	stacks _ is findStacks.	is		writeForExportWithSources: aFileName		inDirectory: fd		changeSet: aChangeSetOrNil.	SecurityManager default signFile: aFileName directory: fd.	"Compress all files and update check sums"	collector forgetObsolete.	self storeResourceList: collector in: fd.	self storeHtmlPageIn: fd.	self storeManifestFileIn: fd.	self storePngThumbnailIn: fd.	self writeStackText: stacks in: fd registerIn: collector.	"local proj.005.myStack.t"	self compressFilesIn: fd to: aFileName in: aDirectory resources: collector.			"also deletes the resource directory"	"Now update everything that we know about"	mgr updateResourcesFrom: collector.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	collector replaceAll.	world flapTabs do: [:ft |		(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!Project methodsFor: 'file in/out' stamp: 'sw 7/17/2009 21:58'!htmlPagePrototype	"Return the HTML page prototype"^'<html><head><title>Squeak Project</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head><body bgcolor="#FFFFFF"><EMBED 	type="application/x-squeak-source"	ALIGN="CENTER"	WIDTH="$$WIDTH$$"	HEIGHT="$$HEIGHT$$"	src="$$PROJECT$$"	pluginspage="http://www.squeakland.org/download/"></EMBED></body></html>'! !!Project methodsFor: 'file in/out' stamp: 'sw 10/3/2009 17:56'!noteManifestDetailsIn: manifestInfo	"The receiver is a project being loaded.  From the dictionary provided, absorb and remember whether it's an 'old' (pre-olpc) project, and remember the GUID, user, and prev-GUID associated with the project when these data are available in the incoming manifest."	| manifestDict oldProject |	manifestInfo isEmptyOrNil ifTrue: [^ self projectParameterAt: #oldProject put: true].	manifestDict := (manifestInfo isKindOf: Dictionary) ifTrue: [manifestInfo] ifFalse: [manifestInfo first].	oldProject := ((manifestDict at: 'Squeak-Version' ifAbsent: ['']) beginsWith: 'etoys') not.	self projectParameterAt: #oldProject put: oldProject.	manifestDict at: #URI ifPresent: [:aUri | self projectParameterAt: #URI put: aUri].	manifestDict at: #user ifPresent: [:aUser | self projectParameterAt: #user put: aUser].	manifestDict at: #'prev-URI' ifPresent: [:aUri | self projectParameterAt: #'prev-URI' put: aUri]! !!Project methodsFor: 'file in/out' stamp: 'bf 10/13/2009 14:37'!storeAttributesOn: aStream	"For the manifest:  write a series of cr-delimited records of the form  <key>: <value> to a  stream." 	| details loggedInAs incomingUser existingUri uri uriPrefix |	self storeAttributeKey: 'Squeak-Version' value: SystemVersion current version on: aStream.	self storeAttributeKey: 'Squeak-LatestUpdate' value: SystemVersion current highestUpdate printString on: aStream.	self storeAttributeKey: 'File-Name-Encoding' value: LanguageEnvironment defaultFileNameConverter class encodingNames first on: aStream.	self storeAttributeKey: 'Project-Language' value: Locale current localeID printString on: aStream.	self localesString ifNotEmptyDo: [:localesString | 		self storeAttributeKey: 'Project-Languages' value: localesString on: aStream].	loggedInAs := 'unknown'.	Utilities loggedIn ifTrue:		[ServerDirectory servers at: 'My Squeakland' ifPresent:			[:server | loggedInAs := server userPerSe ifNil: ['unknown']]].	incomingUser := self projectParameterAt: #user ifAbsent: ['unknown'].		"If the project was loaded from outside, this will be the user associated with that outside version"	existingUri := self projectParameterAt: #URI ifAbsent: [nil].	uriPrefix := 'http://squeakland.org/etoys/'.	uri := uriPrefix, loggedInAs, '-', Time totalSeconds printString.	existingUri ifNotNil:		[incomingUser = loggedInAs			ifTrue:				[uri := existingUri.				(self projectParameterAt: #'prev-URI') ifNotNilDo:					[:prior | self storeAttributeKey: #'prev-URI' value: prior on: aStream]]			ifFalse:				[incomingUser = 'unknown' ifTrue:   "saved as unknown user, now publishing as registered user; teefal wants new uri but using original epoch in this case."					[uri := String streamContents:						[:str |							str nextPutAll: uriPrefix.							str nextPutAll: loggedInAs, '-'.							str nextPutAll: (existingUri copyAfterLast: $-)]].				self storeAttributeKey: 'prev-URI' value: existingUri on: aStream]].	self storeAttributeKey: 'URI' value: uri on: aStream.	self storeAttributeKey: 'user' value: loggedInAs on: aStream.		details _ self world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new].	Project publishInSexp ifTrue: [		self storeAttributeKey: 'Project-Format' value: 'S-Expression' on: aStream.		self storeAttributeKey: 'Project-Format-Version' value: '1.0' on: aStream.	] ifFalse: [		self storeAttributeKey: 'Project-Format' value: 'ImageSegment' on: aStream.	].	details associationsDo: [:assoc |		self storeAttributeKey: assoc key asString value: assoc value asString on: aStream.]! !!Project methodsFor: 'file in/out' stamp: 'sw 9/28/2009 00:45'!storeOnServer	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| aMessageSend |	world setProperty: #optimumExtentFromAuthor toValue: world extent.	aMessageSend := MessageSend receiver: self selector: #acceptDetailsAndStoreProject:.	self validateProjectNameIfOK: aMessageSend! !!Project methodsFor: 'file in/out' stamp: 'yo 9/9/2009 03:28'!storeOnServerInnards	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| resp newName primaryServerDirectory serverVersionPair localDirectory localVersionPair myVersionNumber warning maxNumber suppliedPassword oldResourceUrl priorWorld myDepth |	self assureIntegerVersion.	"Find out what version"	primaryServerDirectory _ self primaryServerIfNil: [		(primaryServerDirectory _ self findAFolderToStoreProjectIn) ifNil: [^self].		oldResourceUrl _ self resourceUrl.		primaryServerDirectory == #localOnly ifTrue: [			self storeNewPrimaryURL: FileDirectory default url.			nil		] ifFalse: [			self storeNewPrimaryURL: primaryServerDirectory downloadUrl.			primaryServerDirectory		].	].	localDirectory _ self squeakletDirectory.	[serverVersionPair _ self class mostRecent: self name onServer: primaryServerDirectory]		on: LoginFailedException do: [:ex |			primaryServerDirectory user: nil.^ self inform: 'Login failed.'].	localVersionPair _ self class mostRecent: self name onServer: localDirectory.	maxNumber _ myVersionNumber _ self currentVersionNumber.	ProgressNotification signal: '2:versionsDetected'.	warning _ ''.	myVersionNumber < serverVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) on the server' translated.		maxNumber _ maxNumber max: serverVersionPair second.	].	myVersionNumber < localVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) in the local directory' translated.		maxNumber _ maxNumber max: localVersionPair second.	].	"8 Nov 2000 - only check on the first attempt to publish"	myVersionNumber = 0 ifTrue: [		warning isEmpty ifFalse: [			myVersionNumber = 0 ifTrue: [				warning _ warning,'\THIS PROJECT HAS NEVER BEEN SAVED' translated.			].			warning _ 'WARNING' translated, '\Project: ' translated, self name,warning.			resp _ (PopUpMenu labels: 'Store anyway\Cancel' translated withCRs) startUpWithCaption: 				(warning, '\Please cancel, rename this project, and see what is there.' translated) withCRs.				resp ~= 1 ifTrue: [^ nil]		].	].	version _ self bumpVersion: maxNumber.	oldResourceUrl		ifNotNil: [self resourceManager adjustToNewServer: self resourceUrl from: oldResourceUrl].	"write locally - now zipped automatically"	Display isVirtualScreen ifTrue: [		myDepth _ displayDepth.		displayDepth _ OLPCVirtualScreen preferredScreenDepth.	].	newName _ self versionedFileName.	lastSavedAtSeconds _ Time totalSeconds.	priorWorld _ ActiveWorld.	self exportSegmentFileName: newName directory: localDirectory withoutInteraction: false.	ActiveWorld _ priorWorld.	(localDirectory readOnlyFileNamed: newName) setFileTypeToObject; close.	Display isVirtualScreen ifTrue: [		displayDepth _ myDepth.	].		ProgressNotification signal: '4:localSaveComplete'.	"3 is deep in export logic"	primaryServerDirectory ifNotNil: [		suppliedPassword _ ''.		Preferences passwordsOnPublish ifTrue: [			suppliedPassword _ FillInTheBlank requestPassword: 'Project password' translated		].		[		primaryServerDirectory			writeProject: self			inFileNamed: newName asFileName			fromDirectory: localDirectory.		] on: ProjectPasswordNotification do: [ :ex |			ex resume: (suppliedPassword ifNil: [''])		].	].	ProgressNotification signal: '9999 save complete'.	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."! !!Project methodsFor: 'file in/out' stamp: 'mu 10/11/2009 23:01'!storeOnServerShowProgressOn: aMorphOrNil forgetURL: forget	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| aMessageSend details |	world setProperty: #optimumExtentFromAuthor toValue: world extent.	world setProperty: #forgetURL toValue: forget.	details := world valueOfProperty: #ProjectDetails.	aMessageSend := MessageSend receiver: self selector: #acceptDetailsAndStoreProjectWithForget: argument: details.	self validateProjectNameIfOK: aMessageSend! !!Project methodsFor: 'file in/out' stamp: 'sw 7/18/2009 12:54'!storePngThumbnailIn: aFileDirectory	"Make an icon representing the receiver, and store it in the given directory."	| file writer |	file _ aFileDirectory forceNewFileNamed: ('thumbnail', FileDirectory dot, 'png').	file ifNil: [^ self].	writer := PNGReadWriter on: file.	[writer nextPutImage: self thumbnail]			ensure: [writer close]! !!Project methodsFor: 'file in/out' stamp: 'sw 9/1/2009 02:08'!writeFileNamed: localFileName fromDirectory: localDirectory toServer: primaryServerDirectory	| local resp gifFileName f |	local _ localDirectory oldFileNamed: localFileName.	resp _ primaryServerDirectory upLoadProject: local named: localFileName resourceUrl: self resourceUrl retry: false.	local close.	resp == true ifFalse: [		"abandon resources that would've been stored with the project"		self resourceManager abandonResourcesThat:			[:loc| loc urlString beginsWith: self resourceUrl].		self error: 'the primary server of this project seems to be down (',							resp printString,')'. 		^ self	]."**** NB:  Commented code that made a gif thumbnail file:	gifFileName _ self name,'.gif'.	localDirectory deleteFileNamed: gifFileName ifAbsent: [].	local _ localDirectory fileNamed: gifFileName.	thumbnail ifNil: [		(thumbnail _ Form extent: 100@80) fillColor: Color orange	] ifNotNil: [		thumbnail unhibernate.	].	f _ thumbnail colorReduced.	f depth > 8 ifTrue: [		f _ thumbnail asFormOfDepth: 8	].	GIFReadWriter putForm: f onStream: local.	local close.	[local _ StandardFileStream readOnlyFileNamed: (localDirectory fullNameFor: gifFileName).	(primaryServerDirectory isKindOf: FileDirectory)		ifTrue: [primaryServerDirectory deleteFileNamed: gifFileName ifAbsent: []].	resp _ primaryServerDirectory putFile: local named: gifFileName retry: false.	] on: Error do: [:ex |].	local close.**** "	primaryServerDirectory updateProjectInfoFor: self.	primaryServerDirectory sleep.	"if ftp, close the connection"! !!Project methodsFor: 'language' stamp: 'kfr 5/2/2010 22:35'!chooseNaturalLanguage	"Put up a menu allowing the user to choose the natural language for the project"	| aMenu availableLanguages item |Cursor wait showWhile: [	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'choose language' translated.	aMenu lastItem setBalloonText: 'This controls the human language in which tiles should be viewed.  It is potentially extensible to be a true localization mechanism, but initially it only works in the classic tile scripting system.  Each project has its own private language choice' translated.	Preferences noviceMode		ifFalse:[aMenu addStayUpItem.					].	Preferences eToyFriendly		ifFalse:[aMenu addUpdating: #useLocaleString action: #toggleUseLocale.					aMenu addLine].	availableLanguages := NaturalLanguageTranslator availableLanguageLocaleIDs										asSortedCollection:[:x :y | x displayName < y displayName].	availableLanguages do:		[:localeID |			item _ aMenu addUpdating: #stringForLanguageNameIs: target: Locale selector:  #switchAndInstallFontToID:gently: argumentList: {localeID. true} extraIcon: (Locale localeID: localeID) iconForNativeLanguage.			item wordingArgument: localeID.].].	aMenu popUpInWorld"Project current chooseNaturalLanguage"! !!Project methodsFor: 'language' stamp: 'bf 10/13/2009 14:30'!locales	"Answer list of all locales found in translatable objects"	| locales |	locales := Set new.	world allMorphsDo: [:m |		((m isKindOf: TextMorph) and: [m translatable]) ifTrue: [			m valueOfProperty: #translations ifPresentDo: [:translations |				translations keysDo: [:locale | locales add: locale]]]].	^locales! !!Project methodsFor: 'language' stamp: 'bf 10/13/2009 14:38'!localesString	"Answer comma-separated string of all locales found in translatable objects"	^String streamContents: [:stream | 		self locales			do: [:locale | stream print: locale]			separatedBy: [stream nextPut: $,]]! !!Project methodsFor: 'language' stamp: 'kfr 5/2/2010 22:33'!toggleUseLocale	^Preferences togglePreference: #useLocale	! !!Project methodsFor: 'language' stamp: 'sw 11/3/2008 22:07'!updateLocaleDependentsWithPreviousSupplies: aCollection gently: gentlyFlag	"Set the project's natural language as indicated"	| morphs scriptEditors |	gentlyFlag ifTrue: [		LanguageEnvironment localeChangedGently.	] ifFalse: [		LanguageEnvironment localeChanged.	].	morphs := IdentitySet new: 400.	ActiveWorld allMorphsAndBookPagesInto: morphs.	scriptEditors := morphs select: [:m | (m isKindOf: ScriptEditorMorph) and: [m topEditor == m]].	morphs := morphs copyWithoutAll: scriptEditors.	morphs do: [:morph |		morph isTileScriptingElement ifTrue: [morph localeChanged].		(morph isKindOf: TextMorph) ifTrue: [morph localeChanged].			"NB: only those marked as translatable will be translated..."		morph class == ObjectsTool ifTrue: [morph localeChanged]].	scriptEditors do: [:m | m localeChanged].	Flaps disableGlobalFlaps: false.	Preferences sugarNavigator 		ifTrue:			[Flaps addAndEnableEToyFlapsWithPreviousEntries: aCollection.			ActiveWorld addGlobalFlaps]		ifFalse:			[Preferences eToyFriendly				ifTrue:					[Flaps addAndEnableEToyFlaps.					ActiveWorld addGlobalFlaps]				ifFalse:					[Flaps enableGlobalFlaps]].	(Project current isFlapIDEnabled: 'Navigator' translated)		ifFalse: [Flaps enableDisableGlobalFlapWithID: 'Navigator' translated].	ParagraphEditor initializeTextEditorMenus.	MenuIcons initializeTranslations.	#(PartsBin ParagraphEditor BitEditor FormEditor StandardSystemController) 		do: [ :key | Smalltalk at: key ifPresent: [ :class | class initialize ]].	ActiveWorld reformulateUpdatingMenus.	"self setFlaps.	self setPaletteFor: aLanguageSymbol."! !!Project methodsFor: 'language' stamp: 'kfr 5/2/2010 11:29'!useLocaleString	"Answer a string characterizing whether the receiver is currently using localized language."	^ (Preferences useLocale == true ifTrue: ['<yes>'] ifFalse: ['<no>']), ('use localized language' translated)! !!Project methodsFor: 'sugar' stamp: 'bf 9/14/2009 18:08'!keepSugarProperties: aDictionary monitor: aBoolean	| dontKeep props |	aDictionary at: 'title' ifPresent: [:title | self name: title].	dontKeep := #('activity' 'activity_id' 'title' 'title_set_by_user' 'keep' 'mtime' 'timestamp' 'preview' 'icon-color' 'mime_type') asSet.	props := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value |		(dontKeep includes: key) ifFalse: [props at: key put: value]].	self sugarProperties: props.	aBoolean ifTrue: [		self sugarObjectId ifNotNilDo: [:id |			SugarLauncher current monitorJournalEntry: id]].! !!Project methodsFor: 'sugar' stamp: 'bf 9/14/2009 16:32'!sugarObjectId	^((self sugarProperties ifNil: [^nil])		at: 'uid' ifAbsent: [nil]) asString! !!Project methodsFor: 'sugar' stamp: 'bf 9/14/2009 16:24'!sugarObjectId: aStringOrNil	| props |	props := self sugarProperties ifNil: [self sugarProperties: Dictionary new].	aStringOrNil		ifNil: [props removeKey: 'uid' ifAbsent: []]		ifNotNil: [props at: 'uid' put: aStringOrNil]! !!Project methodsFor: 'sugar' stamp: 'bf 9/14/2009 16:16'!sugarProperties	^self projectParameterAt: #sugarProperties ifAbsent: [nil]! !!Project methodsFor: 'sugar' stamp: 'bf 9/14/2009 16:16'!sugarProperties: aDictionary	^self projectParameterAt: #sugarProperties put: aDictionary! !!Project class methodsFor: 'utilities' stamp: 'dtl 4/3/2005 14:02'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ self interruptName: labelString preemptedProcess: nil! !!Project class methodsFor: 'utilities' stamp: 'ar 9/6/2009 11:04'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	| preemptedProcess projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	ActiveHand ifNotNil:[ActiveHand interrupted].	ActiveWorld := World. "reinstall active globals"	ActiveHand := World primaryHand.	ActiveHand interrupted. "make sure this one's interrupted too"	ActiveEvent := nil.	projectProcess := self uiProcess.	"we still need the accessor for a while"	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	"Only debug preempted process if its priority is >= projectProcess' priority"	preemptedProcess priority < projectProcess priority 		ifTrue:[preemptedProcess := projectProcess].	preemptedProcess suspend.	Debugger openInterrupt: labelString onProcess: preemptedProcess! !!Project class methodsFor: 'utilities' stamp: 'tk 10/26/1999 14:25'!returnToPreviousProject	"Return to the project from which this project was entered. Do nothing if the current project has no link to its previous project."	| prevProj |	prevProj _ CurrentProject previousProject.	prevProj ifNotNil: [prevProj enter: true revert: false saveForRevert: false].! !!Project class methodsFor: 'constants' stamp: 'bf 9/11/2009 23:57'!home	"Answer the home project."	^self named: 'Home'! !!ProjectLauncher methodsFor: 'running' stamp: 'KR 6/23/2009 12:38'!startUpAfterLogin	| scriptName loader isUrl |	self setupMOPath.	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName _ self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName _ (SmalltalkImage current getSystemAttribute: 2) ifNil:[''].			scriptName _ scriptName convertFromWithConverter: LanguageEnvironment defaultFileNameConverter.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl _ (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[scriptName _ 'file:',scriptName]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader _ CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!ProjectLoading class methodsFor: 'private' stamp: 'yo 9/8/2009 13:47'!loadImageSegment: morphOrList  fromDirectory: aDirectoryOrNil withProjectView: existingView numberOfFontSubstitutes: numberOfFontSubstitutes substituteFont: substituteFont mgr: mgr	| proj projectsToBeDeleted ef f |	(f _ (Flaps globalFlapTabWithID: 'Navigator' translated)) ifNotNil: [f hideFlap].	proj _ morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^ nil].	numberOfFontSubstitutes > 0 ifTrue: [		proj projectParameterAt: #substitutedFont put: substituteFont].	ef := proj projectParameterAt: #eToysFont.	(ef isNil or: [ef ~= substituteFont familySizeFace]) ifTrue: [		proj projectParameterAt: #substitutedFont put: substituteFont.	].	proj projectParameters at: #MultiSymbolInWrongPlace put: false.		"Yoshiki did not put MultiSymbols into outPointers in older images!!"	morphOrList arrayOfRoots do: [:obj |		obj fixUponLoad: proj seg: morphOrList "imageSegment"].	(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [		morphOrList arrayOfRoots do: [:obj | (obj isKindOf: Set) ifTrue: [obj rehash]]].	proj resourceManager: mgr.	"proj versionFrom: preStream."	proj lastDirectory: aDirectoryOrNil.	CurrentProjectRefactoring currentBeParentTo: proj.	projectsToBeDeleted _ OrderedCollection new.	existingView == #none ifFalse: [		self makeExistingView: existingView project: proj projectsToBeDeleted: projectsToBeDeleted].	ChangeSorter allChangeSets add: proj changeSet.	Project current projectParameters		at: #deleteWhenEnteringNewProject		ifPresent: [ :ignored |			projectsToBeDeleted add: Project current.			Project current removeParameter: #deleteWhenEnteringNewProject.		].	projectsToBeDeleted isEmpty ifFalse: [		proj projectParameters			at: #projectsToBeDeleted			put: projectsToBeDeleted.	].	proj removeParameter: #eToysFont.	^ proj! !!ProjectLoading class methodsFor: 'private' stamp: 'sw 9/11/2009 01:45'!loadSexpProjectDict: dict stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView   	| archive anObject newProj d member b s memberStream members newSet allNames realName oldSet |	(self checkStream: preStream) ifTrue: [^ self].	ProgressNotification signal: '0.2'.	preStream reset.	archive _ preStream isZipArchive		ifTrue:[ZipArchive new readFrom: preStream]		ifFalse:[nil].	members _ archive  membersMatching: '*.cs'.	members do: [:e | newSet _ ChangeSorter newChangesFromStream: e contentStream named: 'zzTemp', Time totalSeconds printString].	member _ (archive membersMatching: '*.sexp') first.	memberStream _ member contentStream.	(self checkSecurity: member name preStream: preStream projStream: memberStream)		ifFalse: [^nil].	b _ String new: member uncompressedSize.	s _ RWBinaryOrTextStream on: b.	s binary.	s nextPutAll: memberStream basicUpToEnd.	s reset.	d _ DataStream on: s.	anObject _ d next sissReadObjectsAsEtoysProject.	"anObject _ (MSExpParser parse: (archive membersMatching: '*.sexp') first contents with: #ksexp) sissReadObjects."	anObject ifNil: [^ self].	(anObject isKindOf: PasteUpMorph) ifFalse: [^ World addMorph: anObject].	preStream close.	ProgressNotification  signal: '0.7'.	newProj _ Project newMorphicOn: anObject.	newSet ifNotNil: [oldSet _ newProj changeSet.  newProj setChangeSet: newSet. ChangeSorter removeChangeSet: oldSet].	dict at: 'projectname' ifPresent: [:n |		allNames _ Project allNames.		realName _ Utilities keyLike: n  satisfying:		[:nn | (allNames includes: nn) not].		newProj renameTo: realName.	].	anObject valueOfProperty: #projectVersion ifPresentDo: [:v | newProj version: v].	newProj  noteManifestDetailsIn: dict.	ProgressNotification  signal: '0.8'.	^ newProj.! !!ProjectLoading class methodsFor: 'private' stamp: 'sw 9/11/2009 01:47'!openSexpProjectDict: dict stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView   	| archive anObject newProj d member b s memberStream members newSet allNames realName oldSet |	(self checkStream: preStream) ifTrue: [^ self].	ProgressNotification signal: '0.2'.	preStream reset.	archive _ preStream isZipArchive		ifTrue:[ZipArchive new readFrom: preStream]		ifFalse:[nil].	members _ archive  membersMatching: '*.cs'.	members do: [:e | newSet _ ChangeSorter newChangesFromStream: e contentStream named: 'zzTemp', Time totalSeconds printString].	member _ (archive membersMatching: '*.sexp') first.	memberStream _ member contentStream.	(self checkSecurity: member name preStream: preStream projStream: memberStream)		ifFalse: [^nil].	b _ String new: member uncompressedSize.	s _ RWBinaryOrTextStream on: b.	s binary.	s nextPutAll: memberStream basicUpToEnd.	s reset.	d _ DataStream on: s.	anObject _ d next sissReadObjectsAsEtoysProject.	"anObject _ (MSExpParser parse: (archive membersMatching: '*.sexp') first contents with: #ksexp) sissReadObjects."	anObject ifNil: [^ self].	(anObject isKindOf: PasteUpMorph) ifFalse: [^ World addMorph: anObject].	preStream close.	ProgressNotification  signal: '0.7'.	newProj _ Project newMorphicOn: anObject.	newSet ifNotNil: [oldSet _ newProj changeSet.  newProj setChangeSet: newSet. ChangeSorter removeChangeSet: oldSet].	dict at: 'projectname' ifPresent: [:n |		allNames _ Project allNames.		realName _ Utilities keyLike: n  satisfying:		[:nn | (allNames includes: nn) not].		newProj renameTo: realName.	].	anObject valueOfProperty: #projectVersion ifPresentDo: [:v | newProj version: v].	newProj  noteManifestDetailsIn: dict.	ProgressNotification  signal: '0.8'.	^ newProj		ifNil: [self inform: 'No project found in this file' translated]		ifNotNil: [ProjectEntryNotification signal: newProj].! !!ProjectLoading class methodsFor: 'public' stamp: 'yo 9/8/2009 13:45'!loadName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	^ self loadName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView clearOriginFlag: false.! !!ProjectLoading class methodsFor: 'public' stamp: 'bf 9/14/2009 20:25'!loadName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView clearOriginFlag: clearOriginFlag	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList archive mgr substituteFont numberOfFontSubstitutes resultArray anObject project manifests dict |	(self checkStream: preStream) ifTrue: [^ self].	ProgressNotification signal: '0.2'.	archive _ preStream isZipArchive		ifTrue:[ZipArchive new readFrom: preStream]		ifFalse:[nil].	manifests _ (archive membersMatching: '*manifest').	(manifests size = 1 and: [((dict _ self parseManifest: manifests first contents) at: 'Project-Format' ifAbsent: []) = 'S-Expression'])		ifTrue: [^ self loadSexpProjectDict: dict stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView].	morphOrList _ self morphOrList: aFileName stream: preStream fromDirectory: aDirectoryOrNil archive: archive.	morphOrList ifNil: [^ self].	ProgressNotification  signal: '0.4'.	resultArray _ self fileInName: aFileName archive: archive morphOrList: morphOrList.	anObject _ resultArray first.	numberOfFontSubstitutes _ resultArray second.	substituteFont _ resultArray third.	mgr _ resultArray fourth.	preStream close.	ProgressNotification  signal: '0.7'.		"the hard part is over"	(anObject isKindOf: ImageSegment) ifTrue: [		project _ self loadImageSegment: anObject			fromDirectory: aDirectoryOrNil			withProjectView: existingView			numberOfFontSubstitutes: numberOfFontSubstitutes			substituteFont: substituteFont			mgr: mgr.		project noteManifestDetailsIn: dict.		project removeParameter: #sugarProperties.		SugarPropertiesNotification signal ifNotNilDo: [:props | 			project keepSugarProperties: props monitor: true].		clearOriginFlag ifTrue: [project forgetExistingURL].		ProgressNotification  signal: '0.8'.		^ project	].! !!ProjectLoading class methodsFor: 'public' stamp: 'bf 9/14/2009 18:09'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView clearOriginFlag: clearOriginFlag	"Reconstitute a Morph from the selected file, presumed torepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList archive mgr substituteFont numberOfFontSubstitutes resultArray anObject project manifests dict |	(self checkStream: preStream) ifTrue: [^ self].	ProgressNotification signal: '0.2'.	archive _ preStream isZipArchive		ifTrue:[ZipArchive new readFrom: preStream]		ifFalse:[nil].	archive ifNotNil:[	manifests _ (archive membersMatching: '*manifest').	(manifests size = 1 and: [((dict _ self parseManifest: manifests first contents) at: 'Project-Format' ifAbsent: []) = 'S-Expression'])		ifTrue: [^ self openSexpProjectDict: dict stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView]].	morphOrList _ self morphOrList: aFileName stream: preStream fromDirectory: aDirectoryOrNil archive: archive.	morphOrList ifNil: [^ self].	ProgressNotification  signal: '0.4'.	resultArray _ self fileInName: aFileName archive: archive morphOrList: morphOrList.	anObject _ resultArray first.	numberOfFontSubstitutes _ resultArray second.	substituteFont _ resultArray third.	mgr _ resultArray fourth.	preStream close.	ProgressNotification  signal: '0.7'.		"the hard part is over"	(anObject isKindOf: ImageSegment) ifTrue: [		project _ self loadImageSegment: anObject			fromDirectory: aDirectoryOrNil			withProjectView: existingView			numberOfFontSubstitutes: numberOfFontSubstitutes			substituteFont: substituteFont			mgr: mgr.].	(anObject isKindOf: ImageSegment) ifTrue: [		project noteManifestDetailsIn: dict.		project removeParameter: #sugarProperties.		SugarPropertiesNotification signal ifNotNilDo: [:props | 			project keepSugarProperties: props monitor: true].		clearOriginFlag ifTrue: [project forgetExistingURL].		ProgressNotification  signal: '0.8'.			^ project				ifNil: [self inform: 'No project found in this file' translated]				ifNotNil: [ProjectEntryNotification signal: project]].	self loadSqueakPage: anObject! !!ProjectLoading class methodsFor: 'loading' stamp: 'yo 9/8/2009 13:45'!openFromDirectory: aDirectory andFileName: aFileName 	"Open the project with progress bar"	| fileAndDir |	shouldClearOrigin := (aDirectory isKindOf: DAVMultiUserServerDirectory) and: [aDirectory acceptsUploads not].	self		showProgressBarDuring: [ProgressNotification signal: '0'.			fileAndDir := self bestAccessToFileName: aFileName andDirectory: aDirectory.			self				openName: aFileName				stream: fileAndDir first				fromDirectory: fileAndDir second				withProjectView: nil				clearOriginFlag: ((aDirectory isKindOf: DAVMultiUserServerDirectory) and: [aDirectory acceptsUploads not])]! !!ProjectLoading class methodsFor: 'loading' stamp: 'yo 9/8/2009 13:43'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	^ self openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView clearOriginFlag: false.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'bf 9/12/2009 19:06'!showMenuFor: aSymbol event: evt	(#(publishProject publishProjectSimple keepProject) includes: aSymbol) ifTrue: [		self doPublishButtonMenuEvent: evt.		^true		"we did show the menu"	].	(#(findAProject findAProjectSimple chooseObject) includes: aSymbol) ifTrue: [		self doFindButtonMenuEvent: evt.		^true		"we did show the menu"	].	(aSymbol == #stopSqueak) ifTrue: [		self doStopButtonMenuEvent: evt.		^true		"we did show the menu"	].	(aSymbol == #zoom) ifTrue: [		self doZoomButtonMenuEvent: evt.		^true		"we did show the menu"	].	^false! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'sw 8/6/2009 03:21'!doFindButtonMenuEvent: evt	"Put up the find-projects dialog"	| menu selection |	menu _ CustomMenu new.	menu 		add: 'find a project' translated action: [self findAProjectSimple];		add: 'find a project (more places)' translated action: [self findAProject];		add: 'find any file' translated action: [self findAnything].		"add: 'search the SuperSwiki' translated action: [self findSomethingOnSuperSwiki]."	selection _ menu build startUpCenteredWithCaption: 'find (load) a project' translated.	selection ifNotNil: [selection value]! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'sw 8/6/2009 03:39'!doPublishButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'publish' translated action: [self publishProject];		add: 'publish as...' translated action: [self publishProjectAs];		add: 'publish to different server' translated action: [self publishDifferent];		addLine;		add: 'edit project info' translated action: [self editProjectInfo].	selection _ menu build startUpCenteredWithCaption: 'publish the current project' translated.	selection ifNotNil: [selection value]! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'sw 9/28/2009 15:51'!editProjectInfo	"Put up the project-info dialog, and if the user accept his edits in that dialog, save the changed info back to the project."	| aMessageSend |	aMessageSend := MessageSend receiver: ActiveWorld  selector:  #yourself argument: nil.	"The handling in doOK already installs the project-info changes into the project, so there is no extra processing needed via the actionBlock mechanism in this case, so we supply a no-op message send instead."	EToyProjectDetailsMorph 		getFullInfoFor: (self world ifNil: [^self]) project		ifValid: aMessageSend		expandedFormat: true! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'sw 6/11/2009 17:17'!newProject	Project enterNew! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 9/14/2009 11:06'!publishStyle: aSymbol forgetURL: aBoolean withRename: renameBoolean	| w saveOwner primaryServer rename |	w _ self world ifNil: [^Beeper beep].	w setProperty: #SuperSwikiPublishOptions toValue: aSymbol.	primaryServer _ w project primaryServerIfNil: [nil].	rename _ ((primaryServer notNil		and: [primaryServer acceptsUploads]) not)		or: [renameBoolean].	rename := rename or: [(primaryServer isKindOf: DAVMultiUserServerDirectory)].	w setProperty: #SuperSwikiRename toValue: rename.	saveOwner _ owner.	self delete.	[w project 		storeOnServerShowProgressOn: self 		forgetURL: aBoolean | rename]		ensure: [saveOwner addMorphFront: self]! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'sw 7/7/2009 07:06'!toggleFullScreen	"Toggle the setting of fullScreen"	self inFullScreenMode ifTrue: [self fullScreenOff] ifFalse: [self fullScreenOn]! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'sw 8/6/2009 03:40'!buttonFind	"Answer a button for finding/loading projects"	^ self makeButton: 'FIND' translated balloonText: 'Find (load) another project. Hold mouse button down for further options.' translated for: #findAProjectSimple! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'sw 8/6/2009 03:40'!buttonPublish	"Answer a button for publishing the project "	^ self makeButton: 'PUBLISH IT!!' translated balloonText: 'Publish (save) this project.Hold mouse button down for further options' translated for: #publishProject! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'bf 8/22/2010 16:00'!buttonQuit	"Make and answer a button whose pressing will result in quitting out of Squeak."	^self makeButton: 'QUIT' translated balloonText: 'Quit Etoys (without saving)' translated for: #quitSqueak! !!ProjectNavigationMorph methodsFor: 'buttons' stamp: 'sw 9/13/2009 20:43'!makeTheAdvancedButtons	^{		self buttonNewProject.		self buttonShare.		self buttonPrev.		self buttonNext.		self buttonPublish.		self buttonNewer.		self buttonTell.		self buttonFind.		self buttonFullScreen.		"self buttonFlaps."		self buttonPaint.	},	(		Preferences includeSoundControlInNavigator ifTrue: [{self buttonSound}] ifFalse: [#()]	),	{		self buttonLanguage.		"self buttonUndo."		self buttonQuit.	}! !!ProjectNavigationMorph methodsFor: 'buttons' stamp: 'sw 9/13/2009 20:41'!makeTheSimpleButtons	"Add the buttons for use in normal kids' mode."	^{		self buttonNewProject.		self buttonPrev."		self buttonNext."		self buttonPublish.		self buttonFind."		self buttonFullScreen."		self buttonPaint.	},	(		Preferences includeSoundControlInNavigator ifTrue: [{self buttonSound}] ifFalse: [#()]	),	{		self buttonLanguage.		"self buttonUndo."		self buttonQuit.	}! !!ProjectSorterMorph methodsFor: 'menu commands' stamp: 'sw 9/28/2009 02:45'!handUserSorterMorphForProjectNamed: aName	"Hand the user a sorter token representing the project of the given name."	(self sorterMorphForProjectNamed: aName) openInHand! !!ProjectSorterMorph methodsFor: 'menu commands' stamp: 'sw 9/28/2009 02:45'!insertNewProject: evt	"Insert a new project into the image, and hand the user a sorter token representing that project."	| newProj msgSend |	[newProj _ Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		msgSend := MessageSend receiver: self selector: #handUserSorterMorphForProjectNamed: arguments: {newProj name}.	EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: msgSend		expandedFormat: false! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'sw 12/8/2008 11:18'!expungeProject	"Remove the icon representing the project."	| top itsOwner |	project okToChange ifFalse: [^ self].	top := self topRendererOrSelf.	itsOwner := top owner.	itsOwner isSystemWindow		ifTrue:			[itsOwner model: nil;				 delete]		ifFalse:			[top delete]! !!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:54'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock valueWithPossibleArgument: self! !!ProtoObject methodsFor: 'testing' stamp: 'eem 5/23/2008 11:02'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:55'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock valueWithPossibleArgument: self! !!PseudoClass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30'!isMeta	^false! !!PseudoClass methodsFor: '*monticello' stamp: 'bf 7/25/2005 15:50'!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames asSortedCollection		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!PseudoMetaclass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30'!isMeta	^true! !!QuickGuideGenerator methodsFor: 'all' stamp: 'bf 8/14/2010 01:24'!setInput: aString	input := aString asString.	(input endsWith: FileDirectory slash) ifTrue: [input _ input copyFrom: 1 to: input size - 1].	inputMorph hasUnacceptedEdits: false.! !!QuickGuideGenerator methodsFor: 'all' stamp: 'bf 8/14/2010 01:24'!setOutput: aString	output := aString asString.	(output endsWith: FileDirectory slash) ifTrue: [output _ output copyFrom: 1 to: output size - 1].	outputMorph hasUnacceptedEdits: false.! !!QuickGuideHolderMorph methodsFor: 'accessing' stamp: 'KR 5/28/2010 18:21'!guideName: aString	guideName _ aString.	self setNamePropertyTo: aString.! !!QuickGuideHolderMorph methodsFor: 'file in/file out' stamp: 'tk 8/11/2010 09:20'!load	"If 'guide.00x.pr' is present, take the one with the largest x.  If only '.sexp.data.gz', then use it"	| dir m fileName f unzipped zipped ours proj tm |	self submorphs size > 0 ifTrue: [^ self].	dir _ FileDirectory on: QuickGuideMorph guidePath.	"#('xxx.001.pr' 'xxx.035.pr'  'xxx.sexp.data.gz') asSortedCollection   ('xxx.001.pr' 'xxx.035.pr' 'xxx.sexp.data.gz')"	ours _ dir fileNames select: [:fName | 		(fName beginsWith: guideName) and: [(fName endsWith: '.pr') or: [fName endsWith: '.sexp.data.gz']]].	ours _ ours asSortedCollection.	ours size = 0 ifTrue: [		submorphs size = 0 ifTrue: [			tm := TextMorph new contents: 'guide is missing' translated.			tm topLeft: self topLeft + (4@4).			self width: (self width max: 200).			self addMorphFront: tm].		^ self].	fileName _ ours size > 1 ifTrue: [ours at: (ours size - 1) "most recent .pr file"] ifFalse: [ours last "sexp"].	proj _ fileName endsWith: '.pr'.	Cursor wait showWhile: [		proj ifFalse: [			unzipped _ WriteStream on: ByteArray new.			f _ dir readOnlyFileNamed: fileName.			zipped _ GZipReadStream on: f.			unzipped nextPutAll: zipped contents.			m _ BookMorph bookFromPagesInSISSFormat: (DataStream on: (ReadStream on: (unzipped contents))) next.			f close].		proj ifTrue: [			m _ self loadPR: fileName dir: dir.			m ifNil: [^ self]].		m position: 0@0.		self position: 0@0.		self extent: m extent.		m setNamePropertyTo: guideName.		m beSticky.		self translateGuide: m.		self addMorph: m.	].! !!QuickGuideMorph methodsFor: 'initialization' stamp: 'bf 9/11/2010 18:46'!initializeIndexPage	| indexPage firstPage |	"debugging only -- look on disk"	self checkForIndexOnDisk ifTrue: [		self goToPage: 1.		^ self]. 	"Done.  sets IndexPage every time if found"	IndexPage ifNotNil: [		indexPage _ IndexPage veryDeepCopy.		firstPage _ pages first.		indexPage position: firstPage position.		indexPage beSticky.		firstPage extent: indexPage extent.		firstPage submorphs size > 0 ifTrue: [firstPage submorphs last delete].		firstPage submorphs size > 0 ifTrue: [firstPage submorphs last delete].		firstPage addMorph: indexPage.		self goToPage: 1.	].! !!QuickGuideMorph methodsFor: 'initialization' stamp: 'tk 8/10/2010 22:08'!loadPages	| pageCount newPages page unusedPages |	pageCount := PagesForCategory inject: 0 into: [:arg :each | arg + (each size)].	newPages _ OrderedCollection new: pageCount.	page _ pages detect: [:p | (p hasProperty: #quickGuideHolder) and: [p knownName = 'index']] ifNone: [nil].	page ifNil: [		page _ QuickGuideHolderMorph new.		page guideName: 'index' translated.		page setProperty: #transitionSpec toValue:  (Array with:  'silence' with: #none with: #none).	].	page guideNameInWords ifNil: [			page guideNameInWords: 'Index' translated].	newPages add: page.     Categories do: [:categoryRec | | catKey  |		catKey := categoryRec first.		(PagesForCategory at: catKey) do:  [: rec || guideName guideTitle |			guideName := rec first.			guideTitle := rec second.			page _ pages detect: [:p | (p hasProperty: #quickGuideHolder) and: [p knownName = guideName]] ifNone: [nil].			page ifNil: [				page _ QuickGuideHolderMorph new.				page guideName: guideName.				page guideNameInWords: guideTitle.				page setProperty: #transitionSpec toValue:  (Array with:  'silence' with: #none with: #none).			].			newPages add: page.		].	].			unusedPages _ pages reject: [:e | (newPages includes: e)].	self newPages: (newPages, unusedPages) currentIndex: 1.! !!QuickGuideMorph methodsFor: 'transition' stamp: 'bf 9/11/2010 19:05'!checkForIndexOnDisk	"For localization.  Look on disk every time for a new Index. Overwrite IndexPage if found."	| dir holder |	dir _ FileDirectory on: QuickGuideMorph guidePath.	(dir fileExists: 'index.pr') ifFalse: [		(dir fileExists: 'index.sexp.data.gz') ifFalse: [^ false]].	holder _ pages first.	holder guideName: 'index'. 	holder guideCategory: ''. 	holder load.	"allow index.sexp.data.gz"	IndexPage _  holder submorphs first.	^ true"	IndexPage _ QuickGuideHolderMorph new loadPR: 'index.pr' dir: dir.	"! !!QuickGuideMorph methodsFor: 'page controls' stamp: 'bf 9/9/2010 12:07'!shortControlSpecs	^ {		#spacer.		#pageNumber.		#variableSpacer.		{#PrevPage. 		#previousPage.			'Previous page' translated}.		#spacer.		#showDescription.		#spacer.		{#NextPage.		#nextPage.				'Next page' translated}.		#variableSpacer.		{' ', 'Jump to...' translated, ' '.	#showJumpToMenu.		'Menu to see another Guide' translated.	#border}.			"further adjusted in jumpToAdjust: "		#spacer.	}! !!QuickGuideMorph methodsFor: 'write web pages' stamp: 'tk 8/16/2010 10:18'!guidesIndexForWiki	"Create the html for a long list of guide categories and guides.  Each is a clickable link.  For the laptop.org wiki.  An index to the web pages for the Guides.	Inspect a Guide and go up the owner chain to a QuickGuideMorph.   self  guidesIndexForWiki     "	| strm |	strm _ WriteStream on: (String new: 6000).	strm nextPutAll: 'At the top left of the screen in Etoys is a "?" button.  Clicking it brings up a help flap with more than 50 QuickGuides.  These tell how to use different parts of Etoys.  [[Image:Help-icon.jpeg]]The QuickGuides are also available on the web.  Note that the active buttons and Etoys controls will not work in the web version.__NOTOC__'; cr.	strm nextPutAll: '=== Guides about topics in EToys ==='; cr; cr.	self class categoryNamesDo: [:catName |		strm nextPutAll: '==== '; nextPutAll: catName translated; nextPutAll: ' ===='; cr.		pages do: [:pp |			pp guideCategory = catName ifTrue: [				strm nextPutAll: '* [http://tinlizzie.org/olpc/QG-web/', pp guideName, '.html'.				strm space; nextPutAll: pp guideNameInWords translated; nextPutAll: ']'; cr.				]].		].	^ strm contents	"&nbsp;"! !!QuickGuideMorph methodsFor: 'write web pages' stamp: 'tk 8/11/2010 14:19'!guideToWebWithJPEGs: withPics	"Write all the info in this guide to a web page.  Pages are images (jPEGs).  Create a page to hold them."	| dir qgh bk strm ff allText thisText |	dir _ FileDirectory default directoryNamed: 'QG-web'.	"picutres of guide pages"	qgh _ self submorphOfClass: QuickGuideHolderMorph.	(bk _ qgh submorphOfClass: BookMorph) ifNil: [^ self].	strm _ WriteStream on: (String new: 500).	strm nextPutAll: (self htmlPreamble: qgh guideNameInWords).	"includes index side bar"	allText _ ''.	1 to: bk pages size do: [:ii |		withPics ifTrue: [	"Make images of pages"			bk goToPage: ii.	"show it"			self jPegOutDir: dir].		thisText _ self allTextIn: (bk pages at: ii).		strm nextPutAll: '		  <tr><td>  <img  alt="'.		strm nextPutAll: qgh guideName, ', page ', ii printString,'. ', thisText, '"  src="./'.		strm nextPutAll: qgh guideName , '-', ii printString,'.jpg"> </tr></tc>'.		allText _ allText, thisText].	strm nextPutAll: '		</table></td></tc></table><p><a href="#thetop">Jump to Top</a></p><p>Squeak Etoys is a "media authoring tool"-- software that you can download to your computer <br>and then use to create your own media.  You can write out your project and share it with others.  <br>Etoys runs on any Mac or Windows machine, as well as on the OLPC XO machine.  <br>It is free. &nbsp;&nbsp;	<a href="http://www.squeakland.org/whatis/whatismain.html">Find out about Etoys.</a></p><p><br><br>Text of this guide (for searching): ', allText, '</p></body></html>                  '.	ff _ dir fileNamed: qgh guideName, '.html'.	ff nextPutAll: strm contents; close.! !!QuickGuideMorph methodsFor: 'write web pages' stamp: 'tk 8/11/2010 15:09'!htmlForJumpTo	"Create the html for a long list of guide categories and guides.  Each is a clickable link.  Store in the class var HTMLJumpTo.  For creating web pages from the Guides."	| strm ap |	1 to: pages size do: [:ii | self goToPage: ii].	"create all pages" 	strm _ WriteStream on: (String new: 500).	strm nextPutAll: '<b>Guides about topics in EToys</b><br><i>Help screens for the OLPC<br> XO machine.</i><br>'.	Categories do: [:pair |		strm nextPutAll: pair second translated; nextPutAll: '<br>'; cr.		(PagesForCategory at: pair first) do: [:gPair |			ap := pages detect: [:p | (p hasProperty: #quickGuideHolder) and: [p knownName = gPair first]] ifNone: [nil].			(ap submorphOfClass: BookMorph) ifNotNil: ["exists"				strm tab; tab.				strm nextPutAll: '&nbsp;&nbsp;&nbsp;<a href="./', gPair first, '.html">'.				strm nextPutAll: gPair second; nextPutAll: '</a><br>'; cr]]].	^ HTMLJumpTo _ strm contents! !!QuickGuideMorph methodsFor: 'menu actions' stamp: 'tk 8/10/2010 14:37'!makeCategoryMenu: catName	"return a menu with all guides in this category.  No title"	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	PagesForCategory ifNil: [self class loadIndexAndPeekOnDisk].	(PagesForCategory at: catName ifAbsent: [#()]) 			do: [:articleRec |				subMenu add: (articleRec second) 							target: self 							selector: #goToCardNamed: 							argument: (articleRec first)].	^ subMenu! !!QuickGuideMorph methodsFor: 'menu actions' stamp: 'tk 8/16/2010 10:18'!showDescriptionMenu: evt	"The Jump To menu.  Choose a guide to see next"	| aMenu subMenu aWorld pos |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Quick Guides' translated.	self class categoryNamesDo: [:catName |		subMenu _ self makeCategoryMenu: catName.		subMenu items ifNotEmpty: [				aMenu add: (self class categoryTitleOf: catName)							subMenu: subMenu]].	aMenu add: 'Index' translated action: #goToIndex.	aWorld _ aMenu currentWorld.	pos _ aWorld primaryHand position - (aMenu fullBounds extent) + (-2@30).	aMenu popUpAt: pos forHand: aWorld primaryHand in: aWorld.! !!QuickGuideMorph methodsFor: 'menu actions' stamp: 'KR 5/28/2010 17:57'!showMenuCategory: catName	"put up a menu with all guides in this category"	| subMenu |	subMenu _ self makeCategoryMenu: catName.	subMenu addTitle: (self class categoryTitleOf: catName).	subMenu popUpInWorld.! !!QuickGuideMorph commentStamp: 'tk 8/15/2010 14:18' prior: 0!A BookMorph that holds QuickGuides.Worldan AlignmentMorph (the flap)an AlignmentMorpha QuickGuideMorph  (one page per guide, 54 pages.  		Page may be a stub if guide not in)a QuickGuideHolderMorpha BookMorph (4 pages)a PasteUpMorph (a page)QuickGuides are stored in Contents/Resources/QuickGuides/or by language in Contents/Resources/locale/<id>/QuickGuides/(see guidePath)Categories = OrderedCollection of {catKey. catTitle}	where catKey appears at the start of a file name 'Menu'	catTitle may be UTF-8 full name.PagesForCategory dictionary of (catKey -> list).  list has elements {guideName. guideTitle}.  guideName is last part of a file name and guideTitle may be in UTF-8.!!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/16/2010 10:21'!buildDefaultIndex	| stems beg caps ind |	self fileNameStems.	"used by defaultOrderIn:"	Categories := OrderedCollection new.	self suggestedCategoryOrder 			do: [:cat | Categories add: {cat. cat}].	stems := FileNameStems.	stems do: [:fn | 		(self categoryOf: fn) = '' ifTrue: ["new"			"find first word"			caps := fn collect: [:char | 				char isUppercase ifTrue: [$c] ifFalse: [$l]].			caps at: 1 put: $l.			(ind := caps indexOf: $c) = 0 ifFalse: [				beg := fn copyFrom: 1 to: ind-1.				Categories add: {beg. beg}]]].	PagesForCategory := self defaultIndex.! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/16/2010 10:13'!categoryNamesDo: aBlock	"go through the categories in order"	Categories do: [:catRec |		aBlock value: catRec first].! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'KR 5/28/2010 17:53'!categoryTitleOf: catName	|catTitle|	Categories do: [:catRec |		(catRec first = catName )  			ifTrue: [				catTitle := catRec second.				catTitle isNil ifTrue: [^catName]									ifFalse: [^catTitle].			].	].	^nil! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'bf 8/14/2010 13:55'!convertProjectsWithBooksToSISSIn: dir to: outDir	| p book |	dir fileNames do: [:f |		(f endsWith: '.pr') ifTrue: [			p _ ProjectLoading loadName: f stream: (dir readOnlyFileNamed: f) fromDirectory: dir withProjectView: nil.			book _ p world submorphs detect: [:b | b isMemberOf: BookMorph] ifNone: [nil].			book ifNotNil: [				book hidePageControls.				book storeAsDataStreamNamed: (outDir fullNameFor: (f copyUpTo: $.), '.sexp.data.gz').			].			p okToChangeSilently.		].	].! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/16/2010 10:22'!defaultCatalog	| catalog | 	catalog := Dictionary new.	self fileNameStems.	"used by defaultOrderIn:"	self suggestedCategoryOrder 			do: [:catKey| |articles|				articles := OrderedCollection new.				(self defaultOrderIn: catKey) 					do: [:guideName | | guideTitle |						guideTitle := self getWordyName: guideName forCategory: catKey.						articles add: {guideName. guideTitle}.					].				catalog at: catKey put: articles.			].	^catalog.! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/16/2010 10:13'!defaultIndex	"Produce PagesForCategory.  Categories must already be initialized"	| index | 	index := Dictionary new.	self categoryNamesDo: [:catKey | |articles|				articles := OrderedCollection new.				(self defaultOrderIn: catKey) 					do: [:guideName | | guideTitle |						guideTitle := self getWordyName: guideName forCategory: catKey.						articles add: {guideName. guideTitle}.					].				index at: catKey put: articles.			].	^index.! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'KR 5/28/2010 17:00'!getWordyName: guideName forCategory: guideCategory	"With guideName and category already filled in, make a name in words.  Remove the cat name, and trailing digits.  Separate words at capital letters.  NavBarHowToUse3 -> 'How To Use'  "	| gn mm tt |	gn _ guideName allButFirst: guideCategory size.	gn _ gn withoutTrailingDigits.	mm _ gn size.	gn reversed doWithIndex: [:cc :ind | 		ind < mm  ifTrue: [			cc isUppercase ifTrue: [ 				tt _ mm + 1 - ind.				gn _ (gn copyFrom: 1 to: tt-1), ' ', (gn copyFrom: tt to: gn size)].			cc == $- ifTrue: [				tt _ mm + 1 - ind.				gn at: tt put: $ ].	"convert dash to space"			]].	^ gn! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'bf 9/11/2010 18:50'!indexPage: anObject	IndexPage := anObject.	IndexPage ifNotNil: [		IndexPage setNamePropertyTo: 'index'].! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/17/2010 19:19'!loadIndex	"Optional catalog file 'catalog.txt' may be placed to where Quickguide contents resides.  Purpose is to allow UTF8 encoded titles and menu items for guides.  It also suggests an order for guides within a category.:NavBar/Navigator                        <--- categoryName/title of category PaintBrushes/Brushes                  <--- guideName/title of guidePaintColorPalette/Color Palette    Titles for categories and guides can be translated.      The file is UTF8 encoded.    File name for each guide contents is <guideName>.sexp.data.gz.    <guideName> should be named only with ascii characters.Template of catalog file can be generated by evaluating this:        QuickGuideMorph buildDefaultIndex.        QuickGuideMorph saveCatalog."	| st line rec categoryRec catKey  catTitle guideName guideTitle|	st := FileStream oldFileOrNoneNamed: QuickGuideMorph guidePath, (FileDirectory slash), 'index.txt'.	st ifNil: [^ self buildDefaultIndex].	st wantsLineEndConversion: true.	st text.     Categories := OrderedCollection new.	PagesForCategory := Dictionary new.	[st atEnd] whileFalse: [		line := (st upTo: Character cr) withoutTrailingBlanks.		(line first = $: ) ifTrue: [	"Category"			rec := line allButFirst subStrings: '|'.			catKey := ((rec at: 1) subStrings: '|') at: 1.			rec size = 2				ifTrue:  [ catTitle := rec second]				ifFalse:[ catTitle := catKey].			categoryRec := {catKey. catTitle}.			self replaceInCategories: categoryRec.			PagesForCategory at: catKey put: OrderedCollection new.		] ifFalse: [			rec := line subStrings: '|'.			guideName := rec first.			rec size = 2 				ifTrue: [					guideTitle := rec second]				ifFalse: [					guideTitle := self getWordyName: guideName forCategory: catKey].			(PagesForCategory at: catKey ) add: {guideName. guideTitle}.		]	].! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/17/2010 19:31'!loadIndexAndPeekOnDisk	"If index.txt is present, load it and then scan the actual folder for extra guides.  Add them to the list."	| indCat indPages extras list indList |	(FileStream concreteStream isAFileNamed: 		QuickGuideMorph guidePath, (FileDirectory slash), 'index.txt')			ifTrue: [self loadIndex]			ifFalse: [^ self buildDefaultIndex].	"no index file"	"Add in the guides on disk that are not in index.txt"	indCat := Categories. 	"from index.txt"	indPages := PagesForCategory.	self buildDefaultIndex.	"from the file directory"	Categories "from disk" do: [:categoryRec |		indCat detect: [:pair | pair first = categoryRec first] 			ifNone: [indCat addLast: categoryRec]].	PagesForCategory "from disk" associationsDo: [:pair |		 (indPages includesKey: pair key) 			ifFalse: [indPages at: pair key put: pair value]			ifTrue: [list := pair value.				indList := indPages at: pair key.				extras := OrderedCollection new.				list do: [:diskPair |					indList detect: [:indPair | indPair first = diskPair first]						ifNone: [extras addLast: diskPair]].				indPages at: pair key put: indList, extras]].	Categories := indCat.	PagesForCategory := indPages.! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'bf 9/11/2010 19:14'!preloadIndexPage	self new checkForIndexOnDisk		ifFalse: [self error: 'index page not found'].! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/17/2010 19:21'!replaceInCategories: catPair	"Find an entry in Categories with the same first element (untranslated), and replace that entry.  If not found, put at end.  For translated name to replace default."	Categories withIndexDo: [:oldPair :ind |		oldPair first = catPair first ifTrue: [			^ Categories at: ind put: catPair]].	Categories add: catPair.! !!QuickGuideMorph class methodsFor: 'initialization' stamp: 'tk 8/10/2010 10:34'!saveIndex	"Note: file is put into Etoys folder.  A person must move it to resources/QuickGuides"	|stream |	stream := FileStream forceNewFileNamed: 'index.txt'.	stream lineEndConvention: #lf.	stream converter: UTF8TextConverter new.	[		Categories 			do: [:catRecord |				stream nextPut: $:.				stream nextPutAll: catRecord first.  "category key"				(catRecord second ) = (catRecord first) 					ifFalse:[						stream nextPut: $|.						stream nextPutAll: catRecord second.  "category title (translated)"					].				stream cr.				(PagesForCategory at: (catRecord first)) 					do: [:rec |						stream nextPutAll: rec first.	"guideName"						stream nextPut: $|.						stream nextPutAll: rec second.			"guide title (translated)"						stream cr.					]			]	]  ensure: [stream close].! !!QuickGuideMorph class methodsFor: 'defaults' stamp: 'tk 8/16/2010 10:16'!categoryOf: aName	^ Categories detect: [:e | aName beginsWith: e first] ifNone: [''].! !!QuickGuideMorph class methodsFor: 'defaults' stamp: 'tk 8/16/2010 10:09'!defaultOrderIn: helpCategory	| baseNames suggestedOrder ret last |	baseNames := FileNameStems.	"don't reread every time"	suggestedOrder _ self suggestedOrder.	helpCategory ifNotNil: [		suggestedOrder _ suggestedOrder select: [:e | e beginsWith: helpCategory].		baseNames _ baseNames select: [:e | e beginsWith: helpCategory]].	ret _ OrderedCollection new.	baseNames _ baseNames collect: [:bb | bb withoutTrailingDigits].	suggestedOrder do: [:e |		(baseNames includes: e) ifTrue: [			baseNames remove: e.			ret add: e.		].	].	baseNames ifNotEmpty: [		baseNames asArray do: [:e |			last _ ret reverse detect: [:b | 					b beginsWith: helpCategory]				ifNone: [ret ifNotEmpty: [ret last]].			last ifNil: [ret add: e]				ifNotNil: [ret add: e after: last].		].	].	^ ret asArray.! !!QuickGuideMorph class methodsFor: 'defaults' stamp: 'tk 8/16/2010 10:20'!fileNameStems	"Return a collection of the first part of all quickguide files on the disk.  trailing parts are removed (.sexp.data.gz  .xxx.pr)."	| dir prs |	dir _ FileDirectory on: QuickGuideMorph guidePath.	FileNameStems _ ((dir fileNames select: [:f | f endsWith: '.sexp.data.gz']) collect: 		[:f | f copyFrom: 1 to: f size - '.sexp.data.gz' size]) asSet.	prs := ((dir fileNames select: [:f | f endsWith: '.pr']) collect: 		[:f | f copyFrom: 1 to: f size - '.pr' size]).	prs := prs collect: [:nn | (nn atWrap: nn size-3) = $. 		ifTrue: [nn allButLast: 4]		ifFalse: [nn]].	^ FileNameStems addAll: prs! !!QuickGuideMorph class methodsFor: 'defaults' stamp: 'bf 8/29/2010 18:30'!guidePath	| sepa localesPath langPath countryPath |	sepa  := FileDirectory slash.	localesPath := Smalltalk imagePath, sepa, 'locale'.	"Look for current locale first"	langPath := localesPath, sepa, LocaleID current isoLanguage.	LocaleID current isoCountry ifNotNil: [		countryPath := langPath, '_', LocaleID current isoCountry. 		((FileDirectory on: countryPath ) directoryExists: 'QuickGuides') 			ifTrue: [^ countryPath, sepa, 'QuickGuides' ]].	((FileDirectory on: langPath) directoryExists: 'QuickGuides') 		ifTrue: [^ langPath, sepa, 'QuickGuides' ].	"Try English next"	((FileDirectory on: localesPath, sepa, 'en') directoryExists: 'QuickGuides') 		ifTrue: [^ localesPath, sepa, 'en', sepa, 'QuickGuides' ].	"Old location"	((FileDirectory on: Smalltalk imagePath) directoryExists: 'QuickGuides') 		ifTrue: [^ Smalltalk imagePath, sepa, 'QuickGuides' ].	"Any language"	(FileDirectory on: localesPath) directoryNames do: [:dir |		((FileDirectory on: localesPath, sepa, dir) directoryExists: 'QuickGuides')			ifTrue: [^ localesPath, sepa, dir, sepa, 'QuickGuides']].	"Give up"	^ nil! !!RecordingControls methodsFor: 'private' stamp: 'kfr 6/16/2010 15:59'!delete	"Stop the recorder from recording or playing."	self stop.	self stopStepping.	^super delete! !!Rectangle methodsFor: '*DrGeoII-Core-intersection' stamp: 'HilaireFernandes 6/19/2010 18:03'!intersectionWith: aLineSeg 	| intersections |	intersections := Set new.	(aLineSeg		intersectionWith: (LineSegment from: self origin to: self bottomLeft))		ifNotNilDo: [:inter | intersections add: inter].	(aLineSeg		intersectionWith: (LineSegment from: self origin to: self topRight))		ifNotNilDo: [:inter | intersections add: inter].	(aLineSeg		intersectionWith: (LineSegment from: self corner to: self bottomLeft))		ifNotNilDo: [:inter | intersections add: inter].	(aLineSeg		intersectionWith: (LineSegment from: self corner to: self topRight))		ifNotNilDo: [:inter | intersections add: inter].		intersections := intersections asOrderedCollection.	intersections size = 2		ifTrue: [^ LineSegment from: intersections first to: intersections second].	intersections size = 0 		ifTrue: 			[(self containsPoint: aLineSeg start) 				ifTrue: [(self containsPoint: aLineSeg end) ifTrue: [^aLineSeg ]]				ifFalse: [(self containsPoint: aLineSeg end) ifFalse: [^nil]]].	(self containsPoint: aLineSeg start) 		ifTrue: [			(self containsPoint: aLineSeg start) 				ifTrue: [^aLineSeg]				ifFalse: [^LineSegment from: aLineSeg start to: intersections first]].	(self containsPoint: aLineSeg end) 		ifTrue: [^LineSegment from: aLineSeg end to: intersections first].	^nil! !!ReleaseBuilder methodsFor: 'utilities' stamp: 'bf 9/11/2010 15:57'!initialCleanup	"Perform various image cleanups in preparation for making a Squeak gamma release candidate image."	"ReleaseBuilder new initialCleanup"		Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	Object reInitializeDependentsFields.	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self error:'Still have dependents'].	"Undeclared isEmpty ifFalse: [self error:'Please clean out Undeclared']."	Browser initialize.		self cleanUpChanges.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	Smalltalk garbageCollect.	ScheduledControllers _ nil.	Smalltalk garbageCollect.		SMSqueakMap default purge.	! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 8/29/2010 19:01'!checkCopyright	| inNotice inImage inFile dir |	dir := FileDirectory on: Smalltalk imagePath.	[inFile := (dir readOnlyFileNamed: 'NOTICE') wantsLineEndConversion: true; contentsOfEntireFile]		on: FileDoesNotExistException do: [:ex |				dir = FileDirectory default				ifTrue: [dir := dir containingDirectory. ex retry]				ifFalse: [self error: 'NOTICE file not found']].	inFile = Utilities copyrightNotice ifFalse: [self error: 'NOTICE file does not match image'].	inNotice := ((Utilities copyrightNotice findTokens: Character cr)		select: [:s | s includesSubString: '(c)'])		collect: [:s | s withBlanksTrimmed].	inImage := Smalltalk copyright findTokens: Character cr.	inNotice = inImage ifFalse: [self error: 'Copyright declarations do not match'].! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 9/11/2010 17:34'!finalCleanup	"ReleaseBuilderSqueakland new finalCleanup"	Smalltalk condenseChanges.	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfChangesFileReadOnly.	Preferences disable: #warnIfNoSourcesFile.	Smalltalk zapAllOtherProjects.	super finalCleanup.! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 9/11/2010 18:59'!finalStripping	"ReleaseBuilderSqueakland new finalStripping"	#(#Helvetica #Palatino #Courier #ComicSansMS )		do: [:n | TextConstants				removeKey: n				ifAbsent: []].	QuickGuideMorph indexPage: nil.	Smalltalk		at: #Player		ifPresent: [:superCls | superCls				allSubclassesDo: [:cls | 					cls isSystemDefined						ifFalse: [cls removeFromSystem].					cls := nil]].	Smalltalk garbageCollect.	SystemOrganization removeEmptyCategories.! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 9/17/2010 09:42'!installPreferences	"Install desired preferences for the release."	Preferences cambridge.	Preferences allPreferenceObjects do: [:each |		each defaultValue: each preferenceValue].! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 9/11/2010 17:35'!installReleaseSpecifics	"ReleaseBuilderSqueakland new installReleaseSpecifics"	World color: (Color r: 0.9 g: 0.9 b: 1.0).	Preferences restoreDefaultFontsForSqueakland.	ExternalSettings registerClient: ServerDirectory.! !!ReleaseBuilderSqueakland methodsFor: 'utilities' stamp: 'bf 9/12/2010 13:36'!installVersionInfo	"ReleaseBuilderSqueakland new installVersionInfo"	| newVersion |"	highestUpdate := SystemVersion current highestUpdate.	(self confirm: 'Reset highest update (' , highestUpdate printString , ')?')		ifTrue: [SystemVersion current highestUpdate: 0]."	newVersion := FillInTheBlank request: 'New version designation:' initialAnswer: SystemVersion current version.	SystemVersion newVersion: newVersion.	self inform: 'System version is now:', String cr, SystemVersion current asString! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'bf 9/11/2010 19:14'!buildInitialScreen	"ReleaseBuilderSqueakland new buildInitialScreen"	QuickGuideMorph preloadIndexPage.	World		submorphsDo: [:m | m delete].	Flaps disableGlobalFlaps: false.	Flaps enableEToyFlaps.	ProjectLoading loadFromImagePath: 'Tutorials'.	ProjectLoading loadFromImagePath: 'Gallery'.	ProjectLoading loadFromImagePath: 'Home'.	(World submorphs select: [:e | e isMemberOf: ProjectViewMorph]) do: [:e | e delete].	Project current		setThumbnail: (Project home ifNotNilDo: [:p | p thumbnail]).! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'bf 9/11/2010 17:38'!cleanupForSqueakland	"Perform various image cleanups in preparation for making a Squeakland OLPC image."	"ReleaseBuilderSqueakland new cleanupForSqueakland"		self		initialCleanup;		installPreferences;		finalStripping;		installReleaseSpecifics;		finalCleanup.	OLPCVirtualScreen virtualScreenExtent: nil.	Display isVirtualScreen ifFalse: [		OLPCVirtualScreen install	].	Display newDepth: 16.	Project current displayDepth: 16.	PartsBin  rebuildIconsWithProgress.! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'bf 10/13/2010 01:14'!prepareReleaseImage	"ReleaseBuilderSqueakland new prepareReleaseImage"	self testPrerequired.	self cleanupForSqueakland.	self setupUpdateStreamForSqueakland.	self setupServerDirectoryForSqueakland.	self buildInitialScreen.	self installVersionInfo.	self updateGettext.! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'yo 9/17/2009 12:08'!setupServerDirectoryForSqueakland	| d |"	ReleaseBuilderSqueakland new setupServerDirectoryForSqueakland"	Utilities authorName: nil.	d _ DAVMultiUserServerDirectory on: 'http://content.squeakland.org/showcase/'.	d altUrl: 'http://content.squeakland.org/showcase/'.	d moniker: 'My Squeakland'.	d acceptsUploads: true.	d useDefaultAccount: true.	d origDirectory: '/showcase'.	d setupSelector: #setupPersonalDirectory:.	ServerDirectory inImageServers at: 'My Squeakland' put: d.	d _ DAVMultiUserServerDirectory on: 'http://content.squeakland.org/showcase/'.	d altUrl: 'http://content.squeakland.org/showcase/'.	d moniker: 'Squeakland Showcase'.	d user: 'etoys'.	d useDefaultAccount: true.	d acceptsUploads: false.	d instVarNamed: 'passwordHolder' put: 'kaeuqs'.	ServerDirectory inImageServers at: 'Squeakland Showcase' put: d.	Utilities loggedIn: false.! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'bf 4/23/2010 03:48'!setupUpdateStreamForSqueakland	| base url d |	base := 'etoys.squeak.org/'.	url := 'http://', base, 'updates'.	d := DAVMultiUserServerDirectory on: url.	d altUrl: url.	d moniker: 'Etoys Updates'.	d groupName: 'etoys'.	Utilities classPool at: #UpdateUrlLists put: nil.	ServerDirectory inImageServers keysDo: [:k | ServerDirectory inImageServers removeKey: k].	ServerDirectory inImageServers at: d moniker put: d.	Utilities updateUrlLists add: {d moniker. {base}}.	"SystemVersion newVersion: 'etoys4.1'."	"SystemVersion current resetHighestUpdate."! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'bf 9/11/2010 15:49'!testPrerequired	| directory entries projectNames |	projectNames := #('Gallery' 'Tutorials' 'Home').	directory := FileDirectory on: Smalltalk imagePath.	entries := FileList2 projectOnlySelectionMethod: directory entries.	projectNames		do: [:projectName | (entries					anySatisfy: [:each | (Project parseProjectFileName: each first) first = projectName])				ifFalse: [^ self error: projectName , ' is not found']].	self checkCopyright.	"Test if the screen resolution is correct"	DisplayScreen actualScreenSize = (800 @ 600)		ifFalse: [^ self error: 'The Etoys window be 800 @ 600'].	Display extent = (1200 @ 900)		ifFalse: [^ self error: 'The virtual screen extent should be 1200 @ 900'].! !!ReleaseBuilderSqueakland methodsFor: 'squeakland' stamp: 'Richo 5/24/2010 23:57'!updateGettext	"ReleaseBuilderSqueakland new updateGettext"	"Export gettext template and import all translation in po/"	GetTextExporter exportTemplate.	GetTextImporter importAll.! !!ReleaseBuilderSqueakland commentStamp: 'bf 10/13/2010 01:16' prior: 0!Note: as of this writing, the only reliable way to get rid of all but the current project is to execute the following, one line at a time...Smalltalk zapAllOtherProjects.ProjectHistory currentHistory initialize.Smalltalk garbageCollect.Project rebuildAllProjects.ReleaseBuilderSqueakland new prepareReleaseImage.!!RomePangoFont methodsFor: 'system primitives' stamp: 'yo 12/25/2006 18:06'!clearDescriptionIndex	descriptionIndex := nil.! !!RomePangoFont methodsFor: 'system primitives' stamp: 'yo 6/9/2007 21:44'!descriptionIndex	^ descriptionIndex ifNil: [descriptionIndex := self primGetDescriptionIndex: familyName size: size].! !!RomePangoFont methodsFor: 'system primitives' stamp: 'yo 12/22/2006 16:39'!familyName: fmName size: sz	familyName := fmName.	size := sz asInteger.! !!RomePangoFont methodsFor: 'system primitives' stamp: 'yo 12/22/2006 16:51'!primGetDescriptionIndex: fName size: ptSize	<primitive: 'primitivePangoFontDescriptionIndex' module: 'RomePlugin'>	^ -1.! !!RomePangoFont class methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2008 18:38'!familyNameFrom: aFont	| fontName |	fontName := aFont familyName.	(fontName beginsWith: 'Accuny') ifTrue: [		^ 'Times New Roman'.	].	(fontName beginsWith: 'Accujen') ifTrue: [		^  'Arial'.	].	^ fontName.! !!RomePangoFont class methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2008 18:45'!familyName: familyName size: size	^ self new familyName: familyName size: (size * 0.8) asInteger.! !!RomePluginCanvas commentStamp: '<historical>' prior: 0!INST VAR ORDER IS KNOWN TO PLUGIN!! DO NOT REARRANGE!!handle: index in plugin's contexts array, nil if closedtarget: RomePluginTargetFormflags:	bits 0 to 7 = stroke alpha (0 = no stroke)	bit 8 = do fillstrokeColor: rgb of stroke color (10 bits per component)=============The rest of the inst vars are not actuallt used by the plugin, but it was compiled to expect at least 8 inst vars. The i9 - i13 inst vars are padding because some versions of the plugin were compiled to expect at least 13 inst vars.!!RomePluginCanvas class methodsFor: '*pango' stamp: 'yo 6/7/2007 15:38'!composingCanvas	self pangoIsAvailable ifFalse: [^ nil].	^ ComposingCanvas ifNil: [ComposingCanvas := RomeCanvas on: (Form extent: 4@4 depth: 32)].! !!RomePluginCanvas class methodsFor: '*pango' stamp: 'bf 7/19/2008 02:55'!drawingCanvasFor: aCanvas	DrawingCanvas		ifNil: [DrawingCanvas := RomeCanvas on: Display]		ifNotNil: [DrawingCanvas restoreState].	DrawingCanvas saveState.	DrawingCanvas privateTargetForm: aCanvas form.	^DrawingCanvas! !!RomePluginCanvas class methodsFor: '*pango' stamp: 'yo 6/7/2007 15:37'!pangoIsAvailable	^ PangoAvailable ifNil: [		PangoAvailable := (self pluginAvailable and: [(self on: (Form extent: 4@4 depth: 16)) primPangoIsAvailable]).	].! !!RomePluginCanvas class methodsFor: '*pango' stamp: 'yo 6/7/2007 14:56'!primPangoIsAvailable	<primitive: 'primitivePangoIsAvailable' module: 'RomePlugin'>	^ false.! !!Scanner methodsFor: 'expression types' stamp: 'PeterHugossonMiller 9/3/2009 11:10'!scanLitByteVec	| stream |	stream := (ByteArray new: 16) writeStream.	[ tokenType = #rightBracket or: [ tokenType = #doIt ] ] whileFalse: [		tokenType = #word			ifTrue: [ self scanLitWord ].		(token isInteger and: [ token between: 0 and: 255 ])			ifFalse: [ ^ self offEnd: '8-bit integer or right bracket expected' ].		stream nextPut: token.		self scanToken ].	token := stream contents! !!Scanner methodsFor: 'multi-character scans' stamp: 'eem 4/19/2010 16:22'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start := mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue:			[self scanToken; scanLitVec.			mark := start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse:			[tokenType = #leftBracket				ifTrue:					[self scanToken; scanLitByteVec.					mark := start + 1.					tokenType == #doIt ifTrue:						[self offEnd: 'Unmatched bracket']]				ifFalse:					[(#(word keyword colon ) includes: tokenType)						ifTrue:							[self scanLitWord]						ifFalse:							[(tokenType==#literal)								ifTrue:									[(token isSymbol)										ifTrue: "##word"											[token := token "May want to move toward ANSI here"]]								ifFalse:									[tokenType==#string ifTrue: [token := token asSymbol]]]]].	mark := start.	tokenType := #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!ScorePlayer methodsFor: 'operating' stamp: 'bf 9/14/2010 15:09'!disableReverb: aBoolean	Preferences setPreference: #soundReverb toValue: aBoolean not! !!ScratchPlugin commentStamp: '<historical>' prior: 0!Copyright (c) 2008 Massachusetts Institute of TechnologyThe ScratchPlugin is reused with permission from the ScratchCode1.3.1 release.Thanks to Mitchel Resnick, John Maloney, and the other Lifelong Kindergardeners!! ----------------------------------------------------------------------------------------------------This plugin combines a number of primitives needed by Scratch including:  a. primitives that manipulate 24-bit color images (i.e. 32-bit deep Forms but alpha is ignored)  b. primitive to open browsers, find the user's documents folder, set the window title and other host OS functionsThis plugin includes new serial port primitives, including support for named serial ports. The underlying plugin code can support up to 32 simultaenously open ports.Port options for Set/GetOption primitives:  1. baud rate  2. data bits  3. stop bits  4. parity type  5. input flow control type  6. output flow control typeHandshake lines (options 20-25 for Set/GetOption primitives):  20. DTR	(output line)  21. RTS	(output line)  22. CTS	(input line)  23. DSR	(input line)  24. CD		(input line)  25. RI		(input line)!!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!blurTest: count	"self blurTest: 10"	| f outBits |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	f display.	count timesRepeat: [		outBits _ f bits copy.		self primBlur: f bits into: outBits width: f width.		f bits: outBits.		f display].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!brightnessShiftTest	"self brightnessShiftTest"	| f fOut shift |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	[Sensor anyButtonPressed] whileFalse: [		shift _ ((Sensor cursorPoint x - Display center x) * 220) // Display width.		self primShiftBrightness: f bits into: fOut bits by: shift.		fOut display].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!doubleTest	"self doubleTest"	| f fOut |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ Form extent: (2 * f extent) + 20 depth: 32.	self primDouble: f bits w: f width h: f height into: fOut bits w: fOut width h: fOut height x: 9 y: 10.	fOut display.! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!fishEye: inForm out: outForm power: power	| height sz centerX centerY dx dy ang pix  width r srcX srcY |	"calculate height, center, scales, radius, whirlRadians, and radiusSquared"	sz _ inForm bits size.	width _ inForm width.	height _ sz // width.	centerX _ width // 2.	centerY _ height // 2.	0 to: width - 1 do: [:x |		0 to: height - 1 do: [:y |			dx _ (x - centerX) / centerX asFloat.			dy _ (y - centerY) / centerY asFloat.			r _ ((dx * dx) + (dy * dy)) sqrt raisedTo: power.			r <= 1.0				ifTrue: [					ang _ dy arcTan: dx.					srcX _ centerX + ((r * ang cos) * centerX).					srcY _ centerY + ((r * ang sin) * centerY)]				ifFalse: [					srcX _ x.					srcY _ y].			pix _ self primInterpolate: inForm bits width: inForm width x: (srcX * 1024) truncated y: (srcY * 1024) truncated.			outForm bits at: ((y * width) + x + 1) put: pix]].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!fisheyeTest	"self fisheyeTest"	| f fOut |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	f display.	100 to: 300 by: 10 do: [:power |		self primFisheye: f bits into: fOut bits width: f width power: power.		fOut display].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!fisheyeTest2: power	"self fisheyeTest2: 100"	| f fOut |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	f display.	self primFisheye: f bits into: fOut bits width: f width power: power.	fOut display.! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!hueShiftTest	"self hueShiftTest"	| f fOut shift |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	[Sensor anyButtonPressed] whileFalse: [		shift _ ((Sensor cursorPoint x - Display center x) * 380 * 2) // Display width.		self primShiftHue: f bits into: fOut bits byDegrees: shift.		fOut display].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!interpolationTest: scale	"Answer a copy of the given form scaled by the given factor using linear interpolation."	"(self interpolationTest: 1.5) display"	| scaleP srcForm outExtent fOut w h outW pix outH |	scaleP _ scale asPoint.	(scaleP x <= 0 or: [scaleP y <= 0]) ifTrue: [self error: 'bad scale factor'].	srcForm _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	outExtent _ (srcForm extent * scaleP) truncated.	(outExtent x > 1000 or: [outExtent y > 1000]) ifTrue: [self halt: 'result width or height will be > 1000 pixels'].	fOut _ Form extent: outExtent depth: 32.	w _ srcForm width.	h _ srcForm height.	outW _ fOut width.	outH _ fOut height.	0 to: fOut width - 1 do: [:x |		0 to: fOut height - 1 do: [:y |			pix _ self				primInterpolate: srcForm bits				width: srcForm width				x: (x * w * 1024) // outW				y:  (y * h * 1024) // outH.			fOut bits at: ((y * outW) + x + 1) put: pix]].	^ fOut! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!saturationShiftTest	"self saturationShiftTest"	| f fOut shift |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	[Sensor anyButtonPressed] whileFalse: [		shift _ ((Sensor cursorPoint x - Display center x) * 220) // Display width.		self primShiftSaturation: f bits into: fOut bits by: shift.		fOut display].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!scaleTest: scale	"self scaleTest: 1.5"	| f fOut |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ Form extent: (f extent * scale) rounded depth: 32.	self primScale: f bits w: f width h: f height into: fOut bits w: fOut width h: fOut height.	fOut display.! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!testFileName: aString	"Set the name of an image file for testing."	"self testFileName: 'hammy.jpg'"	"self testFileName: 'JohnMugShotBW.jpg'"	TestFileName _ aString.! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!waterRipples1ModuleTest	"Smalltalk unloadPlugin: self name"	"self waterRipples1ModuleTest"	| f fOut ripply aArray bArray |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	aArray _ ByteArray new: (f width) * (f height) * 8 withAll: 0.	bArray _ ByteArray new: (f width) * (f height) * 8 withAll: 0.	[Sensor anyButtonPressed] whileFalse: [		ripply _ Sensor cursorPoint x max: 1.		ripply _ (((ripply / fOut width) sqrt) * 16.0) asInteger.		ripply < 1 ifTrue: [ripply _ 1].ripply printString display.		self primWaterRipples1: f bits			into: fOut bits			width: f width			dropNum: ripply			array1: aArray			array2: bArray.		fOut displayAt: 10@30].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!waterRipples1ModuleTest: n	"Smalltalk unloadPlugin: self name"	"self waterRipples1ModuleTest: 100"	| f fOut aArray bArray |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	aArray _ ByteArray new: (f width * f height) * 8 withAll: 0.	bArray _ ByteArray new: (f width * f height) * 8 withAll: 0.	self primWaterRipples1: f bits		into: fOut bits		width: f width		dropNum: n		array1: aArray		array2: bArray.	[Sensor anyButtonPressed] whileFalse: [		self primWaterRipples1: f bits			into: fOut bits			width: f width			dropNum: 1			array1: aArray			array2: bArray.		fOut displayAt: 10@30].! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!waterRipplesTime: n	"Smalltalk unloadPlugin: self name"	"self waterRipplesTime: 100"	| f fOut aArray bArray |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	aArray _ ByteArray new: (f width * f height) * 8 withAll: 0.	bArray _ ByteArray new: (f width * f height) * 8 withAll: 0.	self primWaterRipples1: f bits		into: fOut bits		width: f width		dropNum: n		array1: aArray		array2: bArray.	^ [100 timesRepeat: [		self primWaterRipples1: f bits			into: fOut bits			width: f width			dropNum: 100			array1: aArray			array2: bArray]] msecs.! !!ScratchPlugin class methodsFor: 'image filters-testing' stamp: 'jm 11/8/2006 05:30'!whirlTest	"self whirlTest"	| f fOut degrees |	f _ (Form fromFileNamed: TestFileName) asFormOfDepth: 32.	fOut _ f deepCopy.	[Sensor anyButtonPressed] whileFalse: [		degrees _ ((Sensor cursorPoint x - Display center x) * 450 * 2) // Display width.		self primWhirl: f bits into: fOut bits width: f width angle: degrees.		fOut display].! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/31/2005 10:01'!closePort: portNum	"Close the given port."	"self closePort: 1"	<primitive: 'primClose' module: 'ScratchPlugin'>! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/28/2005 11:11'!isPortOpen: portNum	"Answer true if the given serial port is open."	"self isPortOpen: 1"	<primitive: 'primIsPortOpen' module: 'ScratchPlugin'>	^ false! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/31/2005 10:03'!openPortNamed: portName baud: baudRate	"Open the port with the given name at the given baud rate. Answer the port number to use for further operations on the given port or -1 if the port could not be opened."	"self openPortNamed: '/dev/cu.USA19QW3b1P1.1' baud: 9600"	<primitive: 'primOpenPortNamed' module: 'ScratchPlugin'>	^ -1! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/4/2005 17:24'!portCount	"Answer the number of serial ports. Answer 0 if there are no ports or if this primitive fails."	"self portCount"	<primitive: 'primPortCount' module: 'ScratchPlugin'>	^ 0! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/26/2005 15:25'!portCountOrNil	"Answer the number of serial ports. Answer nil if this primitive fails."	"self portCountOrNil"	<primitive: 'primPortCount' module: 'ScratchPlugin'>	^ nil! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/26/2005 15:47'!portName: portIndex	"Answer the name of the serial port with the given index. Answer nil if there is no port with the given index."	"self portName: 1"	<primitive: 'primPortName' module: 'ScratchPlugin'>	^ nil! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 9/12/2005 16:56'!port: portNum getOption: optionNum	"Answer the value of the given serial port option, or nil if the port is not open or the option is not defined. See the class comment for the list of options."	<primitive: 'primGetOption' module: 'ScratchPlugin'>	^ nil! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 9/12/2005 16:57'!port: portNum setOption: optionNum to: anInteger	"Set the given serial port option to the given value. Do nothing if the option is not defined. See the class comment for the list of options."	<primitive: 'primSetOption' module: 'ScratchPlugin'>! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/16/2005 15:57'!readPort: portNum into: buffer	"Read from the given port into the given ByteArray or String and answer the number of bytes read."	"self readPort: 1 into: (ByteArray new: 10)"	<primitive: 'primRead' module: 'ScratchPlugin'>	^ 0! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 11/8/2006 19:45'!serialPortOpsAvailable	"Answer true if this plugin is available."	"self serialPortOpsAvailable"	"Smalltalk unloadPlugin: self name"	^ self portCountOrNil notNil! !!ScratchPlugin class methodsFor: 'serial port primitives' stamp: 'jm 8/16/2005 16:46'!writePort: portNum data: buffer	"Write data from the given ByteArray or String to the given port and answer the number of bytes written."	"self writePort: 1 into: (ByteArray new: 10)"	<primitive: 'primWrite' module: 'ScratchPlugin'>	^ 0! !!ScratchPlugin class methodsFor: 'sound buffer utilities' stamp: 'jm 11/22/2006 19:40'!compactSound: aSoundBuffer by: log2	"Collapse the given by cutting in half log2 times."	"self compactSound: (SoundBuffer fromArray: (1 to: 100) asArray) by: 3"	| buf |	buf _ aSoundBuffer.	log2 timesRepeat: [buf _ self extractChannelFrom: buf rightFlag: false].	^ buf! !!ScratchPlugin class methodsFor: 'sound buffer utilities' stamp: 'jm 11/21/2006 21:22'!condenseSoundBuffer: aSoundBuffer by: factor	"Condense the given SoundBuffer by the given factor. The result is a SoundBuffer 1/factor of the original size in which each sample represents the peak signal value over factor samples of the source."	"self condenseSoundBuffer: (SoundBuffer fromArray: (1 to: 100) asArray) by: 10"	| result |	result _ SoundBuffer newMonoSampleCount: (aSoundBuffer size + factor - 1) // factor.	self primCondense: aSoundBuffer into: result by: factor.	^ result! !!ScratchPlugin class methodsFor: 'sound buffer utilities' stamp: 'jm 11/21/2006 21:22'!extractChannelFrom: aSoundBuffer rightFlag: rightFlag	"Extract one channel from the given stereo sound buffer. If rightFlag is true, extract the right channel; otherwise, extract the left one."	"self extractChannelFrom: (SoundBuffer fromArray: #(1 2 3 4)) rightFlag: true"	| result |	result _ SoundBuffer newMonoSampleCount: aSoundBuffer size // 2.	self primExtractChannelFrom: aSoundBuffer into: result rightFlag: rightFlag.	^ result! !!ScratchPlugin class methodsFor: 'sound buffer utilities' stamp: 'jm 11/21/2006 21:12'!primCondense: srcSoundBuffer into: dstSoundBuffer by: anInteger	"Condense the given SoundBuffer by the given factor storing the rsult into the destination SoundBuffer."	<primitive: 'primitiveCondenseSound' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'sound buffer utilities' stamp: 'jm 11/21/2006 20:33'!primExtractChannelFrom: srcSoundBuffer into: dstSoundBuffer rightFlag: rightFlag	"Extract the given channel of the source SoundBuffer in the destination SoundBuffer."	<primitive: 'primitiveExtractChannel' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'translation' stamp: 'jm 6/22/2007 21:44'!declareCVarsIn: aCCodeGenerator	"self translate"	super declareCVarsIn: aCCodeGenerator.	aCCodeGenerator cExtras: '#include "scratchOps.h"#include <math.h>'.! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 10/29/2007 10:30'!isHidden: fullPath	"Return true if file or folder with the given path should be hidden from the user. Return false if the primitive fails."	"self isHidden: 'testfile.txt'"	Smalltalk isMacOSX ifTrue: [^ false].	((fullPath endsWith: ':\') and: [fullPath size = 3]) ifTrue: [^ false].	^ self primIsHidden: fullPath! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 1/23/2007 15:59'!pluginAvailable	"self pluginAvailable"	| f r |	f _ Form extent: 1@1 depth: 32.	[r _ self primShiftHue: f bits into: f bits byDegrees: 180] ifError: [^ false].	^ r notNil! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 1/23/2007 15:46'!primGetFolderPath: anInteger	"Return the folder path for the given ID. Folder ID's are:		1	home		2	desktop		3	documents		4	my pictures		5	my music.	Return the path for the Scratch folder if the primitive fails."	"self primGetFolderPath: 1"	<primitive: 'primitiveGetFolderPath' module: 'ScratchPlugin'>	^ FileDirectory default pathName! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 6/22/2007 13:28'!primIsHidden: fullPath	"Return true if file or folder with the given path should be hidden from the user. Return false if the primitive fails."	"self primIsHidden: 'testfile.txt'"	<primitive: 'primitiveIsHidden' module: 'ScratchPlugin'>	^ false! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 1/23/2007 15:45'!primOpenURL: aString	"Open a browser window on the given URL. Do nothing if the primitive fails."	"self primOpenURL: 'http://www.google.com'"	<primitive: 'primitiveOpenURL' module: 'ScratchPlugin'>! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 10/5/2007 09:12'!primSetUnicodePasteBuffer: aByteArray	"Set the Mac OS X Unicode paste buffer. The argument is a big-endian UTF-16 Unicode string packed into a ByteArray. Needed to paste strings from Squeak into Second Life's code editor under Mac OS X. Do nothing if the primitive fails."	"self primSetUnicodePasteBuffer: ByteArray new"	<primitive: 'primitiveSetUnicodePasteBuffer' module: 'ScratchPlugin'>! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 1/23/2007 15:45'!primSetWindowTitle: aString	"Set the title of the Scratch window to the given string. Do nothing if the primitive fails."	"self primSetWindowTitle: 'hello!!'"	<primitive: 'primitiveSetWindowTitle' module: 'ScratchPlugin'>! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 4/11/2007 09:02'!primShortToLongPath: aString	"Convert the given Windows short-filename path into a long-filename path. On other platforms this primitive will just return the input string."	"self primShortToLongPath: 'hello!!'"	<primitive: 'primitiveShortToLongPath' module: 'ScratchPlugin'>	^ aString! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 11/8/2006 05:30'!scale: aForm by: scale	"Answer a 32-bit deep Form that's aForm scaled by the given factor. Scales using linear interpolation."	| srcF scaledF r |	srcF _ aForm asFormOfDepth: 32.	srcF unhibernate.	scaledF _ Form extent: (srcF extent * scale) rounded depth: 32.	r _ self		primScaleNoFail: srcF bits w: srcF width h: srcF height		into: scaledF bits w: scaledF width h: scaledF height.	r ifNil: [^ srcF magnify: srcF boundingBox by: scale asFloat smoothing: 1].	^ scaledF! !!ScratchPlugin class methodsFor: 'OS utilities' stamp: 'jm 9/2/2008 16:45'!setUnicodePasteBuffer: aString	"Set the Mac OS X Unicode paste buffer to the given Squeak string. Since the source is a Squeak string, there is no need to handle UTF-16 extended (4-byte) characters. However, we must take byte order into account to accomodate both Intel and PowerPC."	"self setUnicodePasteBuffer: 'Hello, Unicode!!'"	| utf32 s |	utf32 _ aString asUTF32.	s _ WriteStream on: (ByteArray new: 2 * aString size).	Smalltalk isBigEndian		ifTrue: [utf32 do: [:u | s nextPut: (u >> 8). s nextPut: (u bitAnd: 255)]]		ifFalse: [utf32 do: [:u | s nextPut: (u bitAnd: 255). s nextPut: (u >> 8)]].	self primSetUnicodePasteBuffer: s contents.! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primBlur: inBitmap into: outBitmap width: w	"Blur all the non-transparent pixels in the given 32-bit image bitmap, storing the result in outBitmap. The two bitmaps must be the same size. Each call to this primitive does one Gausian blur step."	<primitive: 'primitiveBlur' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primDouble: srcBitmap w: srcWidth h: srcHeight into: dstBitmap w: dstWidth h: dstHeight x: dstX y: dstY	"Display the source form at double-size onto the destination form at the given location. Fails if the target rectangle does not fit entirely within the destination form."	<primitive: 'primitiveDoubleSize' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primFisheye: inBitmap into: outBitmap width: w power: anInteger	"Do a fisheye lens transform of the given 32-bit image bitmap by the given power, storing the result in outBitmap. The two bitmaps must be the same size. Power is 0 for no change, > 0 for fisheye, < 0 for black hole effect."	<primitive: 'primitiveFisheye' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 2/10/2008 11:58'!primInterpolate: aBitmap width: w x: xFixed y: yFixed	"Answer the interpolated pixel value from the given 32-bit bitmap with the given width. The coordinates are given as fixed-point integers with 10-bits of fraction. That is, the float values of x and y are multiplied by 1024, then truncated."	<primitive: 'primitiveInterpolate' module: 'ScratchPlugin'>	^ 0! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primScaleNoFail: srcBitmap w: srcWidth h: srcHeight into: dstBitmap w: dstWidth h: dstHeight	"Scale the source form to exactly fit the destination form using bilinear interpolation. Answer nil if I fail."	<primitive: 'primitiveScale' module: 'ScratchPlugin'>	^ nil! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primScale: srcBitmap w: srcWidth h: srcHeight into: dstBitmap w: dstWidth h: dstHeight	"Scale the source form to exactly fit the destination form using bilinear interpolation."	<primitive: 'primitiveScale' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primShiftBrightness: inBitmap into: outBitmap by: shift	"Shift the brightness of all the non-transparent pixels in the given 32-bit image bitmap, storing the result in outBitmap. The shift should be an integer between -100 and 100. The two bitmaps must be the same size."	<primitive: 'primitiveBrightnessShift' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 1/23/2007 15:58'!primShiftHue: inBitmap into: outBitmap byDegrees: shiftDegrees	"Shift the hue of all the non-transparent, non-black pixels in the given 32-bit image bitmap, storing the result in outBitmap. The shift should be an integer between -360 and 360. The two bitmaps must be the same size."	<primitive: 'primitiveHueShift' module: 'ScratchPlugin'>	self primitiveFailed.	^ nil! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primShiftSaturation: inBitmap into: outBitmap by: shift	"Shift the saturation of all the non-transparent, non-black pixels in the given 32-bit image bitmap, storing the result in outBitmap. The shift should be an integer between -100 and 100. The two bitmaps must be the same size."	<primitive: 'primitiveSaturationShift' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primWaterRipples1: inBitmap into: outBitmap width: w dropNum: aNum array1: aArray array2: bArray	"Apply the water ripple effect to inBitmap putting the result into outBitmap. The two bitmaps must have the same length and are for 32-bit deep Forms of the given width. The dropNum determines how many new water drops are started. The two arrays hold the state of the water-surface model."	<primitive: 'primitiveWaterRipples1' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'image filter primitives' stamp: 'jm 11/8/2006 10:58'!primWhirl: inBitmap into: outBitmap width: w angle: anAngle	"Whirl all the non-transparent pixels in the given 32-bit image bitmap by the given angle, storing the result in outBitmap. The two bitmaps must be the same size."	<primitive: 'primitiveWhirl' module: 'ScratchPlugin'>	self primitiveFailed! !!ScratchPlugin class methodsFor: 'primitive failure' stamp: 'jm 1/23/2007 15:53'!primitiveFailed	"Just beep rather than bringing up an error notifier."	self beep.! !!ScriptCompiler methodsFor: 'as yet unclassified' stamp: 'bf 5/4/2010 15:07'!compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock		self parserClass: ScriptParser.	^super compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'sw 11/3/2008 22:09'!localeChanged	"Update myself to reflect the change in locale"	self fixLayout.	self == self topEditor ifTrue:  "nested script-editors handled by the topmost."		[self fixUpCarets]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/4/2009 17:45'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu count |	self modernize.	ActiveHand showTemporaryCursor: nil.	Preferences eToyFriendly ifTrue: [^ self offerSimplerScriptorMenu].	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	aMenu addStayUpItem.  "NB:  the kids version in #offerSimplerScriptorMenu does not deploy the stay-up item"	aMenu addList: (self hasParameter		ifTrue: [{			{'remove parameter' translated.					#ceaseHavingAParameter}}]		ifFalse: [{			{'add parameter' translated.						#addParameter}}]).	self hasParameter ifFalse:		[aMenu addTranslatedList: {			{'button to fire this script' translatedNoop. #tearOfButtonToFireScript}.			{'fires per tick...' translatedNoop. #chooseFrequency}.			#-		}].	aMenu addUpdating: #showingCaretsString  target: self action: #toggleShowingCarets.	aMenu addLine.	aMenu addList: {		{'edit balloon help for this script' translated.		#editMethodDescription}.		{'explain status alternatives' translated. 			#explainStatusAlternatives}.		#-	}.	Preferences universalTiles ifFalse:		[count _ self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' translated action: #toggleWhetherShowingTiles.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' translated action:	 #revertScriptVersion].				aMenu add: 'save this version' translated	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' translated action: #toggleWhetherShowingTiles]]].	"aMenu addLine.	self addGoldBoxItemsTo: aMenu."	aMenu addLine.		aMenu add: 'grab this object' translated target: playerScripted selector: #grabPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'This will actually pick up the object bearing this script and hand it to you.  Click the (left) button to drop it' translated.	aMenu add: 'reveal this object' translated target: playerScripted selector: #revealPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object bearing this script, use this item to (try to) make it visible' translated.	aMenu add: 'tile representing this object' translated target: playerScripted action: #tearOffTileForSelf.	aMenu balloonTextForLastItem: 'choose this to obtain a tile which represents the object associated with this script' translated.	aMenu addTranslatedList: {		#-.		{'open viewer' translatedNoop. #openObjectsViewer.  'open the viewer of the object to which this script belongs' translatedNoop}.		{'detached method pane' translatedNoop. #makeIsolatedCodePane. 'open a little window that shows the Smalltalk code underlying this script.' translatedNoop}.		#-.		{'destroy this script' translatedNoop. #destroyScript}	}.	aMenu popUpInWorld: self currentWorld.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/4/2009 17:45'!offerSimplerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer.  This variant is used when eToyFriendly preference is true."	| aMenu count |	ActiveHand showTemporaryCursor: nil.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	aMenu addList: (self hasParameter		ifTrue: [{			{'remove parameter' translated.					#ceaseHavingAParameter}}]		ifFalse: [{			{'add parameter' translated.						#addParameter}}]).	self hasParameter ifFalse:		[aMenu addTranslatedList: #(			('button to fire this script' tearOfButtonToFireScript)			-) translatedNoop].	aMenu addUpdating: #showingCaretsString  target: self action: #toggleShowingCarets.	aMenu addLine.	aMenu addList: {		{'edit balloon help for this script' translated.		#editMethodDescription}.		{'explain status alternatives' translated. 			#explainStatusAlternatives}.		#-	}.	Preferences universalTiles ifFalse:		[count _ self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' translated action: #toggleWhetherShowingTiles.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' translated action:	 #revertScriptVersion].				aMenu add: 'save this version' translated	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' translated action: #toggleWhetherShowingTiles]]].	aMenu addLine.		aMenu add: 'grab this object' translated target: playerScripted selector: #grabPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'This will actually pick up the object bearing this script and hand it to you.  Click the (left) button to drop it' translated.	aMenu add: 'reveal this object' translated target: playerScripted selector: #revealPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object bearing this script, use this item to (try to) make it visible' translated.	aMenu add: 'tile representing this object' translated target: playerScripted action: #tearOffTileForSelf.	aMenu balloonTextForLastItem: 'choose this to obtain a tile which represents the object associated with this script' translated.	aMenu addLine.	aMenu addTranslatedList: #(		-		('open viewer'		openObjectsViewer  'open the viewer of the object to which this script belongs')		-		('destroy this script' destroyScript)) translatedNoop.	aMenu popUpInWorld: self currentWorld.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/26/2009 12:51'!renameScriptTo: newSelector	"Rename the receiver's script so that it bears a new selector"	| aMethodNodeMorph methodMorph methodSource pos newMethodSource |	scriptName _ newSelector.	self updateHeader.	Preferences universalTiles		ifFalse:  "classic tiles"			[self showingMethodPane				ifTrue:					["textually coded -- need to change selector"					methodMorph _ self findA: MethodMorph.					methodSource _ methodMorph text string.					pos _ methodSource indexOf: Character cr ifAbsent: [self error: 'no cr'].					newMethodSource _ newSelector.					newSelector numArgs > 0 ifTrue: [newMethodSource _ newMethodSource, ' t1'].  "for the parameter"					newMethodSource _ newMethodSource, (methodSource copyFrom: pos to: methodSource size).					methodMorph editString: newMethodSource.					methodMorph model changeMethodSelectorTo: newSelector.					playerScripted class compileSilently: newMethodSource classified: 'scripts'.					methodMorph accept]				ifFalse:					[self install]]		ifTrue:  "universal tiles..."			[(aMethodNodeMorph _ self methodNodeMorph) ifNotNil:				[aMethodNodeMorph acceptInCategory: 'scripts']]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'Richo 5/23/2010 17:19'!toggleWhetherShowingTiles	"Toggle between showing the method pane and showing the tiles pane"	self showingMethodPane		ifFalse:				"currently showing tiles"			[self showSourceInScriptor]		ifTrue:				"current showing textual source"			[Preferences universalTiles				ifTrue: [^ self revertToTileVersion].			self savedTileVersionsCount >= 1				ifTrue:					[(self userScriptObject lastSourceString = (playerScripted class sourceCodeAt: scriptName))						ifFalse:							[(self confirm: 'Caution -- this script was changedtextually; if you revert to tiles at thispoint you will lose all the changes youmay have made textually.  Do youreally want to do this?' translated) ifFalse: [^ self]].					self revertToTileVersion]				ifFalse:					[Beeper beep]]! !!ScriptEditorMorphBuilder methodsFor: 'initialization' stamp: 'yo 4/2/2007 17:23'!context: c playerScripted: p	context _ c.	playerScripted _ p.! !!ScriptEditorMorphBuilder methodsFor: 'initialization' stamp: 'yo 4/2/2007 17:28'!context: c playerScripted: p topEditor: t	context _ c.	playerScripted _ p.	topEditor _ t.! !!ScriptEditorMorphBuilder methodsFor: 'initialization' stamp: 'yo 4/2/2007 18:00'!fromSexp: sexp	^ self perform: (sexp keyword copyWith: $:) asSymbol with: sexp.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/3/2007 12:45'!assign: sexp	| rcvr propertyName updating rhs p |	rcvr _ self fromSexp: sexp elements first.	propertyName _ sexp attributeAt: #property ifAbsent: [self error: ''].	propertyName _ propertyName asSymbol.	(#(patchValueIn: setRedComponentIn: setGreenComponentIn: setBlueComponentIn:) includes: propertyName) ifTrue: [		^ self specialAssign: sexp with: rcvr.	].	updating _ sexp attributeAt: #updating ifAbsent: [nil].	rhs _ self fromSexp: sexp elements last.	p _ PhraseTileMorph new		setAssignmentRoot: propertyName asSymbol			type: #command			rcvrType: #Player			argType: (sexp attributeAt: #type ifAbsent: [#Number]) asSymbol			vocabulary: self currentVocabulary.	p justGrabbedFromViewer: false.	updating ifNotNil: [p  submorphs second value: updating].	p submorphs first addMorph: rcvr.	p submorphs third setType: (sexp elements last attributeAt: #type ifAbsent: [#Number]) asSymbol.	p submorphs third addMorph: rhs.	(rhs resultType == #Number and: [rhs isMemberOf: TileMorph]) ifTrue: [		rhs addSuffixArrow.	].	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 9/7/2007 15:37'!condition: sexp	| p testPart yesPart noPart n |	testPart _ self fromSexp: (sexp elements first).	yesPart _ self fromSexp: (sexp elements second).	noPart _ self fromSexp: (sexp elements third).	p _ CompoundTileMorph new.	testPart = #() ifFalse: [		p submorphs first submorphs last addNewRow addMorph: testPart.	].	yesPart do: [:e |		n _ p submorphs second submorphs last addNewRow.		n addMorph: e.	].	noPart do: [:e |		n _ p submorphs third submorphs last addNewRow.		n addMorph: e.	].	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 9/7/2007 14:08'!functionSend: sexp with: rcvr with: realSel	| p |	p _ FunctionTile new.	p operator: realSel pad: rcvr.	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'bf 9/25/2010 17:49'!literal: sexp	| type n lit s xComp yComp |	type _ sexp attributeAt: #type ifAbsent: [].	type ifNotNil: [type _ type asSymbol].	(type == #Player or: [type == #Patch]) ifTrue: [		n _ sexp attributeAt: #value ifAbsent: [].		n ifNotNil: [			n = 'self' ifTrue: [^ TileMorph new setToReferTo: playerScripted].			n = 'nil' ifTrue: [^ TileMorph new setToReferTo: playerScripted presenter standardPlayer].			^ TileMorph new setToReferTo: (context at: n asSymbol)		].		^ TileMorph new setToReferTo: World presenter standardPlayer	].	type == #String ifTrue: [		lit _ sexp attributeAt: #value.		^ (TileMorph new setLiteral: lit).	].	type == #Point ifTrue: [		lit _ sexp attributeAt: #value.		xComp _ lit copyFrom: 1 to: (lit indexOf: $@) - 1.		yComp _ lit copyFrom: (lit indexOf: $@) + 1 to: lit size.				lit _ xComp asNumber@yComp asNumber.		^ (TileMorph new setLiteral: lit).	].	type == #Color ifTrue: [		lit _ Color readFrom: (sexp attributeAt: #value).		^ ColorTileMorph new colorSwatchColor: lit.	].	type == #Boolean ifTrue: [		lit _ (sexp attributeAt: #value) = 'true'.		^ TileMorph new addArrows; setLiteral: lit	].	type == #Sound ifTrue: [		lit _ sexp attributeAt: #value.		^ SoundTile new literal: lit.	].	type == #ScriptName ifTrue: [		lit _ sexp attributeAt: #value.		^ ScriptNameTile new literal: lit asSymbol.	].	(type == #TrailStyle or: [type == #ButtonPhase or: [type == #BorderStyle or: [type == #EdgeMode or: [type == #PatchDisplayMode]]]]) ifTrue: [		lit _ sexp attributeAt: #value.		s _ SymbolListTile new.		s choices: (Vocabulary allStandardVocabularies at: type) choices dataType: type.		^ s setLiteral: lit asSymbol; addArrows.	].	(type == #Object or: [type == #Number]) ifTrue: [		lit _ Number readFrom: (sexp attributeAt: #value).		^ (TileMorph new setLiteral: lit)				setDecimalPlacesFromTypeIn: (sexp attributeAt: #value);				addArrows.	].	(type == #Graphic) ifTrue: [		lit _ (context at: (sexp attributeAt: #value) asSymbol).		^ (GraphicTile new setLiteral: lit).	].	(type == #Menu) ifTrue: [		lit _ sexp attributeAt: #value.		^ (MenuTile new setLiteral: lit).	].! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'sw 6/15/2007 18:16'!loop: sexp	"Answer a TimesRepeatTile derived from the s-expression provided."	| p test body whatToRepeatPart numberOfTimesToRepeatPart |	"You can think of different loops, but for current Etoys, there is only one kind."	"initial _ sexp elements detect: [:e | e keyword == #initial] ifNone: [nil].	increment _ sexp elements detect: [:e | e keyword == #increment] ifNone: [nil]."	test _ sexp elements detect: [:e | e keyword == #test] ifNone: [nil].	body _ sexp elements detect: [:e | e keyword == #sequence] ifNone: [nil].	test _ self fromSexp: test elements first.	body _ self fromSexp: body.	p _ TimesRepeatTile new.	numberOfTimesToRepeatPart _ p numberOfTimesToRepeatPart.	numberOfTimesToRepeatPart removeAllMorphs; addMorph: test.	whatToRepeatPart _ p instVarNamed: 'whatToRepeatPart'.	body do: [:b |		whatToRepeatPart addNewRow addMorph: b.	].	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/2/2007 16:03'!phraseForSpecialKedamaSend: realSel	realSel == #getPatchValueIn: ifTrue: [		^ PhraseTileMorph new setGetPixelOperator: realSel type: #Number rcvrType: #Player argType: #Patch.	].	realSel == #getAngleTo: ifTrue: [		^ PhraseTileMorph new setAngleToOperator: realSel type: #Number rcvrType: #Player argType: #Player.	].	realSel == #bounceOn: ifTrue: [		^ PhraseTileMorph new setBounceOnOperator: realSel type: #Boolean rcvrType: #Player argType: #Player.	].	realSel == #getDistanceTo: ifTrue: [		^ PhraseTileMorph new setDistanceToOperator: realSel type: #Number rcvrType: #Player argType: #Player	].	realSel == #getTurtleOf: ifTrue: [		^ PhraseTileMorph new setTurtleOfOperator: realSel type: #Player rcvrType: #Player argType: #Player	].	realSel == #getUphillIn: ifTrue: [		^ PhraseTileMorph new setUpHillOperator: realSel type: #Number rcvrType: #Player argType: #Player	].	realSel == #getRedComponentIn: ifTrue: [		^ PhraseTileMorph new setGetColorComponentOperator: realSel componentName: #red type: #Number rcvrType: #Player argType: #Patch	].	realSel == #getGreenComponentIn: ifTrue: [		^ PhraseTileMorph new setGetColorComponentOperator: realSel componentName: #green type: #Number rcvrType: #Player argType: #Patch	].	realSel == #getBlueComponentIn: ifTrue: [		^ PhraseTileMorph new setGetColorComponentOperator: realSel componentName: #blue type: #Number rcvrType: #Player argType: #Patch	].	^ nil.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/3/2007 11:30'!script: sexp	| scriptName params entry morphs row isTiles code |	scriptName _ (sexp attributeAt: #scriptName) asSymbol.	params _ sexp elements select: [:e | e keyword == #parameter].	entry _ playerScripted class permanentUserScriptFor: scriptName asSymbol player: playerScripted.	params _ params collect: [:e | Variable new name: (e attributeAt: #name) asSymbol type: (e attributeAt: #type) asSymbol].	entry argumentVariables: params.	topEditor _ entry instantiatedScriptEditorForPlayer: playerScripted.	isTiles _ (sexp attributeAt: #language ifAbsent: ['Squeak']) = 'Etoys'.	isTiles ifTrue: [		morphs _ self fromSexp: (sexp elements detect: [:e | e keyword == #sequence] ifNone: []).		morphs do: [:e |			row _ topEditor addNewRow.			row addMorph: e.		].	] ifFalse: [		code _ (sexp elements detect: [:e | e keyword == #code]) attributeAt: #value.		playerScripted class compileSilently: code classified: 'scripts'.		topEditor userScriptObject becomeTextuallyCoded.		(topEditor submorphs copyFrom: 2 to: topEditor submorphs size) do: [:m | m delete].		topEditor showSourceInScriptor.	].	^ entry.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 9/7/2007 14:02'!send: sexp	| rcvr type selNode realSel val p argType |	rcvr _ self fromSexp: sexp elements second.	type _ sexp attributeAt: #type ifAbsent: ['#Player'].	selNode _ sexp elements first.	realSel _ selNode attributeAt: #getter ifAbsent: [].	realSel ifNotNil: [		realSel _ Utilities getterSelectorFor: realSel.		(rcvr isMemberOf: PhraseTileMorph) ifFalse: [rcvr bePossessive].	] ifNil: [		realSel _ (selNode attributeAt: #selector) asSymbol.		"realSel ifNil: [self error: '']."	].	(#(getAngleTo: bounceOn: getDistanceTo: getPatchValueIn: getTurtleOf: getUphillIn: getRedComponentIn: getGreenComponentIn: getBlueComponentIn:) includes: realSel) ifTrue: [		^ self specialKedamaSend: sexp with: rcvr with: realSel	].	(#(color:sees:) includes: realSel) ifTrue: [		^ self specialSend: sexp with: rcvr with: realSel	].	((ScriptingSystem tableOfNumericFunctions collect: [:e | e second]) includes: realSel) ifTrue: [		^ self functionSend: sexp with: rcvr with: realSel	].	p _ PhraseTileMorph new			setOperator: realSel				type: type asSymbol				rcvrType: #Player				argType: #Number.	p justGrabbedFromViewer: false.	p submorphs first addMorph: rcvr.	p submorphs first setType: (sexp elements second attributeAt: #type ifAbsent: ['Number']) asSymbol.	sexp elements size = 2 ifTrue: [		(p resultType == #Number and: [p submorphs second isMemberOf: TileMorph]) ifTrue: [			p submorphs second addSuffixArrow.		].	].	sexp elements size > 2 ifTrue: [		val _ self fromSexp: sexp elements third.		argType _ (sexp elements third attributeAt: #type ifAbsent: ['Number']) asSymbol.		p submorphs third setType: argType.		p submorphs third addMorph: val.		(argType == #Number and: [val isMemberOf: TileMorph]) ifTrue: [val addSuffixArrow.			(#(#+ #- #* #/ #'//' #'\\' #max: #min: #< #'<=' #= #'~=' #> #'>=' #isDivisibleBy:) includes: realSel) ifFalse: [p submorphs second addRetractArrowAnyway].		].	].	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/2/2007 16:05'!sequence: sexp	^ sexp elements collect: [:elem |		self fromSexp: elem.	].! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/3/2007 12:46'!specialAssign: sexp with: rcvr	| propertyName updating rhs patch p componentName |	propertyName _ (sexp attributeAt: #property) asSymbol.	updating _ sexp attributeAt: #updating ifAbsent: [nil].	rhs _ self fromSexp: sexp elements last.	(propertyName == #patchValueIn:) ifTrue: [		patch _ self fromSexp: sexp elements second.		p _ PhraseTileMorph new			setPixelValueRoot: propertyName asSymbol				type: #command				rcvrType: #Player				argType: #Number				vocabulary: self currentVocabulary.		p justGrabbedFromViewer: false.		updating ifNotNil: [p submorphs second value: updating].		p submorphs first addMorph: rcvr.		p submorphs third setType: (sexp elements last attributeAt: #type ifAbsent: [#Number]) asSymbol.		p submorphs third addMorph: rhs.		p submorphs second setPatchDefaultTo: patch actualObject.		^ p.	].	(propertyName == #setRedComponentIn:) ifTrue: [componentName _ #red].	(propertyName == #setGreenComponentIn:) ifTrue: [componentName _ #green].	(propertyName == #setBlueComponentIn:) ifTrue: [componentName _ #blue].	(#(setRedComponentIn: setGreenComponentIn: setBlueComponentIn:) includes: propertyName) ifTrue: [		patch _ self fromSexp: sexp elements second.		p _ PhraseTileMorph new					setColorComponentRoot: propertyName					componentName: componentName					type: #command					rcvrType: #Patch					argType: #Number					vocabulary: self currentVocabulary.		p justGrabbedFromViewer: false.		updating ifNotNil: [p submorphs second value: updating].		p submorphs first addMorph: rcvr.		p submorphs third setType: (sexp elements last attributeAt: #type ifAbsent: [#Number]) asSymbol.		p submorphs third addMorph: rhs.		p submorphs second setPatchDefaultTo: patch actualObject.		^ p.	].! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/3/2007 12:45'!specialKedamaSend: sexp with: rcvr with: realSel	| p val |	val _ self fromSexp: sexp elements third.	p _ self phraseForSpecialKedamaSend: realSel.	p justGrabbedFromViewer: false.	p submorphs first addMorph: rcvr.	p submorphs second setArgumentDefaultTo: val actualObject.	^ p! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 9/7/2007 14:07'!specialSend: sexp with: rcvr with: realSel	| p val |	sexp elements size > 2 ifTrue: [		val _ self fromSexp: sexp elements third.	].	realSel == #color:sees: ifTrue: [		p _  PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"		p justGrabbedFromViewer: false.		p submorphs first addMorph: rcvr.		p submorphs second delete.		p addMorph: (ColorSeerTile new showPalette: false; colorSwatchColor: (val colorSwatch color)) behind: p submorphs first.		p submorphs last setType: (sexp elements fourth attributeAt: #type ifAbsent: ['Number']) asSymbol.		p submorphs last addMorph: (self fromSexp: sexp elements fourth).		^ p.	].! !!ScriptEditorMorphBuilder methodsFor: 'reconstituting scripting tiles ' stamp: 'yo 4/6/2007 15:15'!variable: sexp	| p |	p _ ParameterTile new.	p scriptEditor: topEditor.	p line1: (sexp attributeAt: #type) translated.	^ p.! !!ScriptEditorMorphBuilder methodsFor: 'e-toy support' stamp: 'yo 4/2/2007 17:23'!topEditor	^ topEditor.! !!ScriptEditorMorphBuilder class methodsFor: 'as yet unclassified' stamp: 'yo 4/2/2007 17:28'!context: c playerScripted: p topEditor: t	^ self new context: c playerScripted: p topEditor: t! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 8/4/2009 17:48'!offerMenuIn: aStatusViewer	"Put up a menu."	| aMenu |	ActiveHand showTemporaryCursor: nil.	aMenu _ MenuMorph new defaultTarget: self.	aMenu title: player knownName, ' ', selector.	aMenu addStayUpItem.	(player class instanceCount > 1) ifTrue:		[aMenu add: 'propagate status to siblings' translated selector: #assignStatusToAllSiblingsIn: argument: aStatusViewer.		aMenu balloonTextForLastItem: 'Make the status of this script in all of my sibling instances be the same as the status you see here' translated].	aMenu addLine.	aMenu add: 'grab this object' translated target: player selector: #grabPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'This will actually pick up the object bearing this script and hand it to you.  Click the (left) button to drop it' translated.	aMenu add: 'reveal this object' translated target: player selector: #revealPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object bearing this script, use this item to (try to) make it visible' translated.	aMenu add: 'tile representing this object' translated target: player selector: #tearOffTileForSelf.	aMenu balloonTextForLastItem: 'choose this to obtain a tile which represents the object associated with this script' translated.	aMenu addLine.	aMenu add: 'open this script''s Scriptor' translated target: player selector: #grabScriptorForSelector:in: argumentList: {selector. aStatusViewer world}.	aMenu balloonTextForLastItem: 'Open up the Scriptor for this script' translated.	aMenu add: 'open this object''s Viewer' translated target: player selector: #beViewed.	aMenu balloonTextForLastItem: 'Open up a Viewer for this object' translated.	aMenu addLine.	aMenu add: 'more...' translated target: self selector: #offerShiftedMenuIn: argument: aStatusViewer.	aMenu balloonTextForLastItem: 'The "more..." branch offers you menu items that are less frequently used.' translated.	aMenu popUpInWorld: ActiveWorld! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'kfr 6/16/2010 16:25'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| reply  m menu submenu globalCustomEvents |	#('normal' 'paused' 'ticking' 'opening' 'closing') translatedNoop.	menu _ MenuMorph new.	self addStatusChoices: #( normal " -- run when called" ) toMenu: menu.	self addStatusChoices: 		#(	paused 		"ready to run all the time"			ticking			"run all the time" )		toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati copyFrom: 1 to: 3) toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati allButFirst: 3) toMenu: menu.	self addStatusChoices: 		#(opening			"when I am being opened"			closing			"when I am being closed" )		toMenu: menu.		submenu _ MenuMorph new.	globalCustomEvents := (ScriptingSystem globalCustomEventNamesFor: player) asOrderedCollection.	(Preferences eToyFriendly) ifTrue: [ {#scrolledIntoView. #scrolledOutOfView} do:[: i |globalCustomEvents remove: i ifAbsent:[globalCustomEvents]]].	self addStatusChoices: globalCustomEvents toSubMenu: submenu forMenu: menu.		menu add: 'more... ' translated subMenu: submenu.	(Preferences allowEtoyUserCustomEvents) ifTrue: [		submenu addLine.		self addStatusChoices: ScriptingSystem userCustomEventNames toSubMenu: submenu forMenu: menu.		submenu addLine.		self addStatusChoices:			(Array streamContents: [ :s | s nextPut: { 'define a new custom event' translated. #defineNewEvent }.			ScriptingSystem userCustomEventNames isEmpty				ifFalse: [ s nextPut: { 'delete a custom event' translated. #deleteCustomEvent } ]])			toSubMenu: submenu forMenu: menu ].		menu addLine.	self addStatusChoices: #(		('what do these mean?'explainStatusAlternatives)		('apply my status to all siblings' assignStatusToAllSiblings) ) translatedNoop toMenu: menu.	menu addTitle: 'When should this script run?' translated.	menu submorphs last delete.	menu invokeModal.		reply := menu modalSelection.	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply == #defineNewEvent ifTrue: [ ^self defineNewEvent ].	reply == #deleteCustomEvent ifTrue: [ ^self deleteCustomEvent ].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m _ player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs] ! !!ScriptingTileHolder methodsFor: 'initialization' stamp: 'kfr 12/7/2007 00:40'!around: aTileScriptingElement	"Make the receiver surround the given item, either a TileMorph or a PhraseTileMorph or something like a CompoundTIleMorph."	self removeAllMorphs.	self position: aTileScriptingElement position.	self addMorph: aTileScriptingElement.	aTileScriptingElement lock.! !!ScriptingTileHolder methodsFor: 'initialization' stamp: 'yo 9/3/2008 01:00'!fixLayout	self allMorphsDo: [:m | m fixLayoutOfSubmorphs].! !!ScriptingTileHolder methodsFor: 'initialization' stamp: 'sw 6/29/2007 03:35'!initialize	"initialize the state of the receiver"	super initialize.	self hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 3;		borderColor: Color green muchDarker;		cellInset: 0; layoutInset: 0! !!ScriptingTileHolder methodsFor: 'initialization' stamp: 'yo 9/3/2008 00:56'!localeChanged	self fixLayout.! !!ScriptingTileHolder methodsFor: 'initialization' stamp: 'yo 9/3/2008 00:56'!unhibernate	self fixLayout.! !!ScriptingTileHolder methodsFor: 'mouse handling' stamp: 'sw 6/29/2007 03:21'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	^ true! !!ScriptingTileHolder methodsFor: 'mouse handling' stamp: 'sw 7/11/2007 00:44'!mouseDown: evt	"Handle a mouse-down event."	| actualTile |	actualTile := submorphs at: 1 ifAbsent: [^ self delete].  "Not expected to happen."	actualTile unlock.	self topRendererOrSelf delete.	evt hand grabMorph: actualTile! !!ScriptingTileHolder commentStamp: 'sw 6/28/2007 17:18' prior: 0!Serves as a wrapper for a scripting-tile element that otherwise would be bare on the desktop.!!ScriptingTileHolder class methodsFor: 'instance creation' stamp: 'sw 6/29/2007 03:19'!around: aTile	"Answer a new instance of the receiver, surrounding the given tile."	^ self new around: aTile! !!ScriptParser methodsFor: 'as yet unclassified' stamp: 'bf 5/4/2010 15:33'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."	"Copied from superclass, use ScriptEncoder and give it a referenceWorld. This assumes worldLoading has been set to the right world this player belongs to. --bf 5/4/2010"         | methNode repeatNeeded myStream parser s p |        (req notNil and: [RequestAlternateSyntaxSetting signal and: [(sourceStream isKindOf: FileStream) not]])                ifTrue: [parser _ self as: DialectParser]                ifFalse: [parser _ self].        myStream _ sourceStream.        [repeatNeeded _ false.	   p _ myStream position.	   s _ myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag _ noPattern.        failBlock_ aBlock.        [methNode _ parser method: noPattern context: ctxt                                encoder: (ScriptEncoder new init: class context: ctxt notifying: parser;								referenceObject: ActiveWorld referenceWorld )]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded _ (requestor isKindOf: TextMorphEditor) not.                        myStream _ ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!ScriptParser methodsFor: 'as yet unclassified' stamp: 'yo 8/24/2009 11:00'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock for: anInstance         | methNode repeatNeeded myStream parser s p |        (req notNil and: [RequestAlternateSyntaxSetting signal and: [(sourceStream isKindOf: FileStream) not]])                ifTrue: [parser _ self as: DialectParser]                ifFalse: [parser _ self].        myStream _ sourceStream.        [repeatNeeded _ false.	   p _ myStream position.	   s _ myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag _ noPattern.        failBlock_ aBlock.        [methNode _ parser method: noPattern context: ctxt                                encoder: (ScriptEncoder new init: class context: ctxt notifying: parser;  referenceObject: (anInstance costume ifNotNil: [anInstance costume referenceWorld] ifNil: [ActiveWorld]))]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded _ (requestor isKindOf: TextMorphEditor) not.                        myStream _ ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!ScrollBar methodsFor: 'geometry' stamp: 'bf 5/18/2010 16:51'!buttonExtent	| size |	size := Preferences scrollBarsNarrow		ifTrue: [11]		ifFalse: [Preferences biggerHandles			ifFalse: [15]			ifTrue: [21]].	^ bounds isWide		ifTrue: [size @ self innerBounds height]		ifFalse: [self innerBounds width @ size]! !!ScrollPane methodsFor: 'geometry' stamp: 'bf 5/18/2010 16:51'!scrollBarThickness	"Includes border"	| result |	result := Preferences scrollBarsNarrow		ifTrue: [10]		ifFalse: [Preferences biggerHandles			ifFalse: [14]			ifTrue: [20]].	self flatColoredScrollBarLook		ifFalse: [result := result + 2].		^ result! !!SecurityManager methodsFor: 'security operations' stamp: 'yo 12/15/2008 12:09'!enterRestrictedMode	"Some insecure contents was encountered. Close all doors and proceed."	self isInRestrictedMode ifTrue:[^true].	(SugarLauncher isRunningInRainbow or: [Preferences securityChecksEnabled not]) ifTrue: [^true]. "it's been your choice..."	Preferences warnAboutInsecureContent ifTrue:[		(PopUpMenu confirm:'You are about to load some insecure content.If you continue, access to files as well assome other capabilities will be limited.' translated			trueChoice:'Load it anyways' translated			falseChoice:'Do not load it' translated) ifFalse:[				"user doesn't really want it"				^false.			].	].	"here goes the actual restriction"	self flushSecurityKeys.	self disableFileAccess.	self disableImageWrite.	"self disableSocketAccess."	FileDirectory setDefaultDirectory: self untrustedUserDirectory.	^true! !!SelectionMorph methodsFor: 'dropping/grabbing' stamp: 'kfr 6/6/2009 09:50'!justDroppedInto: newOwner event: evt	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"	selectedItems isEmpty ifTrue:		["Hand just clicked down to draw out a new selection"		^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta _ self position - dupLoc].	selectedItems reverseDo: [:m | 		WorldState addDeferredUIMessage:			[m referencePosition: (newOwner localPointToGlobal: m referencePosition).			newOwner handleDropMorph:				(DropEvent new setPosition: evt cursorPoint contents: m hand: evt hand)] fixTemps].	selectedItems _ nil.	self removeHalo. 	self halo ifNotNil: [self halo visible: false]. 	self delete.	evt wasHandled: true! !!SelectionMorph methodsFor: 'halo commands' stamp: 'bf 8/24/2010 14:48'!addCustomMenuItems: aMenu hand: aHandMorph	"Add custom menu items to the menu"	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addList: {		#-.		{'place into a row' translated. #organizeIntoRow}.		{'place into a column' translated. #organizeIntoColumn}.		#-.		{'align left edges' translated. #alignLeftEdges}.		{'align top edges' translated. #alignTopEdges}.		{'align right edges' translated. #alignRightEdges}.		{'align bottom edges' translated. #alignBottomEdges}.		#-.		{'align centers vertically' translated. #alignCentersVertically}.		{'align centers horizontally' translated. #alignCentersHorizontally}.		#-.		{'distribute vertically' translated. #distributeVertically}.		{'distribute horizontally' translated. #distributeHorizontally}.		}! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ab 9/17/2002 01:02'!do: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			self withIndexDo:				[:each :i |				bar value: i.				aBlock value: each]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/11/2009 19:38'!replace: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into self."	1 to: self size do: [ :index |		self at: index put: (aBlock value: (self at: index)) ]! !!ServerDirectory methodsFor: 'accessing' stamp: 'sw 9/10/2009 19:34'!userPerSe	"Answer the user, even if nil.  No interaction ensues."	^ user! !!ServerDirectory methodsFor: 'updates' stamp: 'bf 5/4/2010 13:53'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system may have its own set of update files, or they may all share the same files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:.	When two sets of updates are stored on the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that index file is used."	| myServers updateStrm newName response localName seq indexPrefix listContents version versIndex lastNum stripped |	localName _ fileStrm localName.	fileStrm size = 0 ifTrue:		[^ self inform: 'That file has zero bytes!!  May have a new name.'].	(fileStrm contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'That file contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: {localName}) ifFalse: [^ nil].	"illegal characters"	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file "', localName, '"as an update for every user of "', SystemVersion current version, '"who updates from server group "', self groupName, '"?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	indexPrefix _ (self groupName includes: $*) 		ifTrue: [(self groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version _ SystemVersion current version.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	"A few affirmations..."	versIndex < listContents size ifTrue:		[(self confirm: 'This system, ', version ,				' is not the latest version.\Make update for an older version?' withCRs)			ifFalse: [self closeGroup.  ^ nil]].	"abort"	(listContents at: versIndex) last isEmpty ifTrue:		[(self confirm: 'Please confirm that you mean to issue the first update for ' ,						version , '\(otherwise something is wrong).' withCRs)			ifFalse: [self closeGroup.  ^ nil]].	"We now determine next update number to be max of entire index"	lastNum _ listContents inject: 0 into:		[:max :pair | pair last isEmpty					ifTrue: [max]					ifFalse: [max max: pair last last initialIntegerOrNil]].	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	Utilities writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"append name to updates with new sequence number"	seq _ (lastNum + 1) printString padded: #left to: 4 with: $0.	"strip off any old seq number"	stripped _ localName copyFrom: (localName  findFirst: [:c | c isDigit not]) to: localName size.	newName _ seq , stripped.	listContents at: versIndex put:		{version. (listContents at: versIndex) last copyWith: newName}.	"Write a new copy on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | Utilities writeList: listContents toStream: s]).	myServers do:		[:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update ', newName, ' succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm close.	(fileStrm isKindOf: StandardFileStream)		ifTrue: [fileStrm directory rename: localName toBe: newName].! !!Set methodsFor: 'accessing' stamp: 'ul 2/19/2010 14:49'!like: anObject ifAbsent: aBlock	"Answer an object in the receiver that is equal to anObject,	or evaluate the block if not found. Relies heavily on hash properties"		^(array at: (self scanFor: anObject))		ifNil: [ aBlock value ]		ifNotNil: [ :element | element enclosedSetElement ]! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'bf 8/14/2010 19:37'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addLabelItemsTo: aCustomMenu hand: aHandMorph.	(target isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' translated action: #setPageSound:.			aCustomMenu add: 'set page visual' translated action: #setPageVisual:]		ifFalse:			[			aCustomMenu add: 'change action selector' translated action: #setActionSelector.			aCustomMenu add: 'change arguments' translated action: #setArguments.			aCustomMenu add: 'change when to act' translated action: #setActWhen.			aCustomMenu add: 'set target' translated action: #sightTargets:.			target ifNotNil: [aCustomMenu add: 'clear target' translated action: #clearTarget]].! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 20:05'!clearTarget	target _ nil.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 6/5/2007 20:52'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt  targetPoint.	target := rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'yo 9/11/2009 10:25'!mouseDown: evt	| aMorph selectors |	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph point: evt position from: self)])		ifTrue:[			self toggleExpandedState: aMorph event: evt.			(aMorph valueOfProperty: #autoExpand ifAbsent: [false]) ifFalse: [^ self]]. 	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	selectors _ Array 		with: #click:		with: nil		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10 "pixels".! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'yo 9/11/2009 10:25'!initialize	"initialize the state of the receiver"	super initialize.	self setProperty: #autoExpand toValue: false.	self		on: #mouseMove		send: #mouseStillDown:onItem:		to: self! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'yo 9/11/2009 10:24'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel autoExpand: false.! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'yo 9/11/2009 10:27'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel autoExpand: aBoolean	self setProperty: #autoExpand toValue: aBoolean.	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'yo 9/11/2009 10:29'!addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent	| priorMorph newCollection firstAddition |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	firstAddition _ nil.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: newIndent.		priorMorph setProperty: #autoExpand toValue: (self valueOfProperty: #autoExpand ifAbsent: [false]).		firstAddition ifNil: [firstAddition _ priorMorph].		morphList add: priorMorph.		((item hasEquivalentIn: expandedItems) or: [priorMorph isExpanded]) ifTrue: [			priorMorph isExpanded: true.			priorMorph 				addChildrenForList: self 				addingTo: morphList				withExpandedItems: expandedItems.		].	].	^firstAddition	! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'yo 9/11/2009 10:27'!addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean	| priorMorph morphList newCollection |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	morphList _ OrderedCollection new.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: parentMorph indentLevel + 1.		priorMorph setProperty: #autoExpand toValue: (self valueOfProperty: #autoExpand ifAbsent: [false]).		morphList add: priorMorph.	].	scroller addAllMorphs: morphList after: parentMorph.	^morphList	! !!SimpleHierarchicalListMorph class methodsFor: 'instance creation' stamp: 'yo 9/11/2009 10:23'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel autoExpand: aBoolean	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel		autoExpand: aBoolean! !!SimpleSelectionMorph methodsFor: 'extending' stamp: 'sw 9/6/2009 21:59'!extendByHand: aHand	"Assumes selection has just been created and added to some pasteUp or world"	| startPoint handle m inner |	startPoint := Sensor cursorPoint.	handle := NewHandleMorph new followHand: aHand		forEachPointDo: [:newPoint |					| localPt |					Cursor crossHair show.					localPt := (self transformFrom: self world) globalPointToLocal: newPoint.					self bounds: (startPoint rect: localPt)]		lastPointDo:			 [:newPoint |			inner := self bounds insetBy: 2@2.			inner area >= 16				ifTrue:					[m := SketchMorph new form: (Form fromDisplay: inner).					aHand attachMorph: m.					ActiveWorld fullRepaintNeeded]  "selection tracking can leave unwanted artifacts"				ifFalse:					[Beeper beep].  "throw minnows back"			self delete].				handle visible: false.	aHand attachMorph: handle.	handle startStepping! !!SimpleSelectionMorph methodsFor: 'initialization' stamp: 'sw 8/3/2009 21:49'!initialize	"initialize the state of the receiver"	super initialize.	self color: Color transparent.        self borderColor: Color black.	self borderWidth: 2.	self setProperty: #ignorePartsBinDrop toValue: true! !!SimpleSelectionMorph commentStamp: 'sw 8/3/2009 22:00' prior: 0!A morph used in the implementaiton of Karl Ramberg's omnidirectional grab-patch tool!!SimpleSliderMorph methodsFor: 'menu' stamp: 'bf 8/14/2010 19:35'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'set action selector' translated action: #setActionSelector.	aCustomMenu add: 'change arguments' translated action: #setArguments.	aCustomMenu add: 'set minimum value' translated action: #setMinVal.	aCustomMenu add: 'set maximum value' translated action: #setMaxVal.	aCustomMenu addUpdating: #descendingString action: #toggleDescending.	aCustomMenu addUpdating: #truncateString action: #toggleTruncate.	aCustomMenu add: 'set target' translated action: #sightTargets:.	target ifNotNil: [	aCustomMenu add: 'clear target' translated action: #clearTarget].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'wiz 6/5/2007 20:52'!setTarget: evt 	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt  targetPoint.	target _ rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'bf 9/13/2010 17:19'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	"Initialize the receiver to edit the given sketchMorph in the given bounds, with the resulting object to reside in the given pasteUpMorph."	| aPaintBox newPaintBoxBounds worldBounds requiredWidth newOrigin aPosition aPal aTab paintBoxFullBounds |	(aTab _ self world paintingFlapTab) ifNotNil:		[aTab showFlap.		^ self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: nil].	self setProperty: #recipientPasteUp toValue: aPasteUpMorph.	aPaintBox _ self world paintBox.	worldBounds _ self world bounds.	requiredWidth _ aPaintBox width.	aPosition _ (aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[boundsToUse topRight].	newOrigin _ ((aPosition x  + requiredWidth <= worldBounds right) or: [Preferences unlimitedPaintArea])			ifTrue:  "will fit to right of aPasteUpMorph"				[aPosition]			ifFalse:  "won't fit to right, try left"				[boundsToUse topLeft - (requiredWidth @ 0)].	paintBoxFullBounds _ aPaintBox maxBounds.	paintBoxFullBounds _ (newOrigin - aPaintBox offsetFromMaxBounds) extent: 					paintBoxFullBounds extent.	newPaintBoxBounds _ paintBoxFullBounds translatedToBeWithin: worldBounds.		self initializeFor: aSketchMorph inBounds: boundsToUse 		pasteUpMorph: aPasteUpMorph 		paintBoxPosition: newPaintBoxBounds origin + aPaintBox offsetFromMaxBounds.! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/2/2009 16:04'!form: aForm rotationCenter: aCenter	"Set the receiver's form, honoring a rotation center.  Maintains existing cartesian location of the receiver across the changed form and rotation center."	| loc |	loc := self topRendererOrSelf assuredPlayer getLocation.	(self hasProperty: #baseGraphic) ifFalse: [self setProperty: #baseGraphic toValue: aForm].	originalForm _ aForm.	self rotationCenter: aCenter.	self layoutChanged.	self topRendererOrSelf player setLocation: loc! !!SketchMorph methodsFor: 'e-toy support' stamp: 'kks 11/15/2007 00:28'!flipHorizontal	|  r |	r _ self rotationCenter.	self left:  self left - (1.0 - (2 * r x) * self width).	self form: (self form flipBy: #horizontal centerAt: self form center).	self rotationCenter: (1 - r x) @ (r y).! !!SketchMorph methodsFor: 'e-toy support' stamp: 'kks 11/15/2007 00:32'!flipVertical	|  r |	r _ self rotationCenter.	self top:  self top - (1.0 - (2 * r y) * self height).	self form: (self form flipBy: #vertical centerAt: self form center).	self rotationCenter:  r x @ (1 - r y).! !!SketchMorph methodsFor: 'menu' stamp: 'wiz 8/10/2010 01:49'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt  targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: 'menus' stamp: 'sw 8/18/2009 18:52'!collapse	"Replace the receiver with a collapsed rendition of itself."	|  w collapsedVersion a ht tab |	(w _ self world) ifNil: [^self].	collapsedVersion _ (self imageForm scaledToSize: 50@50) asMorph.	collapsedVersion setProperty: #uncollapsedMorph toValue: self.	collapsedVersion on: #mouseUp send: #uncollapseSketch to: collapsedVersion.		collapsedVersion setBalloonText: ('A collapsed version of {1}.  Click to open it back up.' translated format: {self externalName}).	self delete.	w addMorphFront: (		a _ AlignmentMorph newRow			hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			borderWidth: 4;			borderColor: Color white;			addMorph: collapsedVersion;			yourself).	a setNameTo: self externalName.	ht := (tab := ActiveWorld findA: SugarNavTab)		ifNotNil:			[tab height]		ifNil:			[80].	a position: 0@ht.	collapsedVersion setProperty: #collapsedMorphCarrier toValue: a.	(self valueOfProperty: #collapsedPosition) ifNotNilDo:		[:priorPosition |			a position: priorPosition]! !!SketchMorph class methodsFor: '*eToys-scripting' stamp: 'bf 8/18/2010 01:32'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((graphics ((slot graphic 	'The picture currently being worn' Graphic	 readWrite Player getGraphic Player setGraphic:)(command wearCostumeOf: 'wear the costume of...' Player)(slot baseGraphic 	'The picture originally painted for this object, but can subsequently be changed via menu or script' Graphic	 readWrite Player getBaseGraphic Player setBaseGraphic:)(command restoreBaseGraphic 'Make my picture be the one I remember in my baseGraphic')(slot rotationStyle 'How the picture should change when the heading is modified' RotationStyle readWrite Player getRotationStyle Player setRotationStyle:)(command flipLeftRight 'Flip the picture left to right' Player)(command flipUpDown 'Flip the picture upside down' Player))))! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'bf 8/31/2009 19:57'!setPlatformPreferences	"Set some platform specific preferences on system startup"	| platform specs |	Preferences automaticPlatformSettings ifFalse:[^self].	platform := self platformName.	specs := 	#(						(soundStopWhenDone false)					(soundQuickStart false)					(swapControlAndAltKeys true)			).	platform = 'Win32' ifTrue:[		specs := #(						(soundStopWhenDone true)					(soundQuickStart false)					(swapControlAndAltKeys true)				)].	platform = 'Mac OS' ifTrue:[		specs := #(						(soundStopWhenDone false)					(soundQuickStart true)					(swapControlAndAltKeys false)				)].	specs do:[:tuple|		Preferences setPreference: tuple first toValue: (tuple last == true).	].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 10/12/2010 23:42'!aboutThisSystem 	"Identify software version"	(self confirm: self systemInformationStringTranslated withCRs,		String cr, 'Show license?' translated) ifTrue: [			Utilities copyrightNotice openInWorkspaceWithTitle: 'License' translated]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 10/12/2010 23:41'!lastUpdateString	"SmalltalkImage current lastUpdateString"	| update |	"don't translate here - use lastUpdateStringTranslated instead"	update := 'latest update: #', SystemVersion current highestUpdate printString.	 SystemVersion current repositoryVersion > 0 ifTrue: [		update := update, ' (', SystemVersion current repositoryString, ')']. 	^update! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 10/12/2010 23:40'!lastUpdateStringTranslated	"SmalltalkImage current lastUpdateStringTranslated"	| update |	update := 'latest update: #' translated, SystemVersion current highestUpdate printString.	 SystemVersion current repositoryVersion > 0 ifTrue: [		update := update, ' (', SystemVersion current repositoryString, ')']. 	^update! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 5/3/2010 10:35'!systemInformationString	"Identify software version"	^ SystemVersion current version, String cr, self lastUpdateString! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 10/12/2010 23:42'!systemInformationStringTranslated	"Identify software version"	^ SystemVersion current version, String cr, self lastUpdateStringTranslated! !!SmalltalkImage methodsFor: 'system attribute' stamp: 'mu 10/20/2009 15:04'!macVmMajorMinorBuildVersion		"SmalltalkImage current macVmMajorMinorBuildVersion"	| aString rawTokens versionPart versionTokens versionArray |	aString := self vmVersion.	aString ifNil: [^ #(0 0 0)].	rawTokens := ((aString copyAfter: $])				findTokens: $ ).	versionPart := rawTokens detect: [:each | each includes: $.] ifNone: [^#(0 0 0)]. 	versionTokens := versionPart findTokens: $..	versionArray := #(0 0 0) collectWithIndex: [:each :index |		(versionTokens at: index ifAbsent:['']) initialIntegerOrNil ifNil: [each]].	^versionArray! !!SmalltalkImage methodsFor: 'system attribute' stamp: 'mu 10/20/2009 15:09'!macVmMajorMinorBuildVersionString	"SmalltalkImage current macVmMajorMinorBuildVersionString"	^ String		streamContents: [:str | self macVmMajorMinorBuildVersion				do: [:each | str nextPutAll: each asString]				separatedBy: [str nextPut: $.]]! !!SortedCollection methodsFor: 'sorting' stamp: 'ul 12/23/2009 12:12'!sort: aSortBlock 	"Sort this collection using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one.	If aSortBlock is nil then <= is used for comparison."	super sort: aSortBlock.	sortBlock := aSortBlock! !!SoundLibraryTool methodsFor: 'initialization' stamp: 'kfr 4/28/2008 15:15'!addSoundList	"Add the sounds list to the tool."		listBox _ PluggableMultiColumnListMorph				on: self				list: #listing				selected: #soundIndex				changeSelected: #soundIndex:.	listBox hResizing: #spaceFill.		listBox hideMenuButton.	listBox height: 240.	listBox font: Preferences standardEToysFont.	self  addMorphBack: listBox! !!SoundLibraryTool methodsFor: 'initialization' stamp: 'kfr 4/29/2008 16:30'!initialize	"initialize the state of the receiver"	super initialize.	showCompression _ false.	self hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	self cellPositioning: #topLeft.	self listDirection: #topToBottom.	self borderWidth: 2;		 borderColor: Color black.	self addHeaderRow.	self addButtonRow.	soundIndex := 1.	self addSoundList.	self soundIndex: 1.	self on: #mouseEnter send: #verifyContents to: listBox! !!SoundLibraryTool methodsFor: 'initialization' stamp: 'kfr 5/1/2008 12:37'!listing	| list newList format soundData selectorList formatList |	list := SampledSound soundLibrary keys asSortedArray.	selectorList := OrderedCollection new.	formatList _ OrderedCollection new.	list		do: [:each | 			soundData := (SampledSound soundLibrary at: each) second.			soundData isNumber				ifTrue: [format := 'uncompressed']				ifFalse: [(soundData includesSubString: 'Vorbis')						ifTrue: [format := 'Vorbis']						ifFalse: [(soundData includesSubString: 'Speex')								ifTrue: [format := 'Speex']								ifFalse: [(soundData includesSubString: 'GSM')										ifTrue: [format := 'GSM']]]].			selectorList add: each.			formatList add:  format].	 newList _ OrderedCollection new.	newList add: selectorList asArray.	showCompression		ifTrue:[newList add: formatList asArray]		ifFalse:[newList add:  (Array new: (formatList size) withAll:' ')].	^newList! !!SoundLibraryTool methodsFor: 'accessing' stamp: 'kfr 5/31/2010 23:15'!soundIndex: aInteger 	"Set the soundIndex to the given integer."	| |	soundIndex :=  aInteger.	soundIndex = 0		ifFalse:			[			currentSound :=  SampledSound soundNamed: self soundName]		ifTrue:			[currentSound := nil].	        self changed: #soundIndex.! !!SoundLibraryTool methodsFor: 'accessing' stamp: 'kfr 5/31/2010 23:34'!soundName	soundIndex = 0 ifTrue:[^self].	^ (listBox getListRow: soundIndex) first! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/1/2008 12:02'!addCustomMenuItems: aMenu hand: aHand	"Add custom menu items to a menu"	super addCustomMenuItems: aMenu hand: aHand.	aMenu addUpdating: #showCompressionString target: self action: #toggleShowCompression.	aMenu add: 'GSM compress sound' translated target: self selector: #compressWith: argument: GSMCodec.	aMenu add: 'Ogg Vorbis compress sound' translated target: self selector: #compressWith: argument:  OggVorbisCodec.	aMenu add: 'Ogg Speex compress sound' translated target: self selector: #compressWith: argument:  OggSpeexCodec.	aMenu addTranslatedList: #(		('Wave editor' edit 'open a tool which, operating with the selected sound as a point of departure, will allow you to construct a new "instrument"')	) translatedNoop! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/31/2010 23:16'!compressWith: aCodec 	"Compress the sound."	| newSound name writer |	soundIndex = 0		ifTrue: [^ self inform: 'No sound selected' translated].		(SampledSound universalSoundKeys includes: self soundName)		ifTrue: [^ self inform: 'You can not compress this sound' translated].	newSound := currentSound compressWith: aCodec.	writer := ByteArray new writeStream.	newSound channels		do: [:channel | writer nextPutAll: channel].	name := self soundName.	SampledSound removeSoundNamed: self soundName.	SampledSound		addLibrarySoundNamed: name		bytes: writer contents		codecSignature: newSound codecSignature.	currentSound := SampledSound soundNamed: name! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/31/2010 23:27'!deleteSound	"Delete the selected sound, if appropriate."	 	soundIndex = 0		ifTrue: [^ self inform: 'No sound selected' translated].	currentSound pause.	(SampledSound universalSoundKeys includes: self soundName)		ifTrue: [^self inform: 'You can not delete this sound' translated]		ifFalse: [ScriptingSystem removeFromSoundLibrary: self soundName].	self soundIndex: 0.	listBox updateList! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/31/2010 23:13'!handMeATile 	| tile |	soundIndex = 0 ifTrue:[^nil].	tile _ SoundTile new literal: self soundName.		tile bounds: tile fullBounds.		tile openInHand! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/31/2010 23:19'!renameSound	"Rename the selected sound, if appropriate."	| name newName |	name := self soundName.	soundIndex = 0		ifTrue: [^ self inform: 'No sound selected' translated].	(SampledSound universalSoundKeys includes: name)		ifTrue: [^ self inform: 'You can not rename this sound' translated].	newName := FillInTheBlank request: 'New name for ' translated, name initialAnswer: name.	(newName isEmptyOrNil or: [newName = name]) ifTrue: [^ self].	(SampledSound soundLibrary includesKey: newName) ifTrue:		[^ self inform: 'sorry, that name is already used.' translated].	ScriptingSystem renameSound: name newName: newName.	listBox updateList.	self soundIndex: (listBox getList indexOf: newName)! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 4/29/2008 16:29'!showCompression	^showCompression! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/1/2008 12:05'!showCompressionString	^ (self showCompression		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'show compression' translated! !!SoundLibraryTool methodsFor: 'menu' stamp: 'kfr 5/31/2010 23:25'!toggleShowCompression	showCompression _ showCompression not.	self listing.! !!SoundLibraryTool commentStamp: 'sw 10/20/2007 01:54' prior: 0!A tool for browsing and managing the sound library.Offers a self-updating, scrolling list of all the sounds in the library.  Has a row of buttons to initiate various functions on the selected sound; the buttons are:	Play	Play the selected sound	Stop		Stop playing selected sound (if it is playing)	Tile		Hand the user a tile for the selected sound.	Rename	Rename the selected sound.	Delete	Delete the selected sound from the ibrary	Load	Load a sound into the sound library from a file.Additionally, a wave-editor can be invoked via an item in the tool's halo menu.The Sound Library tool can be launched from the Objects catalog, and also from the authoring-tools menu!!SoundPlayer class methodsFor: 'initialization' stamp: 'bf 9/14/2010 15:01'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate := 22050.	BufferMSecs := 120.	Stereo := true.	Preferences		addPreference: #soundReverb		categories: #(media)		default: true		balloonHelp: 'If true, a little echo will be added, making it sound as if it is in a larger space.'		projectLocal: true		changeInformee: self		changeSelector: #reverbChanged.	self reverbChanged.	! !!SoundPlayer class methodsFor: 'player process' stamp: 'bf 10/12/2010 20:25'!reverbChanged	Preferences soundReverb		ifTrue: [self startReverb]		ifFalse: [self stopReverb]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 21:23'!balloon	^balloon ifNil: [		| balloonForm |		balloonForm := Form extent: self extent - (0 @ self tailHeight) depth: 16.		self drawBalloonOn: balloonForm getCanvas in: balloonForm boundingBox.		balloonForm floodFill: self color at: balloonForm center.		balloon := (SketchMorph withForm: balloonForm).	]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 21:23'!color: aColor	super color: aColor.	self refresh! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 21:02'!defaultColor	^Color white! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/17/2010 12:43'!extent: aPoint| width height |width := aPoint x max: self minimumAcceptedWidth.height := aPoint y max: self minimumAcceptedHeight.super extent: width @ height.self refresh.target notNil ifTrue: [self positionMyselfAccordingToTarget]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 20:59'!fillStyle: aFillStyle	super fillStyle: aFillStyle.	self refresh! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 13:44'!form^(msgMorph isKindOf: SketchMorph) ifTrue: [msgMorph form]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 13:18'!minimumAcceptedHeight^100 max: self msgMorph fullBounds height + 20 + self tailHeight! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 13:18'!minimumAcceptedWidth^ 175 max: self msgMorph fullBounds width + 20! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/9/2010 20:20'!msgMorph^msgMorph isNil ifTrue: [nil] ifFalse: [msgMorph topRendererOrSelf]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 13:17'!msgMorphExtent^self msgMorph fullBounds extent! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 17:11'!position: aPointtarget notNil ifTrue: [^self positionMyselfAccordingToTarget ].super position: aPoint.! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/14/2010 15:19'!selectedTailForm	^type caseOf: {		[#speech] -> [self class speakingForm].		[#thought] -> [self class thinkingForm].		} otherwise: [self error: 'Wrong type']! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 7/6/2010 13:44'!string^(msgMorph isKindOf: UserText) ifTrue: [msgMorph contents]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 21:24'!tail^tail ifNil: [	| tailForm |	tailForm := self selectedTailForm deepCopy.		"This will paint both forms correctly"	tailForm floodFill: self color at: tailForm center + (6@-15).	"In the #thought case, we also need to paint the little bubbles"	type = #thought ifTrue: [		tailForm floodFill: self color at: tailForm center + (-7@7);				floodFill: self color at: tailForm center + (-22@20)	].	tail := SketchMorph withForm: tailForm]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/14/2010 15:36'!tailHeight^self tail height! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/16/2010 23:58'!target	^target! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 8/31/2010 11:57'!target: aMorph	target isMorph ifTrue: [target bubble: nil].	target := aMorph.	target notNil ifTrue: [target bubble: self topRendererOrSelf. self positionMyselfAccordingToTarget ]! !!SpeechBubbleMorph methodsFor: 'accessing' stamp: 'Richo 6/14/2010 16:43'!type^type! !!SpeechBubbleMorph methodsFor: 'testing' stamp: 'Richo 6/14/2010 16:41'!containsPoint: aPoint^ (self bounds containsPoint: aPoint) and:	  [(self imageForm isTransparentAt: aPoint - bounds origin) not]! !!SpeechBubbleMorph methodsFor: 'initialize-release' stamp: 'Richo 8/31/2010 12:19'!delete	target isMorph ifTrue: [target bubble: nil].	super delete.	target := msgMorph := type := nil.! !!SpeechBubbleMorph methodsFor: 'initialize-release' stamp: 'Richo 7/9/2010 20:09'!initializesuper initialize.stepTime := self minimumStepTime.self positionBalloon; positionTail; positionMsgMorph.self addMorph: self balloon; addMorph: self tail; addMorph: self msgMorph.self extent: self msgMorphExtent + (20 @ self tailHeight + 20); color: Color white.! !!SpeechBubbleMorph methodsFor: 'initialize-release' stamp: 'Richo 6/14/2010 15:41'!positionBalloonself balloon position: self position! !!SpeechBubbleMorph methodsFor: 'initialize-release' stamp: 'Richo 7/6/2010 13:24'!positionMsgMorph| diff |diff := self msgMorph center - self msgMorph fullBounds center.self msgMorph center: self center - (0 @ self tailHeight / 2) + diff.! !!SpeechBubbleMorph methodsFor: 'initialize-release' stamp: 'Richo 6/14/2010 15:40'!positionTailself tail position: self bottomCenter - (0 @ self tailHeight + 2)! !!SpeechBubbleMorph methodsFor: 'drawing' stamp: 'Richo 6/14/2010 15:20'!drawBalloonOn: aCanvas in: sourceRect| cornerBounds rect1 rect2 |cornerBounds := self class topLeftCornerForm boundingBox.aCanvas translucentImage: self class topLeftCornerForm at: sourceRect topLeft;		translucentImage: self class topRightCornerForm at: sourceRect topRight - (cornerBounds width @ 0);		translucentImage: self class bottomLeftCornerForm at: sourceRect bottomLeft - (0 @ (cornerBounds height));		translucentImage: self class bottomRightCornerForm at: sourceRect bottomRight - cornerBounds extent.rect1 := sourceRect topLeft + (cornerBounds width @ 1) corner: sourceRect bottomRight - (cornerBounds width @ 1).rect2 := sourceRect topLeft + (1 @ cornerBounds height) corner: sourceRect bottomRight - (1 @ cornerBounds height).aCanvas fillRectangle: rect1 color: Color white; fillRectangle: rect2 color: Color white.aCanvas line: rect1 topLeft to: rect1 topRight width: 2 color: Color black;		line: rect1 bottomLeft to: rect1 bottomRight width: 2 color: Color black;		line: rect2 topLeft to: rect2 bottomLeft width: 2 color: Color black;		line: rect2 topRight to: rect2 bottomRight width: 2 color: Color black.! !!SpeechBubbleMorph methodsFor: 'drawing' stamp: 'Richo 8/31/2010 11:16'!drawOn: aCanvas! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 6/14/2010 16:31'!incrementStepTime	stepTime := (stepTime + 1) min: self maximumStepTime! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 6/17/2010 00:11'!maximumStepTime	^500! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 6/14/2010 16:32'!minimumStepTime	^20! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 8/31/2010 11:54'!positionMyselfAccordingToTarget	| newCenter newOwner |	"Modify mi position"	newCenter := target topRendererOrSelf center - (0 @ ((target topRendererOrSelf height + self height) / 2)).	self privatePosition: newCenter - (self topRendererOrSelf extent // 2).	"Don't forget to check if my owner is still the right one. Maybe the morph was inside a Playfield and the user grabed it and put it in the World"	(newOwner := target ownerThatIsA: PasteUpMorph) ifNil: [^self].	self owner ~= newOwner ifTrue: [newOwner addMorph: self topRendererOrSelf]! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 7/9/2010 20:28'!step(target isNil or: [lastHash = (lastHash := target boundsSignatureHash)])		ifTrue: [self incrementStepTime]		ifFalse: [stepTime := self minimumStepTime].target notNil ifTrue: [target isInWorld ifFalse: [^self delete].self positionMyselfAccordingToTarget]."This will keep the correct extent if the graphic changed"self msgMorph notNil ifTrue: [(self balloon fullBounds containsRect: self msgMorph fullBounds)	ifFalse: [self extent: 1@1]]! !!SpeechBubbleMorph methodsFor: 'stepping' stamp: 'Richo 6/14/2010 16:34'!stepTime^stepTime ! !!SpeechBubbleMorph methodsFor: 'event handling' stamp: 'Richo 7/6/2010 13:02'!keyStroke: anEvent morph: aMorph 	| string |	(self msgMorph isKindOf: UserText) ifFalse: [^self].	string := self msgMorph contents.	"Update text width if necessary. Make sure we keep the selection at the end of the text so that the user can keep modifying"	self msgMorph width > 300		ifTrue: [self msgMorph contents: string wrappedTo: 300.			self msgMorph editor selectFrom: string size + 1 to: string size].	"Update my extent"	self extent: self msgMorphExtent + (20 @ self tailHeight + 20).! !!SpeechBubbleMorph methodsFor: 'private' stamp: 'Richo 8/31/2010 11:52'!privatePosition: aPoint"Always changes the position, regardless of the target"self isFlexed ifTrue: [self topRendererOrSelf position: aPoint]				ifFalse: [super position: aPoint]! !!SpeechBubbleMorph methodsFor: 'private' stamp: 'Richo 7/6/2010 12:46'!setMorph: aMorph type: aSymbol	msgMorph := aMorph.	type := aSymbol! !!SpeechBubbleMorph methodsFor: 'refreshing' stamp: 'Richo 7/6/2010 12:56'!refreshself refreshBalloon; refreshTail; refreshMsgMorph! !!SpeechBubbleMorph methodsFor: 'refreshing' stamp: 'Richo 6/14/2010 15:49'!refreshBalloon	balloon ifNotNil: [balloon delete].	balloon := nil.	self positionBalloon.	self addMorph: balloon! !!SpeechBubbleMorph methodsFor: 'refreshing' stamp: 'Richo 7/9/2010 20:21'!refreshMsgMorph	self msgMorph owner = self ifFalse: [^self delete].	self positionMsgMorph.	self addMorph: self msgMorph! !!SpeechBubbleMorph methodsFor: 'refreshing' stamp: 'Richo 6/14/2010 15:50'!refreshTail	tail ifNotNil: [tail delete].	tail := nil.	self positionTail.	self addMorph: tail! !!SpeechBubbleMorph class methodsFor: 'viewer categories' stamp: 'Richo 8/14/2010 20:42'!additionsToViewerCategoryBubble	"Answer viewer additions for the 'bubble' category"	^#(		bubble 		(			(command attachTo: 'Make the bubble follow an object' Player)			(command stopAttaching 'Free the bubble from following an object')			(slot attachment 'The object this bubble is currently following' Player readOnly Player getAttachment Player unused)				)	)! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/14/2010 11:08'!bottomLeftCornerForm^self topLeftCornerForm flipBy: #vertical centerAt: self topLeftCornerForm boundingBox topCenter! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/14/2010 11:08'!bottomRightCornerForm^(self topLeftCornerForm flipBy: #horizontal centerAt: self topLeftCornerForm boundingBox leftCenter) flipBy: #vertical centerAt: self topLeftCornerForm boundingBox topCenter! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/16/2010 21:10'!speakingForm"speakingForm := nil"^speakingForm ifNil: [speakingForm := (Form	extent: 56@51	depth: 16	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147418113 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)]! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/16/2010 21:07'!thinkingForm"thinkingForm := nilthinkingForm"^thinkingForm ifNil: [thinkingForm := (Form	extent: 56@49	depth: 16	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 65537 65537 65537 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 65537 65537 2147450879 2147450879 2147450879 65537 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 65537 65537 65537 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 1 65537 65537 65537 65537 65537 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 65537 65537 98303 2147450879 2147418113 65537 65537 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147418113 65537 65536 1 65537 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 65536 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 65537 65537 65537 2147450879 2147450879 2147450879 65537 65537 65537 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 0 1 65537 65537 65537 65537 65537 65537 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 1 65537 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147418113 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65536 0 1 65537 98303 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65537 65537 65536 0 65537 65537 98303 2147450879 2147418113 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 65537 65536 0 0 65537 65537 65537 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147418113 65537 0 0 0 65537 65537 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 2147450879 2147450879 2147450879 2147450879 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65537 98303 2147450879 2147450879 2147418113 65537 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 2147450879 2147450879 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 65537 65537 65536 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)]! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/16/2010 20:50'!topLeftCornerForm"topLeftCornerForm := nil(SketchMorph withForm: topLeftCornerForm) openInHand"^topLeftCornerForm ifNil: [topLeftCornerForm := (Form	extent: 25@25	depth: 16	fromArray: #( 0 0 0 0 0 0 0 1 65537 65537 65537 65537 65536 0 0 0 0 0 1 65537 65537 65537 65537 65537 65537 65536 0 0 0 0 1 65537 65537 65537 2147450879 2147450879 2147450879 2147450879 2147418112 0 0 0 1 65537 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 0 0 65537 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 0 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 1 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 1 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 98303 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112 65537 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147450879 2147418112)	offset: 0@0)]! !!SpeechBubbleMorph class methodsFor: 'forms' stamp: 'Richo 6/14/2010 11:15'!topRightCornerForm^self topLeftCornerForm flipBy: #horizontal centerAt:  self topLeftCornerForm boundingBox leftCenter! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 7/6/2010 13:03'!form: aForm type: aSymbol^(self basicNew setMorph: (SketchMorph withForm: aForm) type: aSymbol) initialize! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 7/2/2010 18:39'!form: aForm type: aSymbol for: aMorph^(self form: aForm type: aSymbol) target: aMorph! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 7/6/2010 12:45'!morph: aMorph type: aSymbol ^(self basicNew setMorph: aMorph type: aSymbol) initialize! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 7/6/2010 15:50'!morph: aMorph type: aSymbol for: targetMorph^(self morph: aMorph type: aSymbol) target: targetMorph! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 6/14/2010 15:11'!new	^self string: 'Hello world!!'! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 6/14/2010 15:12'!string: aString ^self string: aString type: #speech! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 7/6/2010 13:06'!string: aString type: aSymbol"self string: 'Hello world!!' type: #speech"| text instance |text := (UserText new contents: aString) centered.text width > 300 ifTrue: [text contents: aString wrappedTo: 300].text on: #keyStroke send: #keyStroke:morph: to: (instance := self basicNew).^(instance setMorph: text type: aSymbol) initialize! !!SpeechBubbleMorph class methodsFor: 'instance creation' stamp: 'Richo 6/14/2010 15:12'!string: aString type: aSymbol for: aMorph"self string: 'Hello world!!' type: #speech for: Morph new openInHand"^(self string: aString type: aSymbol) target: aMorph! !!SpeechBubbleMorph class methodsFor: 'parts bin' stamp: 'Richo 7/2/2010 18:50'!speechGraphicPrototype	^self form: (ScriptingSystem formAtKey: 'Painting') type: #speech! !!SpeechBubbleMorph class methodsFor: 'parts bin' stamp: 'Richo 6/16/2010 21:33'!speechPrototype	^self string: 'Hello world!!' type: #speech! !!SpeechBubbleMorph class methodsFor: 'parts bin' stamp: 'Richo 8/14/2010 20:40'!supplementaryPartsDescriptions	"Answer a list of DescriptionForPartsBin objects that characterize objects that this class wishes to contribute to Stationery bins *other* than by the standard default #newStandAlone protocol"	^ {	DescriptionForPartsBin		formalName: 'Speech bubble' translatedNoop		categoryList: #('Just for Fun')		documentation: 'An object you can use to make words represent the speech of a character in a comic' translatedNoop		globalReceiverSymbol: #SpeechBubbleMorph		nativitySelector: #speechPrototype.	DescriptionForPartsBin		formalName: 'Thought bubble' translatedNoop		categoryList: #('Just for Fun')		documentation: 'An object you can use to make words represent the thoughts of a character in a comic' translatedNoop		globalReceiverSymbol: #SpeechBubbleMorph		nativitySelector: #thoughtPrototype.	DescriptionForPartsBin		formalName: 'Speech bubble (graphic)' translatedNoop		categoryList: #('Just for Fun')		documentation: 'An object you can use to make pictures represent the speech of a character in a comic' translatedNoop		globalReceiverSymbol: #SpeechBubbleMorph		nativitySelector: #speechGraphicPrototype.	DescriptionForPartsBin		formalName: 'Thought bubble (graphic)' translatedNoop		categoryList: #('Just for Fun')		documentation: 'An object you can use to make pictures represent the thoughts of a character in a comic' translatedNoop		globalReceiverSymbol: #SpeechBubbleMorph		nativitySelector: #thoughtGraphicPrototype.}! !!SpeechBubbleMorph class methodsFor: 'parts bin' stamp: 'Richo 7/2/2010 18:50'!thoughtGraphicPrototype	^self form: (ScriptingSystem formAtKey: 'Painting') type: #thought! !!SpeechBubbleMorph class methodsFor: 'parts bin' stamp: 'Richo 6/16/2010 21:33'!thoughtPrototype	^self string: 'Hello world!!' type: #thought! !!StandardViewer methodsFor: 'categories' stamp: 'sw 5/16/2009 05:38'!addCategoryViewerFor: categoryInfo atEnd: atEnd	"Add a category viewer for the given category info.  If atEnd is true, add it at the end, else add it just after the header morph"	| aViewer |	Cursor wait showWhile: [		aViewer _ self categoryViewerFor: categoryInfo.		atEnd			ifTrue:				[self addMorphBack: aViewer]			ifFalse:				[self addMorph: aViewer after: submorphs first].		aViewer establishContents.		self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer].		self fitFlap.		aViewer assureCategoryFullyVisible							].! !!StarMorph methodsFor: 'initialization' stamp: 'kfr 5/3/2009 19:43'!setVerticesCount: aInteger 	| verticesCount int |	verticesCount := self vertices size.	int := aInteger max: 4.	aInteger > verticesCount		ifTrue: [int even				ifFalse: [int := int + 1]]		ifFalse: [int even				ifFalse: [int := int - 1 max: 4]].	self makeVertices: int! !!StaticTextMorph methodsFor: 'event handling' stamp: 'sw 8/7/2009 21:45'!wouldAcceptKeyboardFocusUponTab	"Since the receiver is not user-editible by conventional means, refuse to give it the selection upon tab."	^ false! !!StaticTextMorph methodsFor: 'e-toy support' stamp: 'sw 8/8/2009 03:03'!printOn: aStream	"Print the receiver on a stream."	super printOn: aStream.	aStream nextPutAll: ': '.	self contents asString printOn: aStream! !!StaticTextMorph methodsFor: 'drawing' stamp: 'sw 8/7/2009 21:45'!drawNullTextOn: aCanvas	"Make null text frame visible"	aCanvas isPostscriptCanvas ifFalse:		[aCanvas fillRectangle: bounds color: Color transparent]! !!Stream methodsFor: '*monticello' stamp: 'cwp 8/9/2003 12:02'!isMessageStream	^ false! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:12'!createExternalFontFileForUnicodeKorean: fileName"	Smalltalk garbageCollect.	StrikeFontSet createExternalFontFileForUnicodeKorean: 'uKoreanFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Korean10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Korean12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'Korean14' overrideWith: 'hanglg16.bdf') fixAscent: 16 andDescent: 4 head: 4)				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Korean18' overrideWith: 'hanglm24.bdf').	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!String methodsFor: 'comparing' stamp: 'ul 11/2/2009 03:01'!hashWithInitialHash: initialHash		^ self class stringHash: self initialHash: initialHash! !!String methodsFor: '*monticello' stamp: 'avi 2/4/2004 14:14'!extractNumber	^ ('0', self select: [:ea | ea isDigit]) asNumber! !!String methodsFor: 'password compatibility' stamp: 'yo 9/9/2009 10:31'!passwordFor: aServerDir	^ self.! !!String methodsFor: '*gettext' stamp: 'bf 9/27/2007 12:20'!literalStringsDo: aBlock 	"Assuming the receiver receiver is a literal, evaluate aBlock with all Strings (but not Symbols) within it."	aBlock value: self! !!String methodsFor: '*gettext' stamp: 'Richo 5/28/2010 10:39'!translated	"answer the receiver translated to the default language"	| translation |	translation := self		translatedTo: LocaleID current		inDomain: (TextDomainManager domainOfMethod: thisContext sender method).	self == translation ifTrue: [^self translatedInAllDomains].	^translation! !!String methodsFor: '*gettext' stamp: 'dgd 8/27/2004 18:43'!translatedIfCorresponds	"answer the receiver translated to the default language only if 	the receiver begins and ends with an underscore (_)"	^ ('_*_' match: self)		ifTrue: [(self copyFrom: 2 to: self size - 1) translated]		ifFalse: [self]! !!String methodsFor: '*gettext' stamp: 'Richo 8/16/2010 22:25'!translatedInAllDomains	| translation |	"Transcript show: self printString, ' translatedInAllDomains'; cr."	TextDomainManager allKnownDomains do: [:domain |		translation := self translatedTo: LocaleID current inDomain: domain.		self = translation ifFalse: [^translation]	].	^self! !!String methodsFor: '*gettext' stamp: 'Richo 8/16/2010 22:26'!translatedInDomain: aDomainName| translation |translation := self translatedTo: LocaleID current inDomain: aDomainName.self == translation ifTrue: [^self translatedInAllDomains].^translation! !!String methodsFor: '*gettext' stamp: 'Richo 8/16/2010 22:27'!translatedInDomain: aDomainName or: anotherDomainName| translation |translation := self translatedTo: LocaleID current inDomain: aDomainName.self == translation ifTrue: [^self translatedInDomain: anotherDomainName].^translation! !!String methodsFor: '*gettext' stamp: 'tak 7/25/2007 00:01'!translatedNoop	"This is correspondence gettext_noop() in gettext."	^ self! !!String methodsFor: '*gettext' stamp: 'Richo 5/12/2010 16:43'!translatedTo: localeID 	"answer the receiver translated to the given locale id"	^ self translatedTo: localeID inDomain: (TextDomainManager domainOfMethod: thisContext sender method).! !!String methodsFor: '*gettext' stamp: 'tk 1/6/2008 12:21'!translatedTo: localeID inDomain: aDomainName	"answer the receiver translated to the given locale id in the textdomain"	^ NaturalLanguageTranslator translate: self 								toLocaleID: localeID 								inDomain:  aDomainName! !!StringButtonMorph methodsFor: 'menu' stamp: 'bf 8/14/2010 19:38'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' translated action: #setLabel.	aCustomMenu add: 'change action selector' translated action: #setActionSelector.	aCustomMenu add: 'change arguments' translated action: #setArguments.	aCustomMenu add: 'change when to act' translated action: #setActWhen.	aCustomMenu add: 'set target' translated action: #sightTargets:.	target ifNotNil: [aCustomMenu add: 'clear target' translated action: #clearTarget].! !!StringButtonMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 19:55'!clearTarget	target _ nil.! !!StringButtonMorph methodsFor: 'menu' stamp: 'wiz 6/5/2007 20:52'!setTarget: evt 	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt  targetPoint.	target _ rootMorphs size > 1		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!StringMorphEditor methodsFor: 'event handling' stamp: 'bf 8/8/2010 13:39'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char newSel w |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	owner ifNotNil: [		w := owner fullBounds width.		self width: w + 1.		self width: w].	self textColor: self color.	self editor selectFrom: newSel first to: newSel last.! !!SugarDatastoreDirectory methodsFor: 'file directory' stamp: 'bf 9/8/2009 16:43'!entries	"Return a collection of directory entries for the files and 	directories in this directory."	^(SugarLauncher current		findJournalEntries: self query properties: #('uid' 'title' 'ctime' 'mtime' 'file-size'))		collect: [:props |			props keysAndValuesDo: [:key :value | props at: key put: value asString].			DirectoryEntry				name: (((props at: 'title') copyReplaceAll: '/' with: '\') contractTo: 64) utf8ToSqueak, '-', (props at: 'uid'), self extension				creationTime: ([(DateAndTime fromString: (props at: 'ctime')) asSeconds] ifError: [0])				modificationTime: ([(DateAndTime fromString: (props at: 'mtime')) asSeconds] ifError: [0])				isDirectory: false				fileSize: (props at: 'file-size' ifAbsent: [42])		]! !!SugarEtoysActivity methodsFor: 'dbus methods' stamp: 'bf 11/25/2009 16:14'!handleViewSource	self dbusMethod: 'org.laptop.Activity.HandleViewSource<>'.	SugarLauncher current viewSource! !!SugarLauncher methodsFor: 'running' stamp: 'bf 11/25/2009 19:26'!parameters: aDictionary	super parameters: aDictionary.	"prevent reading bundled project at startup on resuming a journal object. This is for Etoys-based Sugar activities (e.g. made using #bundle:)."	((parameters includesKey: 'OBJECT_ID') 		and: [(Smalltalk getSystemAttribute: 2) isEmptyOrNil not])			ifTrue: [Preferences disable: #readDocumentAtStartup]! !!SugarLauncher methodsFor: 'running' stamp: 'bf 8/20/2010 10:26'!startUp	self class allInstances do: [:ea | ea shutDown].	Current := self.	SugarNavigatorBar current		ifNotNilDo: [:bar | bar startUp].	parameters at: 'ACTIVITY_ID' ifPresent: [ :activityId |		OLPCVirtualScreen setupIfNeeded.		World windowEventHandler: self.		DBus sessionBus 			export: SugarEtoysActivity new			on: 'org.laptop.Activity', activityId			at: '/org/laptop/Activity/', activityId.		Utilities authorName: self presence getOwner nick.		ServerDirectory			addServer: (SugarDatastoreDirectory mimetype: 'application/x-squeak-project' extension: '.pr')			named: SugarLauncher defaultDatastoreDirName.		self joinSharedActivity.		self isShared ifFalse: [			parameters at: 'OBJECT_ID' ifPresent: [:id |				^self resumeJournalEntry: id]].		self isShared ifTrue: [^self].		^self welcome: (parameters at: 'URI' ifAbsent: [''])].	self welcome: ''! !!SugarLauncher methodsFor: 'commands' stamp: 'bf 8/22/2010 20:05'!quit	| autoSave |	autoSave := self shouldSaveOnQuit.	Preferences sugarAutoSave ifFalse: [		autoSave := false.		(self 			confirm: 'Are you sure you want to quit Etoys?(the project will NOT be saved)' translated)				ifFalse: [^self]].	autoSave		ifFalse: [^Smalltalk quitPrimitive].	Project current		projectParameterAt: #sugarAutoSave put: true;		storeOnServerWithNoInteractionThenQuit.! !!SugarLauncher methodsFor: 'commands' stamp: 'bf 11/25/2009 16:24'!viewSource 	WorldState addDeferredUIMessage: [		World showSourceKeyHit]! !!SugarLauncher methodsFor: 'commands' stamp: 'bf 9/11/2009 23:59'!welcome: aUrl	"Sent either when running from Sugar, or at regular startUp otherwise"	aUrl isEmpty ifFalse: [		| url |		url := (aUrl includes: $/)			ifTrue: [aUrl]			ifFalse: ['file:', (parameters at: 'BUNDLE_PATH'), '/', aUrl].		^(url endsWith: '.pr')			ifTrue: [Project fromUrl: url]			ifFalse: [WorldState addDeferredUIMessage: [FileStream fileIn: (url copyAfter: $:)]]].	self shouldEnterHomeProject ifTrue: [Project home ifNotNilDo: [:p | p enter]].! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 9/14/2010 14:18'!createJournalEntryFor: aProject filename: aFilename mimetype: mimetypeString	| properties id |	properties := self propertiesFrom: aProject.	properties at: 'ctime' put: (properties at: 'mtime').	properties at: 'mime_type' put: mimetypeString.	properties removeKey: 'uid' ifAbsent: [].		"would confuse Sugar 0.82"	aFilename ifEmpty: [properties at: 'title:text' put: 'Etoys' translated].	id := self dataStore create: properties with: aFilename squeakToUtf8 with: true.	^id asString! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 9/14/2009 16:32'!getProperties: objectId	| props |	props := self dataStore getProperties: objectId.	"Make sure the props we care about are strings"	props at: 'title' ifPresent: [:value | props at: 'title' put: value asString utf8ToSqueak composeAccents].	props at: 'mime_type' ifPresent: [:value | props at: 'mime_type' put: value asString].	props at: 'uid' put: objectId asString.	^props! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 8/25/2010 00:09'!makeJournalEntryFor: aProject filename: aFilename mimetype: mimetypeString	"If this is a new project (no journal id yet), create a new Journal object, and remember the new id.	Otherwise, if this is an auto-save, update the existing Journal entry. 	But if it is an explicit save, always create a new entry. Which entry we continue to work on depends on the sugarAutoSave preference. If enabled (before 4.1), the new entry is just a checkpoint, the project continues to use the old id/entry, and will be saved again on quit. If disabled (default since 4.1), we switch to the newly created id/entry."	| id |	(id := aProject sugarObjectId)		ifNil: [			id := self createJournalEntryFor: aProject filename: aFilename mimetype: mimetypeString.			aProject sugarObjectId: id.			self monitorJournalEntry: id]		ifNotNil: [			(Preferences sugarAutoSave and: [aProject projectParameterAt: #sugarAutoSave ifAbsent: [true]])				ifTrue: [self updateJournalEntry: id for: aProject filename: aFilename mimetype: mimetypeString]				ifFalse: [					id := self createJournalEntryFor: aProject filename: aFilename mimetype: mimetypeString.					Preferences sugarAutoSave ifFalse: [						self unmonitorJournalEntry: aProject sugarObjectId.						aProject sugarObjectId: id.						self monitorJournalEntry: id]]]! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 9/14/2009 16:47'!monitorJournalEntry: objectId	self dataStore 		onUpdated: objectId		send: #updatedJournalEntry:		to: self.! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 8/25/2010 00:44'!propertiesFrom: aProject	| preview autoSave props markFavorite setActivity |	preview := [ByteArray streamContents: [:s | PNGReadWriter 		putForm: (aProject thumbnail asFormOfDepth: 16)		onStream: s]] ifError: [''].	autoSave := aProject projectParameterAt: #sugarAutoSave ifAbsent: [true].	setActivity := Preferences sugarAutoSave not | autoSave.		markFavorite := Preferences sugarAutoSave & autoSave not.	props := (aProject sugarProperties ifNil: [Dictionary new]) copy.	{		'activity' -> self bundleId.		'activity_id' -> (setActivity ifTrue: [self activityId] ifFalse: ['']).		'title:text' -> (self titleFromProject: aProject)  squeakToUtf8.		'title_set_by_user' -> (aProject currentVersionNumber>0 ifTrue: ['1'] ifFalse: ['0']).		'keep' -> (markFavorite ifTrue: ['1'] ifFalse: ['0']).		'mtime' -> (DateAndTime now asString first: 19).		'timestamp' -> (DateAndTime now asUnixTime).		'preview' -> preview.		'icon-color' -> self ownerBuddy colors.	} do: [:each | props add: each].	^props! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 9/14/2009 18:09'!resumeJournalEntry: id	| props file title project mimetype |	props := self getProperties: id.	title := props at: 'title' ifAbsent: ['untitled' translated].	mimetype := props at: 'mime_type' ifAbsent: [''].	mimetype isEmpty ifTrue: [^self welcome: ''].	mimetype = 'application/x-squeak-project' ifFalse: [		"reuse drop code"		WorldState addDeferredUIMessage: [			self open: id title: title mimetype: mimetype].		^Project enterNew].	ProjectLoading showProgressBarDuring: [		Display fillWhite;forceToScreen.		file := self getFile: id.		"load project and close temp file (which will thus be deleted)"		project := ProjectLoading 			loadName: ((title copyReplaceAll: '/' with: '\') contractTo: 64)			stream: file			fromDirectory: nil			withProjectView: nil.		file close.		project keepSugarProperties: props monitor: true.		project projectParameterAt: #sugarAutoSave put: true.		project enter].! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 8/25/2010 00:07'!unmonitorJournalEntry: objectId	self dataStore 		onUpdated: objectId		send: nil		to: self.! !!SugarLauncher methodsFor: 'datastore' stamp: 'bf 9/14/2009 18:09'!updatedJournalEntry: objectId	"sent from DBus in background process"	| id project props |	id := objectId asString.	project := Project allProjects detect: [:each | each sugarObjectId = id] ifNone: [^self]. 	props := [self getProperties: objectId] on: DBusError do: [^self].	project keepSugarProperties: props monitor: false.! !!SugarLauncher methodsFor: 'testing' stamp: 'bf 9/12/2009 00:07'!shouldEnterHomeProject	"only if no other content is about to be loaded"	^Preferences eToyFriendly		and: [(Smalltalk getSystemAttribute: 2) isEmptyOrNil			and: [(self includesParameter: 'SRC') not				and: [Sensor hasDandDEvents not]]]! !!SugarLauncher methodsFor: 'testing' stamp: 'bf 8/22/2010 15:55'!shouldSaveOnQuit	"Don't save the home project to avoid confusion. Also, don't save if something was loaded from the XO bundle - this is for Etoys-based Sugar activities (e.g. made using #bundle:)."	^Project current ~~ Project home		and: [(Smalltalk getSystemAttribute: 2) isEmptyOrNil]! !!SugarLauncher methodsFor: 'testing' stamp: 'bf 8/22/2010 19:34'!willSaveOnQuit	^Preferences sugarAutoSave		and: [self shouldSaveOnQuit]! !!SugarLauncher methodsFor: 'chooser' stamp: 'bf 9/14/2009 17:39'!chooser: chooserId response: objectId	self chooserDone: chooserId.	WorldState addDeferredUIMessage: [		| props title mimetype |		props := self getProperties: objectId.		title := props at: 'title' ifAbsent: ['untitled' translated].		mimetype := props at: 'mime_type' ifAbsent: [''].		[self open: objectId title: title mimetype: mimetype]			on: SugarPropertiesNotification do: [:ex | ex resume: props]].! !!SugarLauncher class methodsFor: 'utilities' stamp: 'bf 8/25/2010 01:58'!defaultDatastoreDirName	^ '[Journal]'! !!SugarLauncher class methodsFor: 'accessing' stamp: 'bf 9/12/2009 00:15'!welcomeProjectName	"Deprecated"	^Project home ifNotNilDo: [:p | p name]! !!SugarLauncher class methodsFor: 'services' stamp: 'bf 8/24/2010 23:46'!initialize	Preferences		addPreference: #sugarAutoSave		category:  #morphic		default: false		balloonHelp: 'If enabled, quitting under Sugar will automatically save the current project.'.! !!SugarLibrary methodsFor: 'icon images' stamp: 'sw 5/30/2009 01:12'!iconAt: aName ifAbsent: aBlock	"If the IconDictionary has entry filed under the first argument, answer that entry; if not (e.g. during development) then answer the result of evaluating the block provided"	^ iconDictionary at: aName ifAbsent: [aBlock value]! !!SugarLibrary methodsFor: 'icon images' stamp: 'sw 5/30/2009 01:13'!imageFor: aString color: aColor grayOutColor: grayOutColor	"Answer an image corresponding to the given string, using the specified color scheme."	| icon g h orig w height ret f |	icon _ self iconAt: aString ifAbsent: [self iconAt: #missingIcon].	icon unhibernate.	grayOutColor ifNotNil: [		f _ Form extent: icon extent depth: 32.		f fillColor: grayOutColor.		icon displayOn: f at: 0@0 rule: 37.		icon _ f.	].	orig _ Form new hackBits: icon bits.	height _ icon width * icon height.	g _ Form extent: icon extent depth: 32.	h _ Form new hackBits: g bits.	w _ WarpBlt current toForm: h.	w sourceForm: orig.	w cellSize: 1.	w combinationRule: Form over.	w copyQuad: {1@0. 1@height. 2@height. 2@0} toRect: (0@0 corner: 4@(height + 1)).	ret _ (Form extent: icon extent depth: 32) fillColor: aColor.	g displayOn: ret at: 0 rule: 34.	^ ret asFormOfDepth: 16! !!SugarLibrary methodsFor: 'icon images' stamp: 'sw 7/16/2009 14:59'!makeButton: aString balloonText: anotherString for: aSymbol target: target baseColor: baseColor highLightColor: highLightColor	"Answer a SugarButton constructed from the arguments."	| s keyString img |	keyString _ aSymbol asString.	s _ SugarButton new.	img _ self iconAt: aString ifAbsent: [self iconAt: #missingIcon].	self recolorButton: s for: keyString baseColor: baseColor highLightColor: highLightColor.	s extent: img extent + (25@25).	s target: target.	s actionSelector: aSymbol.	s setBalloonText: anotherString.	^ s! !!SugarLibrary class methodsFor: 'singleton management' stamp: 'bf 9/12/2009 20:36'!newDefault	"Answer a new instance of SugarLibrary."	| i |	i := SugarLibrary new.	i iconAt: 'new' put: self newIcon.	i iconAt: 'prev' put: self prevIcon.	i iconAt: 'next' put: self nextIcon.	i iconAt: 'save' put: self saveIcon.	i iconAt: 'open' put: self openIcon.	i iconAt: 'keep' put: self keepIcon.	i iconAt: 'choose' put: self chooseIcon.	i iconAt: 'paint' put: self paintIcon.	i iconAt: 'language' put: self languageIcon.	i iconAt: 'undo' put: self undoIcon.	i iconAt: 'close' put: self closeIcon.	i iconAt: 'share' put: self shareIcon.	i iconAt: 'miniShare' put: self miniShareIcon.	i iconAt: 'supplies' put: self suppliesIcon.	i iconAt: 'stop' put: self stopIcon.	i iconAt: 'zoom' put: self zoomIcon.	i iconAt: 'help' put: self helpIcon.	i iconAt: 'miniPrivate' put: self miniPrivateIcon.	i iconAt: 'private' put: self privateIcon.	i iconAt: 'hideNavBar' put: self hideNavBarIcon.	i iconAt: 'showNavBar' put: self showNavBarIcon.	i iconAt: 'newProject' put: (i iconAt: 'new').	i iconAt: 'previousProject' put: (i iconAt: 'prev').	i iconAt: 'nextProject' put: (i iconAt: 'next').	i iconAt: 'publishProject' put: (i iconAt: 'save').	i iconAt: 'findAProjectSimple' put: (i iconAt: 'open').	i iconAt: 'keepProject' put: (i iconAt: 'keep').	i iconAt: 'chooseObject' put: (i iconAt: 'choose').	i iconAt: 'doNewPainting' put: (i iconAt: 'paint').	i iconAt: 'chooseLanguage' put: (i iconAt: 'language').	i iconAt: 'undoOrRedoLastCommand' put: (i iconAt: 'undo').	i iconAt: 'toggleSupplies' put: (i iconAt: 'supplies').	i iconAt: 'quitSqueak' put: (i iconAt: 'close').	i iconAt: 'shareThisWorld' put: (i iconAt: 'share').	i iconAt: 'shareMenu' put: (i iconAt: 'private').	i iconAt: 'chooseScreenSetting' put: (i iconAt: 'zoom').	i iconAt: 'stopSqueak' put: (i iconAt: 'stop').	i iconAt: 'toggleHelp' put: (i iconAt: 'help'). 	i iconAt: 'missingIcon' put: (i iconAt: 'private'). 	^  i! !!SugarLibrary class methodsFor: 'icons' stamp: 'bf 9/12/2009 18:47'!chooseIcon	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cTjfv8AAAAT/wsLC/+4uLn/7+/v/4+Pj7r/AAAAB/9oaGkJ/wv/+fn5/xQUFLb/AAAAB/9+f38N/wf/Li4vtv8AAAAH/35/fw3/B/8uLi+2/wAAAAf/fn9/Df8H/y4uL7b/AAAAB/9+f38N/wf/Li4vtv8AAAAH/35/fw3/B/8uLi+2/wAAAAf/fn9/Df8H/y4uL7b/AAAAB/9+f38N/wf/Li4vtv8AAAAH/35/fw3/B/8uLi+2/wAAAAf/fn9/Df8H/y4uL7b/AAAAB/9+f38N/wf/Li4vev8AAAAH/4aHiDr/ury+B//GyMkN/wf/vb3AOv+6vL4H/1dYWT7/AAAAB/+PkJI6/8bIygf/y8zODf8H/8XHyjr/xsjKB/9dXl8+/wAAAAf/j5CSOv/GyMoH/8vMzg3/B//Fx8o6/8bIygf/XV5fPv8AAAAH/4+Qkjr/xsjKB//LzM4N/wf/xcfKOv/GyMoH/11eXz7/AAAAB/+PkJIi/8bIygv/xcfK/8XHyRL/xsjKB//LzM4N/wf/xcfKEv/GyMoL/8bHyf/Fx8ki/8bIygf/XV5fPv8AAAAH/4+Qkh7/xsjKE//X2Nj//////+7u7v/Fx8oO/8bIygf/y8zODf8H/8XHyg7/xsjKE//Ky8z/+/v7///////Jyswe/8bIygf/XV5fPv8AAAAH/4+Qkhr/xsjKC//Hycv/+vr6Cf8L//Dw8P/Fx8kK/8bIygf/y8zODf8H/8XHygr/xsjKC//Hycr//Pz8Cf8H/+Dh4h7/xsjKB/9dXl8+/wAAAAf/j5CSHv/GyMoH/+Hh4g3/E//l5eb/xcfJ/8bIyv/LzM4N/xP/xcfK/8bIyv/Fx8r/9fX1Df8H/87P0B7/xsjKB/9dXl8+/wAAAAf/j5CSHv/GyMoL/8XHyf/w8PAN/w//2tvb/8bIyv/LzM4N/w//xcfK/8XHyf/r7OwN/wv/3t/g/8XHyR7/xsjKB/9dXl8+/wAAAAf/j5CSIv/GyMoL/8XHyv/4+PgN/wv/0NHS/8vMzg3/C//GyMv/4OHiDf8L/+rq6v/GyMki/8bIygf/XV5fPv8AAAAH/4+Qkib/xsjKC//Iycv//v7+Df8H/9bX2A3/B//Z2dsN/wv/8/P0/8XHySb/xsjKB/9dXl8+/wAAAAf/j5CSKv/GyMoH/83Ozw3/B//8/PwZ/wv/+/v7/8fIySr/xsjKB/9dXl8+/wAAAAf/j5CSLv/GyMoH/9bX2CX/B//Kyswu/8bIygf/XV5fPv8AAAAH/4+Qki7/xsjKC//Hycv/4eLiHf8H/9DR0jL/xsjKB/9dXl8+/wAAAAf/j5CSMv/GyMoL/8XHyf/s7O0V/wf/2tvcNv/GyMoH/11eXz7/AAAAB/+PkJI2/8bIygv/xsfJ//j4+Q3/C//o6On/x8nKNv/GyMoH/11eXz7/AAAAB/+PkJI6/8bIygf/yMjKCf8L//r6+v/GyMk6/8bIygf/XV5fPv8AAAAH/4+Qkj7/xsjKD//Fx8j/0NHS/8fJyz7/xsjKB/9dXl8+/wAAAAf/j5CShv/GyMoH/11eXz7/AAAAB/+PkJKG/8bIygf/XV5fPv8AAAAH/4+Qkob/xsjKB/9dXl8+/wAAAAf/j5CShv/GyMoH/11eXz7/AAAAB/+PkJKG/8bIygf/XV5fPv8AAAAH/4+Qkob/xsjKB/9dXl8+/wAAAAf/j5CShv/GyMoH/11eXz7/AAAAB/8kJCSG/zIyMwf/FxgY5l7/AAAA' readStream) contents! !!SugarLibrary class methodsFor: 'icons' stamp: 'bf 9/11/2009 16:38'!closeIcon	^Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cTh2v8AAAA3/xoaGv9cXFz/kJCQ/7e3t//Y2Nj/4+Pj/+7u7v/l5eX/2tra/7u7u/+VlZX/YmJi/yIiIor/AAAAD/8UFBT/cXFx/87OzjX/D//W1tb/e3t7/xwcHHb/AAAAD/8ZGRn/j4+P//T09EX/D//5+fn/nJyc/yIiImb/AAAAD/8DAwP/bm5u//Dw8FX/D//29vb/fn5+/wcHB1r/AAAAC/8YGBj/vr6+Zf8L/8/Pz/8lJSVS/wAAAAv/MzMz/+jo6G3/C//x8fH/Q0NDSv8AAAAL/z4+Pv/x8fF1/wv/+fn5/1RUVEL/AAAAC/8yMjL/8PDwff8L//n5+f9CQkI6/wAAAAv/GRkZ/+jo6IX/C//x8fH/KCgoMv8AAAAL/wMDA/+/v7+N/wv/09PT/woKCi7/AAAAB/9ubm6V/wf/iIiIKv8AAAAL/xgYGP/x8fEh/xf/3d3d/2RkZP8/Pz//cnJy/+3t7S3/F//k5OT/aWlp/z8/P/9tbW3/5+fnIf8L//r6+v8oKCgm/wAAAAf/jo6OIf8L/9zc3P8NDQ0O/wAAAAv/HBwc/9nZ2SX/C//Ly8v/ERERDv8AAAAL/xgYGP/r6+sh/wf/qampIv8AAAAL/xQUFP/09PQh/wf/Y2NjFv8AAAAL/xsbG//Z2dkd/wv/y8vL/xAQEBb/AAAAB/9+fn4h/wv//f39/ycnJx7/AAAAB/9vb28l/wf/QUFBGv8AAAAL/xsbG//Z2dkV/wv/zMzM/xAQEBr/AAAAB/9aWlol/wf/ioqKHv8AAAAH/83NzSX/B/9ycnIe/wAAAAv/Gxsb/9nZ2Q3/C//MzMz/EBAQHv8AAAAH/4uLiyX/C//l5eX/AwMDFv8AAAAH/xoaGin/C//t7e3/HBwcHv8AAAAX/xsbG//Z2dn//////8zMzP8QEBAe/wAAAAv/KSkp//b29in/B/80NDQW/wAAAAf/W1tbLf8L/9nZ2f8aGhoe/wAAAA//Gxsb/6ioqP8QEBAe/wAAAAv/JiYm/+Xl5S3/B/92dnYW/wAAAAf/kJCQMf8L/9nZ2f8aGho+/wAAAAv/JiYm/+Xl5TH/B/+rq6sW/wAAAAf/tbW1Nf8L/9nZ2f8aGho2/wAAAAv/JiYm/+Xl5TX/B//S0tIW/wAAAAf/1tbWOf8L/9nZ2f8aGhou/wAAAAv/Jycn/+Xl5Tn/B//x8fEW/wAAAAf/4uLiPf8L/9nZ2f8aGhom/wAAAAv/Jycn/+Xl5UH/Fv8AAAAH//Dw8EH/B/+np6cm/wAAAAf/v7+/Rf8H/w8PDxL/AAAAB//j4+M9/wv/y8vL/xAQECb/AAAAC/8bGxv/2dnZQf8H/wICAhL/AAAAB//X19c5/wv/y8vL/xAQEC7/AAAAC/8bGxv/2dnZOf8H//Pz8xb/AAAAB/+6uro1/wv/y8vL/xAQEDb/AAAAC/8bGxv/2dnZNf8H/9XV1Rb/AAAAB/+Tk5Mx/wv/y8vL/xAQED7/AAAAC/8aGhr/2dnZMf8H/6+vrxb/AAAAB/9gYGAt/wv/y8vL/xAQEB7/AAAAD/8mJib/v7+//xoaGh7/AAAAC/8aGhr/2dnZLf8H/3x8fBb/AAAAB/8gICAp/wv/4+Pj/xISEh7/AAAAF/8mJib/5eXl///////Z2dn/GhoaHv8AAAAL/x4eHv/w8PAp/wf/Ojo6Gv8AAAAH/9bW1iX/B/9oaGge/wAAAAv/JiYm/+Xl5Q3/C//Z2dn/GhoaHv8AAAAH/4ODgyX/C//r6+v/BQUFGv8AAAAH/3l5eSX/B/9BQUEa/wAAAAv/JiYm/+Xl5RX/C//Y2Nj/GhoaGv8AAAAH/1paWiX/B/+Tk5Me/wAAAAv/Ghoa//n5+SH/B/9sbGwW/wAAAAv/JiYm/+Xl5R3/C//Y2Nj/GhoaFv8AAAAH/4aGhiH/C//+/v7/MTExIv8AAAAH/5qamiH/C//n5+f/GBgYDv8AAAAL/yoqKv/l5eUl/wv/2NjY/x0dHQ7/AAAAC/8lJSX/8/PzIf8H/7S0tCb/AAAAC/8gICD/9vb2If8X/+vr6/9+fn7/Wlpa/4mJif/29vYt/xf/8PDw/4KCgv9aWlr/hoaG//Ly8iH/C//9/f3/NDQ0Kv8AAAAH/3t7e5X/B/+WlpYu/wAAAAv/BgYG/8zMzI3/C//e3t7/EBAQMv8AAAAL/yIiIv/w8PCF/wv/+fn5/zQ0NDr/AAAAC/9CQkL/+fn5ff8L//7+/v9bW1tC/wAAAAv/UlJS//n5+XX/C//9/f3/ZmZmSv8AAAAL/0NDQ//y8vJt/wv/+Pj4/1dXV1L/AAAAC/8oKCj/0tLSZf8L/97e3v80NDRa/wAAAA//CAgI/4eHh//5+flV/w///f39/5eXl/8QEBBm/wAAAA//KCgo/6enp//9/f1F/w///v7+/7S0tP8yMjJ2/wAAAA//JiYm/4iIiP/l5eU1/w//6+vr/5OTk/8wMDCG/wAAABv/AgIC/zMzM/91dXX/qqqq/9DQ0P/v7+8N/xv/8vLy/9XV1f+urq7/fHx8/zs7O/8EBASq/wAAAAf/DQ0N4fb/AAAA' readStream) contents! !!SugarLibrary class methodsFor: 'icons' stamp: 'mz 7/11/2009 00:29'!hideNavBarIcon	"Answer a form with the hideNavBar picture"	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cThmQC5/xEAuf8RALn/EQC5/xEAuf8RALn/EQC5/xEAuf8RAGn/MQAh/xEAaf8xACH/EQBp/zEAIf8RAIH/GQAh/xEAff8dACH/EQB5/yEAIf8RAHX/FQAF/w0AIf8RAHH/FQAJ/w0AIf8RAG3/FQAN/w0AIf8RAGn/FQAR/w0AIf8RAGX/FQAV/w0AIf8RAGX/EQAZ/w0AIf8RAGX/DQBJ/xEAuf8RALn/EQC5/xEAuf8RACH/DQAd/w0AZf8RACH/DQAZ/xEAZf8RACH/DQAV/xUAZf8RACH/DQAR/xUAaf8RACH/DQAN/xUAbf8RACH/DQAJ/xUAcf8RACH/DQAF/xUAdf8RACH/IQB5/xEAIf8dAH3/EQAh/xkAgf8RACH/NQBl/xEAIf81AGX/EQAh/zUAZf8RALn/EQC5/xEAuf8RALn/EQC5/xEAuf8RALn/EQC5/+GZAA=='readStream) contents.! !!SugarLibrary class methodsFor: 'icons' stamp: 'bf 9/12/2009 18:50'!keepIcon	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cTiSv8AAAAH/wEBAaL/AAAAB/8gICAe/wAAABP/Nzc3/4+Pj/91dXX/DAwMUv8AAAAX/xgYGP9DQ0P/TU1N/0VFRf8mJiYu/wAAABf/Dg4O/3l5ef/Gxsb/eXl5/w4ODhL/AAAAC/8xMTH/1dXVCf8H/01NTUr/AAAAI/8VFRX/S0tL/3Z2dv+UlJT/m5ub/5WVlf+AgID/OTk5Kv8AAAAX/yoqKv/n5+f//////+jo6P8rKysO/wAAAAv/MzMz/9nZ2Qn/C//9/f3/Q0NDQv8AAAAv/xMTE/9MTEz/eHh4/4+Pj/+Tk5P/jIyM/4qKiv+MjIz/k5OT/4KCgv8VFRUm/wAAABf/MzMz//Dw8P//////6enp/zAwMAr/AAAAC/8zMzP/2traCf8P//r6+v9xcXH/BgYGOv8AAAA3/wgICP9CQkL/fHx8/46Ojv+RkZH/i4uL/4mJif+YmJj/tra2/5ycnP+Kior/jY2N/z09PSb/AAAAI/9DQ0P//f39///////AwMD/GRkZ/wAAAP8yMjL/2traCf8P//r6+v9tbW3/AQEBNv8AAAAX/woKCv84ODj/eHh4/46Ojv+Pj48K/4qKiiP/l5eX/7+/v//w8PD//Pz8/7CwsP+EhIT/i4uL/0JCQib/AAAAB/9FRUUJ/xP/uLi4/xEREf8uLi7/2dnZCf8L//r6+v9vb282/wAAACv/DQ0N/zIyMv9zc3P/kJCQ/46Ojv+Kior/h4eH/5aWlv+7u7v/7e3tDf8T/7Gxsf+EhIT/i4uL/0FBQSb/AAAAB/9WVlYJ/w//q6ur/0ZGRv/R0dEJ/wv/+fn5/3R0dDL/AAAAK/8NDQ3/NTU1/29vb/+SkpL/jo6O/4qKiv+Ghob/lZWV/7Ozs//k5OQV/xP/sbGx/4SEhP+Li4v/QEBAJv8AAAAH/3R0dAn/C/+2trb/1tbWCf8L//n5+f90dHQu/wAAACv/CAgI/y8vL/9nZ2f/lJSU/5CQkP+Li4v/ioqK/5KSkv+zs7P/3t7eHf8f/7Gxsf+EhIT/i4uL/0NDQ/8DAwP/BAQE/wMDAxb/AAAAC/8CAgL/fHx8Ff8L/+/v7/9mZmYu/wAAACv/HBwc/2BgYP+Ojo7/lJSU/4uLi/+Hh4f/i4uL/4WFhf+urq7//f39If8n/7Gxsf+EhIT/jIyM/3Fxcf9aWlr/W1tb/1xcXP9FRUX/EhISDv8AAAAL/woKCv+cnJwR/yP//v7+/6Ghof8yMjL/Wlpa/1ZWVv9xcXH/Y2Nj/woKChr/AAAAK/9JSUn/nZ2d/4+Pj/+IiIj/i4uL/7y8vP/Hx8f/fn5+/7a2tv/9/f0h/xP/sbGx/4ODg/+MjIz/kZGRCv+WlpYT/5eXl/+Tk5P/cHBw/xsbGwr/AAAAC/8ODg7/qKioFf8T/9PT0//c3Nz/+fn5//b29gn/B/9iYmIa/wAAACv/S0tL/5qamv+Kior/p6en/9zc3P/8/Pz/5+fn/3t7e/+0tLT//Pz8If8T/7Gxsf+Dg4P/jIyM/4qKig7/iYmJH/+NjY3/lZWV/2pqav8KCgr/AAAA/w0NDf+np6ct/wf/hISEGv8AAAAT/0pKSv+ZmZn/ioqK/76+vgn/E//g4OD/fHx8/7S0tP/8/Pwh/xP/sbGx/4ODg/+NjY3/srKyCv/W1tYj/7y8vP+Pj4//i4uL/5CQkP8nJyf/AAAA/woKCv+bm5sJ/wr//v7+I//9/f3/+/v7//n5+f/a2tr/yMjI/8DAwP+JiYn/IiIiGv8AAAAr/0lJSf+ZmZn/ioqK/7+/v//9/f3//////+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/Ly8sJ/xf/+Pj4/7CwsP+EhIT/kJCQ/0ZGRgr/AQEBB/8iIiIK/3x8fCf/VlZW/05OTv84ODj/HBwc/xoaGv8UFBT/ERER/w8PD/8FBQUe/wAAABP/SkpK/5mZmf+Kior/v7+/Cf8T/+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/T09P/wICAkr/AAAAM/8GBgb/IiIi/2tra/+Tk5P/ioqK/6mpqf/k5OT/+vr6/+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAkr/AAAAM/8xMTH/n5+f/5aWlv+Kior/jIyM/4SEhP+Hh4f/39/f/+Li4v98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAkr/AAAAM/8lJSX/W1tb/3Nzc/+QkJD/jIyM/5ubm/+0tLT/6+vr/+Hh4f98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAK/9KSkr/mZmZ/4qKiv+8vLz/+/v7///////g4OD/fHx8/7S0tP/8/Pwh/xP/sbGx/4ODg/+NjY3/ysrKDf8X/8LCwv+BgYH/jo6O/05OTv8CAgJS/wAAABP/SUlJ/5mZmf+Kior/v7+/Cf8T/+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAK/9KSkr/mZmZ/4qKiv++vr7//f39///////g4OD/fHx8/7S0tP/8/Pwh/xP/sbGx/4ODg/+NjY3/ysrKDf8X/8LCwv+BgYH/jo6O/05OTv8CAgJS/wAAACv/SkpK/5mZmf+Kior/vr6+//39/f//////4ODg/3x8fP+0tLT//Pz8If8T/7Gxsf+Dg4P/jY2N/8rKyg3/F//CwsL/gYGB/46Ojv9OTk7/AgICUv8AAAAr/0pKSv+ZmZn/ioqK/76+vv/9/f3//////+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAE/9FRUX/mpqa/4qKiv/BwcEJ/xP/4ODg/3x8fP+0tLT//Pz8If8T/7Gxsf+Dg4P/jY2N/8rKyg3/F//CwsL/gYGB/46Ojv9OTk7/AgICSv8AAAAz/wICAv8aGhr/Xl5e/5aWlv+Kior/sLCw/+zs7P//////4ODg/3x8fP+0tLT//Pz8If8T/7Gxsf+Dg4P/jY2N/8rKyg3/F//CwsL/gYGB/46Ojv9OTk7/AgICSv8AAAAP/ycnJ/+Dg4P/kZGRCv+MjIwf/4iIiP+goKD/6+vr/+Li4v98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAkr/AAAAM/8uLi7/f39//4ODg/+Ojo7/jIyM/5SUlP+ZmZn/4ODg/+Li4v98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAkr/AAAAM/8FBQX/FxcX/1dXV/+Xl5f/ioqK/7e3t//n5+f//v7+/+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAE/9HR0f/mpqa/4qKiv/AwMAJ/xP/4ODg/3x8fP+0tLT//Pz8If8T/7Gxsf+Dg4P/jY2N/8rKyg3/F//CwsL/gYGB/46Ojv9OTk7/AgICUv8AAAAr/0pKSv+ZmZn/ioqK/76+vv/9/f3//////+Dg4P98fHz/tLS0//z8/CH/E/+xsbH/g4OD/42Njf/KysoN/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAK/9KSkr/mZmZ/4qKiv++vr7//f39///////g4OD/fHx8/7S0tP/8/Pwh/xP/sbGx/4ODg/+NjY3/ysrKDf8X/8LCwv+BgYH/jo6O/05OTv8CAgJS/wAAACv/SkpK/5mZmf+Kior/vr6+//39/f//////4ODg/3x8fP+0tLT//Pz8If8T/7Kysv+Dg4P/jY2N/8rKyg3/F//CwsL/gYGB/46Ojv9OTk7/AgICUv8AAAAr/0hISP+ZmZn/ioqK/7+/v//+/v7//////+Dg4P98fHz/tLS0//z8/B3/F//7+/v/p6en/4SEhP+MjIz/yMjIDf8X/8LCwv+BgYH/jo6O/05OTv8CAgJS/wAAABP/TU1N/5mZmf+Kior/vb29Cf8T/+Dg4P98fHz/tLS0//z8/Bn/G//n5+f/uLi4/46Ojv+Kior/jIyM/9zc3A3/F//CwsL/gYGB/46Ojv9OTk7/AgICSv8AAAAz/xUVFf9GRkb/eHh4/5GRkf+Li4v/nZ2d/8PDw//09PT/4eHh/3x8fP+0tLT//Pz8Df8n//f39//Z2dn/vb29/5qamv+FhYX/i4uL/4aGhv+urq7//f39Df8X/8LCwv+BgYH/jo6O/05OTv8CAgJK/wAAAC//PDw8/6enp/+VlZX/ioqK/4yMjP+Dg4P/goKC/9vb2//i4uL/fHx8/7W1tQn/K//j4+P/wsLC/6ioqP+RkZH/hISE/4iIiP+Li4v/g4OD/6mpqf/v7+8R/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAkr/AAAAW/8XFxf/NjY2/2VlZf+Tk5P/i4uL/6urq//Nzc3/9fX1/+Li4v9+fn7/q6ur/8/Pz/+vr6//l5eX/4iIiP+EhIT/iYmJ/4qKiv+Ghob/mJiY/8jIyP/09PQV/xf/wsLC/4GBgf+Ojo7/Tk5O/wICAlL/AAAAE/9JSUn/mZmZ/4qKiv/BwcEJ/xP/0dHR/4SEhP+Pj4//kJCQCv+Hh4cb/4mJif+Li4v/j4+P/6mpqf/U1NT/8fHxHf8X/8LCwv+BgYH/jo6O/05OTv8CAgJS/wAAAEP/SUlJ/5mZmf+Li4v/tra2/83Nzf+np6f/kZGR/4yMjP+Li4v/ioqK/4yMjP+Pj4//mpqa/8LCwv/o6Oj/+fn5Jf8X/7a2tv+EhIT/j4+P/0dHR/8BAQFS/wAAABf/SkpK/5mZmf+MjIz/jY2N/4yMjAr/ioqKDv+MjIwT/4+Pj/+rq6v/0dHR/9fX1wr/2dnZB//X19ca/9bW1hv/2tra/8fHx/+Xl5f/iYmJ/5KSkv8uLi5W/wAAAAv/S0tL/5qamgr/jIyMB/+Li4sa/4yMjAr/i4uLMv+KiooT/4yMjP+UlJT/fHx8/w4ODlb/AAAAC/9KSkr/n5+fVv+WlpYX/5WVlf+Xl5f/lpaW/39/f/8qKipa/wAAAA//Hh4e/1hYWP9gYGBW/15eXg//X19f/09PT/8gICBm/wAAAAf/BQUFUv8EBAQL/wUFBf8EBATirv8AAAA=' readStream) contents! !!SugarLibrary class methodsFor: 'icons' stamp: 'bf 9/12/2009 18:52'!openIcon	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cThZv8AAAAv/xISEv8zMzP/SUlJ/19fX/91dXX/ioqK/6CgoP+2trb/zMzM/66urv8aGhqa/wAAAAv/UFBQ//X19SX/B/94eHia/wAAAAf/jo6OKf8H/35+fpr/AAAAG/8SEhL/oKCg/6Ghof+MjIz/d3d3/7m5uRX/B/9oaGiq/wAAAAf/fHx8Gf8H/1JSUqL/AAAAC/8BAQH/ampqCf8P//7+/v//////8fHxCf8H/zw8PKL/AAAAK/9aWlr//v7+///////+/v7//////+Tk5P+6urr///////7+/v8nJyee/wAAAAv/SkpK//39/Q3/D//r6+v/DAwM/83NzQn/B/8RERGa/wAAAAv/Ojo6//z8/A3/G//x8fH/FBQU/wAAAP/i4uL///////r6+pr/AAAAC/8fHx//+vr6Df8L//b29v8dHR0K/wAAAA//9/f3///////m5uaa/wAAAAv/oqKi//7+/gn/C//5+fn/KCgoDv8AAAAP/8PDw///////qampgv8AAAAH/wEBARb/AAAAB/+Ojo4J/wv/+/v7/zc3NxL/AAAAD/8RERH/TExM/wQEBDr/AAAAB/8BAQEy/wAAAAf/AQEBLv8AAAAP/5iYmP++vr7/MTEx0v8AAAAH/wEBATr/AAAAD/8gICD/bm5u/5SUlBr/qKioE/+kpKT/hISE/1NTU/8JCQmS/wAAAAv/QEBA/6qqqg7/ra2tB/+srKwW/62trRP/rKys/66urv+QkJD/EBAQNv8AAAAH/wEBAVL/AAAAE/8YGBj/qamp/62trf+urq4K/62trQf/rq6uIv+tra0H/3l5eTL/AAAAB/8BAQEO/wAAAAf/AQEBRv8AAAAH/25ubg7/ra2tC/+/v7//0tLSFv/T09Mb/83Nzf+zs7P/rq6u/62trf+urq7/GxsbKv8AAAAH/wEBAVL/AAAAD/8BAQH/AAAA/5mZmQr/ra2tB/+/v78h/wf/7OzsDv+tra0P/6qqqv+oqKj/qampFv+oqKgO/6mpqRf/qKio/6Ojo/+CgoL/SEhI/wEBAUb/AAAAB/8HBwcO/62trQf/2NjYIf8H//7+/kr/ra2tC/+CgoL/CQkJQv8AAAAH/wsLCw7/ra2tB//c3Nwl/w//y8vL/62trf+srKxC/62trQf/c3NzQv8AAAAH/wsLCw7/ra2tB//b29sl/wv/+vr6/9vb2w7/09PTC//S0tL/1NTUIv/T09Mb/8zMzP+vr6//ra2t/66urv+tra3/IyMjIv8AAAAH/wEBARr/AAAAB/8LCwsO/62trQf/29vbMf8H//7+/in/D//+/v7//////+rq6g7/ra2tB/9TU1M+/wAAAAf/CwsLDv+tra0H/9zc3Gn/B/+0tLQK/62trQf/ZmZmEv8AAAAH/wEBASr/AAAAB/8KCgoO/62trQf/29vbUf8H//7+/hX/B/+1tbUK/62trQf/ZmZmPv8AAAAH/wsLCw7/ra2tB//b29sN/xf/+Pj4/9bW1v/FxcX/v7+//76+vgr/v7+/D/++vr7/v7+//8DAwBb/v7+/B/++vr4e/7+/vwf/sLCwCv+tra0b/5mZmf+IiIj/h4eH/3R0dP9JSUn/BQUFKv8AAAAH/wsLCw7/ra2tB//b29sJ/wv/5eXl/7Kysgr/ra2tB/+urq4K/62trQf/rKysLv+tra0H/66urg7/ra2tB/+urq4i/62trQv/kpKS/xISEib/AAAAB/8LCwsO/62trRP/29vb///////y8vL/sLCwev+tra0X/6ysrP+tra3/e3t7/wAAAP8BAQEe/wAAAAf/CwsLDv+tra0f/9ra2v/+/v7/vr6+/62trf+urq7/ra2t/7e3t1b/xMTEB//Dw8MO/8TExAv/w8PD/7Ozsw7/ra2tB/8SEhIi/wAAAAf/CwsLDv+tra0L/9vb2//c3NwO/62trQv/wsLC//7+/mn/B//j4+MO/62trQf/ISEhHv8AAAAP/wEBAf8LCwv/rKysCv+tra0L/9vb2/+9vb0K/62trQv/sbGx//X19W3/B//U1NQO/62trQf/GhoaIv8AAAAH/wsLCw7/ra2tB//X19cK/62trQv/rKys/9HR0W3/C//8/Pz/s7OzCv+tra0L/5SUlP8BAQEi/wAAAAf/CwsLDv+tra0H/8nJyQ7/ra2tB//q6upt/wf/3d3dDv+tra0H/0dHRyb/AAAAB/8LCwsO/62trQf/u7u7Cv+tra0L/7Gxsf/9/f1Z/wf//v7+Df8L//7+/v+5ubkK/62trQv/oKCg/wcHByb/AAAAB/8LCwsO/62trQf/r6+vCv+tra0H/8nJyRn/B//+/v5R/wf/5ubmDv+tra0H/1paWir/AAAAB/8LCwsa/62trQf/4eHhbf8H/8DAwAr/ra2tE/+oqKj/EBAQ/wAAAP8BAQEi/wAAAAf/CwsLFv+tra0L/66urv/6+vpp/wf/7u7uDv+tra0H/2pqai7/AAAAB/8LCwsS/62trQv/rq6u/8DAwA3/B//+/v5d/xf/ycnJ/66urv+tra3/rq6u/x4eHi7/AAAAB/8LCwsW/62trQf/2NjYaf8L//X19f+urq4K/62trQf/fX19Mv8AAAAH/wsLCwr/ra2tB/+srKwK/62trQf/8fHxaf8H/9HR0Q7/ra2tB/8vLy8y/wAAAAf/CwsLEv+tra0H/7e3t2n/C//6+vr/sbGxCv+tra0H/46Ojjb/AAAAC/8LCwv/rq6uDv+tra0H/8/Pz2n/B//a2toK/62trQv/rq6u/0BAQBr/AAAAB/8BAQEa/wAAAAf/CwsLEv+tra0H/+jo6Gn/B/+2trYK/62trQv/nJyc/wQEBDb/AAAAB/8LCwsS/62trQf/x8fHZv/JyckH/8TExA7/ra2tB/9TU1M6/wAAAAf/CwsLev+tra0H/66urgr/ra2tC/+mpqb/DAwMOv8AAAAL/wEBAf+qqqp2/62trQf/rKysCv+tra0H/2RkZD7/AAAAE/8BAQH/S0tL/6CgoP+fn59y/5OTkw//kZGR/11dXf8LCwvhuv8AAAA=' readStream) contents! !!SugarLibrary class methodsFor: 'icons' stamp: 'bf 9/12/2009 18:53'!saveIcon	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cQS/wAAAAf/AQEBuv8AAAAT/wcHB/90dHT/oqKi/zIyMh7/AAAAB/8BAQGa/wAAAAf/UVFRCf8L//f39/88PDwS/wAAAA//HBwc/3BwcP8fHx+a/wAAAAf/X19fDf8L//Dw8P8xMTEO/wAAAA//0NDQ//////+5ubma/wAAAA//BAQE/7e3t//+/v4J/wv/6urq/ycnJwr/AAAAD//k5OT///////Hx8Z7/AAAAC/8KCgr/w8PDDf8T/+Li4v8eHh7/AAAA/8/Pzwn/B/8HBwee/wAAACP/Dw8P/87Ozv///////v7+///////Z2dn/FhYW/7m5uQn/B/8cHBya/wAAABP/AQEB/wAAAP8VFRX/2NjYDf8X/87Ozv+pqan//v7+//////8yMjKm/wAAAAv/HBwc/+Hh4Q3/B//k5OQJ/wv/SEhI/wEBAab/AAAAC/8lJSX/6OjoFf8H/15eXpr/AAAAH/8mJib/ubm5/9LS0v+9vb3/qKio/6ampv/29vYR/wf/c3Nzmv8AAAAH/4SEhCn/B/+JiYkS/wAAAAf/AQEBhv8AAAAL/ysrK//p6ekl/wf/eHh4Rv8AAAAH/wEBAVr/AAAAK/8KCgr/ICAg/zY2Nv9MTEz/YmJi/3d3d/+NjY3/o6Oj/4WFhf8TExMK/wAAAAf/AQEBJv8AAAAH/wEBAeFG/wAAAA//ICAg/25ubv+UlJQW/6ioqBf/qamp/6Wlpf+EhIT/U1NT/wkJCZL/AAAAC/9AQED/qampCv+tra0H/66uriL/ra2tC/+QkJD/EBAQNv8AAAAH/wEBAVL/AAAAC/8YGBj/qampNv+tra0H/3l5eTL/AAAAB/8BAQFW/wAAAAf/bm5uDv+tra0T/76+vv/S0tL/09PT/9TU1A7/09PTC//Nzc3/s7OzCv+tra0L/66urv8bGxsq/wAAAAf/AQEBWv8AAAAH/5mZmQr/ra2tB/+/v78h/wf/7OzsDv+tra0P/6qqqv+oqKj/qampFv+oqKgO/6mpqRf/qKio/6Ojo/+CgoL/SUlJ/wEBAQ7/AAAAB/8BAQE2/wAAAAf/BwcHDv+tra0H/9jY2CH/B//+/v5K/62trQv/goKC/wkJCUL/AAAAB/8LCwsO/62trQf/3NzcJf8P/8vLy/+tra3/rKysQv+tra0H/3Nzc0L/AAAAB/8LCwsO/62trQf/29vbJf8L//r6+v/b29sO/9PT0wv/0tLS/9TU1CL/09PTG//MzMz/r6+v/62trf+urq7/ra2t/yMjIyL/AAAAB/8BAQEa/wAAAAf/CwsLDv+tra0H/9vb2zH/B//+/v4p/w///v7+///////q6uoO/62trQf/U1NTPv8AAAAH/wsLCw7/ra2tB//c3Nxp/wf/tLS0Cv+tra0H/2ZmZhL/AAAAB/8BAQEq/wAAAAf/CgoKDv+tra0H/9vb21H/B//+/v4V/wf/tbW1Cv+tra0H/2ZmZj7/AAAAB/8LCwsO/62trQf/29vbDf8X//j4+P/W1tb/xcXF/7+/v/++vr4K/7+/vw//vr6+/7+/v//AwMAW/7+/vwf/vr6+Hv+/v78H/7CwsAr/ra2tG/+ZmZn/iIiI/4eHh/90dHT/SUlJ/wUFBSr/AAAAB/8LCwsO/62trQf/29vbCf8L/+Xl5f+ysrIK/62trQf/rq6uCv+tra0H/6ysrC7/ra2tB/+urq4O/62trQf/rq6uIv+tra0L/5KSkv8SEhIm/wAAAAf/CwsLDv+tra0T/9vb2///////8vLy/7CwsHr/ra2tF/+srKz/ra2t/3t7e/8AAAD/AQEBHv8AAAAH/wsLCw7/ra2tH//a2tr//v7+/76+vv+tra3/rq6u/62trf+3t7dW/8TExAf/w8PDDv/ExMQL/8PDw/+zs7MO/62trQf/EhISIv8AAAAH/wsLCw7/ra2tC//b29v/3NzcDv+tra0L/8LCwv/+/v5p/wf/4+PjDv+tra0H/yEhIR7/AAAAD/8BAQH/CwsL/6ysrAr/ra2tC//b29v/vb29Cv+tra0L/7Gxsf/19fVt/wf/1NTUDv+tra0H/xoaGiL/AAAAB/8LCwsO/62trQf/19fXCv+tra0L/6ysrP/R0dFt/wv//Pz8/7Ozswr/ra2tC/+UlJT/AQEBIv8AAAAH/wsLCw7/ra2tB//JyckO/62trQf/6urqbf8H/93d3Q7/ra2tB/9HR0cm/wAAAAf/CwsLDv+tra0H/7u7uwr/ra2tC/+xsbH//f39Wf8H//7+/g3/C//+/v7/ubm5Cv+tra0L/6CgoP8HBwcm/wAAAAf/CwsLDv+tra0H/6+vrwr/ra2tB//JyckZ/wf//v7+Uf8H/+bm5g7/ra2tB/9aWloq/wAAAAf/CwsLGv+tra0H/+Hh4W3/B//AwMAK/62trRP/qKio/xAQEP8AAAD/AQEBIv8AAAAH/wsLCxb/ra2tC/+urq7/+vr6af8H/+7u7g7/ra2tB/9qamou/wAAAAf/CwsLEv+tra0L/66urv/AwMAN/wf//v7+Xf8X/8nJyf+urq7/ra2t/66urv8eHh4u/wAAAAf/CwsLFv+tra0H/9jY2Gn/C//19fX/rq6uCv+tra0H/319fTL/AAAAB/8LCwsK/62trQf/rKysCv+tra0H//Hx8Wn/B//R0dEO/62trQf/Ly8vMv8AAAAH/wsLCxL/ra2tB/+3t7dp/wv/+vr6/7GxsQr/ra2tB/+Ojo42/wAAAAv/CwsL/66urg7/ra2tB//Pz89p/wf/2traCv+tra0L/66urv9AQEAa/wAAAAf/AQEBGv8AAAAH/wsLCxL/ra2tB//o6Ohp/wf/tra2Cv+tra0L/5ycnP8EBAQ2/wAAAAf/CwsLEv+tra0H/8fHx2b/ycnJB//ExMQO/62trQf/U1NTOv8AAAAH/wsLC3r/ra2tB/+urq4K/62trQv/pqam/wwMDDr/AAAAC/8BAQH/qqqqdv+tra0H/6ysrAr/ra2tB/9kZGQ+/wAAABP/AQEB/0tLS/+goKD/n5+fcv+Tk5MP/5GRkf9dXV3/CwsL4br/AAAA' readStream) contents! !!SugarLibrary class methodsFor: 'icons' stamp: 'mz 7/6/2009 01:13'!showNavBarIcon	"Answer a form with the showNavBar picture"	^ Form extent: 50@50 depth: 32 bits: (Base64MimeConverter mimeDecodeToBytes: '6cThmQC1/xUAtf8VALX/FQC1/xUAtf8VALX/FQC1/xUAtf8VAI3/DQAd/xUAYf8NAB3/EQAd/xUAYf8NABn/FQAd/xUAYf8NABX/FQAh/xUAYf8NABH/FQAl/xUAYf8NAA3/FQAp/xUAYf8NAAn/FQAt/xUAYf8NAAX/FQAx/xUAYf8hADX/FQBh/x0AOf8VAGH/GQA9/xUAYf81ACH/FQBh/zUAIf8VAGH/NQAh/xUAtf8VALX/FQC1/xUAIf81AGH/FQAh/zUAYf8VACH/NQBh/xUAPf8ZAGH/FQA5/x0AYf8VADX/IQBh/xUAMf8VAAX/DQBh/xUALf8VAAn/DQBh/xUAKf8VAA3/DQBh/xUAJf8VABH/DQBh/xUAIf8VABX/DQBh/xUAIf8RABn/DQBh/xUAIf8FAAsE////AAAAAB3/DQBh/xUAtf8VALX/FQC1/xUAtf8VALX/FQC1/xUAtf8VALX/4Z0A'readStream) contents! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 8/25/2010 01:36'!checkSugarButtons	| wasSugar |	(owner hasProperty: #collapsedMode) ifTrue: [^self].	wasSugar := paintButton owner submorphs anySatisfy:		[:e | e isButton and: [e actionSelector = #chooseObject]].	isSugar := SugarLauncher current isRunningInSugar.	wasSugar = isSugar ifFalse: [self rebuildButtons].! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'sw 7/7/2009 08:55'!configureForSqueakland	"Formerly -- have a narrow, green bar.  Now:  just use the standard."	"self naviHeight: 40.	self color: Color green muchDarker highLightColor: Color green darker."! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 9/12/2009 20:43'!initialize	super initialize.	self layoutInset: 0@0;	  hResizing: #rigid;	  vResizing: #rigid;	  cellPositioning: #topLeft.	self cornerStyle: #square.	self resistsRemoval: true.	self beSticky.	self makeGray.! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 8/25/2010 01:30'!makeTheButtons	^ {		self buttonHelp.		self makeProjectNameLabel.	},	(		Preferences showAdvancedNavigatorButtons			ifTrue: [{self buttonNewProject}]			ifFalse: [#()]	),	{		self buttonPrev.		self buttonNext.		self buttonPaint.		self buttonSupplies.		self buttonLanguage.	}, 	(SugarLauncher isRunningInSugar		ifTrue: [{			self buttonShare.			#spacer.			self buttonChoose.			self buttonKeep.			stopButton := SugarLauncher current willSaveOnQuit				ifTrue: [self buttonStop]				ifFalse: [self buttonQuit]	}]		ifFalse: [{			self buttonZoom.			#spacer.			self buttonFind.			self buttonPublish.			self buttonQuit}]	),	(Preferences navControlInNavBar		ifTrue: [{self buttonHideNavBar}]		ifFalse: [#()])! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 9/15/2009 14:44'!putUpInitialBalloonHelp"	SugarNavigatorBar putUpInitialBalloonHelp"	| suppliesButton b1 b2 p b |	suppliesButton _ paintButton owner submorphs detect: [:e | e isButton and: [e actionSelector = #toggleSupplies]].	b1 _ BalloonMorph string: self paintButtonInitialExplanation for: paintButton corner: #topRight force: false.	b2 _ BalloonMorph string: self suppliesButtonInitialExplanation for: suppliesButton corner: #topLeft force: true.	p _ PasteUpMorph new.	p clipSubmorphs: false.	p color: Color transparent.	p borderWidth: 0.	p addMorph: b1.	p addMorph: b2.	b _ BalloonMorph string: p for: World corner: #bottomLeft.	b color: Color transparent.	b borderWidth: 0.	[(Delay forSeconds: 1) wait. b popUpForHand: ActiveHand] fork.! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'sw 9/10/2009 20:04'!putUpInitialBalloonHelpFor: quads	"Given a list of quads of the form <selector> <help-msg> <corner> <force-boolean> (see senders for examples), put up initial balloon help for them.""	SugarNavigatorBar someInstance putUpInitialBalloonHelpFor: #((doNewPainting 'make a new painting' topRight false) (toggleSupplies 'open the supplies bin' topLeft true))	SugarNavigatorBar someInstance putUpInitialBalloonHelpFor: #((showNavBar 'show the tool bar' bottomLeft false) (hideNavBar 'hide the tool bar' bottomLeft false))"	|  b1 p b |	p _ PasteUpMorph new.	p clipSubmorphs: false.	p color: Color transparent.	p borderWidth: 0.	quads do: [:aQuad |		(submorphs first submorphs detect: [:e | e isButton and: [e actionSelector = aQuad first]] ifNone: [nil]) ifNotNilDo:			[:aButton |				b1 := BalloonMorph string: aQuad second for: aButton corner: aQuad third force: aQuad fourth.				p addMorph: b1]].	b _ BalloonMorph string: p for: World corner: #bottomLeft.	b color: Color transparent.	b borderWidth: 0.	[(Delay forSeconds: 1) wait. b popUpForHand: ActiveHand] fork.! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 8/20/2010 12:40'!rebuildButtons	(owner isNil or: [owner hasProperty: #collapsedMode])		ifFalse: [			submorphs do: [:e | e delete].			self addButtons]! !!SugarNavigatorBar methodsFor: 'initialization' stamp: 'bf 8/25/2010 01:36'!startUp	self checkSugarButtons! !!SugarNavigatorBar methodsFor: 'morphic interaction' stamp: 'sw 7/16/2009 15:02'!checkForResize	"Check to see if the receiver needs to be reconfigured because of a world resize."	| shouldResize h worldBounds inset |	(owner isKindOf: SugarNavTab) ifFalse: [^ self].  "e.g. being held by hand."	owner edgeToAdhereTo = #topRight ifTrue: [^ owner occupyTopRightCorner]. 	shouldResize _ false.	worldBounds _ self world bounds.	(self layoutInset ~= (inset _ SugarLauncher isRunningInSugar ifTrue: [75@0] ifFalse: [0@0]))		ifTrue: [self layoutInset: inset].	worldBounds width ~= self width ifTrue: [shouldResize _ true].	Preferences useArtificialSweetenerBar ifTrue: [		h _ submorphs first submorphs first height.		(worldBounds extent x >= 1200 and: [worldBounds extent y >= 900]) ifTrue: [			h = 40 ifTrue: [self naviHeight: 75. shouldResize _ true]]		ifFalse: [h = 75 ifTrue: [self naviHeight: 40. shouldResize _ true]]].	(h _ submorphs first submorphs first height) ~= self height ifTrue: [shouldResize _ true].	(owner notNil and: [owner isFlapTab]) ifTrue: [		owner edgeToAdhereTo == #top ifTrue: [			self topLeft ~= worldBounds topLeft ifTrue: [shouldResize _ true].		]. 		owner edgeToAdhereTo == #bottom ifTrue: [			self bottomLeft ~= worldBounds bottomLeft ifTrue: [shouldResize _ true].		]. 		shouldResize ifTrue: [			owner edgeToAdhereTo == #top ifTrue: [				self bounds: (0@0 corner: (worldBounds width@h)).			].			owner edgeToAdhereTo == #bottom ifTrue: [				self bounds: (0@(worldBounds height - h) corner: (worldBounds bottomRight)).			].			self resizeProjectNameField.			owner layoutChanged.		].	].! !!SugarNavigatorBar methodsFor: 'morphic interaction' stamp: 'bf 8/20/2010 10:35'!naviHeightWithFullUpdate: anInteger	submorphs isEmpty ifTrue: [^ super extent: self width@anInteger].	self rebuildButtons.	self resizeButtonsAndTabTo: anInteger.! !!SugarNavigatorBar methodsFor: 'morphic interaction' stamp: 'sw 5/30/2009 02:46'!resizeButtonsAndTabTo: newDim	"Resize the receiver's buttons and containing tab to conform to the given dimension."	| frame |	submorphs ifNotEmpty:		[frame := submorphs first.		frame submorphs do: [:e |			e naviHeight: newDim].		frame height: newDim.		supplies ifNotNil:			[supplies naviHeight: newDim]]! !!SugarNavigatorBar methodsFor: 'morphic interaction' stamp: 'sw 5/30/2009 01:23'!showOnlyShowNavBarButton	"Reconfigure the receiver such that it only shows the show-nav-bar button"	self removeAllMorphs.	self addMorph: (self inARow:  {self buttonShowNavBar}).	self hResizing: #shrinkWrap.	Preferences useArtificialSweetenerBar ifTrue: [self configureForSqueakland].! !!SugarNavigatorBar methodsFor: 'morphic interaction' stamp: 'bf 8/25/2010 01:39'!step	self checkSugarButtons.	self checkForResize.	self undoButtonAppearance.	self stopButtonAppearance.! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 8/4/2009 21:55'!availableDisplayModes	"Answer an array of available screen modes.  The full-screen item is not included now."	| ret actual desired |	ret _ OrderedCollection new: 3.	ret add: #physical.	actual _ DisplayScreen actualScreenSize.	desired _ OLPCVirtualScreen virtualScreenExtent.	actual = desired ifTrue: [^ ret].	ret add: #scaledVirtual.	(actual x > desired x and: [actual y > desired y]) ifTrue:		[ret add: #centeredVirtual].	^ ret asArray! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 8/6/2009 02:49'!buttonChoose	"Answer a button for choosing objects from the Journal"	^ self makeButton: 'FIND' translated balloonText: 'Find an entry in the Journal.  Hold mouse button down for further options.' translated for: #chooseObject! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 7/8/2009 11:21'!buttonHideNavBar	"Build and return a fresh HideNavBarButton"	^ self makeButton: 'hideNavBar' balloonText: 'hide the tool bar' translated for: #hideNavBar! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'bf 9/12/2009 20:19'!buttonKeep	"Answer a button for saving the project in the Journal"	^ self makeButton: 'PUBLISH IT!!' translated balloonText:  'Keep a copy of the current project in the Journal. Hold mouse button down for further options.' translated for: #keepProject! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'bf 9/15/2009 14:44'!buttonPaint	"Build and return a fresh Undo button for me."	^paintButton := self makeButton: 'paint' balloonText: 'Make a painting' translated for: #doNewPainting! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 7/8/2009 11:21'!buttonShowNavBar	"Build and return a fresh button for showing the nav-bar."	^ self makeButton: 'showNavBar' balloonText: 'show the tool bar' translated for: #showNavBar! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'bf 8/22/2010 16:01'!buttonStop	^self makeButton: 'stop' balloonText: 'Quit Etoys (with saving)' translated for: #stopSqueak! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'bf 9/12/2009 20:00'!buttonZoom	"Build and return a fresh Zoom button for me."	^self makeButton: 'zoom' balloonText: 'Click here to toggle using the full screen.' translated for: #zoom! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 8/4/2009 23:01'!chooseScreenSetting	"Put up a menu allowing the user to choose between virtual-olpc-display mode and normal-display mode."	| aMenu availableModes |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'display mode' translated.	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	availableModes _ self availableDisplayModes.	availableModes do:		[:mode |			aMenu addUpdating: #stringForDisplayModeIs: target: self selector: #toggleScreenSetting: argumentList: {mode}.			(self balloonTextForMode: mode) ifNotNilDo:				[:help |					aMenu balloonTextForLastItem: help translated]].	aMenu addLine.	aMenu addUpdating: #stringForFullScreenToggle  target: self action: #toggleFullScreen.	aMenu popUpInWorld"(Flaps globalFlapTabWithID: 'Sugar Navigator Flap' translated) referent chooseScreenSetting"! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 8/4/2009 23:06'!stringForDisplayModeIs: aSymbol	"Answer the description of the scaling mode represented by the given symbol."	| currentMode |	currentMode := self currentDisplayMode.	#(	(physical			'No Scaling')		(scaledVirtual		'Scaled Virtual Extent')		(centeredVirtual	'Centered Virtual Extent'))  translatedNoop do:			[:pair |				aSymbol = pair first ifTrue:					[^  (currentMode = aSymbol ifTrue: ['<yes>'] ifFalse: ['<no>']), pair second translated]].	^ 'error'! !!SugarNavigatorBar methodsFor: 'buttons creation' stamp: 'sw 8/4/2009 22:04'!stringForFullScreenToggle	"Answer the wording forf the full-screen toggle."	^ (self inFullScreenMode ifTrue: ['<yes>'] ifFalse: ['<no>']), 'Full Screen' translated! !!SugarNavigatorBar methodsFor: 'button actions' stamp: 'sw 8/4/2009 23:06'!changeDisplayModeTo: aSymbol	"If the user's display mode is not already the one indicated by the input parameter, switch to that mode."	aSymbol == #physical ifTrue: [		OLPCVirtualScreen virtualScreenExtent: nil.		^ OLPCVirtualScreen unInstall.	].	aSymbol == #scaledVirtual ifTrue: [		^ OLPCVirtualScreen install.	].	aSymbol == #centeredVirtual ifTrue: [		OLPCVirtualScreen install.		^ Display zoomOut: true.	].! !!SugarNavigatorBar methodsFor: 'button actions' stamp: 'bf 7/7/2009 16:50'!doZoomButtonMenuEvent: evt	self chooseScreenSetting! !!SugarNavigatorBar methodsFor: 'button actions' stamp: 'sw 5/29/2009 16:52'!hideNavBar	"Reconfigure the nav-bar such that it only shows the 'show nav bar' icon at right edge"	owner hideNavBar! !!SugarNavigatorBar methodsFor: 'button actions' stamp: 'sw 8/4/2009 23:01'!toggleScreenSetting: aSymbol	"The user requested toggling of the display-mode item representing the given symbol"	| currentMode |	currentMode := self currentDisplayMode.	aSymbol = currentMode 		ifTrue:			[#(	(physical			scaledVirtual)				(scaledVirtual		physical)				(centeredVirtual	scaledVirtual)) do:					[:pair |						currentMode = pair first ifTrue: [^ self changeDisplayModeTo: pair second]]].	self changeDisplayModeTo: aSymbol! !!SugarNavigatorBar methodsFor: 'button actions' stamp: 'bf 7/7/2009 16:47'!zoom	self inFullScreenMode		ifTrue: [self fullScreenOff]		ifFalse: [self fullScreenOn]! !!SugarNavigatorBar methodsFor: 'event handling' stamp: 'sw 5/29/2009 17:14'!showNavBar	"Show the full sugar nav bar."	owner showNavBar! !!SugarNavigatorBar methodsFor: 'event handling' stamp: 'bf 8/25/2010 01:21'!stopButtonAppearance	"Indicated whether stopping in Sugar will keep or not"	| wasStop isStop oldButton |	(self isSugar and: [stopButton notNil])  ifTrue: [		wasStop := stopButton actionSelector = #stopSqueak.		isStop := SugarLauncher current willSaveOnQuit.		wasStop = isStop ifFalse: [			oldButton := stopButton.			stopButton := isStop ifTrue: [self buttonStop] ifFalse: [self buttonQuit].			oldButton owner replaceSubmorph: oldButton by: stopButton]].! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 9/15/2009 14:44'!buttonHeight	^ paintButton ifNotNil: [paintButton height] ifNil: [75].! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 8/20/2010 12:41'!color: aColor	| oldHeight |	color = aColor ifTrue: [^ self].	oldHeight _ self buttonHeight.	super color: aColor.	submorphs ifNotEmpty: [self rebuildButtons].	self buttonHeight ~= oldHeight ifTrue: [		self naviHeight: oldHeight.	].! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 8/20/2010 12:41'!color: baseColor highLightColor: hColor	| oldHeight |	oldHeight _ self buttonHeight.	(color = baseColor and: [highLightColor = hColor]) ifTrue: [^ self].	super color: baseColor.	highLightColor _ hColor.	submorphs ifNotEmpty: [self rebuildButtons].	self buttonHeight ~= oldHeight ifTrue: [		self naviHeight: oldHeight.	].! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 8/20/2010 12:41'!highLightColor: aColor	| oldHeight |	highLightColor = aColor ifTrue: [^ self].	highLightColor _ aColor.	oldHeight _ self buttonHeight.	submorphs ifNotEmpty: [self rebuildButtons].	self buttonHeight ~= oldHeight ifTrue: [		self naviHeight: oldHeight.	].! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 8/25/2010 01:19'!isSugar	^isSugar == true! !!SugarNavigatorBar methodsFor: 'accessing' stamp: 'bf 9/15/2009 14:45'!oldHeight	^ paintButton ifNotNil: [paintButton height] ifNil: [75].! !!SugarNavigatorBar methodsFor: 'help flap' stamp: 'tk 8/10/2010 22:00'!buildAndOpenHelpFlap	"Called only when flaps are being created afresh."	| aFlapTab outer leftStrip rightStrip aGuide |	aFlapTab :=  FlapTab new.	aFlapTab assureExtension visible: false.	aFlapTab setProperty: #rigidThickness toValue: true.	outer := AlignmentMorph newRow.	outer assureExtension visible: false.	outer clipSubmorphs: true.	outer beTransparent.	outer vResizing: #spaceFill; hResizing: #spaceFill.	outer layoutInset: 0; cellInset: 0; borderWidth: 0.	outer setProperty: #wantsHaloFromClick toValue: false.	leftStrip := Morph new beTransparent.  "This provides space for tabs to be seen."	leftStrip layoutInset: 0; cellInset: 0; borderWidth: 0.	leftStrip width:  20.	leftStrip hResizing: #rigid; vResizing: #spaceFill.	outer addMorphBack: leftStrip.   	rightStrip := AlignmentMorph newColumn.	rightStrip color: (Color green veryMuchLighter alpha:  0.2).	rightStrip layoutInset: 0; cellInset: 0; borderWidth: 0.	rightStrip setProperty: #wantsHaloFromClick toValue: false.	outer addMorphBack: rightStrip.	outer clipSubmorphs: true.		aGuide := QuickGuideMorph new.	aGuide initializeIndexPage."	aGuide order: QuickGuideMorph defaultOrder.	"	QuickGuideMorph loadIndexAndPeekOnDisk.	aGuide loadPages.	rightStrip addMorphBack: aGuide.	aGuide beSticky.	aFlapTab referent ifNotNil: [aFlapTab referent delete].	aFlapTab referent: outer.	aFlapTab setName: 'Help' translated edge: #left color: (Color r: 0.677 g: 0.935 b: 0.484).	ActiveWorld addMorphFront: aFlapTab.	aFlapTab adaptToWorld: ActiveWorld.	aFlapTab computeEdgeFraction.	aFlapTab position: (outer left @ outer top).	outer extent: (462 @ ActiveWorld height).	outer beFlap: true.	outer beTransparent.	aFlapTab referent hide.	aFlapTab referentMargin: 0@self height.	aFlapTab openFully.	outer beSticky.	leftStrip beSticky.	rightStrip beSticky.	aFlapTab applyThickness: 462.	aFlapTab fitOnScreen.	aFlapTab referent show.	aFlapTab show.	aFlapTab makeFlapCompact: true.	aFlapTab setToPopOutOnDragOver:  false.	Flaps addGlobalFlap: aFlapTab.	ActiveWorld addGlobalFlaps.	ScriptingSystem cleanUpFlapTabsOnLeft! !!SugarNavigatorBar methodsFor: 'help flap' stamp: 'bf 8/29/2010 18:04'!toggleHelp	"Open the help-cards flap, or close it if open."	| ref f guide |	f _ Flaps globalFlapTab: 'Help' translated.	f ifNotNil:		[		f isInWorld			ifTrue:				[ref _ f referent.				ref ifNotNil: [guide _ ref findDeeplyA: QuickGuideMorph].				guide ifNotNil: [guide unloadPages].				Flaps removeFlapTab: f keepInList: false]			ifFalse:				[f openInWorld.				f showFlap.				ref _ f referent.				ref ifNotNil: [					guide _ ref findDeeplyA: QuickGuideMorph].					guide ifNotNil: [Cursor wait showWhile: [guide initializeIndexPage]]]]		ifNil:			[QuickGuideMorph guidePath				ifNil: [^self inform: 'There are no QuickGuides installed' translated].			Cursor wait showWhile: [self buildAndOpenHelpFlap]]! !!SugarNavigatorBar methodsFor: 'the actions' stamp: 'bf 8/25/2010 01:48'!keepProject	Preferences sugarAutoSave		ifTrue: [SugarLauncher current save]		ifFalse: [self publishProject]! !!SugarNavigatorBar methodsFor: 'the actions' stamp: 'bf 9/11/2009 23:59'!previousProject	Preferences eToyFriendly ifTrue: [		| prev |		prev := Project current previousProject.		(prev isNil or: [prev isTopProject]) ifTrue: [			Project home ifNotNilDo: [:p | Project current setParent: p]]].	super previousProject! !!SugarNavigatorBar methodsFor: 'the actions' stamp: 'yo 9/11/2009 14:26'!resizeProjectNameField	"The height should be 45 according to the Sugar guilde line, but an odd number makes the circle distorted.  To be general, it uses 60% of the height of bar."	| h |	h _ (self height * 0.6) roundTo: 2.	projectNameField ifNotNil: [		projectNameField extent: (Display width >= 1200 ifTrue: [220] ifFalse: [130])@h.		projectNameField resizeLabel].! !!SugarNavigatorBar class methodsFor: 'utilitity' stamp: 'bf 8/20/2010 10:32'!rebuildButtons	self current ifNotNilDo: [:bar | bar rebuildButtons]! !!SugarNavigatorBar class methodsFor: 'class initialization' stamp: 'bf 8/20/2010 10:32'!initialize	"self initialize"	Preferences addPreference: #showAdvancedNavigatorButtons 		categories: #(morphic)		default: false		balloonHelp: 'If true, an advanced version of the navigator is shown, otherwise a simplified version.'		projectLocal: false		changeInformee: self		changeSelector: #rebuildButtons.! !!SugarNavTab methodsFor: 'initialization' stamp: 'bf 9/13/2009 22:10'!hideNavBar	"Hide the nav bar."	self setProperty: #collapsedMode toValue: true.	referent delete.	referent showOnlyShowNavBarButton.	self hResizing: #shrinkWrap.	referent layoutInset: 0@0.	self edgeToAdhereTo: #topRight.	self occupyTopRightCorner.	self addMorphBack: referent! !!SugarNavTab methodsFor: 'initialization' stamp: 'bf 8/20/2010 10:35'!showNavBar	"Show the full nav-bar across the top of the screen."	self removeProperty: #collapsedMode.	referent delete.	referent rebuildButtons; hResizing: #spaceFill.	Preferences useArtificialSweetenerBar ifTrue: [referent configureForSqueakland].	self hResizing: #spaceFill.	self edgeToAdhereTo: #top.	self position: 0@0.		self addMorph: referent! !!SugarNavTab methodsFor: 'positioning' stamp: 'sw 5/29/2009 18:36'!collapsedMode	"Answer whether the receiver is currently showing only as a single open-nav-bar button at top-right of the screen."	^ self hasProperty: #collapsedMode! !!SugarNavTab methodsFor: 'positioning' stamp: 'sw 6/5/2009 14:46'!occupyTopRightCorner	"Make the receiver be the correct size, and occupy the top-right corner of the screen."	| worldBounds toUse |	worldBounds := ActiveWorld bounds."	toUse := Preferences useArtificialSweetenerBar		ifFalse:			[75]		ifTrue:			[(ActiveWorld  extent >= (1200 @ 900))				ifTrue:					[75]				ifFalse:					[40]]."	toUse := 40.  "Trying for the moment to use the smaller icon always when in this mode."	referent height: toUse; resizeButtonsAndTabTo: toUse.	self extent: toUse @ toUse.	self topRight: worldBounds topRight! !!SugarNavTab methodsFor: 'positioning' stamp: 'sw 5/30/2009 02:07'!spanWorld	"Make the receiver's height or width commensurate with that of the container."	| container |	self collapsedMode ifTrue:		[^ self occupyTopRightCorner].	container _ self pasteUpMorph ifNil: [self currentWorld].	(self orientation == #vertical) ifTrue: [		referent vResizing == #rigid 			ifTrue:[referent spanContainerVertically: container height].		referent hResizing == #rigid 			ifTrue:[referent width: (referent width min: container width - self width)].		referent top: container top + self referentMargin y.	] ifFalse: [		referent hResizing == #rigid			ifTrue:[referent width: container width].		referent vResizing == #rigid			ifTrue:[referent height: (referent height min: container height - self height)].		referent left: container left + self referentMargin x.	] ! !!SugarRoundedField methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 14:26'!label: aStringOrMorph	label ifNotNil: [label delete. label _ nil].	label _ aStringOrMorph.	label isString ifTrue: [		label _ StringMorph new label: label font: Preferences standardEToysFont	].	self resizeLabel.! !!SugarRoundedField methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 14:26'!naviHeight: aNumber	self extent: self width@(aNumber * 0.6).	self resizeLabel.! !!SugarRoundedField methodsFor: 'as yet unclassified' stamp: 'yo 9/11/2009 14:32'!resizeLabel	| small |	label ifNotNil: [		label width: self width - 10.		small :=self height < 45.		label label: ActiveWorld project name font: (StrikeFont familyName: 'BitstreamVeraSans' size: (small ifTrue: [15] ifFalse: [24])).		label center: self center.		label left: self left + 10.		self addMorph: label.	].! !!SuperSwikiServer methodsFor: 'for real' stamp: 'sw 9/1/2009 01:57'!updateProjectInfoFor: aProject	| data details projectLinks linkString uploader |	data _ OrderedCollection new.	data add: 'action: updatepage'.	data add: 'password: ',ProjectPasswordNotification signal."***NB - Commented out the following line:	data add: 'projectimage: ', (aProject name convertToEncoding: self encodingName) , '.gif'.****"	uploader _ Utilities authorNamePerSe.	uploader isEmptyOrNil ifTrue: [uploader _ Utilities authorInitialsPerSe].	uploader isEmptyOrNil ifFalse: [		data add: ('submittedBy: ',uploader convertToEncoding: self encodingName).	].	projectLinks _ Set new.	aProject world allMorphsDo: [ :each |		(each isKindOf: ProjectViewMorph) ifTrue: [			projectLinks add: each safeProjectName.		].	].	details _ aProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new].	details at: 'projectname' ifAbsentPut: [aProject name].	projectLinks isEmpty ifTrue: [		details removeKey: 'projectlinks' ifAbsent: []	] ifFalse: [		linkString _ String streamContents: [ :strm |			projectLinks asSortedCollection do: [ :each |				strm nextPutAll: each			] separatedBy: [				strm nextPut: $.			].		].		details at: 'projectlinks' put: linkString	].	details keysAndValuesDo: [ :k :v |		data add: k , ': ' , (v convertToEncoding: self encodingName). self flag: #yoFlag.	].	^self sendToSwikiProjectServer: data! !!SuperSwikiServer methodsFor: 'squeaklets' stamp: 'mu 9/5/2009 01:28'!upLoadProject: projectName members: archiveMembers retry: aBool	| answer |	archiveMembers do:[:entry|		ProgressNotification signal: '4:uploadingFile' extra:'(uploading ' translated, entry fileName convertFromSystemString , '...)' translated.		answer _ self sendToSwikiProjectServer: {			'uploadproject2: ', entry fileName.			'password: ',ProjectPasswordNotification signal.			entry contents.		}.		answer = 'OK' ifFalse:[			self inform:'Server responded ' translated, answer.			^false].	].	ProgressNotification signal: '4:uploadingFile' extra:''.	^true! !!SuperSwikiServer class methodsFor: 'as yet unclassified' stamp: 'mu 9/6/2009 23:03'!defaultEncodingName	^'utf-8' copy! !!Symbol methodsFor: 'testing' stamp: 'md 8/27/2005 16:33'!isDoIt	^ (self == #DoIt) or: [self == #DoItIn:].! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 2/22/2001 14:10'!altStyleTester	self doFirstThatWorks		if: [self = 1] do: [self + 1];		if: [self = 2] do: [self + 2];		if: [self = 3] do: [self + 3];		if: [self = 4] do: [self + 4];		if: [true] do: [self + 5]		! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:17'!bobsplace2: letter after: before newLine: isNewLine 	"Position this letter. Put its left edge where the previous letter's right edge is. Move down to the next line if isNewLine is true. Add some 	leading for condensed or expanded text."	(self doFirstThatWorks)		if: [before isNil]			do: [self selfWrittenAsIll march: letter to: leftMargin topRight];		if: [isNewLine]			do: 				[self selfWrittenAsIll march: letter					to: leftMargin right @ (before bottom + 1)];		if: [true] do: [self selfWrittenAsIll march: letter to: before topRight]! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:17'!bobsplace: letter after: before newLine: isNewLine 	"Position this letter. Put its left edge where the previous letter's right 	edge is. Move down to the next line if isNewLine is true. Add some 	leading for condensed or expanded text."	before isNil		ifTrue: [self selfWrittenAsIll march: letter to: leftMargin topRight]		ifFalse: 			[isNewLine 				ifTrue: 					[self selfWrittenAsIll march: letter						to: leftMargin right @ (before bottom + 1)]				ifFalse: [self selfWrittenAsIll march: letter to: before topRight]].	^self! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 11:27'!doAndCollect	self do: [ :j | j isEmpty ifFalse: [j size]].	self collect: [ :each | each asString withBlanksTrimmed].	! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 2/27/2001 14:17'!makeRandomString	| newString foo |	newString _ String new: Goal contents size.	foo _ Goal contents size.	^newString collect: [ :oldLetter | 'abcdefghijklmnopqrstuvwxyz' atRandom]! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 2/28/2001 09:52'!repeatExample	self		repeatFor: (1 to: 50)		doing: [ :i | i + 3]! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 3/5/2001 18:10'!st76LeftArrowTest: foo	foo contentsGetz: foo contents asUppercase		! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 08:23'!wordyTestMethod	self selfWrittenAsMe = 1 ifTrue: [		self selfWrittenAsMy size.		self selfWrittenAsIll stop.		self selfWrittenAsIm large.		self selfWrittenAsThis helps.	].! !!SystemDictionary methodsFor: 'accessing' stamp: 'bf 4/17/2010 14:17'!globals	^self! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'bf 1/14/2010 13:33'!compressSources		"Copy all the source file to a compressed file. Usually preceded by Smalltalk condenseSources."	"The new file will be created in the default directory, and the code in openSources	will try to open it if it is there, otherwise it will look for normal sources."	"Smalltalk compressSources"	| f cfName cf |	f := SourceFiles first readOnlyCopy binary.	"binary to preserve utf8 encoding"	(f localName endsWith: 'sources')		ifTrue: [cfName := (f localName allButLast: 7) , 'stc']		ifFalse: [self error: 'Hey, I thought the sources name ended with ''.sources''.'].	cf := (CompressedSourceStream on: (FileStream newFileNamed: cfName))				segmentSize: 65536 maxSize: f size.	"Copy the sources"'Compressing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: f size	during:		[:bar | f position: 0.		[f atEnd] whileFalse:			[cf nextPutAll: (f next: 65536).			bar value: f position]].	cf close.	self setMacFileInfoOn: cfName.	self inform: 'You now have a compressed sources file!!Squeak will use it the next time you start.'! !!SystemDictionary methodsFor: 'memory space' stamp: 'dtl 10/3/2005 06:12'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	| free preemptedProcess |	self garbageCollectMost <= self lowSpaceThreshold		ifTrue: [self garbageCollect <= self lowSpaceThreshold				ifTrue: ["free space must be above threshold before					starting low space watcher"					^ Beeper beep]].	Smalltalk specialObjectsArray at: 23 put: nil.  "process causing low space will be saved here"	LowSpaceSemaphore := Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess := nil.	"The process that was active at the time of the low space interrupt."	preemptedProcess := Smalltalk specialObjectsArray at: 23.	Smalltalk specialObjectsArray at: 23 put: nil.	"Note: user now unprotected until the low space watcher is re-installed"	self memoryHogs isEmpty		ifFalse: [free := self bytesLeft.			self memoryHogs				do: [ :hog | hog freeSomeSpace ].			self bytesLeft > free				ifTrue: [ ^ self installLowSpaceWatcher ]].	self isMorphic		ifTrue: [CurrentProjectRefactoring				currentInterruptName: 'Space is low'				preemptedProcess: preemptedProcess]		ifFalse: [ScheduledControllers				interruptName: 'Space is low'				preemptedProcess: preemptedProcess]! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'bf 8/29/2010 19:03'!copyright	"The Smalltalk copyright."	^'Copyright (c) 1996 Apple Computer, Inc. All Rights Reserved.Copyright (c) 1996-2010 Viewpoints Research Institute, and Contributors'! !!SystemDictionary methodsFor: 'special objects' stamp: 'eem 7/22/2008 18:37'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used	by the	Squeak virtual machine. Its contents are critical and	unchecked, so don't even think of playing here unless you	know what you are doing."	| newArray |	newArray := Array new: 50.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: ((Display respondsTo: #actualDisplay)	    ifTrue: [Display actualDisplay] ifFalse: [Display]).	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: nil.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'bf 4/19/2010 03:09'!allTraits	^#()! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 4/30/2009 17:58'!baseName	"version sans number"	| p |	p := version findFirst: [:c | c isLetter not].	^p = 0		ifTrue: [version]		ifFalse: [version first: p - 1]! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 5/3/2010 09:59'!repositoryDate	^repositoryDate ifNil: [self date]! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 5/3/2010 09:59'!repositoryDate: aDate	repositoryDate := aDate! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 5/3/2010 10:40'!repositoryString	^self repositoryVersion > 0		ifFalse: ['']		ifTrue: [			'repo v', self repositoryVersion asString,			' of ', self repositoryDate asString]! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 5/3/2010 10:39'!repositoryVersion	^repositoryVersion ifNil: [0]! !!SystemVersion methodsFor: 'accessing' stamp: 'bf 5/3/2010 09:56'!repositoryVersion: anInteger	repositoryVersion := anInteger! !!SystemVersion methodsFor: 'printing' stamp: 'bf 5/3/2010 10:40'!printOn: stream	stream		nextPutAll: self datedVersion;		nextPutAll: ' update ' ;		print: self highestUpdate.	self repositoryVersion > 0 ifTrue: [		stream			nextPutAll: ' (';			nextPutAll: self repositoryString;			nextPut: $)]! !!SystemVersion class methodsFor: 'instance creation' stamp: 'bf 9/13/2010 20:06'!newVersion: versionName	| newVersion |	newVersion := self new version: versionName.	self current updates do: [:n |		n <=  self current highestUpdate			ifTrue: [newVersion registerUpdate: n]].	newVersion		highestUpdate: self current highestUpdate.	Current := newVersion! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 13:26'!index: anInteger	"For renumbering temps in the closure compiler."	index := anInteger.	code := self code: index type: LdTempType! !!Text methodsFor: '*pango' stamp: 'yo 6/19/2008 12:08'!asPangoAttributes	^ runs asPangoAttributesFor: string.! !!Text methodsFor: '*pango' stamp: 'yo 6/18/2008 23:15'!basicPangoLanguageAttributes	| stream currentTag currentStart currentEnd leadingChar converter myStream utf8Stream |	self size = 0 ifTrue: [^ Array new: 0].	(string isMemberOf: ByteString)		ifTrue: [^ Array new: 0].	converter := UTF8TextConverter new.	myStream := ReadStream on: self string.	utf8Stream := WriteStream on: (String new: self size).	stream := WriteStream on: (Array new: self size//20).	currentTag := (string at: 1) leadingChar.	currentStart := 0.	converter nextPut: myStream next toStream: utf8Stream.	currentEnd := utf8Stream position.	2 to: self size do: [:e |		((leadingChar := (string at: e) leadingChar) ~= currentTag) ifTrue: [			stream nextPut: (Array with: #L with: currentStart with: currentEnd with: currentTag).			currentTag := leadingChar.			currentStart := currentEnd.		].		converter nextPut: myStream next toStream: utf8Stream.		currentEnd := utf8Stream position.	].	stream nextPut: (Array with: #L with: currentStart with: currentEnd with: currentTag).	^ stream contents.! !!Text methodsFor: '*pango' stamp: 'yo 6/24/2008 00:29'!pangoLanguageAttributes	| ret array |	ret := self primLanguageAttributes: string lOop: #L into: (array := Array new: self size//3+10).	ret isInteger ifTrue: [^ array copyFrom: 1 to: ret].	^ ret."	^ self basicPangoLanguageAttributes."! !!Text methodsFor: '*pango' stamp: 'yo 6/24/2008 00:29'!primLanguageAttributes: str lOop: l into: array	<primitive: 'primitiveLanguageAttributes' module: 'RomePlugin'>	^ self basicPangoLanguageAttributes.! !!TextDomainManager commentStamp: 'tk 1/4/2008 16:08' prior: 0!I manages mapping from class category to textdomain.Class variables: ClassCategories	IdentityDictionary -- classCategory -> domainName  Classes			IdentityDictionary -- class name (a Symbol) -> domainName   (a cache only!!) DefaultDomain	String -- the default domain name DomainInfos		Dictionary -- domainName -> a TextDomainInfo LoneClasses		IdentityDictionary -- class name (a Symbol) -> domainName.  For classes whose entire category are not all in the same domain (BookMorph and QuickGuideMorph)TextDomainManager registerCategoryPrefix: 'DrGeoII' domain: 'DrGeoII'.TextDomainManager unregisterDomain: 'DrGeoII'.TextDomainManager registerClass: #QuickGuideMorph domain: 'quickguides'.TextDomainManager registerClass: #QuickGuideHolderMorph  domain: 'quickguides'.!!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:08'!allKnownDomains"Every package has it's own text domain now so it's not necessary to keep a registry of all domains, we can simply return all the packages in the image.PROBLEM: If a package doesn't contain translations, it won't have a mo file but the GetTextTranslator will try to load it anyway. This happens when we switch languages. So far I tested it briefly and it seems to work..."^PackageOrganizer default packageNames! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:45'!allMethodsWithTranslations"Look for #translated calls"| methodsWithTranslations |methodsWithTranslations := TranslatedReceiverFinder new stringReceiversWithContext: #translated.methodsWithTranslations := methodsWithTranslations, (TranslatedReceiverFinder newstringReceiversWithContext: #translatedNoop).methodsWithTranslations := methodsWithTranslations collect: [:each | each key compiledMethod]."Look for Etoys tiles and vocabularies"methodsWithTranslations := methodsWithTranslations, (EToyVocabulary allPhrasesWithContextToTranslate collect: [:r |	(MethodReference new setStandardClass: r second methodSymbol: r third) compiledMethod.]).^methodsWithTranslations! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:08'!defaultDomain"I'm not sure we still need a default domain, AFAIK the default domain will only be used when no domain is found. In that case, wouldn't it be better to just look for a translation in all domains?"	^defaultDomain! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:02'!defaultDomain: aDomainName	defaultDomain := aDomainName! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/18/2010 11:13'!domainForClass: aClass^'etoys'! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:10'!domainForPackage: aPackageInfo"Package names and text domains are synonyms now"	^aPackageInfo name! !!TextDomainManager class methodsFor: 'accessing' stamp: 'Richo 5/13/2010 00:17'!domainOfMethod: aCompiledMethod 	^ aCompiledMethod		propertyValueAt: self textDomainProperty		ifAbsent: [self updateDomainOfMethod: aCompiledMethod] ! !!TextDomainManager class methodsFor: 'class initialization' stamp: 'Richo 5/13/2010 16:05'!initialize	"	TextDomainManager initialize	"	self defaultDomain: 'Etoys'; clearAllDomains! !!TextDomainManager class methodsFor: 'private' stamp: 'Richo 5/13/2010 00:16'!clearAllDomains	SystemNavigation default		allCompiledMethodDo: [:each | each				removeProperty: self textDomainProperty				ifAbsent: []] ! !!TextDomainManager class methodsFor: 'private' stamp: 'Richo 5/13/2010 00:12'!textDomainProperty^#textDomain! !!TextDomainManager class methodsFor: 'private' stamp: 'Richo 5/13/2010 00:46'!updateDomainOfAllMethodsWithTranslationsself allMethodsWithTranslations do: [:each|	self updateDomainOfMethod: each]! !!TextDomainManager class methodsFor: 'private' stamp: 'Richo 5/13/2010 00:27'!updateDomainOfMethod: aCompiledMethod 	"First it looks for the package of the method reference (using	the PackageOrganizer: deadly slow). If the method doesn't	belong to any package it uses the default domain. Finally it	stores the text domain of the method using a method	property, this way we gain performance the next time we	translate the same method because we avoid the use of	PackageOrganizer. Have I mentioned it is really slow? :)"	| package |	package := PackageOrganizer default				packageOfMethod: aCompiledMethod methodReference				ifNone: [].	^ aCompiledMethod		propertyValueAt: self textDomainProperty		put: (package isNil				ifTrue: [TextDomainManager defaultDomain]				ifFalse: [package name])! !!TextMorph methodsFor: 'accessing' stamp: 'Richo 8/12/2010 21:56'!crPassesFocus^self valueOfProperty: #crPassesFocus ifAbsent: [false]! !!TextMorph methodsFor: 'accessing' stamp: 'Richo 8/12/2010 21:57'!crPassesFocus: aBoolean^self setProperty: #crPassesFocus toValue: aBoolean! !!TextMorph methodsFor: 'accessing' stamp: 'Richo 8/12/2010 21:59'!highlightsOnFocus"If this property is true, whenever the user clicks on the text it will show the focus change by changing its border color to red"^self valueOfProperty: #highlightsOnFocus ifAbsent: [false]! !!TextMorph methodsFor: 'accessing' stamp: 'Richo 8/12/2010 21:59'!highlightsOnFocus: aBoolean"See #highlightsOnFocus comment"^self setProperty: #highlightsOnFocus toValue: aBoolean! !!TextMorph methodsFor: 'event handling' stamp: 'Richo 8/12/2010 21:58'!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean 		ifTrue: 			["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"]]		ifFalse: 			["A hand has clicked elsewhere..."			(w := self world) isNil 				ifFalse: 					[w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].					"Release control unless some hand is still holding on"					self releaseEditor]].	self highlightsOnFocus ifTrue: [		aBoolean ifTrue: [self borderColor: Color red]  ifFalse: [self borderColor: Color black]]! !!TextMorph methodsFor: 'events-processing' stamp: 'Richo 8/12/2010 21:57'!handleKeystroke: anEvent	"System level event handling."	| pasteUp |	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:	[^ self].	anEvent wasHandled: true.	((anEvent keyCharacter = Character tab) or: [self crPassesFocus and: [anEvent keyCharacter = Character cr]]) ifTrue:		["Allow passing through text morph inside pasteups"		(self wouldAcceptKeyboardFocusUponTab and:				[(pasteUp _ self pasteUpMorphHandlingTabAmongFields) notNil])			ifTrue:[^ pasteUp tabHitWithEvent: anEvent]].	self keyStroke: anEvent! !!TextMorph class methodsFor: 'scripting' stamp: 'yo 11/5/2008 14:31'!nonwrappingPrototype	"Answer the default-text-object de jour; at this time, it's actually an instance of UserText."	| text style index baseFont textMorph |	text := Text fromString: 'Text' translated.	baseFont _ Preferences standardEToysFont.	style _ baseFont textStyle.	index _ style fontIndexOfPointSize: 24.	style defaultFontIndex: index.	text addAttribute: (TextFontChange fontNumber: index).	textMorph := UserText new.	textMorph		contentsWrapped: text;		setTextStyle: style;		margins: 0@0.	"Too ugly dirty hack from boldAuthoringPrototype."	textMorph wrapFlag: false.	textMorph fit.	textMorph usePango ifTrue: [textMorph wrapFlag: true].	^ textMorph"TextMorph nonwrappingPrototype openInHand"! !!TextMorph class methodsFor: '*connectors-text-parts bin' stamp: 'yo 11/5/2008 14:33'!boldAuthoringPrototype	"TextMorph boldAuthoringPrototype openInHand"	| text style index baseFont textMorph |	text := Text fromString: 'Text' translated.	baseFont _ Preferences standardEToysFont.	style _ baseFont textStyle.	index _ style fontIndexOfPointSize: 24.	text addAttribute: (TextFontChange fontNumber: index).	textMorph := self new		contentsWrapped: text;		setTextStyle: style;		margins: 0@0;		yourself.	"Too ugly dirty hack"	textMorph wrapFlag: false.	textMorph fit.	textMorph usePango ifTrue: [textMorph wrapFlag: true].	^ textMorph! !!TextStyle class methodsFor: 'class initialization' stamp: 'bf 7/31/2009 18:21'!styleDecoder	TextConstants at: #StyleDecoder ifPresent: [ :dict | dict ifNotNil: [ ^dict ]].	^TextConstants at: #StyleDecoder put: (		Dictionary new at: 'Regular' put: 0;				 at: 'Roman' put: 0;				 at: 'Medium' put: 0;				 at: 'Light' put: 0;				 at: 'Normal' put: 0;				 at: 'Plain' put: 0;				 at: 'Book' put: 0;				 at: 'Demi' put: 0;				 at: 'Demibold' put: 0;				 at: 'Semibold' put: 0;				 at: 'SemiBold' put: 0;				 at: 'ExtraBold' put: 1;				 at: 'SuperBold' put: 1;				 at: 'Negreta' put: 1;				 at: 'B' put: 1;				 at: 'I' put: 2;				 at: 'U' put: 4;				 at: 'X' put: 16;				 at: 'N' put: 8;				 at: 'Bold' put: 1;				 at: 'Italic' put: 2;				 at: 'Oblique' put: 2;				 at: 'Narrow' put: 8;				 at: 'Condensed' put: 8;				 at: 'Underlined' put: 4;				 yourself )! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 13:48'!appearanceMenu	"Build the appearance menu for the world."	| screenCtrl |	screenCtrl _ DisplayScreen.	^self fillIn: (self menu: 'appearance...' translatedNoop) from: {		{'preferences...' translatedNoop. { Preferences . #openFactoredPanel} . 'Opens a "Preferences Panel" which allows you to alter many settings' translatedNoop} .		{'choose theme...' translatedNoop. { Preferences . #offerThemesMenu} . 'Presents you with a menu of themes; each item''s balloon-help will tell you about the theme.  If you choose a theme, many different preferences that come along with that theme are set at the same time; you can subsequently change any settings by using a Preferences Panel' translatedNoop} .		nil .		{'window colors...' translatedNoop. { Preferences . #windowSpecificationPanel} . 'Lets you specify colors for standard system windows.' translatedNoop}.		{'system fonts...' translatedNoop. { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.' translatedNoop}.		{'text highlight color...' translatedNoop. { Preferences . #chooseTextHighlightColor} . 'Choose which color should be used for text highlighting in Morphic.' translatedNoop}.		{'insertion point color...' translatedNoop. { Preferences . #chooseInsertionPointColor} . 'Choose which color to use for the text insertion point in Morphic.' translatedNoop}.		{'keyboard focus color' translatedNoop. { Preferences . #chooseKeyboardFocusColor} . 'Choose which color to use for highlighting which pane has the keyboard focus' translatedNoop}.		nil.		{#menuColorString . { Preferences . #toggleMenuColorPolicy} . 'Governs whether menu colors should be derived from the desktop color.' translatedNoop}.		{#roundedCornersString . { Preferences . #toggleRoundedCorners} . 'Governs whether morphic windows and menus should have rounded corners.' translatedNoop}.		nil.		{'full screen on' translatedNoop. { screenCtrl . #fullScreenOn} . 'puts you in full-screen mode, if not already there.' translatedNoop}.		{'full screen off' translatedNoop. { screenCtrl . #fullScreenOff} . 'if in full-screen mode, takes you out of it.' translatedNoop}.		nil.		{'set display depth...' translatedNoop. {self. #setDisplayDepth} . 'choose how many bits per pixel.' translatedNoop}.		{'set desktop color...' translatedNoop. {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.' translatedNoop}.		{'set gradient color...' translatedNoop. {self. #setGradientColor} . 'choose second color to use as gradient for desktop background.' translatedNoop}.		{'use texture background' translatedNoop. { #myWorld . #setStandardTexture} . 'apply a graph-paper-like texture background to the desktop.' translatedNoop}.		nil.		{'clear turtle trails from desktop' translatedNoop. { #myWorld . #clearTurtleTrails} . 'remove any pigment laid down on the desktop by objects moving with their pens down.' translatedNoop}.		{'pen-trail arrowhead size...' translatedNoop. { Preferences. #setArrowheads} . 'choose the shape to be used in arrowheads on pen trails.' translatedNoop}.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 13:59'!buildShowSourceMenu	"Build the menu that is put up when the show-source button is hit."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpItem.	self fillIn: menu from: { 		{'open...' translatedNoop. { self  . #openWindow } }.		{'windows...' translatedNoop. { self  . #windowsDo } }.		{'changes...' translatedNoop. { self  . #changesDo } }}.	self fillIn: menu from: { 		{'help...' translatedNoop. { self  . #helpDo }.  'puts up a menu of useful items for updating the system, determining what version you are running, and much else' translatedNoop}.		{'appearance...' translatedNoop. { self  . #appearanceDo }. 'put up a menu offering many controls over appearance.' translatedNoop}}.	self fillIn: menu from: {			{'do...' translatedNoop. { Utilities . #offerCommonRequests} . 'put up an editible list of convenient expressions, and evaluate the one selected.' translatedNoop}}.	self fillIn: menu from: { 		nil.		{'objects (o)' translatedNoop. { #myWorld . #activateObjectsTool } . 'A tool for finding and obtaining many kinds of objects' translatedNoop}.		{'new morph...' translatedNoop. { self  . #newMorph }. 'Offers a variety of ways to create new objects' translatedNoop}.		nil.		{'authoring tools...' translatedNoop. { self  . #scriptingDo } . 'A menu of choices useful for authoring' translatedNoop}.		{'playfield options...' translatedNoop. { self  . #playfieldDo } . 'A menu of options pertaining to this object as viewed as a playfield' translatedNoop}.		{'flaps...' translatedNoop. { self . #flapsDo } . 'A menu relating to use of flaps.  For best results, use "keep this menu up"' translatedNoop}.		{'projects...' translatedNoop. { self  . #projectDo }. 'A menu of commands relating to use of projects' translatedNoop}.		{'debug...' translatedNoop. { self  . #debugDo } . 'a menu of debugging items' translatedNoop}.		nil.		{'edit this menu' translatedNoop.  { self . #editShowSourceMenu } . 'open a code editor on the method that defines this menu' translatedNoop}}.	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 13:38'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu _ MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpItem.	self fillIn: menu from: {		{'previous project' translatedNoop. { #myWorld . #goBack }. 'return to the most-recently-visited project' translatedNoop}.		{'jump to project...' translatedNoop. { #myWorld . #jumpToProject }. 'put up a list of all projects, letting me choose one to go to' translatedNoop}.		{'save project on file...' translatedNoop. { #myWorld  . #saveOnFile }. 'save this project on a file' translatedNoop}.		{'load project from file...' translatedNoop. { self  . #loadProject }. 'load a project from a file' translatedNoop}.		nil}.	myWorld addUndoItemsTo: menu.		self fillIn: menu from: {		{'restore display (r)'  translatedNoop. { World . #restoreMorphicDisplay }. 'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.' translatedNoop}.		nil}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'open...' translatedNoop. { self  . #openWindow } }.			{'windows...' translatedNoop. { self  . #windowsDo } }.			{'changes...' translatedNoop. { self  . #changesDo } }}].	self fillIn: menu from: { 		{'help...' translatedNoop. { self  . #helpDo }.  'puts up a menu of useful items for updating the system, determining what version you are running, and much else' translatedNoop}.		{'appearance...' translatedNoop. { self  . #appearanceDo }. 'put up a menu offering many controls over appearance.' translatedNoop}}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: {			{'do...' translatedNoop. { Utilities . #offerCommonRequests} . 'put up an editible list of convenient expressions, and evaluate the one selected.' translatedNoop}}].	self fillIn: menu from: { 		nil.		{'objects (o)' translatedNoop. { #myWorld . #activateObjectsTool } . 'A tool for finding and obtaining many kinds of objects' translatedNoop}.		{'new morph...' translatedNoop. { self  . #newMorph }. 'Offers a variety of ways to create new objects' translatedNoop}.		nil.		{'authoring tools...' translatedNoop. { self  . #scriptingDo } . 'A menu of choices useful for authoring' translatedNoop}.		{'playfield options...' translatedNoop. { self  . #playfieldDo } . 'A menu of options pertaining to this object as viewed as a playfield' translatedNoop}.		{'flaps...' translatedNoop. { self . #flapsDo } . 'A menu relating to use of flaps.  For best results, use "keep this menu up"' translatedNoop}.		{'projects...' translatedNoop. { self  . #projectDo }. 'A menu of commands relating to use of projects' translatedNoop}}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'print PS to file...' translatedNoop. { self  . #printWorldOnFile } . 'write the world into a postscript file' translatedNoop}.			{'debug...' translatedNoop. { self  . #debugDo } . 'a menu of debugging items' translatedNoop}}].	self fillIn: menu from: { 		nil.		{'save' translatedNoop. { SmalltalkImage current  . #saveSession } . 'save the current version of the image on disk' translatedNoop}.		{'save as...' translatedNoop. { SmalltalkImage current . #saveAs }. 'save the current version of the image on disk under a new name.' translatedNoop}.		{'save as new version' translatedNoop. { SmalltalkImage current . #saveAsNewVersion }. 'give the current image a new version-stamped name and save it under that name on disk.' translatedNoop}.		{'save and quit' translatedNoop. { self  . #saveAndQuit } . 'save the current image on disk, and quit out of Squeak.' translatedNoop}.		{'quit' translatedNoop. { self  . #quitSession } . 'quit out of Squeak.' translatedNoop}}.	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:01'!changesMenu        "Build the changes menu for the world."        | menu |        menu _ self menu: 'changes...' translatedNoop.        self fillIn: menu from: {                { 'file out current change set' translatedNoop. { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.' translatedNoop}.                { 'create new change set...' translatedNoop. { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.' translatedNoop}.                { 'browse changed methods' translatedNoop. { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set' translatedNoop}.                { 'check change set for slips' translatedNoop. { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.' translatedNoop}.                nil.                { 'simple change sorter' translatedNoop. {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool' translatedNoop}.                { 'dual change sorter' translatedNoop. {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.' translatedNoop}.               { 'find a change sorter (C)' translatedNoop. { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window' translatedNoop}.                nil.                { 'browse recent submissions' translatedNoop. { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.' translatedNoop}.                { 'find recent submissions (R)' translatedNoop. { #myWorld . #openRecentSubmissionsBrowser:}.                                'Make an open recent-submissions browser be the front-window, expanding a collapsed one or creating a new one if necessary.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted, latest first.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions at the top of the browser.' translatedNoop}.			nil.                { 'recently logged changes...' translatedNoop. { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.' translatedNoop}.                { 'recent log file...' translatedNoop. { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.' translatedNoop}.                nil.                { 'save world as morph file' translatedNoop. {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.' translatedNoop}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' translatedNoop. {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.' translatedNoop}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' translatedNoop. {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.' translatedNoop}.                }.        ].        ^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:02'!debugMenu        | menu |        menu _ self menu: 'debug...' translatedNoop.        ^self fillIn: menu from: {                 { 'inspect world' translatedNoop. { #myWorld . #inspect } }.                { 'explore world' translatedNoop. { #myWorld . #explore } }.                { 'inspect model' translatedNoop. { self . #inspectWorldModel } }.                        " { 'talk to world...' translated. { self . #typeInMessageToWorld } }."                { 'start MessageTally' translatedNoop. { self . #startMessageTally } }.                { 'start/browse MessageTally' translatedNoop. { self . #startThenBrowseMessageTally } }.                { 'open process browser' translatedNoop. { ProcessBrowser . #open } }.                nil.                        "(self hasProperty: #errorOnDraw) ifTrue:  Later make this come up only when needed."                { 'start drawing again' translatedNoop. { #myWorld . #resumeAfterDrawError } }.                { 'start stepping again' translatedNoop. { #myWorld . #resumeAfterStepError } }.                nil.                { 'call #tempCommand' translatedNoop. { #myWorld . #tempCommand } }.                { 'define #tempCommand' translatedNoop. { #myWorld . #defineTempCommand } }.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:10'!helpMenu        "Build the help menu for the world."        |  menu |  	menu := self menu: 'help...' translatedNoop.        self fillIn: menu from:        {                {'about this system...' translatedNoop. {SmalltalkImage current. #aboutThisSystem}. 'current version information.' translatedNoop}.                {'update code from server' translatedNoop. {Utilities. #updateFromServer}. 'load latest code updates via the internet' translatedNoop}.                {'preferences...' translatedNoop. {Preferences. #openPreferencesInspector}. 'view and change various options.' translatedNoop}.			 {'set language...' translatedNoop. {Project. #chooseNaturalLanguage}. 'choose the language in which tiles should be displayed.' translatedNoop} .                nil.               {'command-key help' translatedNoop. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.' translatedNoop}	}.	self addGestureHelpItemsTo: menu.	self fillIn: menu from:	{                {'world menu help' translatedNoop. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.' translatedNoop}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.' translated}."                {'font size summary' translatedNoop. { TextStyle . #fontSizeSummary}.  'summary of names and sizes of available fonts.' translatedNoop}.                {'useful expressions' translatedNoop. { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.' translatedNoop}.			 {'annotation setup...' translatedNoop. { Preferences . #editAnnotations}. 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools' translatedNoop}.			nil.                {'graphical imports' translatedNoop. { Imports default . #viewImages}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList' translatedNoop}.                {'standard graphics library' translatedNoop. { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.' translatedNoop}.                nil.                {'telemorphic...' translatedNoop. {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments' translatedNoop}.                {#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.' translatedNoop}.                {'definition for...' translatedNoop. { Utilities . #lookUpDefinition}.  'if connected to the internet, use this to look up the definition of an English word.' translatedNoop}.                nil.                {'set author initials...' translatedNoop. { Utilities . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.' translatedNoop}.                {'vm statistics' translatedNoop. { self . #vmStatistics}.  'obtain some intriguing data about the vm.' translatedNoop}.			  nil.			  {'purge undo records' translatedNoop. { CommandHistory . #resetAllHistory }. 'save space by removing all the undo information remembered in all projects.' translatedNoop}.                {'space left' translatedNoop. { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.' translatedNoop}.        }.	^menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:12'!openMenu	"Build the open window menu for the world."	| menu |	menu _ self menu: 'open...' translatedNoop.	self fillIn: menu from: {		{'browser (b)' translatedNoop. { self . #openBrowser}. 'A five-paned tool that lets you see all the code in the system' translatedNoop}.		{'package-pane browser' translatedNoop. { PackagePaneBrowser . #openBrowser} . 'Similar to the regular browser, but adds an extra pane at top-left that groups class-categories that start with the same prefix' translatedNoop}.		{'workspace (k)' translatedNoop. {self . #openWorkspace}. 'A window for composing text' translatedNoop}.		{'file list' translatedNoop. {self . #openFileList} . 'A tool allowing you to browse any file' translatedNoop}.		{'file...' translatedNoop. { FileList . #openFileDirectly} . 'Lets you open a window on a single file' translatedNoop}.		{'transcript (t)' translatedNoop. {self . #openTranscript}. 'A window used to report messages sent to Transcript' translatedNoop}.		"{'inner world' translated. { WorldWindow . #test1} }."		{'event theatre' translatedNoop. {EventRecordingSpace. #open}. 'A place for recording "event movies" using the Event Recorder' translatedNoop}.		nil.		{'method finder' translatedNoop . { self . #openSelectorBrowser} . 'A tool for discovering methods' translatedNoop}.		{'message names (W)' translatedNoop. { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.' translatedNoop}.			 nil.		{'simple change sorter' translatedNoop. {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a single change set' translatedNoop}.		{'dual change sorter' translatedNoop. {self . #openChangeSorter2} . 'A tool allowing you to compare and manipulate two change sets concurrently' translatedNoop}.		nil.	}.	self fillIn: menu from: self class registeredOpenCommands.	menu addLine.	self mvcProjectsAllowed ifTrue:		[self fillIn: menu from: { {'mvc project' translatedNoop. {self. #openMVCProject} . 'Creates a new project of the classic "mvc" style' translatedNoop} }].	^ self fillIn: menu from: { 		{'morphic project' translatedNoop. {self. #openMorphicProject} . 'Creates a new morphic project' translatedNoop}.	}.! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:12'!projectMenu	"Build the project menu for the world."	| menu |	self flag: #bob0302.	menu _ self menu: 'projects...' translatedNoop.	self fillIn: menu from: { 		{ 'save on server (also makes a local copy)' translatedNoop. { #myProject . #storeOnServer } }.		{ 'save to a different server' translatedNoop. { #myProject . #saveAs } }.		{ 'save project on local file only' translatedNoop. { #myWorld . #saveOnFile } }.		{ 'see if server version is more recent...' translatedNoop. { #myProject . #loadFromServer } }.		{ 'load project from file...' translatedNoop. { self . #loadProject } }.		nil.	}.	self fillIn: menu from:		{{'show project hierarchy' translatedNoop. {Project. #showProjectHierarchyInWindow}. 'Opens a window that shows names and relationships of all the projects in your system.' translatedNoop}.		nil}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: {			{ 'create new mvc project' translatedNoop. { self . #openMVCProject } }.		}	].	self fillIn: menu from: { 		{ 'create new morphic project' translatedNoop. { self . #openMorphicProject } }.		nil.		{ 'go to previous project' translatedNoop. { Project . #returnToPreviousProject } }.		{ 'go to next project' translatedNoop. { Project . #advanceToNextProject } }.		{ 'jump to project...' translatedNoop. { #myWorld . #jumpToProject } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			nil.			{ 'save for future revert' translatedNoop. { #myProject . #saveForRevert } }.			{ 'revert to saved copy' translatedNoop. { #myProject . #revert } }.		}.	].	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'Richo 5/18/2010 14:13'!remoteMenu        "Build the Telemorphic menu for the world."        ^self fillIn: (self menu: 'Telemorphic' translatedNoop) from: {                { 'local host address' translatedNoop. { #myWorld . #reportLocalAddress } }.                { 'connect remote user' translatedNoop. { #myWorld . #connectRemoteUser } }.                { 'disconnect remote user' translatedNoop. { #myWorld . #disconnectRemoteUser } }.                { 'disconnect all remote users' translatedNoop. { #myWorld . #disconnectAllRemoteUsers } }.        }! !!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'Richo 5/22/2010 16:12'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows' translatedNoop) from: {                  { 'find window' translatedNoop. { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.' translatedNoop}.                { 'find changed browsers...' translatedNoop. { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.' translatedNoop}.                { 'find changed windows...' translatedNoop. { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.' translatedNoop}.			nil.                { 'find a transcript (t)' translatedNoop. { #myWorld . #findATranscript: }. 'Brings an open Transcript to the front, creating one if necessary, and makes it the active window' translatedNoop}.               { 'find a fileList (L)' translatedNoop. { #myWorld . #findAFileList: }. 'Brings an open fileList  to the front, creating one if necessary, and makes it the active window' translatedNoop}.               { 'find a change sorter (C)' translatedNoop. { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window' translatedNoop}.			{ 'find message names (W)' translatedNoop. { #myWorld . #findAMessageNamesWindow: }. 'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window' translatedNoop}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.' translatedNoop}.                nil.                { 'collapse all windows' translatedNoop. { #myWorld . #collapseAllWindows }. 'Reduce all open windows to collapsed forms that only show titles.' translatedNoop}.                { 'collapse all objects' translatedNoop. { #myWorld . #collapseAllWindowsAndNonWindows }. 'Reduce all open windows and all other objects on the desktop to labeled tabs' translatedNoop}.                { 'expand all' translatedNoop. { #myWorld . #expandAllCollapsedObjects }. 'Expand all collapsed windows and other collapsed objects back to their expanded forms.' translatedNoop}.		                { 'close top window (w)' translatedNoop. { SystemWindow . #closeTopWindow }. 'Close the topmost window if possible.' translatedNoop}.                { 'send top window to back (\)' translatedNoop. { SystemWindow . #sendTopWindowToBack  }. 'Make the topmost window become the backmost one, and activate the window just beneath it.' translatedNoop}.			 { 'move windows onscreen' translatedNoop. { #myWorld . #bringWindowsFullOnscreen }. 'Make all windows fully visible on the screen' translatedNoop}.                nil.                { 'delete unchanged windows' translatedNoop. { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.' translatedNoop}.                { 'delete non-windows' translatedNoop. { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.' translatedNoop}.                { 'delete both of the above' translatedNoop. { self . #cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.' translatedNoop}.        }! !!TheWorldMenu methodsFor: 'menu' stamp: 'sw 9/8/2009 15:26'!offerScalingMenu	"Put up the sugar-navigator's scaling / display-mode ) menu."	| aBar |	aBar := SugarNavigatorBar current ifNil: [SugarNavigatorBar new].	aBar chooseScreenSetting	! !!TheWorldMenu methodsFor: '*MorphicExtras-windows & flaps menu' stamp: 'Richo 5/18/2010 14:04'!formulateFlapsMenu: aMenu	"Fill aMenu with appropriate content"	aMenu addTitle: 'flaps' translated.	aMenu addStayUpItem.	Preferences classicNavigatorEnabled ifTrue:		[aMenu			addUpdating: #navigatorShowingString			enablementSelector: #enableProjectNavigator			target: Preferences			selector: #togglePreference: 			argumentList: #(showProjectNavigator).		aMenu balloonTextForLastItem: (Preferences preferenceAt: #showProjectNavigator) helpString translated].	Flaps sharedFlapsAllowed		ifTrue:			[self fillIn: aMenu from:				{{#suppressFlapsString.					{CurrentProjectRefactoring. #currentToggleFlapsSuppressed}.				'Whether prevailing flaps should be shown in the project right now or not.' translatedNoop}}.			aMenu addUpdating: #automaticFlapLayoutString  target: Preferences selector: #togglePreference: argumentList: #(automaticFlapLayout).			aMenu balloonTextForLastItem: (Preferences preferenceAt: #automaticFlapLayout) helpString translated.			aMenu addLine.			Flaps addIndividualGlobalFlapItemsTo: aMenu].     self fillIn: aMenu from: {			nil.               {'make a new flap' translatedNoop.			{Flaps. #addLocalFlap}.			'Create a new flap.  You can later make it into a shared flap is you wish.' translatedNoop}.			nil.}.	Flaps sharedFlapsAllowed		ifTrue:			[aMenu addWithLabel: 'put shared flaps on bottom' translated enablementSelector: #showSharedFlaps				target: Flaps selector: #sharedFlapsAlongBottom argumentList: #().			aMenu balloonTextForLastItem: 'Group all the standard shared flaps along the bottom edge of the screen' translated.			self fillIn: aMenu from: {				{'destroy all shared flaps' translatedNoop.				{Flaps. #disableGlobalFlaps}.				'Destroy all the shared flaps and disable their use in all projects.' translatedNoop}.				{'destroy flap...' translatedNoop.				{Flaps. #destroyFlapDotDotDot}.				'Choose a flap to destroy, from a pop-up list that will be presented' translatedNoop}}]		ifFalse:			[aMenu add: 'install olpc etoy flaps' translated target: Flaps action: #enableOLPCEToyFlaps.			aMenu balloonTextForLastItem: 'Put up the default etoy flaps: a custom Supplies flap and the Navigator flap' translated.aMenu add: 'install developers'' flaps' translated target: Flaps action: #enableDeveloperFlaps.			aMenu balloonTextForLastItem: 'Create the default set of shared flaps used by successive versions of the Squeak development platform' translated.			aMenu add: 'install classic etoy flaps' translated target: Flaps action: #enableClassicEToyFlaps.			aMenu addLine].	self fillIn: aMenu from: {			nil.			{'about flaps...' translatedNoop.			{Flaps . #explainFlaps}.			'Gives a window full of details about how to use flaps.' translatedNoop}}! !!TheWorldMenu methodsFor: '*Etoys' stamp: 'Richo 5/18/2010 14:05'!fullScriptingMenu	"Build the authoring-tools menu for the world.  This method offeres all the item historically offered in the full etoy system; when eToyFriendly is on, most of the items are suppressed."	^ self fillIn: (self menu: 'authoring tools...' translatedNoop) from: { 		{ 'objects (o)' translatedNoop. { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.' translatedNoop}.		nil.  "----------" 		{ 'view trash contents' translatedNoop. { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.' translatedNoop}. 		{ 'empty trash can' translatedNoop. { Utilities . #emptyScrapsBookGC}. 'Empty out all the morphs that have accumulated in the trash can.' translatedNoop}.		nil.  "----------"			{ 'sound library' translatedNoop.  { SoundLibraryTool.  #newInHand}.'A tool that lets you see and manage all the sounds in the sound library' translatedNoop}.	{ 'new scripting area' translatedNoop. { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.' translatedNoop}.		nil.  "----------"					{ 'status of scripts' translatedNoop. {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.' translatedNoop}.		{ 'summary of scripts' translatedNoop. {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.' translatedNoop}.		{ 'browser for scripts' translatedNoop. {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' "browser" format' translatedNoop}.		nil.		{ 'gallery of players' translatedNoop. {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project' translatedNoop}."		{ 'gallery of scripts' translated. {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project' translated}."		{ 'etoy vocabulary summary' translatedNoop. {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.' translatedNoop}.		{ 'attempt misc repairs' translatedNoop. {#myWorld . #attemptCleanup}. 'Take measures that may help fix up some things about a faulty or problematical project.' translatedNoop}.		{ 'remove all viewers' translatedNoop. {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.' translatedNoop}.		{ 'abandon unsituated players' translatedNoop.  {#myWorld. #abandonUnsituatedPlayers}. 'If any objects in the project have references, in player-valued variables, to other objects otherwise not present in the project, abandon them and replace former references to them by references to Dot'}.		{ 'refer to masters' translatedNoop. {#myWorld . #makeAllScriptEditorsReferToMasters }. 'Ensure that all script editors are referring to the first (alphabetically by external name) Player of their type' translatedNoop}.		nil.  "----------" 		{ 'unlock locked objects' translatedNoop. { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.' translatedNoop}.		{ 'unhide hidden objects' translatedNoop. { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.' translatedNoop}.        }! !!TheWorldMenu methodsFor: '*Etoys' stamp: 'Richo 5/18/2010 14:13'!scriptingMenu	"Build the authoring-tools menu for the world. FORMERLY:  If eToyFriendly is set, a reduced menu is offered."	true ifTrue: [^ self fullScriptingMenu].	Preferences eToyFriendly ifFalse: [^ self fullScriptingMenu]. 	^ self fillIn: (self menu: 'authoring tools...' translatedNoop) from: { 		{ 'objects (o)' translatedNoop. { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.' translatedNoop}.		nil.  "----------" 		{ 'view trash contents' translatedNoop. { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.' translatedNoop}. 		{ 'empty trash can' translatedNoop. { Utilities . #emptyScrapsBookGC}. 'Empty out all the morphs that have accumulated in the trash can.' translatedNoop}.		nil.  "----------"				{ 'sound library' translatedNoop.  { SoundLibraryTool.  #newInHand}.'A tool that lets you see and manage all the sounds in the sound library' translatedNoop}.	"{ 'new scripting area' translated. { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.' translated}.		nil.  ""----------"					{ 'status of scripts' translatedNoop. {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.' translatedNoop}.		"{ 'summary of scripts' translated. {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}."		"{ 'browser for scripts' translated. {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' ""browser"" format'}."		{ 'gallery of players' translatedNoop. {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project' translatedNoop}.		nil."		{ 'gallery of scripts' translated. {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project' translated}."		"{ 'etoy vocabulary summary' translated. {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.' translated}."		"{ 'attempt misc repairs' translated. {#myWorld . #attemptCleanup}. 'Take measures that may help fix up some things about a faulty or problematical project.' translated}."		{ 'remove all viewers' translatedNoop. {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.' translatedNoop}.		"{ 'refer to masters' translated. {#myWorld . #makeAllScriptEditorsReferToMasters }. 'Ensure that all script editors are referring to the first (alphabetically by external name) Player of their type' translated}."		"nil."  "----------" 		"{ 'unlock locked objects' translated. { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.' translated}."		"{ 'unhide hidden objects' translated. { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.' translated}."        }! !!TileMorph methodsFor: 'arrows' stamp: 'sw 11/3/2008 15:04'!addRetractArrow	"If it's appropriate, add the retract arrow.  Only called when suffixArrow is already present and in submorph tree."	self couldRetract ifNil: [^ self rescindRetractArrow].	retractArrow ifNil:		[retractArrow _ ImageMorph new image: RetractPicture].	self addMorph: retractArrow inFrontOf: suffixArrow.	fullBounds _ nil.	self extent: self fullBounds extent! !!TileMorph methodsFor: 'misc' stamp: 'bf 9/25/2010 17:51'!setDecimalPlacesFromTypeIn: aString	self labelMorph ifNotNilDo: [:m |		m setDecimalPlacesFromTypeIn: aString]! !!TileMorph methodsFor: 'mouse handling' stamp: 'kks 10/7/2009 23:42'!arrowDelta	"Answer the amount by which a number I display should increase at a time"	| readout |	(readout _ self findA: UpdatingStringMorph) ifNotNil: [^readout floatPrecision ].	^1! !!TileMorph methodsFor: 'mouse handling' stamp: 'kks 10/7/2009 23:42'!decimalPlaces	"Answer the number of decimal places of the contained number"	| readout |	(readout _ self findA: UpdatingStringMorph) ifNotNil: [^readout decimalPlaces ].	^0! !!Time class methodsFor: '*monticello' stamp: 'nk 11/2/2003 10:51'!fromString: aString	^ self readFrom: (ReadStream on: aString).! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47'!fromMethodTimeStamp: aString	| stream |	stream := ReadStream on: aString.	stream skipSeparators.	stream skipTo: Character space.	^self readFrom: stream.! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'nk 10/21/2003 23:05'!fromString: aString	"Answer a new instance for the value given by aString.	 TimeStamp fromString: '1-10-2000 11:55:00 am'. 	"	^self readFrom: (ReadStream on: aString).! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47'!readFrom: stream	| date time |	stream skipSeparators.	date := Date readFrom: stream.	stream skipSeparators.	time := Time readFrom: stream.	^self 		date: date		time: time! !!TimesRepeatMorph methodsFor: 'initialization' stamp: 'sw 12/19/2006 17:45'!initialize	"Fully initialize the receiver."	| dummyColumn timesRow  timesRepeatColumn repeatRow separator repeatLabel placeHolder doLabel ephemerum |	submorphs _ EmptyArray.	bounds _ 0@0 corner: 50@40.	self color: Color orange muchLighter.	self layoutPolicy: TableLayout new.	self "border, and layout properties in alphabetical order..."		borderColor: self color darker;		borderWidth: 2; 		cellSpacing: #none;		cellPositioning: #topLeft;		hResizing: #spaceFill;		layoutInset: 0;		listDirection: #leftToRight;		rubberBandCells: true;		vResizing: #shrinkWrap;		wrapCentering: #none.	self setNameTo: 'Repeat Complex'.	dummyColumn _ AlignmentMorph newColumn.	dummyColumn cellInset: 0; layoutInset: 0.	dummyColumn width: 0.	dummyColumn cellPositioning: #leftCenter.	dummyColumn hResizing: #shrinkWrap; vResizing: #spaceFill.	self addMorph: dummyColumn.	timesRepeatColumn _ AlignmentMorph newColumn.	timesRepeatColumn setNameTo: 'Times Repeat'.	timesRepeatColumn cellPositioning: #topLeft.	timesRepeatColumn hResizing: #spaceFill. 	timesRepeatColumn vResizing: #shrinkWrap.	timesRepeatColumn layoutInset: 0.	timesRepeatColumn borderWidth: 0.	timesRepeatColumn color:  Color orange muchLighter.	timesRow _ AlignmentMorph newRow color: color; layoutInset: 0.	timesRow minCellSize: (2@16).	timesRow setNameTo: 'Times'.	repeatLabel _ StringMorph  contents: 'Repeat' translated font:  Preferences standardEToysFont.	timesRow addMorphBack: repeatLabel.	timesRow vResizing: #shrinkWrap.	timesRow addMorphBack: (Morph new color: color; extent: 6@5).  "spacer"	numberOfTimesToRepeatPart := TilePadMorph new setType: #Number.	numberOfTimesToRepeatPart hResizing: #shrinkWrap; color: Color transparent.	numberOfTimesToRepeatPart addMorphBack: (TileMorph new addArrows; setLiteral: 2).	numberOfTimesToRepeatPart borderWidth: 0; layoutInset: (1@0).	timesRow addMorphBack: numberOfTimesToRepeatPart.	timesRow addMorphBack: (StringMorph  contents: ' times ' font: Preferences standardEToysFont).	timesRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	timesRepeatColumn addMorphBack: timesRow.	separator _ AlignmentMorph newRow color:  Color transparent.	separator vResizing: #rigid; hResizing: #spaceFill; height: 2.	separator borderWidth: 0.	timesRepeatColumn addMorphBack: separator.	repeatRow _ AlignmentMorph newRow color: color; layoutInset: 0.	repeatRow minCellSize: (2@16).	repeatRow setNameTo: 'Repeat '.	placeHolder _ Morph new.	placeHolder beTransparent; extent: (8@0).	repeatRow addMorphBack: placeHolder.	repeatRow vResizing: #shrinkWrap.	doLabel _ StringMorph  contents: 'Do' font: Preferences standardEToysFont.	repeatRow addMorphBack: doLabel.	repeatRow addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	repeatRow addMorphBack: (whatToRepeatPart _ ScriptEditorMorph new borderWidth: 0; layoutInset: 0).	whatToRepeatPart hResizing: #spaceFill.	whatToRepeatPart vResizing: #shrinkWrap.	whatToRepeatPart color: Color transparent.	whatToRepeatPart setNameTo: 'Script to repeat'.	whatToRepeatPart addMorphBack: (ephemerum := Morph new height: 14) beTransparent.	timesRepeatColumn addMorphBack: repeatRow.		self addMorphBack: timesRepeatColumn.	self bounds: self fullBounds.	ephemerum delete! !!TimesRepeatMorph methodsFor: 'initialization' stamp: 'sw 8/16/2005 14:35'!targetPartFor: aMorph	"Return the row into which the given morph should be inserted."	| centerY |	centerY _ aMorph fullBounds center y.	{numberOfTimesToRepeatPart, whatToRepeatPart} do: [:m |		(centerY <= m bounds bottom) ifTrue: [^ m]].	^ noPart! !!TimesRepeatMorph methodsFor: 'access' stamp: 'yo 1/8/2007 21:58'!labelMorphs	| w |	w := WriteStream on: (Array new: 3).	w nextPut: self submorphs second submorphs first submorphs first.	w nextPut: self submorphs second submorphs first submorphs fourth.	w nextPut: self submorphs second submorphs third submorphs second.	^ w contents.! !!TimesRepeatMorph methodsFor: 'code generation' stamp: 'sw 6/23/2007 04:07'!parseNodeWith: encoder	| rec selector arg |	rec _ numberOfTimesToRepeatPart submorphs		ifEmpty:			[encoder encodeLiteral: 0]		ifNotEmpty:			[numberOfTimesToRepeatPart parseNodeWith: encoder].	selector _ #timesRepeat:.	arg _ self blockNode: whatToRepeatPart with: encoder.	^ MessageNode new				receiver: rec				selector: selector				arguments: (Array with: arg)				precedence: (selector precedence)				from: encoder				sourceRange: nil.! !!TimesRepeatMorph methodsFor: 'code generation' stamp: 'yo 3/15/2007 14:03'!sexpWith: dictionary	| n elements e |	n _ SExpElement keyword: #loop.	n attributeAt: #type put: 'repeat'.	elements _ WriteStream on: (Array new: 3).	e _ SExpElement keyword: #initial.	e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '1'; yourself)).	elements nextPut: e.	e _ SExpElement keyword: #increment.	e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '1'; yourself)).	elements nextPut: e.	e _ SExpElement keyword: #test.	numberOfTimesToRepeatPart submorphs		ifEmpty:			[e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '0'; yourself))]		ifNotEmpty:			[e elements: (Array with: (numberOfTimesToRepeatPart sexpWith: dictionary))].	elements nextPut: e.		elements nextPut: (self sexpBlockFor: whatToRepeatPart with: dictionary).	n elements: elements contents.	^ n.! !!TimesRepeatMorph methodsFor: 'code generation' stamp: 'sw 8/18/2005 15:24'!storeCodeOn: aStream indent: tabCount	"Store code representing the receiver on the stream, obeying the tab state."	aStream nextPutAll: '(('.	numberOfTimesToRepeatPart submorphs		ifEmpty:			[aStream nextPutAll: '0']		ifNotEmpty:			[numberOfTimesToRepeatPart storeCodeOn: aStream indent: tabCount + 2].	aStream nextPutAll: ' ) asInteger max: 0) timesRepeat:'.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: '['; cr.	self storeCodeBlockFor: whatToRepeatPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !!TimesRepeatMorph commentStamp: '<historical>' prior: 0!This class is not used anymore. We keep it to let old projects work.If we added code to auto-convert old instances of this classs to TimesRepeatTile instances, we could delete it for good.!!TimesRepeatTile methodsFor: 'initialization' stamp: 'sw 5/20/2008 18:52'!initialize	"Fully initialize the receiver."	| dummyColumn  timesRepeatColumn repeatRow separator placeHolder doLabel ephemerum |	submorphs _ EmptyArray.	bounds _ 0@0 corner: 50@40.	self color: Color orange muchLighter.	self layoutPolicy: TableLayout new.	self "border, and layout properties in alphabetical order..."		borderColor: self color darker;		borderWidth: 2; 		cellSpacing: #none;		cellPositioning: #topLeft;		hResizing: #spaceFill;		layoutInset: 0;		listDirection: #leftToRight;		rubberBandCells: true;		vResizing: #shrinkWrap;		wrapCentering: #none.	self setNameTo: 'Repeat Complex'.	dummyColumn _ AlignmentMorph newColumn.	dummyColumn cellInset: 0; layoutInset: 0.	dummyColumn width: 0.	dummyColumn cellPositioning: #leftCenter.	dummyColumn hResizing: #shrinkWrap; vResizing: #spaceFill.	self addMorph: dummyColumn.	timesRepeatColumn _ AlignmentMorph newColumn.	timesRepeatColumn setNameTo: 'Times Repeat'.	timesRepeatColumn cellPositioning: #topLeft.	timesRepeatColumn hResizing: #spaceFill. 	timesRepeatColumn vResizing: #shrinkWrap.	timesRepeatColumn layoutInset: 0.	timesRepeatColumn borderWidth: 0.	timesRepeatColumn color:  Color orange muchLighter.	timesRow _ TimesRow newRow color: color; layoutInset: 0.	timesRepeatColumn addMorphBack: timesRow.	separator _ AlignmentMorph newRow color:  Color transparent.	separator vResizing: #rigid; hResizing: #spaceFill; height: 2.	separator borderWidth: 0.	timesRepeatColumn addMorphBack: separator.	repeatRow _ AlignmentMorph newRow color: color; layoutInset: 0.	repeatRow minCellSize: (2@16).	repeatRow setNameTo: 'Repeat '.	placeHolder _ Morph new.	placeHolder beTransparent; extent: (8@0).	repeatRow addMorphBack: placeHolder.	repeatRow vResizing: #shrinkWrap.	doLabel _ StringMorph  contents: 'Do' translated font: Preferences standardEToysFont.	repeatRow addMorphBack: doLabel.	repeatRow addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	repeatRow addMorphBack: (whatToRepeatPart _ ScriptEditorMorph new borderWidth: 0; layoutInset: 0).	whatToRepeatPart hResizing: #spaceFill.	whatToRepeatPart vResizing: #shrinkWrap.	whatToRepeatPart color: Color transparent.	whatToRepeatPart setNameTo: 'Script to repeat' translated.	whatToRepeatPart addMorphBack: (ephemerum := Morph new height: 14) beTransparent.	timesRepeatColumn addMorphBack: repeatRow.		self addMorphBack: timesRepeatColumn.	self bounds: self fullBounds.	ephemerum delete! !!TimesRepeatTile methodsFor: 'initialization'!targetPartFor: aMorph	"Return the row into which the given morph should be inserted."	| centerY |	centerY _ aMorph fullBounds center y.	{self numberOfTimesToRepeatPart, whatToRepeatPart} do: [:m |		(centerY <= m bounds bottom) ifTrue: [^ m]].	^ noPart! !!TimesRepeatTile methodsFor: 'code generation' stamp: 'sw 6/23/2007 04:02'!parseNodeWith: encoder	"Answer a MessageNode representing the receiver."	| rec selector arg timesPart |	rec _ (timesPart := self numberOfTimesToRepeatPart) submorphs		ifEmpty:			[encoder encodeLiteral: 0]		ifNotEmpty:			[timesPart parseNodeWith: encoder].	selector _ #timesRepeat:.	arg _ self blockNode: whatToRepeatPart with: encoder.	^ MessageNode new				receiver: rec				selector: selector				arguments: (Array with: arg)				precedence: (selector precedence)				from: encoder				sourceRange: nil! !!TimesRepeatTile methodsFor: 'code generation' stamp: 'sw 6/15/2007 18:36'!sexpWith: dictionary	"Answer an SExpElement representing the receiver."	| n elements e |	n _ SExpElement keyword: #loop.	n attributeAt: #type put: 'repeat'.	elements _ WriteStream on: (Array new: 3).	e _ SExpElement keyword: #initial.	e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '1'; yourself)).	elements nextPut: e.	e _ SExpElement keyword: #increment.	e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '1'; yourself)).	elements nextPut: e.	e _ SExpElement keyword: #test.	self numberOfTimesToRepeatPart submorphs		ifEmpty:			[e elements: (Array with: ((SExpElement keyword: #literal) attributeAt: #value put: '0'; yourself))]		ifNotEmpty:			[e elements: (Array with: (self numberOfTimesToRepeatPart sexpWith: dictionary))].	elements nextPut: e.		elements nextPut: (self sexpBlockFor: whatToRepeatPart with: dictionary).	n elements: elements contents.	^ n.! !!TimesRepeatTile methodsFor: 'code generation' stamp: 'yo 2/20/2008 00:04'!sissComeFullyUpOnReloadFrom: from to: to	whatToRepeatPart borderWidth: 0; layoutInset: 0; hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: Color transparent;		setNameTo: 'Script to repeat'.! !!TimesRepeatTile methodsFor: 'code generation'!storeCodeOn: aStream indent: tabCount	"Store code representing the receiver on the stream, obeying the tab state."	aStream nextPutAll: '(('.	self numberOfTimesToRepeatPart submorphs		ifEmpty:			[aStream nextPutAll: '0']		ifNotEmpty:			[self numberOfTimesToRepeatPart storeCodeOn: aStream indent: tabCount + 2].	aStream nextPutAll: ' ) asInteger max: 0) timesRepeat:'.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: '['; cr.	self storeCodeBlockFor: whatToRepeatPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !!TimesRepeatTile methodsFor: 'access' stamp: 'sw 6/15/2007 18:07'!labelMorphs	"Answer a list of the StringMorphs that constitute the user-visible labels in the receiver's interior -- in this case, the StringMorphs showing the words Repeat, times, and Do."	| w |	w := WriteStream on: (Array new: 3).	w nextPut: self submorphs second submorphs first submorphs first.	w nextPut: self submorphs second submorphs first submorphs fourth.	w nextPut: self submorphs second submorphs third submorphs second.	^ w contents"TimesRepeatTile new labelMorphs collect: [:m | m contents]"! !!TimesRepeatTile methodsFor: 'access'!numberOfTimesToRepeatPart	"Answer the TilePadMorph which holds the tiles defining the number of times to repeat"	^ timesRow timesPad ! !!TimesRepeatTile commentStamp: 'sw 6/15/2007 18:39' prior: 0!A variant on the CompoundTileMorph that allows a section of code to be executed as many times as a numeric-control-field indicates.  For reasons of sharing and history, the CompoundTileMorph continues to be the one for test/yes/no, and this subclass disregards those three areas and adds two of its own.  An associated class is the TimesRow -- see its class comment.!!TimesRow methodsFor: 'accessing' stamp: 'Richo 6/29/2010 00:51'!timesPad	"Answer the TilePadMorph at the top of the tile	tree for the times part. Guard against repeating	less than 0 times"	| number |	timesPad submorphs isEmpty ifTrue: [		timesPad addMorphBack: (TileMorph new addArrows; setLiteral: 0; addSuffixArrow; yourself)	].	((number := timesPad submorphs first) isKindOf: TileMorph)		ifTrue: [number literal < 0				ifTrue: [number literal: 0]].	^ timesPad! !!TimesRow methodsFor: 'initialization' stamp: 'sw 5/28/2008 18:05'!initialize	"object initialization"	| repeatLabel |	super initialize.	self minCellSize: (2@16).	self setNameTo: 'Times'.	repeatLabel _ StringMorph  contents: 'Repeat' translated font:  Preferences standardEToysFont.	self addMorphBack: repeatLabel.	self vResizing: #shrinkWrap.	self addTransparentSpacerOfSize: (6@5).	timesPad := TilePadMorph new setType: #Number.	timesPad hResizing: #shrinkWrap; color: Color transparent.	timesPad addMorphBack: (TileMorph new addArrows; setLiteral: 2; addSuffixArrow; yourself).	timesPad borderWidth: 0; layoutInset: (1@0).	self addMorphBack: timesPad.	self addMorphBack: (StringMorph  contents: (' ', ('times' translated), ' ') font: Preferences standardEToysFont).	self addMorphBack: AlignmentMorph newVariableTransparentSpacer! !!TimesRow methodsFor: 'retract-arrow processing' stamp: 'sw 6/14/2007 19:18'!replaceSubmorph: existingMorph by: newMorph	"Replace a submorph by a different morph. Fix up my  inst vars as appropriate."	super replaceSubmorph: existingMorph by: newMorph.	(newMorph isKindOf: TilePadMorph)		ifTrue:			[timesPad := newMorph]! !!TimesRow commentStamp: 'sw 6/14/2007 19:15' prior: 0!A custom alignment morph that holds the "times' portion of a Times/Repeat complex!!TranscriptStream methodsFor: 'private' stamp: 'dtl 2/10/2010 17:32'!countOpenTranscripts	"Transcript countOpenTranscripts"	^ (self dependents select: [:e | e isTextView]) size! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'kfr 4/25/2010 10:58'!resistsRemoval	| m |	^ ((m _ self renderedMorph) == self) ifTrue: [false] ifFalse: [m resistsRemoval].! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'kfr 4/25/2010 11:08'!willingToBeDiscarded	| m |	^ ((m _ self renderedMorph) == self) ifTrue: [false] ifFalse: [m willingToBeDiscarded].! !!TranslatedReceiverFinder methodsFor: 'accessing' stamp: 'tak 9/27/2007 15:59'!findWordsWith: aSymbol in: aMethodReference 	"Find words for translation with the symbol in a method. See	LanguageEditorTest >>testFindTranslatedWords"	"| message | 	message := MethodReference new setStandardClass: Morph class	methodSymbol: #supplementaryPartsDescriptions.	self new findWordsWIth: #translatedNoop in: message"	| messages keywords aParseNode |	aParseNode := aMethodReference decompile.	"Find from string literal"	messages := Set new.	self		search: aSymbol		messageNode: aParseNode		addTo: messages.	keywords := OrderedCollection new.	messages		select: [:aMessageNode | aMessageNode receiver isMemberOf: LiteralNode]		thenDo: [:aMessageNode | aMessageNode receiver key				literalStringsDo: [:literal | keywords add: literal]].	"Find from array literal"	self		arraySearch: aSymbol		messageNode: aParseNode		addTo: keywords.	^ keywords! !!TranslatedReceiverFinder methodsFor: 'accessing' stamp: 'tak 7/24/2007 14:52'!nonLiteralReceivers	"self new nonLiteralReceivers"	| receivers |	"Answer method references of non literal senders of #translated"	^ (SystemNavigation default allCallsOn: #translated)		select: [:message | 			receivers := OrderedCollection new.			self search: #translated messageNode: message decompile addTo: receivers.			receivers				anySatisfy: [:each | (each receiver isMemberOf: LiteralNode) not]]! !!TranslatedReceiverFinder methodsFor: 'accessing' stamp: 'tak 7/24/2007 14:53'!stringReceivers	"TranslatedReceiverFinder new stringReceivers"	| stringReceivers messages |	messages := Set new.	(SystemNavigation default allCallsOn: #translated)		do: [:message | self search: #translated messageNode: message decompile addTo: messages].	stringReceivers := messages				select: [:each | each receiver isMemberOf: LiteralNode]				thenCollect: [:each | each receiver key].	^ stringReceivers asArray sort! !!TranslatedReceiverFinder methodsFor: 'accessing' stamp: 'KR 7/11/2007 02:06'!stringReceiversWithContext	| mrs results rr cls mn t o |	mrs _ SystemNavigation default allCallsOn: #translated.	results _ OrderedCollection new.	mrs do: [:mr |		rr _ OrderedCollection new.		cls _ Smalltalk at: mr classSymbol.		rr add: cls category.		rr add: mr classSymbol.		rr add: mr methodSymbol.		mr classIsMeta ifTrue: [			mn _  cls class decompile: mr methodSymbol.		] ifFalse: [			mn _ cls decompile: mr methodSymbol.		].		o _ OrderedCollection new.		t _ Set new.		self searchMessageNode: mn addTo: t.		t do: [ :te |			(te receiver isMemberOf: LiteralNode) ifTrue: [ 			    o add: te receiver key.			].		].		o ifNotEmpty: [			rr add: o.			results add: rr.		].	].	^ results.! !!TranslatedReceiverFinder methodsFor: 'accessing' stamp: 'tak 9/27/2007 15:59'!stringReceiversWithContext: aSymbol	"Find string receivers for a symbol.	Answer a collection of aMethodReference -> {keyword. keyword...}"	"self new stringReceiversWithContext: #translated"	| keywords methodReferences |	methodReferences _ SystemNavigation default allCallsOn: aSymbol.	^ methodReferences inject: OrderedCollection new into: [:list :next |		keywords := self findWordsWith: aSymbol in: next.		keywords			ifNotEmpty: [list add: next -> keywords].		list]! !!TranslatedReceiverFinder methodsFor: 'private' stamp: 'tak 7/30/2007 15:22'!arraySearch: aSymbol fromArray: anArray addTo: aCollection 	"Find literals ahead of aSymbol from arrays in the method."	"BUG: it can handle just one occurrence"	"self new arraySearch: #hello fromArray: #(ignore (ignore detected	hello ignore)) addTo: Set new"	| index |	(index := anArray identityIndexOf: aSymbol) > 1		ifTrue: [aCollection add: (anArray at: index - 1) asString].	(anArray		select: [:each | each isMemberOf: Array])		do: [:each | self				arraySearch: aSymbol				fromArray: each				addTo: aCollection].	^ aCollection! !!TranslatedReceiverFinder methodsFor: 'private' stamp: 'tak 7/30/2007 15:27'!arraySearch: aSymbol messageNode: aParseNode addTo: aCollection 	"Find literals ahead of aSymbol from arrays in the method."	"self new arraySearch: #hello messageNode: (self	decompile: #arraySearch:messageNode:addTo:) addTo: Set new"	self flag: #(#ignore #detected #hello ).	((aParseNode isMemberOf: LiteralNode)			and: [aParseNode key isMemberOf: Array])		ifTrue: [self				arraySearch: aSymbol				fromArray: aParseNode key				addTo: aCollection].	(aParseNode notNil			and: [aParseNode isLeaf not])		ifTrue: [aParseNode getAllChildren				do: [:child | self						arraySearch: aSymbol						messageNode: child						addTo: aCollection]].	^ aCollection! !!TranslatedReceiverFinder methodsFor: 'private' stamp: 'tak 7/24/2007 17:15'!search: aSymbol messageNode: aParseNode addTo: aCollection 	"self new search: #translated messageNode: (Project decompile: #updateLocaleDependentsWithPreviousSupplies:gently:) addTo: OrderedCollection new"	((aParseNode isMemberOf: MessageNode)			and: [(aParseNode selector isMemberOf: SelectorNode)					and: [aParseNode selector key = aSymbol]])		ifTrue: [aCollection add: aParseNode].	(aParseNode notNil			and: [aParseNode isLeaf not])		ifTrue: [aParseNode getAllChildren				do: [:child | self						search: aSymbol						messageNode: child						addTo: aCollection]].	^ aCollection! !!TranslatedReceiverFinder class methodsFor: 'utilities' stamp: 'tak 11/8/2006 19:45'!browseNonLiteralReceivers	"TranslatedReceiverFinder browseNonLiteralReceivers"	SystemNavigation default		browseMessageList: self new nonLiteralReceivers  asSortedCollection		name: 'Non literal receivers of #translated'		autoSelect: 'translated'! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:35'!ascent	ascent ifNil:[ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y].	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:43'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := (ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender)) * Scale y + 1].! !!TTCFont methodsFor: 'accessing' stamp: 'yo 5/6/2004 19:25'!emphasis	"Answer the emphasis code (0 to 3) corresponding to my subfamily name"	^self indexOfSubfamilyName: self subfamilyName! !!TTCFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 01:25'!fallbackFont	^ fallbackFont		ifNil: [fallbackFont := FixedFaceFont new errorFont fontSize: self height]! !!TTCFont methodsFor: 'accessing' stamp: 'dgd 5/19/2007 16:20'!fallbackFont: aFontSetOrNil	aFontSetOrNil == self		ifTrue:[^ self error: 'Invalid fallback font'].	fallbackFont := aFontSetOrNil.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:44'!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize * Scale y]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!maxAscii	"Answer the max. code point in this font. The name of this method is historical."	^maxAscii ifNil:[ttcDescription size].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!minAscii	"Answer the min. code point in this font. The name of this method is historical."	^ 0.! !!TTCFont methodsFor: 'accessing' stamp: 'Richo 5/30/2010 17:03'!textStyle	^ TextStyle actualTextStyles		detect: [:aStyle | (aStyle fontArray collect: [:s | s name]) includes: self name]		ifNone: [].! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!cache	^cache! !!TTCFont methodsFor: 'friend' stamp: 'yo 5/6/2004 19:54'!derivativeFontArray	^ derivatives.! !!TTCFont methodsFor: 'friend' stamp: 'yo 8/3/2005 07:46'!derivativeFont: aTTCFont	| index |	index := self indexOfSubfamilyName: (aTTCFont subfamilyName).	index < 1 ifTrue: [		^ self "inform: 'unknown sub family name.  This font will be skipped'".	].	self derivativeFont: aTTCFont at: index.	self addLined: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'yo 5/7/2004 12:40'!derivativeFont: aTTCFont at: index	| newDeriv |	aTTCFont ifNil: [derivatives := nil. ^ self].	derivatives ifNil: [derivatives := Array new: 32].	derivatives size < 32 ifTrue: [		newDeriv := Array new: 32.		newDeriv replaceFrom: 1 to: derivatives size with: derivatives.		derivatives := newDeriv.	].	derivatives at: index put: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:40'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| form glyphInfo destX destY hereX nextX actualFont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo at: 1.		hereX := glyphInfo at: 2.		nextX := glyphInfo at: 3.		(actualFont := glyphInfo at: 5) ==  aBitBlt lastFont			ifFalse: [actualFont installOn: aBitBlt].		destY := baselineY - (glyphInfo at: 4). 		aBitBlt sourceForm: form.		aBitBlt destX: destX.		aBitBlt destY: destY.		aBitBlt sourceX: hereX; sourceY: 0.		aBitBlt width: nextX - hereX.		aBitBlt height: form height.		aBitBlt copyBits.		destX := destX + (nextX - hereX) + kernDelta.	].	^ destX @ destY! !!TTCFont methodsFor: 'friend' stamp: 'yo 11/16/2002 01:00'!initialize	foregroundColor := Color black.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:26'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	self foregroundColor: fgColor. "install color"	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'yo 8/3/2005 07:44'!setupDefaultFallbackFontTo: aTextStyleOrNil"	TTCFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'MultiMSMincho')]."	| fonts f |	aTextStyleOrNil ifNil: [		self fallbackFont: nil.		^ self.	].	fonts := aTextStyleOrNil fontArray.	(aTextStyleOrNil defaultFont familyName endsWith: self familyName) ifTrue: [fallbackFont := nil. ^ self].	f := fonts first.	1 to: fonts size do: [:i |		self height >= (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'Richo 6/4/2010 07:59'!setupDefaultFallbackTextStyleTo: aTextStyle	| fonts f |	aTextStyle isNil ifTrue: [^self].	fonts _ aTextStyle fontArray.	f _ fonts first.	f familyName = self familyName ifTrue: [^ self].	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self flushCache.! !!TTCFont methodsFor: 'objects from disk' stamp: 'nk 4/2/2004 11:29'!convertToCurrentVersion: varDict refStream: smartRefStrm	"If we're reading in an old version with a pixelSize instance variable, convert it to a point size."	"Deal with the change from pixelSize to pointSize, assuming the current monitor dpi."	varDict at: 'pixelSize' ifPresent: [ :x | 		pointSize := (TextStyle pixelsToPoints: x) rounded.	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TTCFont methodsFor: 'objects from disk' stamp: 'yo 3/17/2005 11:21'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write areference to a known FontSet in the other system instead."	"a path to me"	dp := DiskProxy global: #TTCFont selector: #familyName:pointSize:emphasis:			args: {self familyName. self pointSize. self emphasis}.	refStrm replace: self with: dp.	^ dp.! !!TTCFont methodsFor: 'public' stamp: 'ar 7/30/2009 21:48'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !!TTCFont methodsFor: 'testing' stamp: 'yo 5/6/2004 19:25'!isRegular	"Answer true if I am a Regular/Roman font (i.e. not bold, etc.)"	^ (self indexOfSubfamilyName: (self subfamilyName)) = 0.! !!TTCFont methodsFor: 'private' stamp: 'yo 5/7/2004 12:23'!addLined: aTTCFont	| l |	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 4.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 16.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 20.	self derivativeFont: l at: l emphasis.! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:19'!at: char put: form	| assoc |	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:42'!computeForm: char	| ttGlyph scale |	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	Scale ifNotNil: [scale := Scale * scale].	ttGlyph := ttcDescription at: (char isCharacter ifTrue: [char charCode] ifFalse: [char]).	^ ttGlyph ifNotNil:[ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth].! !!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:47'!formOf: char	| code form |	char charCode > self maxAscii		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		form ifNil:[^nil].		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !!TTCFont methodsFor: 'private' stamp: 'Richo 6/8/2010 13:52'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: self ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:47'!hasGlyphOf: aCharacter	"Answer whether this font includes a glyph for the given character"	^ aCharacter charCode <= self maxAscii		and:[(self formOf: aCharacter) notNil]! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:17'!flushCache	"Flush the cache of this font"	cache := foregroundColor := colorToCacheMap := nil.! !!TTCFont methodsFor: 'initialize' stamp: 'ar 6/2/2007 21:14'!foregroundColor: fgColor	"Install the given foreground color"	foregroundColor = fgColor ifFalse:[		foregroundColor := fgColor.		colorToCacheMap ifNil:[colorToCacheMap := Dictionary new].		cache := colorToCacheMap at: fgColor ifAbsentPut:[WeakArray new: self maxAscii+1].		ShutdownList ifNotNil:[ShutdownList add: self].	].! !!TTCFont methodsFor: 'emphasis' stamp: 'dgd 5/19/2007 16:19'!setupDefaultFallbackFont	| fonts f |	fonts := TextStyle default fontArray.	f := fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f := fonts at: i].	].	(f == self)		ifFalse:[ self fallbackFont: f ].	self reset.! !!TTCFont methodsFor: 'html' stamp: 'dgd 9/2/2005 12:39'!closeHtmlOn: aStream 	"put on the given stream the tag to close the html  	representation of the receiver"	self htmlSize isZero		ifFalse: [aStream nextPutAll: '</font>']! !!TTCFont methodsFor: 'html' stamp: 'dgd 9/2/2005 11:19'!htmlSize"private - answer the size in html form, assumes 12 as default size"	^ (self pointSize - 12 / 3) rounded! !!TTCFont methodsFor: 'html' stamp: 'dgd 9/2/2005 12:38'!openHtmlOn: aStream 	"put on the given stream the tag to open the html  	representation of the receiver"	| size |	size := self htmlSize.	size isZero		ifFalse: [aStream nextPutAll: '<font size="' , size asString , '">']! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'instance creation' stamp: 'yo 8/1/2005 15:06'!familyName: n pointSize: s emphasis: code	"(TTCFont familyName: 'BitstreamVeraSans' pointSize: 12 emphasis: 0)"	| t ret index |	t := self registry at: n asSymbol ifAbsent: [#()].	t isEmpty ifTrue: [		t := (TextConstants at: #DefaultTextStyle) fontArray.		ret := t first.		ret pointSize >= s ifTrue: [^ ret emphasis: code].		index := 2.		[index <= t size and: [(t at: index) pointSize <= s]] whileTrue: [			ret := t at: index.			index := index + 1.		].		^ ret emphasis: code.	].	^ ((TextStyle named: n) addNewFontSize: s) emphasis: code.! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 6/23/2003 18:44'!family: f size: s	^ self allInstances detect: [:a | a familyName = f and: [a pointSize = s]] ifNone: [nil].! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 12/13/2002 12:20'!getExistings: fontArray	| result em |	result := OrderedCollection new.	result add: fontArray.	1 to: 3 do: [:i |		em := (fontArray collect: [:f | f emphasized: i]).		(em at: 1) ~= (fontArray at: 1) ifTrue: [			result add: em.		].	].	^ result asArray.! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 11/8/2004 19:27'!newTextStyleFromTTFile: fileName	"Create a new TextStyle from specified file name.  On certain versions of Windows, you can evaluate following to get Arial font into the image.  On other platforms, wait and see someone implements the support code for FontPlugin then we can start relying on the generic font lookup mechanism.	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.TTF'.	"	| description |	description := TTFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'tb 6/24/2003 17:12'!newTextStyleFromTTStream: readStream""	| description |	description := TTFontDescription addFromTTStream: readStream.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 10/9/2005 13:05'!reorganizeForNewFontArray: array name: styleName	| style existings regular altName |	(TextConstants includesKey: styleName) ifFalse: [		TextConstants at: styleName put: (TextStyle fontArray: array).		^ TextConstants at: styleName.	]. 	"There is a text style with the name I want to use.  See if it is a TTC font..."	style := TextConstants at: styleName.	style isTTCStyle ifFalse: [		altName := ((array at: 1) name, 'TT') asSymbol.		^ self reorganizeForNewFontArray: array name: altName.	].	existings := (self getExistings: style fontArray), (Array with: array).	regular := existings detect: [:e | (e at: 1) isRegular] ifNone: [existings at: 1].	regular do: [:r |		r addLined: r.	].	"The existing array may be different in size than the new one."	existings do: [:e |		(e at: 1) isRegular ifFalse: [			regular do: [ :r | | f |				f := e detect: [ :ea | ea pointSize = r pointSize ] ifNone: [ ].				f ifNotNil: [ r derivativeFont: f ].			].		].	].	style newFontArray: regular.	self register: regular at: styleName.	self recreateCache.		^ style.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:48'!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:28'!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.	ShutdownList ifNotNil:[ShutdownList do:[:fnt| fnt flushCache]].	ShutdownList := WeakSet new.! !!TTCFont class methodsFor: 'other' stamp: 'ar 11/14/2006 15:19'!recreateCache"	self recreateCache."	self allSubInstances do: [:inst | inst flushCache].	Smalltalk garbageCollect.! !!TTCFont class methodsFor: 'other' stamp: 'yo 3/17/2005 11:11'!registerAll"	TTCFont registerAll"	TextStyle allInstancesDo: [:e |		(e fontArray first isMemberOf: TTCFont) ifTrue: [			self register: e fontArray at: e fontArray first familyName asSymbol.		].	].! !!TTCFont class methodsFor: 'other' stamp: 'yo 11/30/2002 22:37'!removeStyleName: aString	TextConstants removeKey: aString asSymbol ifAbsent: [].	TTFontDescription removeDescriptionNamed: aString asString.! !!TTCFont class methodsFor: 'other' stamp: 'nk 4/13/2004 17:56'!repairBadSizes	"There was a bug that would cause the TTCFonts to generate incorrectly sized glyphs.	By looking at the dimensions of cached forms,	we can tell whether the incorrect height logic was used.	If it was, change the point size of the font and its derivatives.		Note that this is probably pointless to call after the new code has been loaded; it's here for documentation (it should be called from the CS preamble instead)."	"TTCFont repairBadSizes"	| description computedScale cached desiredScale newPointSize repaired |	repaired := OrderedCollection new.	TTCFont allInstancesDo: [ :font |		cached := (font cache copyFrom: $A asciiValue + 1 to: $z asciiValue + 1)			detect: [ :f | f notNil ] ifNone: [].		cached := cached ifNil: [  font formOf: $A ] ifNotNil: [ cached value ].		description := font ttcDescription.		desiredScale := cached height asFloat / (description ascender - description descender).		computedScale := font pixelSize asFloat / font ttcDescription unitsPerEm.		(((computedScale / desiredScale) - 1.0 * cached height) abs < 1.0) ifFalse: [			newPointSize := (font pointSize * desiredScale / computedScale) rounded.			font pointSize: newPointSize; flushCache.			repaired add: font.			font derivativeFonts do: [ :df | df ifNotNil: [				df pointSize: newPointSize; flushCache.				repaired add: df. ]].		].	].	repaired isEmpty ifFalse: [ repaired asArray inspect ].! !!TTCFont class methodsFor: 'other' stamp: 'yo 2/17/2004 14:40'!scale: anObject	Scale := anObject.! !!TTCFont class methodsFor: 'file list services'!serviceInstallTrueTypeFontStyle	"Return a service to install a true type font as a text style"	^ SimpleServiceEntry		provider: self		label: 'install ttf style'		selector: #newTextStyleFromTTFile: 		description: 'install a true type font as a text style'		buttonLabel: 'install ttf'! !!TTCompositeGlyph methodsFor: 'initialize' stamp: 'bf 6/3/2009 14:55'!referenceVertexAt: index	"Only used while reading before constructing contours"	| i p |	i := index.	self glyphsAndTransformationsDo: [:glyph :transform |		p := glyph referenceVertexAt: i.		p isPoint			ifTrue: [^transform localPointToGlobal: p].		i := i - p].	self error: ['this should not happen']! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 7/30/2009 17:06'!buildAllContours	"Build the contours in all non-composite glyphs."	glyphs do:[:assoc| assoc value buildAllContours].! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:31'!ascender	"Ascender of the font. Relative to unitsPerEm."	^ascender! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:33'!at: charOrCode	"Compatibility with TTFontDescription"	^self glyphAt: charOrCode! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:31'!descender	"Descender of the font. Relative to unitsPerEm."	^descender! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:52'!familyName	"The family name for the font"	^familyName! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/30/2009 20:23'!fileName	"The name of the Truetype file"	^fileName! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:31'!lineGap	"Ascender of the font. Relative to unitsPerEm."	^lineGap! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/30/2009 14:16'!name	"For compatibility with TTFontDescription"	^familyName! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:32'!numGlyphs	"The number of glyphs represented in this font"	^numGlyphs! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/30/2009 00:16'!size	"Compatibility with TTFontDescription"	^16rFFFF! !!TTFileDescription methodsFor: 'accessing' stamp: 'ar 7/29/2009 23:52'!subfamilyName	"The subfamily name for the font"	^subfamilyName! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/30/2009 17:05'!childGlyphAt: glyphIndex in: glyphCache fromFile: fontFile	"Get the glyph with the given glyph index. Look in cache first, then read from file.	Ensure file is positioned at point where it was when it came here."	^glyphCache at: glyphIndex ifAbsentPut:[ | glyph filePos |		filePos := fontFile position.		glyph := self readGlyphAt: glyphIndex fromFile: fontFile.		fontFile position: filePos.		glyph].! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/29/2009 21:41'!getGlyphFlagsFrom: fontFile size: nPts	"Read in the flags for this glyph.  The outer loop gathers the flags that	are actually contained in the table.  If the repeat bit is set in a flag	then the next byte is read from the table; this is the number of times	to repeat the last flag.  The inner loop does this, incrementing the	outer loops index each time."	| flags index repCount flagBits |	flags := ByteArray new: nPts.	index := 1.	[index <= nPts] whileTrue:[		flagBits := fontFile next.		flags at: index put: flagBits.		(flagBits bitAnd: 8) = 8 ifTrue:[			repCount := fontFile next.			repCount timesRepeat:[				index := index + 1.				flags at: index put: flagBits]].		index := index + 1].	^flags! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/30/2009 21:40'!glyphAt: charOrCode	"Answer the glyph with the given code point"	| codePoint glyphIndex glyph |	codePoint := charOrCode asCharacter charCode.	self withFileDo:[:fontFile|		glyphIndex := self readCmapTableAt: codePoint fromFile: fontFile.		glyph := self readGlyphAt: glyphIndex fromFile: fontFile.		self updateGlyphMetrics: glyph fromFile: fontFile.	].	^glyph! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/30/2009 17:03'!processCompositeGlyph: glyph contours: nContours from: fontFile	"Read a composite glyph from the font data. The glyph passed into this method contains some state variables that must be copied into the resulting composite glyph."	| flags glyphIndex hasInstr ofsX ofsY iLen a11 a12 a21 a22 m glyphCache |	glyphCache := Dictionary new.	a11 := a22 := 16r4000.	"1.0 in F2Dot14"	a21 := a12 := 0.			"0.0 in F2Dot14"	"Copy state"	hasInstr := false.	[ flags := fontFile nextNumber: 2.	glyphIndex := fontFile nextNumber: 2.	(flags bitAnd: 1) = 1 ifTrue:[		ofsX := self short: (fontFile nextNumber: 2).		ofsY := self short: (fontFile nextNumber: 2).	] ifFalse:[		(ofsX := fontFile next) > 127 ifTrue:[ofsX := ofsX - 256].		(ofsY := fontFile next) > 127 ifTrue:[ofsY := ofsY - 256].	].	((flags bitAnd: 2) = 2) ifFalse:[		| i1 i2 p1 p2 |		(flags bitAnd: 1) = 1 ifTrue: [			i1 := ofsX + 65536 \\ 65536.			i2 := ofsY + 65536 \\ 65536]		 ifFalse: [			i1 := ofsX + 256 \\ 256.			i2 := ofsY + 256 \\ 256].		p1 := glyph referenceVertexAt: i1+1.		p2 := (self childGlyphAt: glyphIndex in: glyphCache fromFile: fontFile) referenceVertexAt: i2+1.		ofsX := p1 x - p2 x.		ofsY := p1 y - p2 y.	].	(flags bitAnd: 8) = 8 ifTrue:[		a11 := a22 := self short: (fontFile nextNumber: 2)].	(flags bitAnd: 64) = 64 ifTrue:[		a11 := self short: (fontFile nextNumber: 2).		a22 := self short: (fontFile nextNumber: 2).	].	(flags bitAnd: 128) = 128 ifTrue:[		"2x2 transformation"		a11 := self short: (fontFile nextNumber: 2).		a21 := self short: (fontFile nextNumber: 2).		a12 := self short: (fontFile nextNumber: 2).		a22 := self short: (fontFile nextNumber: 2).	].	m := MatrixTransform2x3 new.	"Convert entries from F2Dot14 to float"	m a11: (a11 asFloat / 16r4000).	m a12: (a12 asFloat / 16r4000).	m a21: (a21 asFloat / 16r4000).	m a22: (a22 asFloat / 16r4000).	m a13: ofsX.	m a23: ofsY.	glyph addGlyph: (self childGlyphAt: glyphIndex in: glyphCache fromFile: fontFile) transformation: m.	hasInstr := hasInstr or:[ (flags bitAnd: 256) = 256].	"Continue as long as the MORE:=COMPONENTS bit is set"	(flags bitAnd: 32) = 32] whileTrue.	hasInstr ifTrue:[		iLen := fontFile nextNumber: 2.		fontFile skip: iLen].! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/30/2009 17:37'!processSimpleGlyph: glyph contours: nContours from: fontFile	"Construct a simple glyph frm the font file"	| endPts  nPts iLength flags |	endPts := Array new: nContours.	1 to: nContours do:[:i| endPts at: i put: (fontFile nextNumber: 2)].	glyph initializeContours: nContours with: endPts.	nContours = 0 ifTrue:[^self].	nPts := endPts last + 1.	iLength := fontFile nextNumber: 2. "instruction length"	fontFile skip: iLength.	flags := self getGlyphFlagsFrom: fontFile size: nPts.	self readGlyphXCoords: fontFile glyph: glyph nContours: nContours flags: flags endPoints: endPts.	self readGlyphYCoords: fontFile glyph: glyph nContours: nContours flags: flags endPoints: endPts.! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/29/2009 23:19'!readCmapTableAt: codePoint fromFile: fontFile	| cmapFmt length firstCode entryCount segCount segIndex  startCode endCode idDelta idRangeOffset offset |	fontFile position: cmapOffset.	cmapFmt := fontFile nextNumber: 2.	length := fontFile nextNumber: 2.	fontFile skip: 2. "skip version"	cmapFmt = 0 ifTrue:["byte encoded table"		codePoint > 255 ifTrue:[^0].		length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^0].	"but sometimes, this table is empty"		fontFile skip: codePoint.		"move to correct byte offset in table"		^fontFile next].	cmapFmt = 4 ifTrue:[ "segment mapping to deltavalues"		codePoint > 16rFFFF ifTrue:[^0].		segCount := (fontFile nextNumber: 2) // 2.		fontFile skip: 6. "skip searchRange, entrySelector, rangeShift"		segIndex := (0 to: segCount-1) 			detect:[:i| (endCode := (fontFile nextNumber: 2)) >= codePoint].		fontFile position: cmapOffset + 16 + (segCount*2) + (segIndex*2).		startCode := fontFile nextNumber: 2.		startCode <= codePoint ifFalse:[^0]. "not in segment range"		fontFile position: cmapOffset + 16 + (segCount*4) + (segIndex*2).		idDelta := fontFile nextNumber: 2.		fontFile position: cmapOffset + 16 + (segCount*6) + (segIndex*2).		idRangeOffset := fontFile nextNumber: 2.		idRangeOffset = 0 ifTrue:[^(idDelta + codePoint) bitAnd: 16rFFFF].		offset := (fontFile position - 2) + idRangeOffset + ((codePoint - startCode) * 2).		fontFile position: offset.		^fontFile nextNumber: 2.	].	cmapFmt = 6 ifTrue:[ "trimmed table"		firstCode := fontFile nextNumber: 2.		entryCount := fontFile nextNumber: 2.		(codePoint between: firstCode and: firstCode+entryCount) ifFalse:[^0].		fontFile skip: (codePoint-firstCode) * 2.		^fontFile nextNumber: 2].	^0! !!TTFileDescription methodsFor: 'glyphs' stamp: 'Richo 6/8/2010 13:35'!readGlyphAt: glyphIndex	| glyph |	self withFileDo:[:fontFile|		glyph := self readGlyphAt: glyphIndex fromFile: fontFile.		self updateGlyphMetrics: glyph fromFile: fontFile.	].	^glyph! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/30/2009 17:06'!readGlyphAt: glyphIndex fromFile: fontFile	"Answer the glyph with the given glyph index"	| glyphOffset nextOffset glyphLength glyph nContours left top right bottom |	indexToLocFormat = 0 ifTrue:["Format0: offset/2 is stored"		fontFile position: indexToLocOffset+(glyphIndex * 2).		glyphOffset := (fontFile nextNumber: 2) * 2.		nextOffset := (fontFile nextNumber: 2) * 2.	] ifFalse:["Format1: store actual offset"		fontFile position: indexToLocOffset+(glyphIndex * 4).		glyphOffset := fontFile nextNumber: 4.		nextOffset := fontFile nextNumber: 4.	].	glyphLength := nextOffset - glyphOffset.	glyphLength = 0 ifTrue:[^TTGlyph new glyphIndex: glyphIndex].	fontFile position: glyphTableOffset+glyphOffset.	nContours := self short: (fontFile nextNumber: 2).	left := self short: (fontFile nextNumber: 2).	top := self short: (fontFile nextNumber: 2).	right := self short: (fontFile nextNumber: 2).	bottom := self short: (fontFile nextNumber: 2).	nContours >= 0 ifTrue:[		glyph := TTGlyph new glyphIndex: glyphIndex.		self processSimpleGlyph: glyph contours: nContours from: fontFile.	] ifFalse:[		glyph := TTCompositeGlyph new glyphIndex: glyphIndex.		self processCompositeGlyph: glyph contours: nContours from: fontFile.	].	glyph buildAllContours.	glyph bounds: (left@top corner: right@bottom).	^glyph! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/29/2009 21:42'!readGlyphXCoords: fontFile glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the x coordinates for the given glyph from the font file."	| startPoint endPoint flagBits xValue contour ttPoint |	startPoint := 1.	1 to: nContours do:[:i|		contour := glyph contours at: i.		"Get the end point"		endPoint := (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint := contour points at: (j - startPoint + 1).			flagBits := flags at: j.			"If bit zero in the flag is set then this point is an on-curve			point, if not, then it is an off-curve point."			(flagBits bitAnd: 1) = 1 				ifTrue:[ ttPoint type: #OnCurve]				ifFalse:[ttPoint type: #OffCurve].			"First we check to see if bit one is set.  This would indicate that			the corresponding coordinate data in the table is 1 byte long.			If the bit is not set, then the coordinate data is 2 bytes long."			(flagBits bitAnd: 2) = 2 ifTrue:[ "one byte"				xValue := fontFile next.				xValue := (flagBits bitAnd: 16)=16 ifTrue:[xValue] ifFalse:[xValue negated].				ttPoint x: xValue.			] ifFalse:[ "two byte"				"If bit four is set, then this coordinate is the same as the				last one, so the relative offset (of zero) is stored.  If bit				is not set, then read in two bytes and store it as a signed value."				(flagBits bitAnd: 16) = 16 ifTrue:[ ttPoint x: 0 ]				ifFalse:[					xValue := self short: (fontFile nextNumber: 2).					ttPoint x: xValue]]].		startPoint := endPoint + 1]! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/29/2009 21:44'!readGlyphYCoords: fontFile glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the y coordinates for the given glyph from the font file."	| startPoint endPoint flagBits yValue contour ttPoint |	startPoint := 1.	1 to: nContours do:[:i|		contour := glyph contours at: i.		"Get the end point"		endPoint := (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint := contour points at: (j - startPoint + 1).			flagBits := flags at: j.			"Check if this value one or two byte encoded"			(flagBits bitAnd: 4) = 4 ifTrue:[ "one byte"				yValue := fontFile next.				yValue := (flagBits bitAnd: 32)=32 ifTrue:[yValue] ifFalse:[yValue negated].				ttPoint y: yValue.			] ifFalse:[ "two byte"				(flagBits bitAnd: 32) = 32 ifTrue:[ ttPoint y: 0 ]				ifFalse:[					yValue := self short: (fontFile nextNumber: 2).					ttPoint y: yValue]]].		startPoint := endPoint + 1]! !!TTFileDescription methodsFor: 'glyphs' stamp: 'ar 7/29/2009 23:51'!updateGlyphMetrics: glyph fromFile: fontFile	"Update the horizontal metrics for the given glyph"	| glyphIndex |	glyphIndex := glyph glyphIndex.	glyphIndex <= numHMetrics ifTrue:[		fontFile position: hmtxTableOffset + (glyphIndex*4).		glyph advanceWidth: (fontFile nextNumber: 2).		glyph leftSideBearing: (self short: (fontFile nextNumber: 2)).	] ifFalse:[		fontFile position: hmtxTableOffset + ((numHMetrics-1) *4).		glyph advanceWidth: (fontFile nextNumber: 2).		fontFile position: hmtxTableOffset + (numHMetrics * 4) + ((glyphIndex-numHMetrics)*2).		glyph leftSideBearing: (self short: (fontFile nextNumber: 2)).	].	glyph updateRightSideBearing.! !!TTFileDescription methodsFor: 'private' stamp: 'ar 7/30/2009 18:15'!displayAll	"Read all the glyphs and display them"	| glyph form scale points x y |	points := 24.	scale := points asFloat / unitsPerEm.	x := y := 0.	Display deferUpdates: true.	1 to: numGlyphs do:[:i|		glyph := self readGlyphAt: i-1.		form := glyph asFormWithScale: scale			ascender: ascender			descender: descender.		Display fillWhite: (x@y extent: form extent).		form displayOn: Display at: x@y rule: 34.		Display forceToScreen: (x@y extent: form extent).		x := x + form width.		x > Display width ifTrue:[y := y + form height. x := 0].		y > Display height ifTrue:[y := 0].		Sensor anyButtonPressed ifTrue:[^Display restore].	].! !!TTFileDescription methodsFor: 'private' stamp: 'ar 7/30/2009 18:15'!profileAll	"Profile reading all the glyphs"	MessageTally spyOn:[		1 to: numGlyphs do:[:glyphIndex| self readGlyphAt: glyphIndex-1].	].! !!TTFileDescription methodsFor: 'private' stamp: 'ar 7/29/2009 21:25'!short: aNumber	(aNumber bitAnd: 16r8000) = 0		ifTrue: [^aNumber]		ifFalse: [^-1 - (aNumber bitXor: 16rFFFF)]! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/30/2009 13:55'!findTable: tag in: fontFile	"Position the fontFile at the beginning of the table with the given tag.	Answer true if we found the table, false otherwise."	| maxTables chksum offset length table |	fontFile position: fileOffset.	fontFile skip: 4. "version"	maxTables := fontFile nextNumber: 2.	fontFile skip: 6.	1 to: maxTables do:[:i|		table := (fontFile next: 4) asString.		chksum := fontFile nextNumber: 4.		offset := fontFile nextNumber: 4.		length := fontFile nextNumber: 4.		table = tag ifTrue:[			fontFile position: offset.			^true].	].	chksum. length. "fake usage"	^false! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/29/2009 22:29'!processCharacterMappingTable: fontFile	"Read the font's character to glyph index mapping table."	| initialOffset nSubTables pID sID offset |	initialOffset := fontFile position.	fontFile skip: 2. "Skip table version"	nSubTables := fontFile nextNumber: 2.	1 to: nSubTables do:[:i|		pID := fontFile nextNumber: 2.		sID := fontFile nextNumber: 2.		offset := fontFile nextNumber: 4.		"Check if this is either a Unicode (0), Macintosh (1),		or a Windows (3) encoded table"		(#(0 1 3) includes: pID) ifTrue:[			cmapType := pID.			cmapOffset := initialOffset + offset.			cmapType = 0 ifTrue:[^self]. "found Unicode table; use it"		].	].! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/29/2009 21:59'!processFontHeaderTable: fontFile"Value				Data Type    DescriptionunitsPerEm			USHORT      Granularity of the font's em square.xMax				USHORT      Maximum X-coordinate for the entire font.xMin				USHORT      Minimum X-coordinate for the entire font.yMax				USHORT      Maximum Y-coordinate for the entire font.yMin				USHORT      Minimum Y-coordinate for the entire font.indexToLocFormat	SHORT       Used when processing the Index To Loc Table."	fontFile skip: 4. "Skip table version number"	fontFile skip: 4. "Skip font revision number"	fontFile skip: 4. "Skip check sum adjustment"	fontFile skip: 4. "Skip magic number"	fontFile skip: 2. "Skip flags"	unitsPerEm := fontFile nextNumber: 2.	fontFile skip: 8. "Skip creation date"	fontFile skip: 8. "Skip modification date"	"Skip min/max values of all glyphs"	fontFile skip: 2.	fontFile skip: 2.	fontFile skip: 2.	fontFile skip: 2.	fontFile skip: 2. "Skip mac style"	fontFile skip: 2. "Skip lowest rec PPEM"	fontFile skip: 2. "Skip font direction hint"	indexToLocFormat := fontFile nextNumber: 2.! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/29/2009 23:45'!processHorizontalHeaderTable: fontFile"ascender           SHORT          Typographic ascent.descender          SHORT          Typographic descent.lineGap            SHORT          Typographic lineGap.numberOfHMetrics   USHORT         Number hMetric entries in the HTMX                                               Table; may be smaller than the total                                             number of glyphs."	fontFile skip: 4. "Skip table version"	ascender := self short: (fontFile nextNumber: 2).	descender := self short: (fontFile nextNumber: 2).	lineGap := self short: (fontFile nextNumber: 2).	fontFile skip: 2. "Skip advanceWidthMax"	fontFile skip: 2. "Skip minLeftSideBearing"	fontFile skip: 2. "Skip minRightSideBearing"	fontFile skip: 2. "Skip xMaxExtent"	fontFile skip: 2. "Skip caretSlopeRise"	fontFile skip: 2. "Skip caretSlopeRun"	fontFile skip: 10. "Skip 5 reserved shorts"	fontFile skip: 2. "Skip metricDataFormat"	numHMetrics := fontFile nextNumber: 2.	^numHMetrics! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/29/2009 21:05'!processMaximumProfileTable: fontFile"numGlyphs         USHORT      The number of glyphs in the font."	fontFile skip: 4. "Skip Table version number"	numGlyphs := fontFile nextNumber: 2.! !!TTFileDescription methodsFor: 'ttf tables' stamp: 'ar 7/30/2009 14:02'!processNamingTable: fontFile"copyright         CHARPTR     The font's copyright notice.familyName        CHARPTR     The font's family name.subfamilyName     CHARPTR     The font's subfamily name.uniqueName        CHARPTR     A unique identifier for this font.fullName          CHARPTR     The font's full name (a combination of                                          familyName and subfamilyName).versionName       CHARPTR     The font's version string."	| nRecords initialOffset storageOffset pID sID nID length offset string |	initialOffset := fontFile position.	fontFile skip: 2. "Skip format selector"	"Get the number of name records"	nRecords := fontFile nextNumber: 2.	"Offset from the beginning of this table"	storageOffset := (fontFile nextNumber: 2) + initialOffset.	1 to: nRecords do:[:i|		fontFile position: initialOffset + 6 + ((i-1) * 12).		pID := fontFile nextNumber: 2.		sID := fontFile nextNumber: 2.		"lID := "fontFile nextNumber: 2.		nID := fontFile nextNumber: 2.		length := fontFile nextNumber: 2.		offset := fontFile nextNumber: 2.		"Read only Macintosh or Microsoft strings"		(pID = 1 or:[pID = 3 and:[sID = 1]]) ifTrue:[			"MS uses Unicode all others single byte"			"multiBytes := pID = 3."			fontFile position: storageOffset+offset.			string := (fontFile next: length) asString.			pID = 3 ifTrue:[ | keep |				keep := true.				string := string select:[:ch| keep := keep not].			].			nID caseOf: {				"[0] -> [copyright := string]."				[1] -> [(pID = 1 or:[familyName == nil]) ifTrue:[familyName := string]].				[2] -> [(pID = 1 or:[subfamilyName == nil]) ifTrue:[subfamilyName := string]].				"[3] -> [(pID = 1 or:[uniqueName == nil]) ifTrue:[uniqueName := string]]."				"[4] -> [(pID = 1 or:[fullName == nil]) ifTrue:[fullName := string]]."				"[5] -> [(pID = 1 or:[versionName == nil]) ifTrue:[versionName := string]]."				"[6] -> [(pID = 1 or:[postscriptName == nil]) ifTrue:[postscriptName := string]]."				"[7] -> [(pID = 1 or:[trademark == nil]) ifTrue:[trademark := string]]."			} otherwise:["ignore"].		].	].! !!TTFileDescription methodsFor: 'initialize' stamp: 'ar 7/29/2009 23:46'!on: aFileName	"Initialize the receiver from a file name"	fileName := aFileName.	self withFileDo:[:fontFile|		(self findTable: 'head' in: fontFile) 			ifFalse:[^self error: 'File does not have a header table'].		self processFontHeaderTable: fontFile.		(self findTable: 'maxp' in: fontFile) 			ifFalse:[^self error: 'File does not have a profile table'].		self processMaximumProfileTable: fontFile.		(self findTable: 'name' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		self processNamingTable: fontFile.		(self findTable: 'hhea' in: fontFile) 			ifFalse:[^self error: 'File does not have a horizontal header table'].		self processHorizontalHeaderTable: fontFile.		(self findTable: 'hmtx' in: fontFile) 			ifFalse:[^self error: 'File does not have a horizontal header table'].		hmtxTableOffset := fontFile position.		(self findTable: 'loca' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		indexToLocOffset := fontFile position.		(self findTable: 'glyf' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		glyphTableOffset := fontFile position.		(self findTable: 'cmap' in: fontFile) 			ifFalse:[^self error: 'File does not have a header table'].		self processCharacterMappingTable: fontFile.	].! !!TTFileDescription methodsFor: 'initialize' stamp: 'ar 7/31/2009 22:22'!on: aFileName offset: fontOffset	"Initialize the receiver from a file name"	fileName := aFileName.	fileOffset := fontOffset.	self withFileDo:[:fontFile|		"Some bitmap fonts are called .ttf; skip anything that doesn't have a header"		(self findTable: 'head' in: fontFile) ifFalse:[^nil].		self processFontHeaderTable: fontFile.		(self findTable: 'maxp' in: fontFile) 			ifFalse:[^self error: 'File does not have a profile table'].		self processMaximumProfileTable: fontFile.		(self findTable: 'name' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		self processNamingTable: fontFile.		(self findTable: 'hhea' in: fontFile) 			ifFalse:[^self error: 'File does not have a horizontal header table'].		self processHorizontalHeaderTable: fontFile.		(self findTable: 'hmtx' in: fontFile) 			ifFalse:[^self error: 'File does not have a horizontal header table'].		hmtxTableOffset := fontFile position.		(self findTable: 'loca' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		indexToLocOffset := fontFile position.		(self findTable: 'glyf' in: fontFile) 			ifFalse:[^self error: 'File does not have a naming table'].		glyphTableOffset := fontFile position.		(self findTable: 'cmap' in: fontFile) 			ifFalse:[^self error: 'File does not have a header table'].		self processCharacterMappingTable: fontFile.	].! !!TTFileDescription methodsFor: 'initialize' stamp: 'ar 7/30/2009 19:54'!withFileDo: aBlock	"Open the font file for the duration of aBlock"	^self class openFontFile: fileName do: aBlock.! !!TTFileDescription methodsFor: 'printing' stamp: 'ar 7/30/2009 13:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('; print: fileName; nextPutAll: ')'.! !!TTFileDescription commentStamp: 'ar 7/29/2009 22:18' prior: 0!Contrary to TTFontDescritption, this class leaves true type files on disk and only reads the required portions when constructing glyphs. This avoids the need of reading the entire font into memory at the cost of having to hit disk whenever a glyph is requested.!!TTFileDescription class methodsFor: 'font paths' stamp: 'ar 7/30/2009 21:31'!allFamilyNamesAndFiles	"Answer a dictionary of all known family names and their corresponding file names."	| names |	AllFontsAndFiles ifNil:[		AllFontsAndFiles := Dictionary new.		Cursor wait showWhile:[self allFontsDo:[:font|			names := AllFontsAndFiles at: font familyName 					ifAbsentPut:[OrderedCollection new].			names add: font fileName]]].	^AllFontsAndFiles ! !!TTFileDescription class methodsFor: 'font paths' stamp: 'ar 7/30/2009 21:31'!allFontsAndFiles	"Answer a dictionary of all known family names and their corresponding file names."	| names |	AllFontsAndFiles ifNil:[		AllFontsAndFiles := Dictionary new.		Cursor wait showWhile:[self allFontsDo:[:font|			names := AllFontsAndFiles at: font familyName 					ifAbsentPut:[OrderedCollection new].			names add: font fileName]]].	^AllFontsAndFiles ! !!TTFileDescription class methodsFor: 'font paths' stamp: 'ar 7/30/2009 20:37'!allFontsDo: aBlock	"Evaluate aBlock with all the fonts we can find. Use sparingly."	self fontPathsDo:[:path|		self fontFilesIn: path do:[:font|			font familyName 				ifNotNil:[aBlock value: font]]]! !!TTFileDescription class methodsFor: 'font paths' stamp: 'ar 7/30/2009 21:34'!findFontFile: fontFileName	"Find the path containing the font with the given name.	If it can't be found, return nil."	| fd |	self fontPathsDo:[:path|		fd := FileDirectory on: path.		([fd fileExists: fontFileName] on: Error do:[false]) 			ifTrue:[^fd fullNameFor: fontFileName].	].	^nil! !!TTFileDescription class methodsFor: 'font paths' stamp: 'ar 7/30/2009 21:57'!fontFilesIn: path do: aBlock	"TTFileDescription loadAllFilesIn: 'C:\Windows\Fonts'"	"Load all the TTF files we can find in the given path"	| fd |	fd := FileDirectory on: path.	(fd fileNamesMatching: '*.ttf;*.ttc') do:[:fn|		(self readFontsFrom: fn) do:[:font| aBlock value: font]].! !!TTFileDescription class methodsFor: 'font paths' stamp: 'Richo 6/12/2010 16:07'!fontPathsDo: aBlock	"Evaluate aBlock with all of the font paths that should be searched on the current platform"	(Preferences valueOfPreference: #usePlatformFonts ifAbsent: [false])	ifTrue: [	"Start with the current directory"	aBlock value: FileDirectory default pathName.	"Then subdirectory 'fonts'"	aBlock value: (FileDirectory default directoryNamed: 'fonts') pathName.	"Platform specific directories"	SmalltalkImage current platformName caseOf:{		['Win32']	->	[			"Standard Windows fonts directory"			aBlock value: 'C:\Windows\Fonts'.		].		['Mac OS']	->	[			"Standard system fonts directory"			aBlock value: '/Library/Fonts'.		].		['unix']		->	[ | base |			"Standard fonts are in /usr/share/fonts/*"			base := '/usr/share/fonts'.			(FileDirectory on: base) directoryNames 				do:[:dn| aBlock value: base, '/', dn].		].	} otherwise:[].	].	aBlock value: (SmalltalkImage current imagePath, FileDirectory pathNameDelimiter asString, 'fonts').! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'ar 7/30/2009 20:22'!fontFromUser	"TTFileDescription fontFromUser"	^self fontFromUser: TextStyle defaultFont! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'ar 7/30/2009 20:16'!fontFromUser: priorFont	^self fontFromUser: priorFont allowKeyboard: true! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'ar 7/30/2009 21:31'!fontFromUser: priorFont allowKeyboard: aBoolean	"TTFileDescription fontFromUser"	| fontMenu active ptMenu label fontNames builder resultBlock result item style font widget |	builder := ToolBuilder default.	fontNames := self allFontsAndFiles keys asArray sort.	fontMenu := builder pluggableMenuSpec new.	fontMenu label: 'Non-portable fonts'.	resultBlock := [:value| result := value].	fontNames do: [:fontName |		active := priorFont familyName sameAs: fontName.		ptMenu := builder pluggableMenuSpec new.		TTCFont pointSizes do: [:pt |			label := pt printString, ' pt'.			item := ptMenu add: label 				target: resultBlock				selector: #value:				argumentList: {{fontName. pt}}.			item checked: (active and:[pt = priorFont pointSize]).		].		item := fontMenu add: fontName action: nil.		item subMenu: ptMenu.		item checked: active.	].	widget := builder open: fontMenu.	builder runModal: widget.	result ifNil:[^nil].	style := (TextStyle named: result first) ifNil:[self installFamilyNamed: result first].	style ifNil: [^ self].	font := style fonts detect: [:any | any pointSize = result last] ifNone: [nil].	^ font! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'ar 7/30/2009 22:53'!offerNonPortableFonts	"Should native fonts be offered when displaying font menus?"	^OfferNonPortableFonts ifNil:[true]! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'ar 7/30/2009 21:29'!offerNonPortableFonts: aBool	"Should native fonts be offered when displaying font menus?"	OfferNonPortableFonts := aBool.! !!TTFileDescription class methodsFor: 'instance creation' stamp: 'ar 7/31/2009 22:20'!fontOffsetsInFile: file	"Answer a collection of font offsets in the given file"	| tag version nFonts |	file position: 0.	tag := file next: 4.	tag caseOf:{		['true' asByteArray] -> ["Version 1.0 TTF file"			"http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6.html			The values 'true' (0x74727565) and 0x00010000 are recognized by the Mac OS 			as referring to TrueType fonts."			^Array with: 0 "only one font"		].		[#(0 1 0 0) asByteArray] -> ["Version 1.0 TTF file"			^Array with: 0 "only one font"		].		['ttcf' asByteArray]	-> ["TTC file"			version := file next: 4.			version = #(0 1 0 0) asByteArray ifFalse:[^self error: 'Unsupported TTC version'].			nFonts := file nextNumber: 4.			^(1 to: nFonts) collect:[:i| file nextNumber: 4].		].	} otherwise:[		self error: 'This is not a valid Truetype file'.	].! !!TTFileDescription class methodsFor: 'instance creation' stamp: 'ar 7/30/2009 21:32'!installFamilyNamed: familyName	"Install all the corresponding fonts for this family"	"		TTFileDescription installFamilyNamed: 'Arial'.		TTFileDescription installFamilyNamed: 'Batang'.	"	| fontFiles ttDesc |	fontFiles := self allFontsAndFiles at: familyName ifAbsent:[#()].	fontFiles do:[:fileName|		ttDesc := (self readFontsFrom: fileName) detect:[:fnt| fnt familyName = familyName].		TTCFont newTextStyleFromTT: ttDesc.	].	^TextStyle named: familyName! !!TTFileDescription class methodsFor: 'instance creation' stamp: 'ar 7/30/2009 21:51'!openFontFile: fontFileName do: aBlock	"Open the font with the given font file name"	| fontFilePath file |	fontFilePath := FontPaths at: fontFileName 		ifAbsentPut:[self findFontFile: fontFileName].	fontFilePath ifNil:[^nil].	[file := FileStream readOnlyFileNamed: fontFilePath] on: Error do:[:ex|		"We lost the font; someone might have moved it away"		fontFilePath removeKey: fontFileName ifAbsent:[].		^nil	].	^[aBlock value: file binary] ensure:[file close].! !!TTFileDescription class methodsFor: 'instance creation' stamp: 'ar 7/31/2009 22:23'!readFontsFrom: aFilename	"Reads and returns all the fonts in the given file"	"		TTFileDescription readFontsFrom: 'batang.ttc'.	"	^self openFontFile: aFilename do:[:file|		(self fontOffsetsInFile: file)			collect:[:offset| self new on: aFilename offset: offset]			thenSelect:[:font| font notNil]].	! !!TTFileDescription class methodsFor: 'class initialization' stamp: 'Richo 6/12/2010 16:08'!initialize	"TTFileDescription initialize"	Smalltalk addToShutDownList: self.	FontPaths := Dictionary new.	AllFontsAndFiles := nil.	Preferences addBooleanPreference: #usePlatformFonts category: 'fonts' default: false balloonHelp: 'usePlatformFonts:If true, TTFileDescription will look for fonts in platform specific directories. Otherwise, it will only look in <imagePath>/fonts'! !!TTFileDescription class methodsFor: 'class initialization' stamp: 'ar 7/30/2009 21:31'!shutDown	"Flush my caches"	FontPaths := Dictionary new.	AllFontsAndFiles := nil.! !!TTFileDescription class methodsFor: 'examples' stamp: 'ar 7/30/2009 20:49'!loadAllFontFiles	"Load all the TTF files we can find in all font paths"	"		TTFileDescription loadAllFontFiles.	"	self fontPathsDo:[:path| | fd |		fd := FileDirectory on: path.		(fd fileNamesMatching: '*.ttf;*.ttc') do:[:fn|			(self readFontsFrom: fn) do:[:font|				(1 to: font numGlyphs) 					do:[:i| font readGlyphAt: i-1] 					displayingProgress: 'Reading ', font name].		] displayingProgress: 'Scanning ', path.	].! !!TTFontDescription methodsFor: 'accessing' stamp: 'bf 9/29/2010 11:09'!size	^ glyphTable size.! !!TTFontReader methodsFor: 'processing' stamp: 'yo 3/19/2009 10:37'!processSimpleGlyph: glyph contours: nContours from: entry	| endPts  nPts iLength flags |	endPts _ Array new: nContours.	1 to: nContours do:[:i| endPts at: i put: entry nextUShort].	glyph initializeContours: nContours with: endPts.	nContours = 0 ifTrue: [^ self].	nPts _ endPts last + 1.	iLength _ entry nextUShort. "instruction length"	entry skip: iLength.	flags _ self getGlyphFlagsFrom: entry size: nPts.	self readGlyphXCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	self readGlyphYCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	glyph buildContours.! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 7/30/2009 17:06'!buildAllContours	"Build the contours in all non-composite glyphs."	^self buildContours! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 7/30/2009 17:16'!buildContours	"Build the contours in the receiver glyph.	The contour is constructed by converting the points	form each contour into an absolute value and then	compressing the contours into PointArrays."	| tx ty points |	tx := ty := 0.	contours := contours collect:[:contour|		contour isCollection ifTrue:[^self]. "already built"		points := contour points.		points do:[:pt|			pt x: (tx := tx + pt x).			pt y: (ty := ty + pt y)].		contour asCompressedPoints].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'bf 6/2/2009 19:13'!referenceVertexAt: index	"Only used while reading before constructing contours"	| count vertices |	count := 0.	contours do: [:construction |		vertices := construction points.		index - count > vertices size			ifTrue: [count := count + vertices size]			ifFalse: [^(vertices at: index - count) asPoint]].	^count! !!UIManager commentStamp: 'bf 4/19/2010 01:51' prior: 0!Fake enough of UIManager for various newer tools like Monticello to work!!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/19/2010 02:15'!chooseFrom: aList lines: lines title: aString	^(PopUpMenu labelArray: aList lines: lines)		startUpWithCaption: aString! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/19/2010 02:15'!chooseFrom: aList title: aString	^self chooseFrom: aList lines: nil title: aString! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/29/2010 17:00'!chooseFrom: labelList values: valueList	^self chooseFrom: labelList values: valueList title: ''! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/19/2010 01:45'!chooseFrom: labelList values: valueList title: aString	| result |	result := self chooseFrom: labelList title: aString.	^result > 0 ifTrue: [valueList at: result]! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/17/2010 17:08'!displayProgress: titleString at: aPoint from: minVal to: maxVal during: workBlock	^ProgressInitiationException 		display: titleString		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/28/2010 02:39'!requestPassword: queryString 	^FillInTheBlank requestPassword: queryString! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/17/2010 17:08'!request: queryString 	^self request: queryString initialAnswer: ''! !!UIManager class methodsFor: 'ui requests' stamp: 'bf 4/17/2010 17:08'!request: queryString initialAnswer: defaultAnswer 	^FillInTheBlankMorph request: queryString initialAnswer: defaultAnswer ! !!UIManager class methodsFor: 'class initialization' stamp: 'bf 4/17/2010 17:08'!default	^self! !!UndefinedObject methodsFor: '*DrGeoII-Core-accessing' stamp: 'HilaireFernandes 4/19/2010 10:27'!area	^nil! !!UndefinedObject methodsFor: '*DrGeoII-Core-accessing' stamp: 'HilaireFernandes 4/19/2010 12:46'!gridVisible	^false! !!UniclassScript methodsFor: 'textually coded' stamp: 'Richo 5/23/2010 17:18'!becomeTextuallyCoded	"Transform the receiver into one which is textually coded"	isTextuallyCoded _ true.	lastSourceString _ (playerClass sourceCodeAt: selector)  		"Save this to compare when going back to tiles"! !!UnixEUCKRInputInterpreter methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:05'!initialize	converter _ EUCKRTextConverter new.! !!UnixEUCKRInputInterpreter methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:06'!nextCharFrom: sensor firstEvt: evtBuf	| firstChar secondChar peekEvent keyValue type stream multiChar |	keyValue _ evtBuf third.	evtBuf fourth = EventKeyChar ifTrue: [type _ #keystroke].	peekEvent _ sensor peekEvent.	(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [		sensor nextEvent.		peekEvent _ sensor peekEvent].	(type == #keystroke	and: [peekEvent notNil 	and: [peekEvent first = EventTypeKeyboard	and: [peekEvent fourth = EventKeyChar]]]) ifTrue: [		firstChar _ keyValue asCharacter.		secondChar _ (peekEvent third) asCharacter.		stream _ ReadStream on: (String with: firstChar with: secondChar).		multiChar _ converter nextFromStream: stream.		multiChar isOctetCharacter ifFalse: [sensor nextEvent].		^ multiChar].	^ keyValue asCharacter! !!UnixUTF8JPInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 12/8/2008 21:48'!nextCharFrom: sensor firstEvt: evtBuf	| firstChar aCollection bytes peekEvent keyValue type stream multiChar evt |	keyValue _ evtBuf third.	evtBuf fourth = EventKeyChar ifTrue: [type _ #keystroke].	peekEvent _ sensor peekEvent.	(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [		sensor nextEvent.		peekEvent _ sensor peekEvent].	(type == #keystroke	and: [peekEvent notNil 	and: [peekEvent first = EventTypeKeyboard	and: [peekEvent fourth = EventKeyChar]]]) ifTrue: [		firstChar _ keyValue asCharacter.		aCollection _ OrderedCollection with: firstChar..		bytes _ (keyValue <= 127)			ifTrue: [ 0 ]			ifFalse: [ (keyValue bitAnd: 16rE0) = 192				ifTrue: [ 1 ]				ifFalse: [ (keyValue bitAnd: 16rF0) = 224					ifTrue: [ 2 ]					ifFalse: [ 3 ]				]			].		[bytes > 0] whileTrue: [			(evt :=  sensor nextEvent) fourth = EventKeyChar ifTrue: [				bytes := bytes - 1.				aCollection add: (Character value: evt third)]].		"aCollection do: [ :each | Transcript show: (each asciiValue hex , ' ')].		Transcript show: Character cr."		stream _ ReadStream on: (String withAll: aCollection).		multiChar _ converter nextFromStream: stream.		multiChar isOctetCharacter ifFalse: [ sensor nextEvent ].		^ multiChar].	^ keyValue asCharacter! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'kfr 5/30/2010 18:54'!readFromTarget	"Update my readout from my target"	| v ret places |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	ret _ self checkTarget.	ret ifFalse: [^ '0'].	((target isMorph) or:[target isPlayerLike]) ifTrue:[	places _ target decimalPlacesForGetter: getSelector.	(places ~= nil and: [ places ~= decimalPlaces ])  ifTrue: [ self decimalPlaces: places ]].	v := target perform: getSelector.	"scriptPerformer"	(v isKindOf: Text) ifTrue: [v := v asString].	^self acceptValueFromTarget: v! !!UserText methodsFor: 'initialization' stamp: 'bf 8/22/2010 16:44'!initialize	"Initialize the receiver."	super initialize.	wrapFlag _ false.	self margins: 6@0.	self autoFit: true.! !!Utilities class methodsFor: 'fetching updates' stamp: 'bf 5/4/2010 19:28'!defaultRepositoryChangeLogOn: aStream	"Transcript clear. Utilities defaultRepositoryChangeLogOn: Transcript"	| repo updates latest previous latestVersion previousVersion added removed latestPackages previousPackages prevDep prevInfo latestInfo |	repo := MCRepositoryGroup default repositories detect: [:r |		r description = MCMcmUpdater defaultUpdateURL].	updates := repo allFileNames select: [:each | 'update-*.mcm' match: each].	updates := updates asSortedCollection:		[:a :b | a splitInteger second > b splitInteger second].	latest := repo versionFromFileNamed: updates first.	previous := repo versionFromFileNamed: updates second.	latestVersion := self versionNumberAndDateFromConfig: latest.	previousVersion := self versionNumberAndDateFromConfig: previous.	aStream nextPutAll: 'Changes from v'; print: previousVersion first;		nextPutAll: ' of '; print: previousVersion second;		nextPutAll: ' to v'; print: latestVersion first;		nextPutAll: ' of '; print: latestVersion second;		nextPutAll: ':'; cr.	aStream flush.	latestPackages := latest dependencies collect: [:dep | dep package].	previousPackages :=  previous dependencies collect: [:dep | dep package].	added := latestPackages difference: previousPackages.	removed := previousPackages difference: latestPackages.	added ifNotEmpty: [		aStream nextPutAll: 'Added packages:'.		added do: [:each | aStream space; nextPutAll: each name].		aStream cr].	removed ifNotEmpty: [		aStream nextPutAll: 'Removed packages:'.		removed do: [:each | aStream space; nextPutAll: each name].		aStream cr].	 latest dependencies do: [:latestDep |		prevDep := previous dependencies detect: [:p | latestDep package = p package] ifNone: [].		(prevDep notNil and: [prevDep versionInfo ~= latestDep versionInfo])			ifTrue: [				aStream nextPutAll: '--------------------'; cr.				prevInfo := prevDep package workingCopy ancestry findAncestor: prevDep versionInfo.				latestInfo := latestDep package workingCopy ancestry findAncestor: latestDep versionInfo.				(latestInfo allAncestorsOnPathTo: prevInfo) reverse, {latestInfo}					do: [:ver | aStream nextPutAll: ver name; cr; nextPutAll: ver message; cr]					separatedBy: [aStream cr]]].	aStream flush! !!Utilities class methodsFor: 'fetching updates' stamp: 'bf 4/29/2010 11:13'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""When two sets of updates need to use the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that is the index file used.""Utilities readServerUpdatesThrough: 3922 saveLocally: true updateImage: true"	| failed loaded str res servers triple tryAgain indexPrefix |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	servers _ Utilities serverUrls copy.	indexPrefix _ (Utilities updateUrlLists first first includes: $*) 		ifTrue: [(Utilities updateUrlLists first first findTokens: ' ') first]						"special for internal updates"		ifFalse: ['']. 	"normal"	[servers isEmpty] whileFalse: [		triple _ self readServer: servers special: indexPrefix 					updatesThrough: maxNumber 					saveLocally: saveLocally updateImage: updateImage.		"report to user"		failed _ triple first.		loaded _ triple second.		tryAgain _ false.		failed ifNil: ["is OK"			loaded = 0 ifTrue: ["found no updates"				servers size > 1 ifTrue: ["not the last server"					res _ PopUpMenu withCaption: 'No new updates on the server' translated, servers first, 'Would you like to try the next server?(Normally, all servers are identical, but sometimes aserver won''t let us store new files, and gets out of date.)' translated						chooseFrom: 'Stop looking\Try next server' translated.					res = 2 ifFalse: [^ self]						 ifTrue: [servers _ servers allButFirst.	"try the next server"							tryAgain _ true]]]].		tryAgain ifFalse: [			str _  '{1} new update file(s) processed.' translated format: {loaded printString}.			maxNumber notNil | updateImage not ifTrue: [^ self inform: str].			str _ str, String cr, 'Load the latest packages from the default repository?' translated. 			(self confirm: str) ifTrue: [self updateFromDefaultRepository].			^self].	].! !!Utilities class methodsFor: 'fetching updates' stamp: 'bf 5/3/2010 10:00'!setSystemVersionFromConfig: anMCConfiguration	"Set the current system version date to the latest date found in anMCConfiguration (or the associated working copy). Also set the highest update number to the sum of version numbers in the config."	| numberAndDate |	numberAndDate := self versionNumberAndDateFromConfig: anMCConfiguration.	SystemVersion current		repositoryVersion: numberAndDate first;		repositoryDate: numberAndDate second.	^numberAndDate! !!Utilities class methodsFor: 'fetching updates' stamp: 'bf 5/3/2010 11:47'!updateFromDefaultRepository	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Repository unavailable' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.System version is now:{1}' translated format: {SystemVersion current asString}).! !!Utilities class methodsFor: 'fetching updates' stamp: 'bf 5/4/2010 18:38'!versionNumberAndDateFromConfig: anMCConfiguration	"Answer the latest date found in anMCConfiguration (or the associated working copy), and the sum of its version numbers."	| versionNumbers versionDates |	versionNumbers := anMCConfiguration dependencies collect: [:d |		(d versionInfo name copyAfterLast: $.) asInteger].	versionDates := anMCConfiguration dependencies collect: [:d |		d versionInfo date			ifNil: [((d package workingCopy ancestry findAncestor: d versionInfo)				ifNotNilDo: [:v | v date])					ifNil: [Date fromDays: 0]]].	^{versionNumbers sum. versionDates max}.! !!Utilities class methodsFor: 'identification' stamp: 'sw 9/11/2009 16:08'!authorName	"Answer the AuthorName; if nil or empty, put up a dialog requesting one.  Answers a string, which may be empty."	AuthorName isEmptyOrNil ifTrue: [self setAuthorName].	^ AuthorName"AuthorName := nilUtilities authorName"! !!Utilities class methodsFor: 'identification' stamp: 'bf 8/29/2010 19:01'!copyrightNotice	^ 'The files "etoys.image" and "EtoysV4.sources" contain portions of theoriginal Squeak 1.1 release, which was relicensed by Apple in 2007 to theApache 2.0 license:   Copyright (c) 1996 Apple Computer, Inc. All Rights Reserved.    Licensed under the Apache License, Version 2.0 (the "License");   you may not use this file except in compliance with the License.   You may obtain a copy of the License at       http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.Everything else is   Copyright (c) 1996-2010 Viewpoints Research Institute, and Contributors   Permission is hereby granted, free of charge, to any person obtaining a copy   of this software and associated documentation files (the "Software"), to deal   in the Software without restriction, including without limitation the rights   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell   copies of the Software, and to permit persons to whom the Software is   furnished to do so, subject to the following conditions:   The above copyright notice and this permission notice shall be included in   all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.'! !!Utilities class methodsFor: 'identification' stamp: 'yo 9/9/2009 02:18'!loggedIn	^ LoggedIn! !!Utilities class methodsFor: 'identification' stamp: 'yo 9/9/2009 02:16'!loggedIn: aBoolean	LoggedIn := aBoolean.! !!ViewerEntry methodsFor: 'access' stamp: 'sw 11/5/1998 10:09'!entryType	^ self viewerRow entryType! !!ViewerEntry methodsFor: 'access' stamp: 'sw 12/28/1998 13:01'!playerBearingCode	^ owner owner scriptedPlayer! !!ViewerEntry methodsFor: 'access' stamp: 'sw 11/5/1998 10:09'!viewerRow	"Answer the ViewerRow object, that contains the controls and the phraseTile"	^ submorphs first! !!ViewerEntry methodsFor: 'contents' stamp: 'nb 6/17/2003 12:25'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	| info |	(info _ self userSlotInformation)		ifNotNil:			[info documentation: c.			^ true].	Beeper beep.	^ false! !!ViewerEntry methodsFor: 'contents' stamp: 'sw 11/5/1998 09:31'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.985		b: 0.985! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:07'!initialize"initialize the state of the receiver"	super initialize.""	self layoutInset: 0! !!ViewerEntry methodsFor: 'menu' stamp: 'sw 11/9/1998 13:57'!codePaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'menueventuallywillbeuseful'		lines: #(1)		selections: #(beep flash beep flash beep)! !!ViewerEntry methodsFor: 'slot' stamp: 'sw 1/13/1999 12:57'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow elementSymbol! !!ViewerEntry methodsFor: 'slot' stamp: 'sw 12/28/1998 12:50'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	((self entryType == #systemSlot) or: [self entryType == #userSlot])		ifFalse:			[^ nil].	aSlotName _ self slotName.	^ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerFlapTab methodsFor: 'positioning' stamp: 'sw 8/24/2009 21:38'!spanWorld	"Make the receiver's height and width be harmonious with those of the container."	| container ht nav |	container _ self pasteUpMorph ifNil: [self currentWorld].	ht := (nav := ActiveWorld findA: SugarNavTab)		ifNotNil:			[nav height]		ifNil:			[0].	referent width: (referent width min: container width - self width).	referent top: container top + ht! !!ViewerRow methodsFor: 'access' stamp: 'sw 2/1/1999 13:00'!elementSymbol	^ elementSymbol! !!ViewerRow methodsFor: 'access' stamp: 'sw 1/13/1999 12:47'!elementSymbol: aSymbol	elementSymbol _ aSymbol! !!ViewerRow methodsFor: 'access' stamp: 'sw 5/25/2001 10:36'!entryType	"Answer one of: #systemSlot #userSlot #systemScript #userScript"	^ self playerBearingCode elementTypeFor: elementSymbol vocabulary: self currentVocabulary! !!ViewerRow methodsFor: 'access' stamp: 'sw 12/28/1998 13:10'!playerBearingCode	^ owner playerBearingCode! !!ViewerRow methodsFor: 'initialization' stamp: 'ar 11/9/2000 20:44'!initialize	super initialize.	self layoutInset: 1! !!Vocabulary methodsFor: 'translation' stamp: 'bf 9/24/2010 18:06'!translatedWordingFor: aSymbol	"If I have a translated wording for aSymbol, return it, else return aSymbol.  Caveat: at present, this mechanism is only germane for *assignment-operator wordings* and the special-case numeric comparitor #isDivisibleBy:"	#(: Incr: Decr: Mult: isDivisibleBy:)  with: #('' 'increase by' 'decrease by' 'multiply by' 'divisible by') translatedNoop do:		[:a :b | aSymbol = a ifTrue: [^ b  translatedInDomain: 'Etoys-Tiles']].	^ aSymbol fromCamelCase translatedInDomain: 'Etoys-Tiles'! !!Vocabulary methodsFor: '*Etoys-queries' stamp: 'sw 11/3/2008 22:30'!tileWordingForSelector: aSelector	"Answer the wording to emblazon on tiles representing aSelector"	| anInterface inherent |	anInterface _ self methodInterfaceAt: aSelector asSymbol ifAbsent:		[inherent _ Utilities inherentSelectorForGetter: aSelector.		^ (#(isDivisibleBy:) includes: inherent)			ifTrue:				[self translatedWordingFor: inherent]			ifFalse:				[inherent]].	^ anInterface wording! !!WeakSet methodsFor: 'accessing' stamp: 'ul 2/19/2010 14:56'!like: anObject ifAbsent: aBlock	"Answer an object in the receiver that is equal to anObject,	or evaluate the block if not found. Relies heavily on hash properties"	| element |	((element  := array at: (self scanFor: anObject)) == flag or: [ element == nil ])		ifTrue: [ ^aBlock value ]		ifFalse: [ ^element enclosedSetElement ]! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:56'!actionSelector	^ actionSelector! !!WheelMorph methodsFor: 'accessing' stamp: 'CedrickBeler 4/23/2010 17:43'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:32'!angle	^angle! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:33'!angle: aNumber	angle := aNumber! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 17:02'!factor	^factor! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 17:03'!factor: aFloat	factor := aFloat! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:35'!maxAngle	^maxAngle! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:35'!maxAngle: aNumber	maxAngle := aNumber! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:47'!target	^target! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:48'!target: aTargetObject	target := aTargetObject! !!WheelMorph methodsFor: 'private' stamp: 'ti 3/20/2000 15:58'!addAngle: aNumber	| new |	new := self angle + aNumber.	self isCircular ifTrue: [new := new \\ self maxAngle].	self angle: new.	lastRedraw := lastRedraw + aNumber.	(lastRedraw abs > 2) ifTrue: [		lastRedraw := 0.		self changed]! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:18'!beCircular	circular := true! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:34'!beHorizontal	self isHorizontal		ifFalse: [self extent: self extent transposed] ! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!beLinear	circular := false! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:34'!beVertical	self isHorizontal		ifTrue: [self extent: self extent transposed] ! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!isCircular	^circular! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:26'!isHorizontal	^ bounds isWide! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!isLinear	^circular not! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/22/2000 19:12'!isVertical	^self isHorizontal not! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 17:03'!doTargetAction: cursorPoint	| new delta |	self isHorizontal		ifTrue: [new := cursorPoint x]		ifFalse: [new := cursorPoint y].	delta := new - old.	delta isZero ifTrue: [^self].	self addAngle: delta.	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: (Array with: (delta * self factor))]].	old := new.! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 14:50'!handlesMouseDown: evt	^true! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/14/2000 18:09'!mouseDown: evt	self isHorizontal		ifTrue: [old := evt cursorPoint x]		ifFalse: [old := evt cursorPoint y].! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 14:51'!mouseMove: evt	(evt anyButtonPressed)		ifTrue: [self doTargetAction: evt cursorPoint]! !!WheelMorph methodsFor: 'drawing' stamp: 'HilaireFernandes 4/23/2010 16:33'!drawOn: aCanvas	| interval delta frame x0 x1 y0 y1 deltaX deltaY  hilitColor shadowColor |	super drawOn: aCanvas.		"border & background"	borderColor isColor		ifTrue: [hilitColor := shadowColor := borderColor]		ifFalse: [hilitColor := color lighter lighter.			shadowColor := color darker darker].	frame := self innerBounds insetBy: 2.	aCanvas frameAndFillRectangle: frame fillColor: color		borderWidth: 1 topLeftColor: hilitColor bottomRightColor: shadowColor.	frame := frame insetBy: (borderColor isColor ifTrue: [1] ifFalse: [2]).	x0 := frame origin x.	x1 := frame corner x.	y0 := frame origin y.	y1 := frame corner y.	deltaX := (x1 - x0) / 2.	deltaY := (y1 - y0) / 2.	interval := 10.	delta := self angle \\ interval.	1 to: (self maxAngle / (2 * interval)) rounded do: [ :i |		| x y |		self isHorizontal ifTrue: [			x := x0 + deltaX - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaX).			aCanvas fillRectangle: (Rectangle origin: (x-1)@y0 corner: x@y1) color: hilitColor.			borderColor isColor ifFalse:				 [aCanvas fillRectangle: (Rectangle origin: x@y0 corner: (x+1)@y1) color: shadowColor]]		ifFalse: [			y := y0 + deltaY - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaY).			aCanvas fillRectangle: (Rectangle origin: x0@(y-1) corner: x1@y) color: hilitColor.			borderColor isColor ifFalse:				 [aCanvas fillRectangle: (Rectangle origin: x0@y corner: x1@(y+1)) color: shadowColor]]]! !!WheelMorph methodsFor: 'initialization' stamp: 'HilaireFernandes 1/27/2008 10:22'!initialize	super initialize.	self target: nil.	self actionSelector: #flash.	self angle: 0.	self maxAngle: 360.	self factor: 1.0.	self extent: 100@23.	self beCircular.	self borderColor: #raised.	self borderWidth: 1.	self color: Color lightGray.	lastRedraw := 0.! !!WheelMorph commentStamp: '<historical>' prior: 0!A thumb wheel widget control!!WinKSX1001ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:07'!fromSystemClipboard: aString	^ aString macToSqueak convertFromSystemString.! !!WinKSX1001InputInterpreter methodsFor: 'as yet unclassified' stamp: 'janggoon 11/4/2008 22:07'!nextCharFrom: sensor firstEvt: evtBuf 	| keyValue |	keyValue := evtBuf at: 6.	keyValue < 256		ifTrue: [^ (Character value: keyValue) squeakToIso].	"Smalltalk systemLanguage charsetClass charFromUnicode: keyValue."	^ Unicode value: keyValue! !!WsWorldStethoscopeMorph methodsFor: 'accessing' stamp: 'kfr 6/16/2010 23:12'!offset	^model offset! !!WsWorldStethoscopeMorph methodsFor: 'accessing' stamp: 'kfr 6/16/2010 23:12'!offset: number 	model offset: number! !!XMLNode methodsFor: 'enumerating' stamp: 'yo 9/9/2009 01:23'!withAllElementsDo: aBlock	aBlock value: self.! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'yo 9/9/2009 01:23'!withAllElementsDo: aBlock	aBlock value: self.	elements		ifNotNil: [			self elements do: [:each | each withAllElementsDo: aBlock]]! !'From etoys4.1 of 29 April 2010 [latest update: #2384 (repo v1305 of 31 August 2010)] on 5 September 2010 at 1:56:17 am'!| cont | (Smalltalk includesKey: #MorphExtensionPlus) ifFalse: [self inform: 'This project cannot be loaded into an older system.\Please use an OLPC Etoys compatible image.' translated withCRs.		cont _ thisContext.		[cont notNil] whileTrue: [			cont selector == #handleEvent: ifTrue: [cont return: nil].			cont _ cont sender.		]]!----End fileIn of a stream----!'From etoys4.1 of 29 April 2010 [latest update: #2384 (repo v1316 of 11 September 2010)] on 11 September 2010 at 5:08:10 pm'!| cont | (Smalltalk includesKey: #MorphExtensionPlus) ifFalse: [self inform: 'This project cannot be loaded into an older system.\Please use an OLPC Etoys compatible image.' translated withCRs.		cont _ thisContext.		[cont notNil] whileTrue: [			cont selector == #handleEvent: ifTrue: [cont return: nil].			cont _ cont sender.		]]!----End fileIn of a stream----!'From etoys4.1 of 29 April 2010 [latest update: #2384 (repo v1316 of 11 September 2010)] on 11 September 2010 at 5:20:11 pm'!| cont | (Smalltalk includesKey: #MorphExtensionPlus) ifFalse: [self inform: 'This project cannot be loaded into an older system.\Please use an OLPC Etoys compatible image.' translated withCRs.		cont _ thisContext.		[cont notNil] whileTrue: [			cont selector == #handleEvent: ifTrue: [cont return: nil].			cont _ cont sender.		]]!Player subclass: #Player192	instanceVariableNames: 'projectName'	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!!Player192 methodsFor: 'access'!getProjectName	^ projectName! !!Player192 methodsFor: 'access'!setProjectName: t1 	projectName := t1! !----End fileIn of a stream----!ReleaseBuilderSqueakland new prepareReleaseImage.!----QUIT----#(13 October 2010 11:04:01 pm) etoys.image priorSource: 1879307!----STARTUP----#(20 January 2011 1:44:50 pm) as C:\Users\Derek\Downloads\Etoys-To-Go-4.1.1\Etoys-To-Go 4.1.1.app\Contents\Resources\etoys.image!----QUIT/NOSAVE----#(20 January 2011 1:46:53 pm) etoys.image priorSource: 1881126!----STARTUP----#(8 March 2011 3:15:17 pm) as C:\Users\Derek\Downloads\Etoys-To-Go-4.1.1\Etoys-To-Go 4.1.1.app\Contents\Resources\etoys.image!----QUIT/NOSAVE----#(8 March 2011 3:15:46 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:02:40 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go 4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:02:44 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:08:56 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:08:58 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:15:10 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:15:13 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:28:07 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:28:09 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:28:30 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:28:33 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:28:54 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:29:06 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:41:21 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:41:24 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:43:44 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:43:48 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 10:44:59 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 10:45:01 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 11:30:06 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 11:30:08 pm) etoys.image priorSource: 1881126!----STARTUP----#(4 April 2011 11:43:12 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(4 April 2011 11:43:15 pm) etoys.image priorSource: 1881126!----STARTUP----#(5 April 2011 12:05:58 am) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(5 April 2011 12:06 am) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 1:33:49 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 1:33:54 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 1:34:05 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 1:34:14 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 1:37:29 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 1:37:32 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 1:38:52 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 1:38:54 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 1:39 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 1:39:02 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 2:07:06 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 2:07:08 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 2:09:08 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 2:09:10 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 2:36:56 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 2:36:59 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 2:53:47 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 2:53:49 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 2:57:48 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 2:57:50 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 3:16:28 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 3:16:31 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 3:46:18 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 3:46:21 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 10:05:19 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 10:05:21 pm) etoys.image priorSource: 1881126!----STARTUP----#(15 April 2011 10:19:46 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(15 April 2011 10:19:48 pm) etoys.image priorSource: 1881126!----STARTUP----#(16 April 2011 1:25:10 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(16 April 2011 1:25:17 pm) etoys.image priorSource: 1881126!----STARTUP----#(16 April 2011 1:27:01 pm) as /home/derek/One2One2Go/ProgramFiles/Etoys-To-Go_4.1.1.app/Contents/Resources/etoys.image!----QUIT/NOSAVE----#(16 April 2011 1:27:03 pm) etoys.image priorSource: 1881126!