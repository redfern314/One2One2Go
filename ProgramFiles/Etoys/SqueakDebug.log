Error: Error: Instances of UndefinedObject are not indexable8 March 2011 3:15:20 pmVM: Win32 - a SmalltalkImageImage: etoys4.1 [latest update: #2390]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir C:\Users\Derek\Downloads\Etoys-To-Go-4.1.1\EtoysTrusted Dir C:\Users\Derek\Downloads\Etoys-To-Go-4.1.1\.etoysUntrusted Dir C:\Users\Derek\Downloads\Etoys-To-Go-4.1.1\EtoysUndefinedObject(Object)>>error:	Receiver: nil	Arguments and temporary variables: 		aString: 	'Error: Instances of UndefinedObject are not indexable'	Receiver's instance variables: nil[] in WorldState>>displayWorldSafely: {[:err :rcvr |  errCtx := thisContext.  [errCtx := errCtx sender.  [errCtx no...]}	Arguments and temporary variables: 		aWorld: 	a PasteUpMorph<world>(773) [world]		err: 	'Error: Instances of UndefinedObject are not indexable'		rcvr: 	nil		errCtx: 	BalloonMorph(PolygonMorph)>>computeNextToEndPoints		errMorph: 	a BalloonMorph(3284)BlockContext>>valueWithPossibleArgs:	Receiver: [] in WorldState>>displayWorldSafely: {[:err :rcvr |  errCtx := thisContext.  [errCtx := e...etc...	Arguments and temporary variables: 		anArray: 	#('Error: Instances of UndefinedObject are not indexable' nil)	Receiver's instance variables: 		sender: 	BlockContext>>valueWithPossibleArgs:		pc: 	121		stackp: 	0		nargs: 	2		startpc: 	74		home: 	WorldState>>displayWorldSafely:[] in BlockContext>>ifError: {[:ex | errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]}	Arguments and temporary variables: 		errorHandlerBlock: 	[] in WorldState>>displayWorldSafely: {[:err :rcvr |  errCtx...etc...		ex: 	Error: Instances of UndefinedObject are not indexable--- The full stack ---UndefinedObject(Object)>>error:[] in WorldState>>displayWorldSafely: {[:err :rcvr |  errCtx := thisContext.  [errCtx := errCtx sender.  [errCtx no...]}BlockContext>>valueWithPossibleArgs:[] in BlockContext>>ifError: {[:ex | errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]} - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -BlockContext>>valueWithPossibleArgs:[] in MethodContext(ContextPart)>>handleSignal: {[(self tempAt: 2)   valueWithPossibleArgs: {exception}]}BlockContext>>ensure:MethodContext(ContextPart)>>handleSignal:Error(Exception)>>signalError(Exception)>>signal:UndefinedObject(Object)>>error:UndefinedObject(Object)>>errorNotIndexableUndefinedObject(Object)>>at:put:BalloonMorph(PolygonMorph)>>computeNextToEndPointsBalloonMorph(PolygonMorph)>>coefficientsBalloonMorph(PolygonMorph)>>lineSegmentsDo:[] in BalloonMorph(PolygonMorph)>>getVertices {[:s | self   lineSegmentsDo: [:pt1 :pt2 | s nextPut: pt1]]}Array class(SequenceableCollection class)>>streamContents:BalloonMorph(PolygonMorph)>>getVerticesBalloonMorph(PolygonMorph)>>drawOn:FormCanvas(Canvas)>>draw:FormCanvas(Canvas)>>drawMorph:[] in BalloonMorph(Morph)>>fullDrawOn: {[(aCanvas isVisible: self bounds)   ifTrue: [aCanvas drawMorph: self].  self...]}FormCanvas>>roundCornersOf:in:during:FormCanvas(Canvas)>>roundCornersOf:during:BalloonMorph(Morph)>>fullDrawOn:FormCanvas(Canvas)>>fullDraw:FormCanvas(Canvas)>>fullDrawMorph:[] in PasteUpMorph>>drawSubmorphsOn: {[:m | m ~~ backgroundMorph   ifTrue: [canvas fullDrawMorph: m]]}Array(SequenceableCollection)>>reverseDo:[] in PasteUpMorph>>drawSubmorphsOn: {[:canvas | submorphs   reverseDo: [:m | m ~~ backgroundMorph     ifTrue: [ca...]}PasteUpMorph>>drawSubmorphsOn:[] in PasteUpMorph(Morph)>>fullDrawOn: {[(aCanvas isVisible: self bounds)   ifTrue: [aCanvas drawMorph: self].  self...]}FormCanvas>>roundCornersOf:in:during:FormCanvas(Canvas)>>roundCornersOf:during:PasteUpMorph(Morph)>>fullDrawOn:FormCanvas(Canvas)>>fullDraw:FormCanvas(Canvas)>>fullDrawMorph:[] in BalloonMorph(Morph)>>drawSubmorphsOn: {[:m | canvas fullDrawMorph: m]}Array(SequenceableCollection)>>reverseDo:[] in BalloonMorph(Morph)>>drawSubmorphsOn: {[:canvas | submorphs   reverseDo: [:m | canvas fullDrawMorph: m]]}BalloonMorph(Morph)>>drawSubmorphsOn:[] in BalloonMorph(Morph)>>fullDrawOn: {[(aCanvas isVisible: self bounds)   ifTrue: [aCanvas drawMorph: self].  self...]}FormCanvas>>roundCornersOf:in:during:FormCanvas(Canvas)>>roundCornersOf:during:BalloonMorph(Morph)>>fullDrawOn:FormCanvas(Canvas)>>fullDraw:FormCanvas(Canvas)>>fullDrawMorph:[] in WorldState>>drawWorld:submorphs:invalidAreasOn: {[:r |  rectToFill := r.  i := 1.  [rectToFill isNil   or: [i > n]]   whileFa...]}...etc...